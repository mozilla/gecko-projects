/* Clone of the automatically generated bindgen code */

#[link(name = "AudioUnit", kind = "framework")]
#[link(name = "CoreAudio", kind = "framework")]
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const TARGET_OS_MAC: u32 = 1;
pub const TARGET_OS_WIN32: u32 = 0;
pub const TARGET_OS_UNIX: u32 = 0;
pub const TARGET_OS_OSX: u32 = 1;
pub const TARGET_OS_IPHONE: u32 = 0;
pub const TARGET_OS_IOS: u32 = 0;
pub const TARGET_OS_WATCH: u32 = 0;
pub const TARGET_OS_BRIDGE: u32 = 0;
pub const TARGET_OS_TV: u32 = 0;
pub const TARGET_OS_SIMULATOR: u32 = 0;
pub const TARGET_OS_EMBEDDED: u32 = 0;
pub const TARGET_IPHONE_SIMULATOR: u32 = 0;
pub const TARGET_OS_NANO: u32 = 0;
pub const TARGET_CPU_PPC: u32 = 0;
pub const TARGET_CPU_PPC64: u32 = 0;
pub const TARGET_CPU_68K: u32 = 0;
pub const TARGET_CPU_X86: u32 = 0;
pub const TARGET_CPU_X86_64: u32 = 1;
pub const TARGET_CPU_ARM: u32 = 0;
pub const TARGET_CPU_ARM64: u32 = 0;
pub const TARGET_CPU_MIPS: u32 = 0;
pub const TARGET_CPU_SPARC: u32 = 0;
pub const TARGET_CPU_ALPHA: u32 = 0;
pub const TARGET_RT_MAC_CFM: u32 = 0;
pub const TARGET_RT_MAC_MACHO: u32 = 1;
pub const TARGET_RT_LITTLE_ENDIAN: u32 = 1;
pub const TARGET_RT_BIG_ENDIAN: u32 = 0;
pub const TARGET_RT_64_BIT: u32 = 1;
pub const AUDIO_UNIT_VERSION: u32 = 1070;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 101304;
pub const COREAUDIOTYPES_VERSION: u32 = 20150414;
pub const __COREFOUNDATION_CFBASE__: u32 = 1;
pub const __COREFOUNDATION_CFAVAILABILITY__: u32 = 1;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 101304;
pub const __AVAILABILITY_MACROS_USES_AVAILABILITY: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const UNIVERSAL_INTERFACES_VERSION: u32 = 1024;
pub const PRAGMA_IMPORT: u32 = 0;
pub const PRAGMA_ONCE: u32 = 0;
pub const PRAGMA_STRUCT_PACK: u32 = 1;
pub const PRAGMA_STRUCT_PACKPUSH: u32 = 1;
pub const PRAGMA_STRUCT_ALIGN: u32 = 0;
pub const PRAGMA_ENUM_PACK: u32 = 0;
pub const PRAGMA_ENUM_ALWAYSINT: u32 = 0;
pub const PRAGMA_ENUM_OPTIONS: u32 = 0;
pub const TYPE_EXTENDED: u32 = 0;
pub const TYPE_LONGDOUBLE_IS_DOUBLE: u32 = 0;
pub const TYPE_LONGLONG: u32 = 1;
pub const FUNCTION_PASCAL: u32 = 0;
pub const FUNCTION_DECLSPEC: u32 = 0;
pub const FUNCTION_WIN32CC: u32 = 0;
pub const TARGET_API_MAC_OS8: u32 = 0;
pub const TARGET_API_MAC_CARBON: u32 = 1;
pub const TARGET_API_MAC_OSX: u32 = 1;
pub const TARGET_CARBON: u32 = 1;
pub const OLDROUTINENAMES: u32 = 0;
pub const OPAQUE_TOOLBOX_STRUCTS: u32 = 1;
pub const OPAQUE_UPP_TYPES: u32 = 1;
pub const ACCESSOR_CALLS_ARE_FUNCTIONS: u32 = 1;
pub const CALL_NOT_IN_CARBON: u32 = 0;
pub const MIXEDMODE_CALLS_ARE_FUNCTIONS: u32 = 1;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const ALLOW_OBSOLETE_CARBON_MACMEMORY: u32 = 0;
pub const ALLOW_OBSOLETE_CARBON_OSUTILS: u32 = 0;
pub const kInvalidID: u32 = 0;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const kCFCoreFoundationVersionNumber10_0: f64 = 196.4;
pub const kCFCoreFoundationVersionNumber10_0_3: f64 = 196.5;
pub const kCFCoreFoundationVersionNumber10_1: f64 = 226.0;
pub const kCFCoreFoundationVersionNumber10_1_1: f64 = 226.0;
pub const kCFCoreFoundationVersionNumber10_1_2: f64 = 227.2;
pub const kCFCoreFoundationVersionNumber10_1_3: f64 = 227.2;
pub const kCFCoreFoundationVersionNumber10_1_4: f64 = 227.3;
pub const kCFCoreFoundationVersionNumber10_2: f64 = 263.0;
pub const kCFCoreFoundationVersionNumber10_2_1: f64 = 263.1;
pub const kCFCoreFoundationVersionNumber10_2_2: f64 = 263.1;
pub const kCFCoreFoundationVersionNumber10_2_3: f64 = 263.3;
pub const kCFCoreFoundationVersionNumber10_2_4: f64 = 263.3;
pub const kCFCoreFoundationVersionNumber10_2_5: f64 = 263.5;
pub const kCFCoreFoundationVersionNumber10_2_6: f64 = 263.5;
pub const kCFCoreFoundationVersionNumber10_2_7: f64 = 263.5;
pub const kCFCoreFoundationVersionNumber10_2_8: f64 = 263.5;
pub const kCFCoreFoundationVersionNumber10_3: f64 = 299.0;
pub const kCFCoreFoundationVersionNumber10_3_1: f64 = 299.0;
pub const kCFCoreFoundationVersionNumber10_3_2: f64 = 299.0;
pub const kCFCoreFoundationVersionNumber10_3_3: f64 = 299.3;
pub const kCFCoreFoundationVersionNumber10_3_4: f64 = 299.31;
pub const kCFCoreFoundationVersionNumber10_3_5: f64 = 299.31;
pub const kCFCoreFoundationVersionNumber10_3_6: f64 = 299.32;
pub const kCFCoreFoundationVersionNumber10_3_7: f64 = 299.33;
pub const kCFCoreFoundationVersionNumber10_3_8: f64 = 299.33;
pub const kCFCoreFoundationVersionNumber10_3_9: f64 = 299.35;
pub const kCFCoreFoundationVersionNumber10_4: f64 = 368.0;
pub const kCFCoreFoundationVersionNumber10_4_1: f64 = 368.1;
pub const kCFCoreFoundationVersionNumber10_4_2: f64 = 368.11;
pub const kCFCoreFoundationVersionNumber10_4_3: f64 = 368.18;
pub const kCFCoreFoundationVersionNumber10_4_4_Intel: f64 = 368.26;
pub const kCFCoreFoundationVersionNumber10_4_4_PowerPC: f64 = 368.25;
pub const kCFCoreFoundationVersionNumber10_4_5_Intel: f64 = 368.26;
pub const kCFCoreFoundationVersionNumber10_4_5_PowerPC: f64 = 368.25;
pub const kCFCoreFoundationVersionNumber10_4_6_Intel: f64 = 368.26;
pub const kCFCoreFoundationVersionNumber10_4_6_PowerPC: f64 = 368.25;
pub const kCFCoreFoundationVersionNumber10_4_7: f64 = 368.27;
pub const kCFCoreFoundationVersionNumber10_4_8: f64 = 368.27;
pub const kCFCoreFoundationVersionNumber10_4_9: f64 = 368.28;
pub const kCFCoreFoundationVersionNumber10_4_10: f64 = 368.28;
pub const kCFCoreFoundationVersionNumber10_4_11: f64 = 368.31;
pub const kCFCoreFoundationVersionNumber10_5: f64 = 476.0;
pub const kCFCoreFoundationVersionNumber10_5_1: f64 = 476.0;
pub const kCFCoreFoundationVersionNumber10_5_2: f64 = 476.1;
pub const kCFCoreFoundationVersionNumber10_5_3: f64 = 476.13;
pub const kCFCoreFoundationVersionNumber10_5_4: f64 = 476.14;
pub const kCFCoreFoundationVersionNumber10_5_5: f64 = 476.15;
pub const kCFCoreFoundationVersionNumber10_5_6: f64 = 476.17;
pub const kCFCoreFoundationVersionNumber10_5_7: f64 = 476.18;
pub const kCFCoreFoundationVersionNumber10_5_8: f64 = 476.19;
pub const kCFCoreFoundationVersionNumber10_6: f64 = 550.0;
pub const kCFCoreFoundationVersionNumber10_6_1: f64 = 550.0;
pub const kCFCoreFoundationVersionNumber10_6_2: f64 = 550.13;
pub const kCFCoreFoundationVersionNumber10_6_3: f64 = 550.19;
pub const kCFCoreFoundationVersionNumber10_6_4: f64 = 550.29;
pub const kCFCoreFoundationVersionNumber10_6_5: f64 = 550.42;
pub const kCFCoreFoundationVersionNumber10_6_6: f64 = 550.42;
pub const kCFCoreFoundationVersionNumber10_6_7: f64 = 550.42;
pub const kCFCoreFoundationVersionNumber10_6_8: f64 = 550.43;
pub const kCFCoreFoundationVersionNumber10_7: f64 = 635.0;
pub const kCFCoreFoundationVersionNumber10_7_1: f64 = 635.0;
pub const kCFCoreFoundationVersionNumber10_7_2: f64 = 635.15;
pub const kCFCoreFoundationVersionNumber10_7_3: f64 = 635.19;
pub const kCFCoreFoundationVersionNumber10_7_4: f64 = 635.21;
pub const kCFCoreFoundationVersionNumber10_7_5: f64 = 635.21;
pub const kCFCoreFoundationVersionNumber10_8: f64 = 744.0;
pub const kCFCoreFoundationVersionNumber10_8_1: f64 = 744.0;
pub const kCFCoreFoundationVersionNumber10_8_2: f64 = 744.12;
pub const kCFCoreFoundationVersionNumber10_8_3: f64 = 744.18;
pub const kCFCoreFoundationVersionNumber10_8_4: f64 = 744.19;
pub const kCFCoreFoundationVersionNumber10_9: f64 = 855.11;
pub const kCFCoreFoundationVersionNumber10_9_1: f64 = 855.11;
pub const kCFCoreFoundationVersionNumber10_9_2: f64 = 855.14;
pub const kCFCoreFoundationVersionNumber10_10: f64 = 1151.16;
pub const kCFCoreFoundationVersionNumber10_10_1: f64 = 1151.16;
pub const kCFCoreFoundationVersionNumber10_10_2: u32 = 1152;
pub const kCFCoreFoundationVersionNumber10_10_3: f64 = 1153.18;
pub const kCFCoreFoundationVersionNumber10_10_4: f64 = 1153.18;
pub const kCFCoreFoundationVersionNumber10_10_5: f64 = 1153.18;
pub const kCFCoreFoundationVersionNumber10_10_Max: u32 = 1199;
pub const kCFCoreFoundationVersionNumber10_11: u32 = 1253;
pub const kCFCoreFoundationVersionNumber10_11_1: f64 = 1255.1;
pub const kCFCoreFoundationVersionNumber10_11_2: f64 = 1256.14;
pub const kCFCoreFoundationVersionNumber10_11_3: f64 = 1256.14;
pub const kCFCoreFoundationVersionNumber10_11_4: f64 = 1258.1;
pub const kCFCoreFoundationVersionNumber10_11_Max: u32 = 1299;
pub const CA_PREFER_FIXED_POINT: u32 = 0;
pub const __COREFOUNDATION_COREFOUNDATION__: u32 = 1;
pub const __COREFOUNDATION__: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const _CACHED_RUNES: u32 = 256;
pub const _CRMASK: i32 = -256;
pub const _RUNE_MAGIC_A: &'static [u8; 9usize] = b"RuneMagA\0";
pub const _CTYPE_A: u32 = 256;
pub const _CTYPE_C: u32 = 512;
pub const _CTYPE_D: u32 = 1024;
pub const _CTYPE_G: u32 = 2048;
pub const _CTYPE_L: u32 = 4096;
pub const _CTYPE_P: u32 = 8192;
pub const _CTYPE_S: u32 = 16384;
pub const _CTYPE_U: u32 = 32768;
pub const _CTYPE_X: u32 = 65536;
pub const _CTYPE_B: u32 = 131072;
pub const _CTYPE_R: u32 = 262144;
pub const _CTYPE_I: u32 = 524288;
pub const _CTYPE_T: u32 = 1048576;
pub const _CTYPE_Q: u32 = 2097152;
pub const _CTYPE_SW0: u32 = 536870912;
pub const _CTYPE_SW1: u32 = 1073741824;
pub const _CTYPE_SW2: u32 = 2147483648;
pub const _CTYPE_SW3: u32 = 3221225472;
pub const _CTYPE_SWM: u32 = 3758096384;
pub const _CTYPE_SWS: u32 = 30;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 262144;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 8192;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const LC_ALL: u32 = 0;
pub const LC_COLLATE: u32 = 1;
pub const LC_CTYPE: u32 = 2;
pub const LC_MONETARY: u32 = 3;
pub const LC_NUMERIC: u32 = 4;
pub const LC_TIME: u32 = 5;
pub const LC_MESSAGES: u32 = 6;
pub const _LC_LAST: u32 = 7;
pub const FP_NAN: u32 = 1;
pub const FP_INFINITE: u32 = 2;
pub const FP_ZERO: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const FP_SUBNORMAL: u32 = 5;
pub const FP_SUPERNORMAL: u32 = 6;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: u32 = 1;
pub const FP_QNAN: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const _JBLEN: u32 = 37;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _I386_SIGNAL_H_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const FP_PREC_24B: u32 = 0;
pub const FP_PREC_53B: u32 = 2;
pub const FP_PREC_64B: u32 = 3;
pub const FP_RND_NEAR: u32 = 0;
pub const FP_RND_DOWN: u32 = 1;
pub const FP_RND_UP: u32 = 2;
pub const FP_CHOP: u32 = 3;
pub const FP_STATE_BYTES: u32 = 512;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const __CTERMID_DEFINED: u32 = 1;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_CURRENT: u32 = 4;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const __PRI_8_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\0";
pub const PRId8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIi8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIo8: &'static [u8; 4usize] = b"hho\0";
pub const PRIu8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIx8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIX8: &'static [u8; 4usize] = b"hhX\0";
pub const PRId16: &'static [u8; 3usize] = b"hd\0";
pub const PRIi16: &'static [u8; 3usize] = b"hi\0";
pub const PRIo16: &'static [u8; 3usize] = b"ho\0";
pub const PRIu16: &'static [u8; 3usize] = b"hu\0";
pub const PRIx16: &'static [u8; 3usize] = b"hx\0";
pub const PRIX16: &'static [u8; 3usize] = b"hX\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRId64: &'static [u8; 4usize] = b"lld\0";
pub const PRIi64: &'static [u8; 4usize] = b"lli\0";
pub const PRIo64: &'static [u8; 4usize] = b"llo\0";
pub const PRIu64: &'static [u8; 4usize] = b"llu\0";
pub const PRIx64: &'static [u8; 4usize] = b"llx\0";
pub const PRIX64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIXLEAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const PRIiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const PRIoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const PRIuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const PRIxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const PRIXLEAST16: &'static [u8; 3usize] = b"hX\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIXLEAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIXFAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"hd\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"hi\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"ho\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"hu\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"hx\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"hX\0";
pub const PRIdFAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIiFAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIoFAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIuFAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIxFAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIXFAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIXFAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"jd\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"ji\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"jo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"ju\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"jx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"jX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNd64: &'static [u8; 4usize] = b"lld\0";
pub const SCNi64: &'static [u8; 4usize] = b"lli\0";
pub const SCNo64: &'static [u8; 4usize] = b"llo\0";
pub const SCNu64: &'static [u8; 4usize] = b"llu\0";
pub const SCNx64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNdFAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNiFAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNoFAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNuFAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNxFAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"jd\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"ji\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"jo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"ju\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"jx\0";
pub const __COREFOUNDATION_CFARRAY__: u32 = 1;
pub const __COREFOUNDATION_CFBAG__: u32 = 1;
pub const __COREFOUNDATION_CFBINARYHEAP__: u32 = 1;
pub const __COREFOUNDATION_CFBITVECTOR__: u32 = 1;
pub const __COREFOUNDATION_CFBYTEORDER__: u32 = 1;
pub const CF_USE_OSBYTEORDER_H: u32 = 1;
pub const __COREFOUNDATION_CFCALENDAR__: u32 = 1;
pub const __COREFOUNDATION_CFLOCALE__: u32 = 1;
pub const __COREFOUNDATION_CFDICTIONARY__: u32 = 1;
pub const __COREFOUNDATION_CFNOTIFICATIONCENTER__: u32 = 1;
pub const __COREFOUNDATION_CFDATE__: u32 = 1;
pub const __COREFOUNDATION_CFTIMEZONE__: u32 = 1;
pub const __COREFOUNDATION_CFDATA__: u32 = 1;
pub const __COREFOUNDATION_CFSTRING__: u32 = 1;
pub const __COREFOUNDATION_CFCHARACTERSET__: u32 = 1;
pub const kCFStringEncodingInvalidId: u32 = 4294967295;
pub const __kCFStringInlineBufferLength: u32 = 64;
pub const __COREFOUNDATION_CFDATEFORMATTER__: u32 = 1;
pub const __COREFOUNDATION_CFERROR__: u32 = 1;
pub const __COREFOUNDATION_CFNUMBER__: u32 = 1;
pub const __COREFOUNDATION_CFNUMBERFORMATTER__: u32 = 1;
pub const __COREFOUNDATION_CFPREFERENCES__: u32 = 1;
pub const __COREFOUNDATION_CFPROPERTYLIST__: u32 = 1;
pub const __COREFOUNDATION_CFSTREAM__: u32 = 1;
pub const __COREFOUNDATION_CFURL__: u32 = 1;
pub const __COREFOUNDATION_CFRUNLOOP__: u32 = 1;
pub const BYTE_SIZE: u32 = 8;
pub const I386_PGBYTES: u32 = 4096;
pub const I386_PGSHIFT: u32 = 12;
pub const PAGE_SIZE: u32 = 4096;
pub const PAGE_SHIFT: u32 = 12;
pub const PAGE_MASK: u32 = 4095;
pub const PAGE_MAX_SHIFT: u32 = 12;
pub const PAGE_MAX_SIZE: u32 = 4096;
pub const PAGE_MAX_MASK: u32 = 4095;
pub const PAGE_MIN_SHIFT: u32 = 12;
pub const PAGE_MIN_SIZE: u32 = 4096;
pub const PAGE_MIN_MASK: u32 = 4095;
pub const I386_LPGBYTES: u32 = 2097152;
pub const I386_LPGSHIFT: u32 = 21;
pub const I386_LPGMASK: u32 = 2097151;
pub const MACH_PORT_NULL: u32 = 0;
pub const MACH_PORT_TYPE_DNREQUEST: u32 = 2147483648;
pub const MACH_PORT_TYPE_SPREQUEST: u32 = 1073741824;
pub const MACH_PORT_TYPE_SPREQUEST_DELAYED: u32 = 536870912;
pub const MACH_PORT_SRIGHTS_NONE: u32 = 0;
pub const MACH_PORT_SRIGHTS_PRESENT: u32 = 1;
pub const MACH_PORT_QLIMIT_ZERO: u32 = 0;
pub const MACH_PORT_QLIMIT_BASIC: u32 = 5;
pub const MACH_PORT_QLIMIT_SMALL: u32 = 16;
pub const MACH_PORT_QLIMIT_LARGE: u32 = 1024;
pub const MACH_PORT_QLIMIT_KERNEL: u32 = 65534;
pub const MACH_PORT_QLIMIT_MIN: u32 = 0;
pub const MACH_PORT_QLIMIT_DEFAULT: u32 = 5;
pub const MACH_PORT_QLIMIT_MAX: u32 = 1024;
pub const MACH_PORT_STATUS_FLAG_TEMPOWNER: u32 = 1;
pub const MACH_PORT_STATUS_FLAG_GUARDED: u32 = 2;
pub const MACH_PORT_STATUS_FLAG_STRICT_GUARD: u32 = 4;
pub const MACH_PORT_STATUS_FLAG_IMP_DONATION: u32 = 8;
pub const MACH_PORT_STATUS_FLAG_REVIVE: u32 = 16;
pub const MACH_PORT_STATUS_FLAG_TASKPTR: u32 = 32;
pub const MACH_PORT_LIMITS_INFO: u32 = 1;
pub const MACH_PORT_RECEIVE_STATUS: u32 = 2;
pub const MACH_PORT_DNREQUESTS_SIZE: u32 = 3;
pub const MACH_PORT_TEMPOWNER: u32 = 4;
pub const MACH_PORT_IMPORTANCE_RECEIVER: u32 = 5;
pub const MACH_PORT_DENAP_RECEIVER: u32 = 6;
pub const MACH_PORT_INFO_EXT: u32 = 7;
pub const MACH_PORT_DNREQUESTS_SIZE_COUNT: u32 = 1;
pub const MPO_CONTEXT_AS_GUARD: u32 = 1;
pub const MPO_QLIMIT: u32 = 2;
pub const MPO_TEMPOWNER: u32 = 4;
pub const MPO_IMPORTANCE_RECEIVER: u32 = 8;
pub const MPO_INSERT_SEND_RIGHT: u32 = 16;
pub const MPO_STRICT: u32 = 32;
pub const MPO_DENAP_RECEIVER: u32 = 64;
pub const GUARD_TYPE_MACH_PORT: u32 = 1;
pub const __COREFOUNDATION_CFSOCKET__: u32 = 1;
pub const _POSIX_VERSION: u32 = 200112;
pub const _POSIX2_VERSION: u32 = 200112;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const _READ_OK: u32 = 512;
pub const _WRITE_OK: u32 = 1024;
pub const _EXECUTE_OK: u32 = 2048;
pub const _DELETE_OK: u32 = 4096;
pub const _APPEND_OK: u32 = 8192;
pub const _RMFILE_OK: u32 = 16384;
pub const _RATTR_OK: u32 = 32768;
pub const _WATTR_OK: u32 = 65536;
pub const _REXT_OK: u32 = 131072;
pub const _WEXT_OK: u32 = 262144;
pub const _RPERM_OK: u32 = 524288;
pub const _WPERM_OK: u32 = 1048576;
pub const _CHOWN_OK: u32 = 2097152;
pub const _ACCESS_EXTENDED_MASK: u32 = 4193792;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const ACCESSX_MAX_DESCRIPTORS: u32 = 100;
pub const ACCESSX_MAX_TABLESIZE: u32 = 16384;
pub const _PC_LINK_MAX: u32 = 1;
pub const _PC_MAX_CANON: u32 = 2;
pub const _PC_MAX_INPUT: u32 = 3;
pub const _PC_NAME_MAX: u32 = 4;
pub const _PC_PATH_MAX: u32 = 5;
pub const _PC_PIPE_BUF: u32 = 6;
pub const _PC_CHOWN_RESTRICTED: u32 = 7;
pub const _PC_NO_TRUNC: u32 = 8;
pub const _PC_VDISABLE: u32 = 9;
pub const _PC_NAME_CHARS_MAX: u32 = 10;
pub const _PC_CASE_SENSITIVE: u32 = 11;
pub const _PC_CASE_PRESERVING: u32 = 12;
pub const _PC_EXTENDED_SECURITY_NP: u32 = 13;
pub const _PC_AUTH_OPAQUE_NP: u32 = 14;
pub const _PC_2_SYMLINKS: u32 = 15;
pub const _PC_ALLOC_SIZE_MIN: u32 = 16;
pub const _PC_ASYNC_IO: u32 = 17;
pub const _PC_FILESIZEBITS: u32 = 18;
pub const _PC_PRIO_IO: u32 = 19;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 20;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 21;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 22;
pub const _PC_REC_XFER_ALIGN: u32 = 23;
pub const _PC_SYMLINK_MAX: u32 = 24;
pub const _PC_SYNC_IO: u32 = 25;
pub const _PC_XATTR_SIZE_BITS: u32 = 26;
pub const _PC_MIN_HOLE_SIZE: u32 = 27;
pub const _CS_PATH: u32 = 1;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _XOPEN_VERSION: u32 = 600;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _POSIX_ADVISORY_INFO: i32 = -1;
pub const _POSIX_ASYNCHRONOUS_IO: i32 = -1;
pub const _POSIX_BARRIERS: i32 = -1;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: i32 = -1;
pub const _POSIX_CPUTIME: i32 = -1;
pub const _POSIX_FSYNC: u32 = 200112;
pub const _POSIX_IPV6: u32 = 200112;
pub const _POSIX_JOB_CONTROL: u32 = 200112;
pub const _POSIX_MAPPED_FILES: u32 = 200112;
pub const _POSIX_MEMLOCK: i32 = -1;
pub const _POSIX_MEMLOCK_RANGE: i32 = -1;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200112;
pub const _POSIX_MESSAGE_PASSING: i32 = -1;
pub const _POSIX_MONOTONIC_CLOCK: i32 = -1;
pub const _POSIX_NO_TRUNC: u32 = 200112;
pub const _POSIX_PRIORITIZED_IO: i32 = -1;
pub const _POSIX_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_RAW_SOCKETS: i32 = -1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const _POSIX_REALTIME_SIGNALS: i32 = -1;
pub const _POSIX_REGEXP: u32 = 200112;
pub const _POSIX_SAVED_IDS: u32 = 200112;
pub const _POSIX_SEMAPHORES: i32 = -1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_SHELL: u32 = 200112;
pub const _POSIX_SPAWN: i32 = -1;
pub const _POSIX_SPIN_LOCKS: i32 = -1;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_SYNCHRONIZED_IO: i32 = -1;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200112;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200112;
pub const _POSIX_THREAD_CPUTIME: i32 = -1;
pub const _POSIX_THREAD_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200112;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200112;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREADS: u32 = 200112;
pub const _POSIX_TIMEOUTS: i32 = -1;
pub const _POSIX_TIMERS: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX2_C_BIND: u32 = 200112;
pub const _POSIX2_C_DEV: u32 = 200112;
pub const _POSIX2_CHAR_TERM: u32 = 200112;
pub const _POSIX2_FORT_DEV: i32 = -1;
pub const _POSIX2_FORT_RUN: u32 = 200112;
pub const _POSIX2_LOCALEDEF: u32 = 200112;
pub const _POSIX2_PBS: i32 = -1;
pub const _POSIX2_PBS_ACCOUNTING: i32 = -1;
pub const _POSIX2_PBS_CHECKPOINT: i32 = -1;
pub const _POSIX2_PBS_LOCATE: i32 = -1;
pub const _POSIX2_PBS_MESSAGE: i32 = -1;
pub const _POSIX2_PBS_TRACK: i32 = -1;
pub const _POSIX2_SW_DEV: u32 = 200112;
pub const _POSIX2_UPE: u32 = 200112;
pub const __ILP32_OFF32: i32 = -1;
pub const __ILP32_OFFBIG: u32 = 1;
pub const __LP64_OFF64: u32 = 1;
pub const __LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: i32 = -1;
pub const _POSIX_V6_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V7_ILP32_OFF32: i32 = -1;
pub const _POSIX_V7_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V7_LPBIG_OFFBIG: u32 = 1;
pub const _V6_ILP32_OFF32: i32 = -1;
pub const _V6_ILP32_OFFBIG: u32 = 1;
pub const _V6_LP64_OFF64: u32 = 1;
pub const _V6_LPBIG_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFF32: i32 = -1;
pub const _XBS5_ILP32_OFFBIG: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const _XBS5_LPBIG_OFFBIG: u32 = 1;
pub const _XOPEN_CRYPT: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: i32 = -1;
pub const _XOPEN_REALTIME: i32 = -1;
pub const _XOPEN_REALTIME_THREADS: i32 = -1;
pub const _XOPEN_SHM: u32 = 1;
pub const _XOPEN_STREAMS: i32 = -1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _SC_ARG_MAX: u32 = 1;
pub const _SC_CHILD_MAX: u32 = 2;
pub const _SC_CLK_TCK: u32 = 3;
pub const _SC_NGROUPS_MAX: u32 = 4;
pub const _SC_OPEN_MAX: u32 = 5;
pub const _SC_JOB_CONTROL: u32 = 6;
pub const _SC_SAVED_IDS: u32 = 7;
pub const _SC_VERSION: u32 = 8;
pub const _SC_BC_BASE_MAX: u32 = 9;
pub const _SC_BC_DIM_MAX: u32 = 10;
pub const _SC_BC_SCALE_MAX: u32 = 11;
pub const _SC_BC_STRING_MAX: u32 = 12;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 13;
pub const _SC_EXPR_NEST_MAX: u32 = 14;
pub const _SC_LINE_MAX: u32 = 15;
pub const _SC_RE_DUP_MAX: u32 = 16;
pub const _SC_2_VERSION: u32 = 17;
pub const _SC_2_C_BIND: u32 = 18;
pub const _SC_2_C_DEV: u32 = 19;
pub const _SC_2_CHAR_TERM: u32 = 20;
pub const _SC_2_FORT_DEV: u32 = 21;
pub const _SC_2_FORT_RUN: u32 = 22;
pub const _SC_2_LOCALEDEF: u32 = 23;
pub const _SC_2_SW_DEV: u32 = 24;
pub const _SC_2_UPE: u32 = 25;
pub const _SC_STREAM_MAX: u32 = 26;
pub const _SC_TZNAME_MAX: u32 = 27;
pub const _SC_ASYNCHRONOUS_IO: u32 = 28;
pub const _SC_PAGESIZE: u32 = 29;
pub const _SC_MEMLOCK: u32 = 30;
pub const _SC_MEMLOCK_RANGE: u32 = 31;
pub const _SC_MEMORY_PROTECTION: u32 = 32;
pub const _SC_MESSAGE_PASSING: u32 = 33;
pub const _SC_PRIORITIZED_IO: u32 = 34;
pub const _SC_PRIORITY_SCHEDULING: u32 = 35;
pub const _SC_REALTIME_SIGNALS: u32 = 36;
pub const _SC_SEMAPHORES: u32 = 37;
pub const _SC_FSYNC: u32 = 38;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 39;
pub const _SC_SYNCHRONIZED_IO: u32 = 40;
pub const _SC_TIMERS: u32 = 41;
pub const _SC_AIO_LISTIO_MAX: u32 = 42;
pub const _SC_AIO_MAX: u32 = 43;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 44;
pub const _SC_DELAYTIMER_MAX: u32 = 45;
pub const _SC_MQ_OPEN_MAX: u32 = 46;
pub const _SC_MAPPED_FILES: u32 = 47;
pub const _SC_RTSIG_MAX: u32 = 48;
pub const _SC_SEM_NSEMS_MAX: u32 = 49;
pub const _SC_SEM_VALUE_MAX: u32 = 50;
pub const _SC_SIGQUEUE_MAX: u32 = 51;
pub const _SC_TIMER_MAX: u32 = 52;
pub const _SC_NPROCESSORS_CONF: u32 = 57;
pub const _SC_NPROCESSORS_ONLN: u32 = 58;
pub const _SC_2_PBS: u32 = 59;
pub const _SC_2_PBS_ACCOUNTING: u32 = 60;
pub const _SC_2_PBS_CHECKPOINT: u32 = 61;
pub const _SC_2_PBS_LOCATE: u32 = 62;
pub const _SC_2_PBS_MESSAGE: u32 = 63;
pub const _SC_2_PBS_TRACK: u32 = 64;
pub const _SC_ADVISORY_INFO: u32 = 65;
pub const _SC_BARRIERS: u32 = 66;
pub const _SC_CLOCK_SELECTION: u32 = 67;
pub const _SC_CPUTIME: u32 = 68;
pub const _SC_FILE_LOCKING: u32 = 69;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 70;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 71;
pub const _SC_HOST_NAME_MAX: u32 = 72;
pub const _SC_LOGIN_NAME_MAX: u32 = 73;
pub const _SC_MONOTONIC_CLOCK: u32 = 74;
pub const _SC_MQ_PRIO_MAX: u32 = 75;
pub const _SC_READER_WRITER_LOCKS: u32 = 76;
pub const _SC_REGEXP: u32 = 77;
pub const _SC_SHELL: u32 = 78;
pub const _SC_SPAWN: u32 = 79;
pub const _SC_SPIN_LOCKS: u32 = 80;
pub const _SC_SPORADIC_SERVER: u32 = 81;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 82;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 83;
pub const _SC_THREAD_CPUTIME: u32 = 84;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 85;
pub const _SC_THREAD_KEYS_MAX: u32 = 86;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 87;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 88;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 89;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 90;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 91;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 92;
pub const _SC_THREAD_STACK_MIN: u32 = 93;
pub const _SC_THREAD_THREADS_MAX: u32 = 94;
pub const _SC_TIMEOUTS: u32 = 95;
pub const _SC_THREADS: u32 = 96;
pub const _SC_TRACE: u32 = 97;
pub const _SC_TRACE_EVENT_FILTER: u32 = 98;
pub const _SC_TRACE_INHERIT: u32 = 99;
pub const _SC_TRACE_LOG: u32 = 100;
pub const _SC_TTY_NAME_MAX: u32 = 101;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 102;
pub const _SC_V6_ILP32_OFF32: u32 = 103;
pub const _SC_V6_ILP32_OFFBIG: u32 = 104;
pub const _SC_V6_LP64_OFF64: u32 = 105;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 106;
pub const _SC_IPV6: u32 = 118;
pub const _SC_RAW_SOCKETS: u32 = 119;
pub const _SC_SYMLOOP_MAX: u32 = 120;
pub const _SC_ATEXIT_MAX: u32 = 107;
pub const _SC_IOV_MAX: u32 = 56;
pub const _SC_PAGE_SIZE: u32 = 29;
pub const _SC_XOPEN_CRYPT: u32 = 108;
pub const _SC_XOPEN_ENH_I18N: u32 = 109;
pub const _SC_XOPEN_LEGACY: u32 = 110;
pub const _SC_XOPEN_REALTIME: u32 = 111;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 112;
pub const _SC_XOPEN_SHM: u32 = 113;
pub const _SC_XOPEN_STREAMS: u32 = 114;
pub const _SC_XOPEN_UNIX: u32 = 115;
pub const _SC_XOPEN_VERSION: u32 = 116;
pub const _SC_XOPEN_XCU_VERSION: u32 = 121;
pub const _SC_XBS5_ILP32_OFF32: u32 = 122;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 123;
pub const _SC_XBS5_LP64_OFF64: u32 = 124;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 125;
pub const _SC_SS_REPL_MAX: u32 = 126;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 127;
pub const _SC_TRACE_NAME_MAX: u32 = 128;
pub const _SC_TRACE_SYS_MAX: u32 = 129;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 130;
pub const _SC_PASS_MAX: u32 = 131;
pub const _SC_PHYS_PAGES: u32 = 200;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: u32 = 2;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: u32 = 3;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: u32 = 4;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: u32 = 5;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: u32 = 6;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: u32 = 7;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: u32 = 8;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: u32 = 9;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: u32 = 10;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: u32 = 11;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: u32 = 12;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: u32 = 13;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: u32 = 14;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: u32 = 20;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: u32 = 21;
pub const _CS_XBS5_ILP32_OFF32_LIBS: u32 = 22;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: u32 = 23;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: u32 = 24;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: u32 = 25;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: u32 = 26;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: u32 = 27;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: u32 = 28;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: u32 = 29;
pub const _CS_XBS5_LP64_OFF64_LIBS: u32 = 30;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: u32 = 31;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: u32 = 32;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: u32 = 33;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: u32 = 34;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: u32 = 35;
pub const _CS_DARWIN_USER_DIR: u32 = 65536;
pub const _CS_DARWIN_USER_TEMP_DIR: u32 = 65537;
pub const _CS_DARWIN_USER_CACHE_DIR: u32 = 65538;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const SYNC_VOLUME_FULLSYNC: u32 = 1;
pub const SYNC_VOLUME_WAIT: u32 = 2;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_ACCMODE: u32 = 3;
pub const FREAD: u32 = 1;
pub const FWRITE: u32 = 2;
pub const O_NONBLOCK: u32 = 4;
pub const O_APPEND: u32 = 8;
pub const O_SYNC: u32 = 128;
pub const O_SHLOCK: u32 = 16;
pub const O_EXLOCK: u32 = 32;
pub const O_ASYNC: u32 = 64;
pub const O_FSYNC: u32 = 128;
pub const O_NOFOLLOW: u32 = 256;
pub const O_CREAT: u32 = 512;
pub const O_TRUNC: u32 = 1024;
pub const O_EXCL: u32 = 2048;
pub const AT_FDCWD: i32 = -2;
pub const AT_EACCESS: u32 = 16;
pub const AT_SYMLINK_NOFOLLOW: u32 = 32;
pub const AT_SYMLINK_FOLLOW: u32 = 64;
pub const AT_REMOVEDIR: u32 = 128;
pub const O_EVTONLY: u32 = 32768;
pub const O_NOCTTY: u32 = 131072;
pub const O_DIRECTORY: u32 = 1048576;
pub const O_SYMLINK: u32 = 2097152;
pub const O_DSYNC: u32 = 4194304;
pub const O_CLOEXEC: u32 = 16777216;
pub const O_DP_GETRAWENCRYPTED: u32 = 1;
pub const O_DP_GETRAWUNENCRYPTED: u32 = 2;
pub const FAPPEND: u32 = 8;
pub const FASYNC: u32 = 64;
pub const FFSYNC: u32 = 128;
pub const FFDSYNC: u32 = 4194304;
pub const FNONBLOCK: u32 = 4;
pub const FNDELAY: u32 = 4;
pub const O_NDELAY: u32 = 4;
pub const CPF_OVERWRITE: u32 = 1;
pub const CPF_IGNORE_MODE: u32 = 2;
pub const CPF_MASK: u32 = 3;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETOWN: u32 = 5;
pub const F_SETOWN: u32 = 6;
pub const F_GETLK: u32 = 7;
pub const F_SETLK: u32 = 8;
pub const F_SETLKW: u32 = 9;
pub const F_SETLKWTIMEOUT: u32 = 10;
pub const F_FLUSH_DATA: u32 = 40;
pub const F_CHKCLEAN: u32 = 41;
pub const F_PREALLOCATE: u32 = 42;
pub const F_SETSIZE: u32 = 43;
pub const F_RDADVISE: u32 = 44;
pub const F_RDAHEAD: u32 = 45;
pub const F_NOCACHE: u32 = 48;
pub const F_LOG2PHYS: u32 = 49;
pub const F_GETPATH: u32 = 50;
pub const F_FULLFSYNC: u32 = 51;
pub const F_PATHPKG_CHECK: u32 = 52;
pub const F_FREEZE_FS: u32 = 53;
pub const F_THAW_FS: u32 = 54;
pub const F_GLOBAL_NOCACHE: u32 = 55;
pub const F_ADDSIGS: u32 = 59;
pub const F_ADDFILESIGS: u32 = 61;
pub const F_NODIRECT: u32 = 62;
pub const F_GETPROTECTIONCLASS: u32 = 63;
pub const F_SETPROTECTIONCLASS: u32 = 64;
pub const F_LOG2PHYS_EXT: u32 = 65;
pub const F_GETLKPID: u32 = 66;
pub const F_SETBACKINGSTORE: u32 = 70;
pub const F_GETPATH_MTMINFO: u32 = 71;
pub const F_GETCODEDIR: u32 = 72;
pub const F_SETNOSIGPIPE: u32 = 73;
pub const F_GETNOSIGPIPE: u32 = 74;
pub const F_TRANSCODEKEY: u32 = 75;
pub const F_SINGLE_WRITER: u32 = 76;
pub const F_GETPROTECTIONLEVEL: u32 = 77;
pub const F_FINDSIGS: u32 = 78;
pub const F_ADDFILESIGS_FOR_DYLD_SIM: u32 = 83;
pub const F_BARRIERFSYNC: u32 = 85;
pub const F_ADDFILESIGS_RETURN: u32 = 97;
pub const F_CHECK_LV: u32 = 98;
pub const F_PUNCHHOLE: u32 = 99;
pub const F_TRIM_ACTIVE_FILE: u32 = 100;
pub const FCNTL_FS_SPECIFIC_BASE: u32 = 65536;
pub const F_DUPFD_CLOEXEC: u32 = 67;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_WRLCK: u32 = 3;
pub const S_IFMT: u32 = 61440;
pub const S_IFIFO: u32 = 4096;
pub const S_IFCHR: u32 = 8192;
pub const S_IFDIR: u32 = 16384;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFWHT: u32 = 57344;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_ISTXT: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const F_ALLOCATECONTIG: u32 = 2;
pub const F_ALLOCATEALL: u32 = 4;
pub const F_PEOFPOSMODE: u32 = 3;
pub const F_VOLPOSMODE: u32 = 4;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const O_POPUP: u32 = 2147483648;
pub const O_ALERT: u32 = 536870912;
pub const DISPATCH_API_VERSION: u32 = 20170124;
pub const OS_OBJECT_HAVE_OBJC_SUPPORT: u32 = 0;
pub const OS_OBJECT_USE_OBJC: u32 = 0;
pub const OS_OBJECT_SWIFT3: u32 = 0;
pub const OS_OBJECT_USE_OBJC_RETAIN_RELEASE: u32 = 0;
pub const DISPATCH_SWIFT3_OVERLAY: u32 = 0;
pub const TIME_MICROS_MAX: u32 = 1000000;
pub const SYSTEM_CLOCK: u32 = 0;
pub const CALENDAR_CLOCK: u32 = 1;
pub const REALTIME_CLOCK: u32 = 0;
pub const CLOCK_GET_TIME_RES: u32 = 1;
pub const CLOCK_ALARM_CURRES: u32 = 3;
pub const CLOCK_ALARM_MINRES: u32 = 4;
pub const CLOCK_ALARM_MAXRES: u32 = 5;
pub const NSEC_PER_USEC: u32 = 1000;
pub const USEC_PER_SEC: u32 = 1000000;
pub const NSEC_PER_SEC: u32 = 1000000000;
pub const NSEC_PER_MSEC: u32 = 1000000;
pub const ALRMTYPE: u32 = 255;
pub const TIME_ABSOLUTE: u32 = 0;
pub const TIME_RELATIVE: u32 = 1;
pub const DISPATCH_TIME_NOW: u32 = 0;
pub const DISPATCH_TIME_FOREVER: i32 = -1;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const DISPATCH_APPLY_AUTO_AVAILABLE: u32 = 1;
pub const DISPATCH_QUEUE_PRIORITY_HIGH: u32 = 2;
pub const DISPATCH_QUEUE_PRIORITY_DEFAULT: u32 = 0;
pub const DISPATCH_QUEUE_PRIORITY_LOW: i32 = -2;
pub const DISPATCH_QUEUE_PRIORITY_BACKGROUND: i32 = -32768;
pub const KERN_SUCCESS: u32 = 0;
pub const KERN_INVALID_ADDRESS: u32 = 1;
pub const KERN_PROTECTION_FAILURE: u32 = 2;
pub const KERN_NO_SPACE: u32 = 3;
pub const KERN_INVALID_ARGUMENT: u32 = 4;
pub const KERN_FAILURE: u32 = 5;
pub const KERN_RESOURCE_SHORTAGE: u32 = 6;
pub const KERN_NOT_RECEIVER: u32 = 7;
pub const KERN_NO_ACCESS: u32 = 8;
pub const KERN_MEMORY_FAILURE: u32 = 9;
pub const KERN_MEMORY_ERROR: u32 = 10;
pub const KERN_ALREADY_IN_SET: u32 = 11;
pub const KERN_NOT_IN_SET: u32 = 12;
pub const KERN_NAME_EXISTS: u32 = 13;
pub const KERN_ABORTED: u32 = 14;
pub const KERN_INVALID_NAME: u32 = 15;
pub const KERN_INVALID_TASK: u32 = 16;
pub const KERN_INVALID_RIGHT: u32 = 17;
pub const KERN_INVALID_VALUE: u32 = 18;
pub const KERN_UREFS_OVERFLOW: u32 = 19;
pub const KERN_INVALID_CAPABILITY: u32 = 20;
pub const KERN_RIGHT_EXISTS: u32 = 21;
pub const KERN_INVALID_HOST: u32 = 22;
pub const KERN_MEMORY_PRESENT: u32 = 23;
pub const KERN_MEMORY_DATA_MOVED: u32 = 24;
pub const KERN_MEMORY_RESTART_COPY: u32 = 25;
pub const KERN_INVALID_PROCESSOR_SET: u32 = 26;
pub const KERN_POLICY_LIMIT: u32 = 27;
pub const KERN_INVALID_POLICY: u32 = 28;
pub const KERN_INVALID_OBJECT: u32 = 29;
pub const KERN_ALREADY_WAITING: u32 = 30;
pub const KERN_DEFAULT_SET: u32 = 31;
pub const KERN_EXCEPTION_PROTECTED: u32 = 32;
pub const KERN_INVALID_LEDGER: u32 = 33;
pub const KERN_INVALID_MEMORY_CONTROL: u32 = 34;
pub const KERN_INVALID_SECURITY: u32 = 35;
pub const KERN_NOT_DEPRESSED: u32 = 36;
pub const KERN_TERMINATED: u32 = 37;
pub const KERN_LOCK_SET_DESTROYED: u32 = 38;
pub const KERN_LOCK_UNSTABLE: u32 = 39;
pub const KERN_LOCK_OWNED: u32 = 40;
pub const KERN_LOCK_OWNED_SELF: u32 = 41;
pub const KERN_SEMAPHORE_DESTROYED: u32 = 42;
pub const KERN_RPC_SERVER_TERMINATED: u32 = 43;
pub const KERN_RPC_TERMINATE_ORPHAN: u32 = 44;
pub const KERN_RPC_CONTINUE_ORPHAN: u32 = 45;
pub const KERN_NOT_SUPPORTED: u32 = 46;
pub const KERN_NODE_DOWN: u32 = 47;
pub const KERN_NOT_WAITING: u32 = 48;
pub const KERN_OPERATION_TIMED_OUT: u32 = 49;
pub const KERN_CODESIGN_ERROR: u32 = 50;
pub const KERN_POLICY_STATIC: u32 = 51;
pub const KERN_INSUFFICIENT_BUFFER_SIZE: u32 = 52;
pub const KERN_RETURN_MAX: u32 = 256;
pub const MACH_MSGH_BITS_ZERO: u32 = 0;
pub const MACH_MSGH_BITS_REMOTE_MASK: u32 = 31;
pub const MACH_MSGH_BITS_LOCAL_MASK: u32 = 7936;
pub const MACH_MSGH_BITS_VOUCHER_MASK: u32 = 2031616;
pub const MACH_MSGH_BITS_PORTS_MASK: u32 = 2039583;
pub const MACH_MSGH_BITS_COMPLEX: u32 = 2147483648;
pub const MACH_MSGH_BITS_USER: u32 = 2149523231;
pub const MACH_MSGH_BITS_RAISEIMP: u32 = 536870912;
pub const MACH_MSGH_BITS_DENAP: u32 = 536870912;
pub const MACH_MSGH_BITS_IMPHOLDASRT: u32 = 268435456;
pub const MACH_MSGH_BITS_DENAPHOLDASRT: u32 = 268435456;
pub const MACH_MSGH_BITS_CIRCULAR: u32 = 268435456;
pub const MACH_MSGH_BITS_USED: u32 = 2954829599;
pub const MACH_MSG_TYPE_MOVE_RECEIVE: u32 = 16;
pub const MACH_MSG_TYPE_MOVE_SEND: u32 = 17;
pub const MACH_MSG_TYPE_MOVE_SEND_ONCE: u32 = 18;
pub const MACH_MSG_TYPE_COPY_SEND: u32 = 19;
pub const MACH_MSG_TYPE_MAKE_SEND: u32 = 20;
pub const MACH_MSG_TYPE_MAKE_SEND_ONCE: u32 = 21;
pub const MACH_MSG_TYPE_COPY_RECEIVE: u32 = 22;
pub const MACH_MSG_TYPE_DISPOSE_RECEIVE: u32 = 24;
pub const MACH_MSG_TYPE_DISPOSE_SEND: u32 = 25;
pub const MACH_MSG_TYPE_DISPOSE_SEND_ONCE: u32 = 26;
pub const MACH_MSG_PHYSICAL_COPY: u32 = 0;
pub const MACH_MSG_VIRTUAL_COPY: u32 = 1;
pub const MACH_MSG_ALLOCATE: u32 = 2;
pub const MACH_MSG_OVERWRITE: u32 = 3;
pub const MACH_MSG_PORT_DESCRIPTOR: u32 = 0;
pub const MACH_MSG_OOL_DESCRIPTOR: u32 = 1;
pub const MACH_MSG_OOL_PORTS_DESCRIPTOR: u32 = 2;
pub const MACH_MSG_OOL_VOLATILE_DESCRIPTOR: u32 = 3;
pub const MACH_MSG_TRAILER_FORMAT_0: u32 = 0;
pub const MACH_MSGH_KIND_NORMAL: u32 = 0;
pub const MACH_MSGH_KIND_NOTIFICATION: u32 = 1;
pub const MACH_MSG_TYPE_PORT_NONE: u32 = 0;
pub const MACH_MSG_TYPE_PORT_NAME: u32 = 15;
pub const MACH_MSG_TYPE_PORT_RECEIVE: u32 = 16;
pub const MACH_MSG_TYPE_PORT_SEND: u32 = 17;
pub const MACH_MSG_TYPE_PORT_SEND_ONCE: u32 = 18;
pub const MACH_MSG_TYPE_LAST: u32 = 22;
pub const MACH_MSG_OPTION_NONE: u32 = 0;
pub const MACH_SEND_MSG: u32 = 1;
pub const MACH_RCV_MSG: u32 = 2;
pub const MACH_RCV_LARGE: u32 = 4;
pub const MACH_RCV_LARGE_IDENTITY: u32 = 8;
pub const MACH_SEND_TIMEOUT: u32 = 16;
pub const MACH_SEND_OVERRIDE: u32 = 32;
pub const MACH_SEND_INTERRUPT: u32 = 64;
pub const MACH_SEND_NOTIFY: u32 = 128;
pub const MACH_SEND_ALWAYS: u32 = 65536;
pub const MACH_SEND_TRAILER: u32 = 131072;
pub const MACH_SEND_NOIMPORTANCE: u32 = 262144;
pub const MACH_SEND_NODENAP: u32 = 262144;
pub const MACH_SEND_IMPORTANCE: u32 = 524288;
pub const MACH_SEND_SYNC_OVERRIDE: u32 = 1048576;
pub const MACH_RCV_TIMEOUT: u32 = 256;
pub const MACH_RCV_NOTIFY: u32 = 512;
pub const MACH_RCV_INTERRUPT: u32 = 1024;
pub const MACH_RCV_VOUCHER: u32 = 2048;
pub const MACH_RCV_OVERWRITE: u32 = 4096;
pub const MACH_RCV_SYNC_WAIT: u32 = 16384;
pub const MACH_RCV_TRAILER_NULL: u32 = 0;
pub const MACH_RCV_TRAILER_SEQNO: u32 = 1;
pub const MACH_RCV_TRAILER_SENDER: u32 = 2;
pub const MACH_RCV_TRAILER_AUDIT: u32 = 3;
pub const MACH_RCV_TRAILER_CTX: u32 = 4;
pub const MACH_RCV_TRAILER_AV: u32 = 7;
pub const MACH_RCV_TRAILER_LABELS: u32 = 8;
pub const MACH_RCV_TRAILER_MASK: u32 = 251658240;
pub const MACH_MSG_SUCCESS: u32 = 0;
pub const MACH_MSG_MASK: u32 = 15872;
pub const MACH_MSG_IPC_SPACE: u32 = 8192;
pub const MACH_MSG_VM_SPACE: u32 = 4096;
pub const MACH_MSG_IPC_KERNEL: u32 = 2048;
pub const MACH_MSG_VM_KERNEL: u32 = 1024;
pub const MACH_SEND_IN_PROGRESS: u32 = 268435457;
pub const MACH_SEND_INVALID_DATA: u32 = 268435458;
pub const MACH_SEND_INVALID_DEST: u32 = 268435459;
pub const MACH_SEND_TIMED_OUT: u32 = 268435460;
pub const MACH_SEND_INVALID_VOUCHER: u32 = 268435461;
pub const MACH_SEND_INTERRUPTED: u32 = 268435463;
pub const MACH_SEND_MSG_TOO_SMALL: u32 = 268435464;
pub const MACH_SEND_INVALID_REPLY: u32 = 268435465;
pub const MACH_SEND_INVALID_RIGHT: u32 = 268435466;
pub const MACH_SEND_INVALID_NOTIFY: u32 = 268435467;
pub const MACH_SEND_INVALID_MEMORY: u32 = 268435468;
pub const MACH_SEND_NO_BUFFER: u32 = 268435469;
pub const MACH_SEND_TOO_LARGE: u32 = 268435470;
pub const MACH_SEND_INVALID_TYPE: u32 = 268435471;
pub const MACH_SEND_INVALID_HEADER: u32 = 268435472;
pub const MACH_SEND_INVALID_TRAILER: u32 = 268435473;
pub const MACH_SEND_INVALID_RT_OOL_SIZE: u32 = 268435477;
pub const MACH_RCV_IN_PROGRESS: u32 = 268451841;
pub const MACH_RCV_INVALID_NAME: u32 = 268451842;
pub const MACH_RCV_TIMED_OUT: u32 = 268451843;
pub const MACH_RCV_TOO_LARGE: u32 = 268451844;
pub const MACH_RCV_INTERRUPTED: u32 = 268451845;
pub const MACH_RCV_PORT_CHANGED: u32 = 268451846;
pub const MACH_RCV_INVALID_NOTIFY: u32 = 268451847;
pub const MACH_RCV_INVALID_DATA: u32 = 268451848;
pub const MACH_RCV_PORT_DIED: u32 = 268451849;
pub const MACH_RCV_IN_SET: u32 = 268451850;
pub const MACH_RCV_HEADER_ERROR: u32 = 268451851;
pub const MACH_RCV_BODY_ERROR: u32 = 268451852;
pub const MACH_RCV_INVALID_TYPE: u32 = 268451853;
pub const MACH_RCV_SCATTER_SMALL: u32 = 268451854;
pub const MACH_RCV_INVALID_TRAILER: u32 = 268451855;
pub const MACH_RCV_IN_PROGRESS_TIMED: u32 = 268451857;
pub const DISPATCH_MACH_SEND_DEAD: u32 = 1;
pub const DISPATCH_MEMORYPRESSURE_NORMAL: u32 = 1;
pub const DISPATCH_MEMORYPRESSURE_WARN: u32 = 2;
pub const DISPATCH_MEMORYPRESSURE_CRITICAL: u32 = 4;
pub const DISPATCH_PROC_EXIT: u32 = 2147483648;
pub const DISPATCH_PROC_FORK: u32 = 1073741824;
pub const DISPATCH_PROC_EXEC: u32 = 536870912;
pub const DISPATCH_PROC_SIGNAL: u32 = 134217728;
pub const DISPATCH_VNODE_DELETE: u32 = 1;
pub const DISPATCH_VNODE_WRITE: u32 = 2;
pub const DISPATCH_VNODE_EXTEND: u32 = 4;
pub const DISPATCH_VNODE_ATTRIB: u32 = 8;
pub const DISPATCH_VNODE_LINK: u32 = 16;
pub const DISPATCH_VNODE_RENAME: u32 = 32;
pub const DISPATCH_VNODE_REVOKE: u32 = 64;
pub const DISPATCH_VNODE_FUNLOCK: u32 = 256;
pub const DISPATCH_TIMER_STRICT: u32 = 1;
pub const DISPATCH_ONCE_INLINE_FASTPATH: u32 = 1;
pub const DISPATCH_IO_STREAM: u32 = 0;
pub const DISPATCH_IO_RANDOM: u32 = 1;
pub const DISPATCH_IO_STOP: u32 = 1;
pub const DISPATCH_IO_STRICT_INTERVAL: u32 = 1;
pub const __COREFOUNDATION_CFSET__: u32 = 1;
pub const __COREFOUNDATION_CFSTRINGENCODINGEXT__: u32 = 1;
pub const __COREFOUNDATION_CFTREE__: u32 = 1;
pub const __COREFOUNDATION_CFURLACCESS__: u32 = 1;
pub const __COREFOUNDATION_CFUUID__: u32 = 1;
pub const __COREFOUNDATION_CFUTILITIES__: u32 = 1;
pub const __COREFOUNDATION_CFBUNDLE__: u32 = 1;
pub const __COREFOUNDATION_CFMESSAGEPORT__: u32 = 1;
pub const __COREFOUNDATION_CFPLUGIN__: u32 = 1;
pub const COREFOUNDATION_CFPLUGINCOM_SEPARATE: u32 = 1;
pub const __COREFOUNDATION_CFMACHPORT__: u32 = 1;
pub const __COREFOUNDATION_CFATTRIBUTEDSTRING__: u32 = 1;
pub const __COREFOUNDATION_CFURLENUMERATOR__: u32 = 1;
pub const __COREFOUNDATION_CFFILESECURITY__: u32 = 1;
pub const KAUTH_GUID_SIZE: u32 = 16;
pub const KAUTH_NTSID_MAX_AUTHORITIES: u32 = 16;
pub const KAUTH_NTSID_HDRSIZE: u32 = 8;
pub const KAUTH_EXTLOOKUP_SUCCESS: u32 = 0;
pub const KAUTH_EXTLOOKUP_BADRQ: u32 = 1;
pub const KAUTH_EXTLOOKUP_FAILURE: u32 = 2;
pub const KAUTH_EXTLOOKUP_FATAL: u32 = 3;
pub const KAUTH_EXTLOOKUP_INPROG: u32 = 100;
pub const KAUTH_EXTLOOKUP_VALID_UID: u32 = 1;
pub const KAUTH_EXTLOOKUP_VALID_UGUID: u32 = 2;
pub const KAUTH_EXTLOOKUP_VALID_USID: u32 = 4;
pub const KAUTH_EXTLOOKUP_VALID_GID: u32 = 8;
pub const KAUTH_EXTLOOKUP_VALID_GGUID: u32 = 16;
pub const KAUTH_EXTLOOKUP_VALID_GSID: u32 = 32;
pub const KAUTH_EXTLOOKUP_WANT_UID: u32 = 64;
pub const KAUTH_EXTLOOKUP_WANT_UGUID: u32 = 128;
pub const KAUTH_EXTLOOKUP_WANT_USID: u32 = 256;
pub const KAUTH_EXTLOOKUP_WANT_GID: u32 = 512;
pub const KAUTH_EXTLOOKUP_WANT_GGUID: u32 = 1024;
pub const KAUTH_EXTLOOKUP_WANT_GSID: u32 = 2048;
pub const KAUTH_EXTLOOKUP_WANT_MEMBERSHIP: u32 = 4096;
pub const KAUTH_EXTLOOKUP_VALID_MEMBERSHIP: u32 = 8192;
pub const KAUTH_EXTLOOKUP_ISMEMBER: u32 = 16384;
pub const KAUTH_EXTLOOKUP_VALID_PWNAM: u32 = 32768;
pub const KAUTH_EXTLOOKUP_WANT_PWNAM: u32 = 65536;
pub const KAUTH_EXTLOOKUP_VALID_GRNAM: u32 = 131072;
pub const KAUTH_EXTLOOKUP_WANT_GRNAM: u32 = 262144;
pub const KAUTH_EXTLOOKUP_VALID_SUPGRPS: u32 = 524288;
pub const KAUTH_EXTLOOKUP_WANT_SUPGRPS: u32 = 1048576;
pub const KAUTH_EXTLOOKUP_REGISTER: u32 = 0;
pub const KAUTH_EXTLOOKUP_RESULT: u32 = 1;
pub const KAUTH_EXTLOOKUP_WORKER: u32 = 2;
pub const KAUTH_EXTLOOKUP_DEREGISTER: u32 = 4;
pub const KAUTH_GET_CACHE_SIZES: u32 = 8;
pub const KAUTH_SET_CACHE_SIZES: u32 = 16;
pub const KAUTH_CLEAR_CACHES: u32 = 32;
pub const IDENTITYSVC_ENTITLEMENT: &'static [u8; 30usize] = b"com.apple.private.identitysvc\0";
pub const KAUTH_ACE_KINDMASK: u32 = 15;
pub const KAUTH_ACE_PERMIT: u32 = 1;
pub const KAUTH_ACE_DENY: u32 = 2;
pub const KAUTH_ACE_AUDIT: u32 = 3;
pub const KAUTH_ACE_ALARM: u32 = 4;
pub const KAUTH_ACE_INHERITED: u32 = 16;
pub const KAUTH_ACE_FILE_INHERIT: u32 = 32;
pub const KAUTH_ACE_DIRECTORY_INHERIT: u32 = 64;
pub const KAUTH_ACE_LIMIT_INHERIT: u32 = 128;
pub const KAUTH_ACE_ONLY_INHERIT: u32 = 256;
pub const KAUTH_ACE_SUCCESS: u32 = 512;
pub const KAUTH_ACE_FAILURE: u32 = 1024;
pub const KAUTH_ACE_INHERIT_CONTROL_FLAGS: u32 = 480;
pub const KAUTH_ACE_GENERIC_ALL: u32 = 2097152;
pub const KAUTH_ACE_GENERIC_EXECUTE: u32 = 4194304;
pub const KAUTH_ACE_GENERIC_WRITE: u32 = 8388608;
pub const KAUTH_ACE_GENERIC_READ: u32 = 16777216;
pub const KAUTH_ACL_MAX_ENTRIES: u32 = 128;
pub const KAUTH_ACL_FLAGS_PRIVATE: u32 = 65535;
pub const KAUTH_ACL_DEFER_INHERIT: u32 = 65536;
pub const KAUTH_ACL_NO_INHERIT: u32 = 131072;
pub const KAUTH_FILESEC_MAGIC: u32 = 19710317;
pub const KAUTH_FILESEC_FLAGS_PRIVATE: u32 = 65535;
pub const KAUTH_FILESEC_DEFER_INHERIT: u32 = 65536;
pub const KAUTH_FILESEC_NO_INHERIT: u32 = 131072;
pub const KAUTH_FILESEC_XATTR: &'static [u8; 26usize] = b"com.apple.system.Security\0";
pub const KAUTH_ENDIAN_HOST: u32 = 1;
pub const KAUTH_ENDIAN_DISK: u32 = 2;
pub const KAUTH_VNODE_READ_DATA: u32 = 2;
pub const KAUTH_VNODE_LIST_DIRECTORY: u32 = 2;
pub const KAUTH_VNODE_WRITE_DATA: u32 = 4;
pub const KAUTH_VNODE_ADD_FILE: u32 = 4;
pub const KAUTH_VNODE_EXECUTE: u32 = 8;
pub const KAUTH_VNODE_SEARCH: u32 = 8;
pub const KAUTH_VNODE_DELETE: u32 = 16;
pub const KAUTH_VNODE_APPEND_DATA: u32 = 32;
pub const KAUTH_VNODE_ADD_SUBDIRECTORY: u32 = 32;
pub const KAUTH_VNODE_DELETE_CHILD: u32 = 64;
pub const KAUTH_VNODE_READ_ATTRIBUTES: u32 = 128;
pub const KAUTH_VNODE_WRITE_ATTRIBUTES: u32 = 256;
pub const KAUTH_VNODE_READ_EXTATTRIBUTES: u32 = 512;
pub const KAUTH_VNODE_WRITE_EXTATTRIBUTES: u32 = 1024;
pub const KAUTH_VNODE_READ_SECURITY: u32 = 2048;
pub const KAUTH_VNODE_WRITE_SECURITY: u32 = 4096;
pub const KAUTH_VNODE_TAKE_OWNERSHIP: u32 = 8192;
pub const KAUTH_VNODE_CHANGE_OWNER: u32 = 8192;
pub const KAUTH_VNODE_SYNCHRONIZE: u32 = 1048576;
pub const KAUTH_VNODE_LINKTARGET: u32 = 33554432;
pub const KAUTH_VNODE_CHECKIMMUTABLE: u32 = 67108864;
pub const KAUTH_VNODE_ACCESS: u32 = 2147483648;
pub const KAUTH_VNODE_NOIMMUTABLE: u32 = 1073741824;
pub const KAUTH_VNODE_SEARCHBYANYONE: u32 = 536870912;
pub const KAUTH_VNODE_GENERIC_READ_BITS: u32 = 2690;
pub const KAUTH_VNODE_GENERIC_WRITE_BITS: u32 = 5492;
pub const KAUTH_VNODE_GENERIC_EXECUTE_BITS: u32 = 8;
pub const KAUTH_VNODE_GENERIC_ALL_BITS: u32 = 8190;
pub const KAUTH_VNODE_WRITE_RIGHTS: u32 = 100676980;
pub const __DARWIN_ACL_READ_DATA: u32 = 2;
pub const __DARWIN_ACL_LIST_DIRECTORY: u32 = 2;
pub const __DARWIN_ACL_WRITE_DATA: u32 = 4;
pub const __DARWIN_ACL_ADD_FILE: u32 = 4;
pub const __DARWIN_ACL_EXECUTE: u32 = 8;
pub const __DARWIN_ACL_SEARCH: u32 = 8;
pub const __DARWIN_ACL_DELETE: u32 = 16;
pub const __DARWIN_ACL_APPEND_DATA: u32 = 32;
pub const __DARWIN_ACL_ADD_SUBDIRECTORY: u32 = 32;
pub const __DARWIN_ACL_DELETE_CHILD: u32 = 64;
pub const __DARWIN_ACL_READ_ATTRIBUTES: u32 = 128;
pub const __DARWIN_ACL_WRITE_ATTRIBUTES: u32 = 256;
pub const __DARWIN_ACL_READ_EXTATTRIBUTES: u32 = 512;
pub const __DARWIN_ACL_WRITE_EXTATTRIBUTES: u32 = 1024;
pub const __DARWIN_ACL_READ_SECURITY: u32 = 2048;
pub const __DARWIN_ACL_WRITE_SECURITY: u32 = 4096;
pub const __DARWIN_ACL_CHANGE_OWNER: u32 = 8192;
pub const __DARWIN_ACL_SYNCHRONIZE: u32 = 1048576;
pub const __DARWIN_ACL_EXTENDED_ALLOW: u32 = 1;
pub const __DARWIN_ACL_EXTENDED_DENY: u32 = 2;
pub const __DARWIN_ACL_ENTRY_INHERITED: u32 = 16;
pub const __DARWIN_ACL_ENTRY_FILE_INHERIT: u32 = 32;
pub const __DARWIN_ACL_ENTRY_DIRECTORY_INHERIT: u32 = 64;
pub const __DARWIN_ACL_ENTRY_LIMIT_INHERIT: u32 = 128;
pub const __DARWIN_ACL_ENTRY_ONLY_INHERIT: u32 = 256;
pub const __DARWIN_ACL_FLAG_NO_INHERIT: u32 = 131072;
pub const ACL_MAX_ENTRIES: u32 = 128;
pub const __COREFOUNDATION_CFSTRINGTOKENIZER__: u32 = 1;
pub const __COREFOUNDATION_CFFILEDESCRIPTOR__: u32 = 1;
pub const __COREFOUNDATION_CFUSERNOTIFICATION__: u32 = 1;
pub const __COREFOUNDATION_CFXMLNODE__: u32 = 1;
pub const __CFXMLNode_DEPRECATION_MSG: &'static [u8; 83usize] =
    b"CFXMLNode is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead\0";
pub const __COREFOUNDATION_CFXMLPARSER__: u32 = 1;
pub const __CFXMLParser_DEPRECATION_MSG: &'static [u8; 85usize] =
    b"CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead\0";
pub const kAudioComponentConfigurationInfo_ValidationResult: &'static [u8; 17usize] =
    b"ValidationResult\0";
pub const kAudioComponentValidationParameter_TimeOut: &'static [u8; 8usize] = b"TimeOut\0";
pub const kAudioComponentValidationParameter_ForceValidation: &'static [u8; 16usize] =
    b"ForceValidation\0";
pub const kAUPresetVersionKey: &'static [u8; 8usize] = b"version\0";
pub const kAUPresetTypeKey: &'static [u8; 5usize] = b"type\0";
pub const kAUPresetSubtypeKey: &'static [u8; 8usize] = b"subtype\0";
pub const kAUPresetManufacturerKey: &'static [u8; 13usize] = b"manufacturer\0";
pub const kAUPresetDataKey: &'static [u8; 5usize] = b"data\0";
pub const kAUPresetNameKey: &'static [u8; 5usize] = b"name\0";
pub const kAUPresetRenderQualityKey: &'static [u8; 15usize] = b"render-quality\0";
pub const kAUPresetCPULoadKey: &'static [u8; 9usize] = b"cpu-load\0";
pub const kAUPresetElementNameKey: &'static [u8; 13usize] = b"element-name\0";
pub const kAUPresetExternalFileRefs: &'static [u8; 16usize] = b"file-references\0";
pub const kAUPresetVSTDataKey: &'static [u8; 8usize] = b"vstdata\0";
pub const kAUPresetVSTPresetKey: &'static [u8; 10usize] = b"vstpreset\0";
pub const kAUPresetMASDataKey: &'static [u8; 8usize] = b"masdata\0";
pub const kAUPresetPartKey: &'static [u8; 5usize] = b"part\0";
pub const kAudioUnitConfigurationInfo_HasCustomView: &'static [u8; 14usize] = b"HasCustomView\0";
pub const kAudioUnitConfigurationInfo_ChannelConfigurations: &'static [u8; 22usize] =
    b"ChannelConfigurations\0";
pub const kAudioUnitConfigurationInfo_InitialInputs: &'static [u8; 14usize] = b"InitialInputs\0";
pub const kAudioUnitConfigurationInfo_InitialOutputs: &'static [u8; 15usize] = b"InitialOutputs\0";
pub const kAudioUnitConfigurationInfo_IconURL: &'static [u8; 8usize] = b"IconURL\0";
pub const kAudioUnitConfigurationInfo_BusCountWritable: &'static [u8; 17usize] =
    b"BusCountWritable\0";
pub const kAudioUnitConfigurationInfo_SupportedChannelLayoutTags: &'static [u8; 27usize] =
    b"SupportedChannelLayoutTags\0";
pub const kAudioSettings_TopLevelKey: &'static [u8; 5usize] = b"name\0";
pub const kAudioSettings_Version: &'static [u8; 8usize] = b"version\0";
pub const kAudioSettings_Parameters: &'static [u8; 11usize] = b"parameters\0";
pub const kAudioSettings_SettingKey: &'static [u8; 4usize] = b"key\0";
pub const kAudioSettings_SettingName: &'static [u8; 5usize] = b"name\0";
pub const kAudioSettings_ValueType: &'static [u8; 11usize] = b"value type\0";
pub const kAudioSettings_AvailableValues: &'static [u8; 17usize] = b"available values\0";
pub const kAudioSettings_LimitedValues: &'static [u8; 15usize] = b"limited values\0";
pub const kAudioSettings_CurrentValue: &'static [u8; 14usize] = b"current value\0";
pub const kAudioSettings_Summary: &'static [u8; 8usize] = b"summary\0";
pub const kAudioSettings_Hint: &'static [u8; 5usize] = b"hint\0";
pub const kAudioSettings_Unit: &'static [u8; 5usize] = b"unit\0";
pub const kAudioEndPointDeviceUIDKey: &'static [u8; 4usize] = b"uid\0";
pub const kAudioEndPointDeviceNameKey: &'static [u8; 5usize] = b"name\0";
pub const kAudioEndPointDeviceEndPointListKey: &'static [u8; 10usize] = b"endpoints\0";
pub const kAudioEndPointDeviceMasterEndPointKey: &'static [u8; 7usize] = b"master\0";
pub const kAudioEndPointDeviceIsPrivateKey: &'static [u8; 8usize] = b"private\0";
pub const kAudioEndPointUIDKey: &'static [u8; 4usize] = b"uid\0";
pub const kAudioEndPointNameKey: &'static [u8; 5usize] = b"name\0";
pub const kAudioEndPointInputChannelsKey: &'static [u8; 12usize] = b"channels-in\0";
pub const kAudioEndPointOutputChannelsKey: &'static [u8; 13usize] = b"channels-out\0";
pub const kAudioAggregateDeviceUIDKey: &'static [u8; 4usize] = b"uid\0";
pub const kAudioAggregateDeviceNameKey: &'static [u8; 5usize] = b"name\0";
pub const kAudioAggregateDeviceSubDeviceListKey: &'static [u8; 11usize] = b"subdevices\0";
pub const kAudioAggregateDeviceMasterSubDeviceKey: &'static [u8; 7usize] = b"master\0";
pub const kAudioAggregateDeviceClockDeviceKey: &'static [u8; 6usize] = b"clock\0";
pub const kAudioAggregateDeviceIsPrivateKey: &'static [u8; 8usize] = b"private\0";
pub const kAudioAggregateDeviceIsStackedKey: &'static [u8; 8usize] = b"stacked\0";
pub const kAudioSubDeviceUIDKey: &'static [u8; 4usize] = b"uid\0";
pub const kAudioSubDeviceNameKey: &'static [u8; 5usize] = b"name\0";
pub const kAudioSubDeviceInputChannelsKey: &'static [u8; 12usize] = b"channels-in\0";
pub const kAudioSubDeviceOutputChannelsKey: &'static [u8; 13usize] = b"channels-out\0";
pub const kAudioSubDeviceExtraInputLatencyKey: &'static [u8; 11usize] = b"latency-in\0";
pub const kAudioSubDeviceExtraOutputLatencyKey: &'static [u8; 12usize] = b"latency-out\0";
pub const kAudioSubDeviceDriftCompensationKey: &'static [u8; 6usize] = b"drift\0";
pub const kAudioSubDeviceDriftCompensationQualityKey: &'static [u8; 14usize] = b"drift quality\0";
pub const kAudioHardwareRunLoopMode: &'static [u8; 26usize] = b"com.apple.audio.CoreAudio\0";
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __darwin_pthread_handler_rec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_attr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_cond_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_rwlock_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn _Block_copy(aBlock: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _Block_release(aBlock: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _Block_object_assign(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn _Block_object_dispose(arg1: *const ::std::os::raw::c_void, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub static mut _NSConcreteGlobalBlock: [*mut ::std::os::raw::c_void; 32usize];
}
extern "C" {
    pub static mut _NSConcreteStackBlock: [*mut ::std::os::raw::c_void; 32usize];
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type UInt8 = ::std::os::raw::c_uchar;
pub type SInt8 = ::std::os::raw::c_schar;
pub type UInt16 = ::std::os::raw::c_ushort;
pub type SInt16 = ::std::os::raw::c_short;
pub type UInt32 = ::std::os::raw::c_uint;
pub type SInt32 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wide {
    pub _bindgen_opaque_blob: [u16; 4usize],
}
#[test]
fn bindgen_test_layout_wide() {
    assert_eq!(
        ::std::mem::size_of::<wide>(),
        8usize,
        concat!("Size of: ", stringify!(wide))
    );
    assert_eq!(
        ::std::mem::align_of::<wide>(),
        2usize,
        concat!("Alignment of ", stringify!(wide))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UnsignedWide {
    pub _bindgen_opaque_blob: [u16; 4usize],
}
#[test]
fn bindgen_test_layout_UnsignedWide() {
    assert_eq!(
        ::std::mem::size_of::<UnsignedWide>(),
        8usize,
        concat!("Size of: ", stringify!(UnsignedWide))
    );
    assert_eq!(
        ::std::mem::align_of::<UnsignedWide>(),
        2usize,
        concat!("Alignment of ", stringify!(UnsignedWide))
    );
}
pub type SInt64 = ::std::os::raw::c_longlong;
pub type UInt64 = ::std::os::raw::c_ulonglong;
pub type Fixed = SInt32;
pub type FixedPtr = *mut Fixed;
pub type Fract = SInt32;
pub type FractPtr = *mut Fract;
pub type UnsignedFixed = UInt32;
pub type UnsignedFixedPtr = *mut UnsignedFixed;
pub type ShortFixed = ::std::os::raw::c_short;
pub type ShortFixedPtr = *mut ShortFixed;
pub type Float32 = f32;
pub type Float64 = f64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Float80 {
    pub exp: SInt16,
    pub man: [UInt16; 4usize],
}
#[test]
fn bindgen_test_layout_Float80() {
    assert_eq!(
        ::std::mem::size_of::<Float80>(),
        10usize,
        concat!("Size of: ", stringify!(Float80))
    );
    assert_eq!(
        ::std::mem::align_of::<Float80>(),
        2usize,
        concat!("Alignment of ", stringify!(Float80))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Float80>())).exp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Float80),
            "::",
            stringify!(exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Float80>())).man as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Float80),
            "::",
            stringify!(man)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Float96 {
    pub exp: [SInt16; 2usize],
    pub man: [UInt16; 4usize],
}
#[test]
fn bindgen_test_layout_Float96() {
    assert_eq!(
        ::std::mem::size_of::<Float96>(),
        12usize,
        concat!("Size of: ", stringify!(Float96))
    );
    assert_eq!(
        ::std::mem::align_of::<Float96>(),
        2usize,
        concat!("Alignment of ", stringify!(Float96))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Float96>())).exp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Float96),
            "::",
            stringify!(exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Float96>())).man as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Float96),
            "::",
            stringify!(man)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Float32Point {
    pub _bindgen_opaque_blob: [u16; 4usize],
}
#[test]
fn bindgen_test_layout_Float32Point() {
    assert_eq!(
        ::std::mem::size_of::<Float32Point>(),
        8usize,
        concat!("Size of: ", stringify!(Float32Point))
    );
    assert_eq!(
        ::std::mem::align_of::<Float32Point>(),
        2usize,
        concat!("Alignment of ", stringify!(Float32Point))
    );
}
pub type Ptr = *mut ::std::os::raw::c_char;
pub type Handle = *mut Ptr;
pub type Size = ::std::os::raw::c_long;
pub type OSErr = SInt16;
pub type OSStatus = SInt32;
pub type LogicalAddress = *mut ::std::os::raw::c_void;
pub type ConstLogicalAddress = *const ::std::os::raw::c_void;
pub type PhysicalAddress = *mut ::std::os::raw::c_void;
pub type BytePtr = *mut UInt8;
pub type ByteCount = ::std::os::raw::c_ulong;
pub type ByteOffset = ::std::os::raw::c_ulong;
pub type Duration = SInt32;
pub type AbsoluteTime = UnsignedWide;
pub type OptionBits = UInt32;
pub type ItemCount = ::std::os::raw::c_ulong;
pub type PBVersion = UInt32;
pub type ScriptCode = SInt16;
pub type LangCode = SInt16;
pub type RegionCode = SInt16;
pub type FourCharCode = UInt32;
pub type OSType = FourCharCode;
pub type ResType = FourCharCode;
pub type OSTypePtr = *mut OSType;
pub type ResTypePtr = *mut ResType;
pub type Boolean = ::std::os::raw::c_uchar;
pub type ProcPtr = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub type Register68kProcPtr = ::std::option::Option<unsafe extern "C" fn()>;
pub type UniversalProcPtr = ProcPtr;
pub type ProcHandle = *mut ProcPtr;
pub type UniversalProcHandle = *mut UniversalProcPtr;
pub type PRefCon = *mut ::std::os::raw::c_void;
pub type URefCon = *mut ::std::os::raw::c_void;
pub type SRefCon = *mut ::std::os::raw::c_void;
pub const noErr: _bindgen_ty_1 = 0;
pub type _bindgen_ty_1 = u32;
pub const kNilOptions: _bindgen_ty_2 = 0;
pub type _bindgen_ty_2 = u32;
pub const kVariableLengthArray: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = u32;
pub const kUnknownType: _bindgen_ty_4 = 1061109567;
pub type _bindgen_ty_4 = u32;
pub type UnicodeScalarValue = UInt32;
pub type UTF32Char = UInt32;
pub type UniChar = UInt16;
pub type UTF16Char = UInt16;
pub type UTF8Char = UInt8;
pub type UniCharPtr = *mut UniChar;
pub type UniCharCount = ::std::os::raw::c_ulong;
pub type UniCharCountPtr = *mut UniCharCount;
pub type Str255 = [::std::os::raw::c_uchar; 256usize];
pub type Str63 = [::std::os::raw::c_uchar; 64usize];
pub type Str32 = [::std::os::raw::c_uchar; 33usize];
pub type Str31 = [::std::os::raw::c_uchar; 32usize];
pub type Str27 = [::std::os::raw::c_uchar; 28usize];
pub type Str15 = [::std::os::raw::c_uchar; 16usize];
pub type Str32Field = [::std::os::raw::c_uchar; 34usize];
pub type StrFileName = Str63;
pub type StringPtr = *mut ::std::os::raw::c_uchar;
pub type StringHandle = *mut StringPtr;
pub type ConstStringPtr = *const ::std::os::raw::c_uchar;
pub type ConstStr255Param = *const ::std::os::raw::c_uchar;
pub type ConstStr63Param = *const ::std::os::raw::c_uchar;
pub type ConstStr32Param = *const ::std::os::raw::c_uchar;
pub type ConstStr31Param = *const ::std::os::raw::c_uchar;
pub type ConstStr27Param = *const ::std::os::raw::c_uchar;
pub type ConstStr15Param = *const ::std::os::raw::c_uchar;
pub type ConstStrFileNameParam = ConstStr63Param;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ProcessSerialNumber {
    pub _bindgen_opaque_blob: [u16; 4usize],
}
#[test]
fn bindgen_test_layout_ProcessSerialNumber() {
    assert_eq!(
        ::std::mem::size_of::<ProcessSerialNumber>(),
        8usize,
        concat!("Size of: ", stringify!(ProcessSerialNumber))
    );
    assert_eq!(
        ::std::mem::align_of::<ProcessSerialNumber>(),
        2usize,
        concat!("Alignment of ", stringify!(ProcessSerialNumber))
    );
}
pub type ProcessSerialNumberPtr = *mut ProcessSerialNumber;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Point {
    pub v: ::std::os::raw::c_short,
    pub h: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_Point() {
    assert_eq!(
        ::std::mem::size_of::<Point>(),
        4usize,
        concat!("Size of: ", stringify!(Point))
    );
    assert_eq!(
        ::std::mem::align_of::<Point>(),
        2usize,
        concat!("Alignment of ", stringify!(Point))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Point>())).v as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Point), "::", stringify!(v))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Point>())).h as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(Point), "::", stringify!(h))
    );
}
pub type PointPtr = *mut Point;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Rect {
    pub top: ::std::os::raw::c_short,
    pub left: ::std::os::raw::c_short,
    pub bottom: ::std::os::raw::c_short,
    pub right: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_Rect() {
    assert_eq!(
        ::std::mem::size_of::<Rect>(),
        8usize,
        concat!("Size of: ", stringify!(Rect))
    );
    assert_eq!(
        ::std::mem::align_of::<Rect>(),
        2usize,
        concat!("Alignment of ", stringify!(Rect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rect>())).top as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Rect), "::", stringify!(top))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rect>())).left as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Rect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rect>())).bottom as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Rect),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rect>())).right as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Rect),
            "::",
            stringify!(right)
        )
    );
}
pub type RectPtr = *mut Rect;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FixedPoint {
    pub _bindgen_opaque_blob: [u16; 4usize],
}
#[test]
fn bindgen_test_layout_FixedPoint() {
    assert_eq!(
        ::std::mem::size_of::<FixedPoint>(),
        8usize,
        concat!("Size of: ", stringify!(FixedPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<FixedPoint>(),
        2usize,
        concat!("Alignment of ", stringify!(FixedPoint))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FixedRect {
    pub _bindgen_opaque_blob: [u16; 8usize],
}
#[test]
fn bindgen_test_layout_FixedRect() {
    assert_eq!(
        ::std::mem::size_of::<FixedRect>(),
        16usize,
        concat!("Size of: ", stringify!(FixedRect))
    );
    assert_eq!(
        ::std::mem::align_of::<FixedRect>(),
        2usize,
        concat!("Alignment of ", stringify!(FixedRect))
    );
}
pub type CharParameter = ::std::os::raw::c_short;
pub const normal: _bindgen_ty_5 = 0;
pub const bold: _bindgen_ty_5 = 1;
pub const italic: _bindgen_ty_5 = 2;
pub const underline: _bindgen_ty_5 = 4;
pub const outline: _bindgen_ty_5 = 8;
pub const shadow: _bindgen_ty_5 = 16;
pub const condense: _bindgen_ty_5 = 32;
pub const extend: _bindgen_ty_5 = 64;
pub type _bindgen_ty_5 = u32;
pub type Style = ::std::os::raw::c_uchar;
pub type StyleParameter = ::std::os::raw::c_short;
pub type StyleField = Style;
pub type TimeValue = SInt32;
pub type TimeScale = SInt32;
pub type CompTimeValue = wide;
pub type TimeValue64 = SInt64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TimeBaseRecord {
    _unused: [u8; 0],
}
pub type TimeBase = *mut TimeBaseRecord;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TimeRecord {
    pub _bindgen_opaque_blob: [u16; 10usize],
}
#[test]
fn bindgen_test_layout_TimeRecord() {
    assert_eq!(
        ::std::mem::size_of::<TimeRecord>(),
        20usize,
        concat!("Size of: ", stringify!(TimeRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<TimeRecord>(),
        2usize,
        concat!("Alignment of ", stringify!(TimeRecord))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NumVersion {
    pub nonRelRev: UInt8,
    pub stage: UInt8,
    pub minorAndBugRev: UInt8,
    pub majorRev: UInt8,
}
#[test]
fn bindgen_test_layout_NumVersion() {
    assert_eq!(
        ::std::mem::size_of::<NumVersion>(),
        4usize,
        concat!("Size of: ", stringify!(NumVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<NumVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(NumVersion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NumVersion>())).nonRelRev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumVersion),
            "::",
            stringify!(nonRelRev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NumVersion>())).stage as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(NumVersion),
            "::",
            stringify!(stage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NumVersion>())).minorAndBugRev as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NumVersion),
            "::",
            stringify!(minorAndBugRev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NumVersion>())).majorRev as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(NumVersion),
            "::",
            stringify!(majorRev)
        )
    );
}
pub const developStage: _bindgen_ty_6 = 32;
pub const alphaStage: _bindgen_ty_6 = 64;
pub const betaStage: _bindgen_ty_6 = 96;
pub const finalStage: _bindgen_ty_6 = 128;
pub type _bindgen_ty_6 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union NumVersionVariant {
    pub _bindgen_opaque_blob: [u16; 2usize],
}
#[test]
fn bindgen_test_layout_NumVersionVariant() {
    assert_eq!(
        ::std::mem::size_of::<NumVersionVariant>(),
        4usize,
        concat!("Size of: ", stringify!(NumVersionVariant))
    );
    assert_eq!(
        ::std::mem::align_of::<NumVersionVariant>(),
        2usize,
        concat!("Alignment of ", stringify!(NumVersionVariant))
    );
}
impl Default for NumVersionVariant {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type NumVersionVariantPtr = *mut NumVersionVariant;
pub type NumVersionVariantHandle = *mut NumVersionVariantPtr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VersRec {
    pub numericVersion: NumVersion,
    pub countryCode: ::std::os::raw::c_short,
    pub shortVersion: Str255,
    pub reserved: Str255,
}
#[test]
fn bindgen_test_layout_VersRec() {
    assert_eq!(
        ::std::mem::size_of::<VersRec>(),
        518usize,
        concat!("Size of: ", stringify!(VersRec))
    );
    assert_eq!(
        ::std::mem::align_of::<VersRec>(),
        2usize,
        concat!("Alignment of ", stringify!(VersRec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VersRec>())).numericVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VersRec),
            "::",
            stringify!(numericVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VersRec>())).countryCode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VersRec),
            "::",
            stringify!(countryCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VersRec>())).shortVersion as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(VersRec),
            "::",
            stringify!(shortVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VersRec>())).reserved as *const _ as usize },
        262usize,
        concat!(
            "Offset of field: ",
            stringify!(VersRec),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for VersRec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type VersRecPtr = *mut VersRec;
pub type VersRecHndl = *mut VersRecPtr;
pub type Byte = UInt8;
pub type SignedByte = SInt8;
pub type WidePtr = *mut wide;
pub type UnsignedWidePtr = *mut UnsignedWide;
pub type extended80 = Float80;
pub type extended96 = Float96;
pub type VHSelect = SInt8;
extern "C" {
    pub fn Debugger();
}
extern "C" {
    pub fn DebugStr(debuggerMsg: ConstStr255Param);
}
extern "C" {
    pub fn SysBreak();
}
extern "C" {
    pub fn SysBreakStr(debuggerMsg: ConstStr255Param);
}
extern "C" {
    pub fn SysBreakFunc(debuggerMsg: ConstStr255Param);
}
extern "C" {
    pub static mut kCFCoreFoundationVersionNumber: f64;
}
pub type CFTypeID = ::std::os::raw::c_ulong;
pub type CFOptionFlags = ::std::os::raw::c_ulong;
pub type CFHashCode = ::std::os::raw::c_ulong;
pub type CFIndex = ::std::os::raw::c_long;
pub type CFTypeRef = *const ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFString {
    _unused: [u8; 0],
}
pub type CFStringRef = *const __CFString;
pub type CFMutableStringRef = *mut __CFString;
pub type CFPropertyListRef = CFTypeRef;
pub type CFComparisonResult = CFIndex;
pub const kCFCompareLessThan: _bindgen_ty_7 = -1;
pub const kCFCompareEqualTo: _bindgen_ty_7 = 0;
pub const kCFCompareGreaterThan: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = i32;
pub type CFComparatorFunction = ::std::option::Option<
    unsafe extern "C" fn(
        val1: *const ::std::os::raw::c_void,
        val2: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
    ) -> CFComparisonResult,
>;
pub const kCFNotFound: CFIndex = -1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CFRange {
    pub location: CFIndex,
    pub length: CFIndex,
}
#[test]
fn bindgen_test_layout_CFRange() {
    assert_eq!(
        ::std::mem::size_of::<CFRange>(),
        16usize,
        concat!("Size of: ", stringify!(CFRange))
    );
    assert_eq!(
        ::std::mem::align_of::<CFRange>(),
        8usize,
        concat!("Alignment of ", stringify!(CFRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRange>())).location as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRange),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRange>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRange),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn __CFRangeMake(loc: CFIndex, len: CFIndex) -> CFRange;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFNull {
    _unused: [u8; 0],
}
pub type CFNullRef = *const __CFNull;
extern "C" {
    pub fn CFNullGetTypeID() -> CFTypeID;
}
extern "C" {
    pub static kCFNull: CFNullRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFAllocator {
    _unused: [u8; 0],
}
pub type CFAllocatorRef = *const __CFAllocator;
extern "C" {
    pub static kCFAllocatorDefault: CFAllocatorRef;
}
extern "C" {
    pub static kCFAllocatorSystemDefault: CFAllocatorRef;
}
extern "C" {
    pub static kCFAllocatorMalloc: CFAllocatorRef;
}
extern "C" {
    pub static kCFAllocatorMallocZone: CFAllocatorRef;
}
extern "C" {
    pub static kCFAllocatorNull: CFAllocatorRef;
}
extern "C" {
    pub static kCFAllocatorUseContext: CFAllocatorRef;
}
pub type CFAllocatorRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
>;
pub type CFAllocatorReleaseCallBack =
    ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>;
pub type CFAllocatorCopyDescriptionCallBack =
    ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef>;
pub type CFAllocatorAllocateCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        allocSize: CFIndex,
        hint: CFOptionFlags,
        info: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type CFAllocatorReallocateCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        newsize: CFIndex,
        hint: CFOptionFlags,
        info: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type CFAllocatorDeallocateCallBack = ::std::option::Option<
    unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void, info: *mut ::std::os::raw::c_void),
>;
pub type CFAllocatorPreferredSizeCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        size: CFIndex,
        hint: CFOptionFlags,
        info: *mut ::std::os::raw::c_void,
    ) -> CFIndex,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFAllocatorContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: CFAllocatorRetainCallBack,
    pub release: CFAllocatorReleaseCallBack,
    pub copyDescription: CFAllocatorCopyDescriptionCallBack,
    pub allocate: CFAllocatorAllocateCallBack,
    pub reallocate: CFAllocatorReallocateCallBack,
    pub deallocate: CFAllocatorDeallocateCallBack,
    pub preferredSize: CFAllocatorPreferredSizeCallBack,
}
#[test]
fn bindgen_test_layout_CFAllocatorContext() {
    assert_eq!(
        ::std::mem::size_of::<CFAllocatorContext>(),
        72usize,
        concat!("Size of: ", stringify!(CFAllocatorContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFAllocatorContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFAllocatorContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFAllocatorContext>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFAllocatorContext>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFAllocatorContext>())).retain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFAllocatorContext>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFAllocatorContext>())).copyDescription as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFAllocatorContext>())).allocate as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(allocate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFAllocatorContext>())).reallocate as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(reallocate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFAllocatorContext>())).deallocate as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(deallocate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFAllocatorContext>())).preferredSize as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CFAllocatorContext),
            "::",
            stringify!(preferredSize)
        )
    );
}
impl Default for CFAllocatorContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn CFAllocatorGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFAllocatorSetDefault(allocator: CFAllocatorRef);
}
extern "C" {
    pub fn CFAllocatorGetDefault() -> CFAllocatorRef;
}
extern "C" {
    pub fn CFAllocatorCreate(
        allocator: CFAllocatorRef,
        context: *mut CFAllocatorContext,
    ) -> CFAllocatorRef;
}
extern "C" {
    pub fn CFAllocatorAllocate(
        allocator: CFAllocatorRef,
        size: CFIndex,
        hint: CFOptionFlags,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFAllocatorReallocate(
        allocator: CFAllocatorRef,
        ptr: *mut ::std::os::raw::c_void,
        newsize: CFIndex,
        hint: CFOptionFlags,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFAllocatorDeallocate(allocator: CFAllocatorRef, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn CFAllocatorGetPreferredSizeForSize(
        allocator: CFAllocatorRef,
        size: CFIndex,
        hint: CFOptionFlags,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFAllocatorGetContext(allocator: CFAllocatorRef, context: *mut CFAllocatorContext);
}
extern "C" {
    pub fn CFGetTypeID(cf: CFTypeRef) -> CFTypeID;
}
extern "C" {
    pub fn CFCopyTypeIDDescription(type_id: CFTypeID) -> CFStringRef;
}
extern "C" {
    pub fn CFRetain(cf: CFTypeRef) -> CFTypeRef;
}
extern "C" {
    pub fn CFRelease(cf: CFTypeRef);
}
extern "C" {
    pub fn CFAutorelease(arg: CFTypeRef) -> CFTypeRef;
}
extern "C" {
    pub fn CFGetRetainCount(cf: CFTypeRef) -> CFIndex;
}
extern "C" {
    pub fn CFEqual(cf1: CFTypeRef, cf2: CFTypeRef) -> Boolean;
}
extern "C" {
    pub fn CFHash(cf: CFTypeRef) -> CFHashCode;
}
extern "C" {
    pub fn CFCopyDescription(cf: CFTypeRef) -> CFStringRef;
}
extern "C" {
    pub fn CFGetAllocator(cf: CFTypeRef) -> CFAllocatorRef;
}
extern "C" {
    pub fn CFMakeCollectable(cf: CFTypeRef) -> CFTypeRef;
}
pub const kAudio_UnimplementedError: _bindgen_ty_8 = -4;
pub const kAudio_FileNotFoundError: _bindgen_ty_8 = -43;
pub const kAudio_FilePermissionError: _bindgen_ty_8 = -54;
pub const kAudio_TooManyFilesOpenError: _bindgen_ty_8 = -42;
pub const kAudio_BadFilePathError: _bindgen_ty_8 = 561017960;
pub const kAudio_ParamError: _bindgen_ty_8 = -50;
pub const kAudio_MemFullError: _bindgen_ty_8 = -108;
pub type _bindgen_ty_8 = i32;
///@struct         AudioValueRange
///@abstract       This structure holds a pair of numbers that represent a continuous range of
///values.
///@field          mMinimum
///The minimum value.
///@field          mMaximum
///The maximum value.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioValueRange {
    pub mMinimum: Float64,
    pub mMaximum: Float64,
}
#[test]
fn bindgen_test_layout_AudioValueRange() {
    assert_eq!(
        ::std::mem::size_of::<AudioValueRange>(),
        16usize,
        concat!("Size of: ", stringify!(AudioValueRange))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioValueRange>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioValueRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioValueRange>())).mMinimum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioValueRange),
            "::",
            stringify!(mMinimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioValueRange>())).mMaximum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioValueRange),
            "::",
            stringify!(mMaximum)
        )
    );
}
///@struct         AudioValueTranslation
///@abstract       This stucture holds the buffers necessary for translation operations.
///@field          mInputData
///The buffer containing the data to be translated.
///@field          mInputDataSize
///The number of bytes in the buffer pointed at by mInputData.
///@field          mOutputData
///The buffer to hold the result of the translation.
///@field          mOutputDataSize
///The number of bytes in the buffer pointed at by mOutputData.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioValueTranslation {
    pub mInputData: *mut ::std::os::raw::c_void,
    pub mInputDataSize: UInt32,
    pub mOutputData: *mut ::std::os::raw::c_void,
    pub mOutputDataSize: UInt32,
}
#[test]
fn bindgen_test_layout_AudioValueTranslation() {
    assert_eq!(
        ::std::mem::size_of::<AudioValueTranslation>(),
        32usize,
        concat!("Size of: ", stringify!(AudioValueTranslation))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioValueTranslation>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioValueTranslation))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioValueTranslation>())).mInputData as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioValueTranslation),
            "::",
            stringify!(mInputData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioValueTranslation>())).mInputDataSize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioValueTranslation),
            "::",
            stringify!(mInputDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioValueTranslation>())).mOutputData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioValueTranslation),
            "::",
            stringify!(mOutputData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioValueTranslation>())).mOutputDataSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioValueTranslation),
            "::",
            stringify!(mOutputDataSize)
        )
    );
}
impl Default for AudioValueTranslation {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@struct         AudioBuffer
///@abstract       A structure to hold a buffer of audio data.
///@field          mNumberChannels
///The number of interleaved channels in the buffer.
///@field          mDataByteSize
///The number of bytes in the buffer pointed at by mData.
///@field          mData
///A pointer to the buffer of audio data.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioBuffer {
    pub mNumberChannels: UInt32,
    pub mDataByteSize: UInt32,
    pub mData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AudioBuffer() {
    assert_eq!(
        ::std::mem::size_of::<AudioBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(AudioBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioBuffer>())).mNumberChannels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioBuffer),
            "::",
            stringify!(mNumberChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioBuffer>())).mDataByteSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioBuffer),
            "::",
            stringify!(mDataByteSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioBuffer>())).mData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioBuffer),
            "::",
            stringify!(mData)
        )
    );
}
impl Default for AudioBuffer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@struct         AudioBufferList
///@abstract       A variable length array of AudioBuffer structures.
///@field          mNumberBuffers
///The number of AudioBuffers in the mBuffers array.
///@field          mBuffers
///A variable length array of AudioBuffers.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioBufferList {
    pub mNumberBuffers: UInt32,
    pub mBuffers: [AudioBuffer; 1usize],
}
#[test]
fn bindgen_test_layout_AudioBufferList() {
    assert_eq!(
        ::std::mem::size_of::<AudioBufferList>(),
        24usize,
        concat!("Size of: ", stringify!(AudioBufferList))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioBufferList>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioBufferList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioBufferList>())).mNumberBuffers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioBufferList),
            "::",
            stringify!(mNumberBuffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioBufferList>())).mBuffers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioBufferList),
            "::",
            stringify!(mBuffers)
        )
    );
}
impl Default for AudioBufferList {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type AudioSampleType = Float32;
pub type AudioUnitSampleType = Float32;
///@typedef        AudioFormatID
///@abstract       A four char code indicating the general kind of data in the stream.
pub type AudioFormatID = UInt32;
///@typedef        AudioFormatFlags
///@abstract       Flags that are specific to each format.
pub type AudioFormatFlags = UInt32;
///@struct         AudioStreamBasicDescription
///@abstract       This structure encapsulates all the information for describing the basic
///format properties of a stream of audio data.
///@discussion     This structure is sufficient to describe any constant bit rate format that  has
///channels that are the same size. Extensions are required for variable bit rate
///data and for constant bit rate data where the channels have unequal sizes.
///However, where applicable, the appropriate fields will be filled out correctly
///for these kinds of formats (the extra data is provided via separate properties).
///In all fields, a value of 0 indicates that the field is either unknown, not
///applicable or otherwise is inapproprate for the format and should be ignored.
///Note that 0 is still a valid value for most formats in the mFormatFlags field.
///
///In audio data a frame is one sample across all channels. In non-interleaved
///audio, the per frame fields identify one channel. In interleaved audio, the per
///frame fields identify the set of n channels. In uncompressed audio, a Packet is
///one frame, (mFramesPerPacket == 1). In compressed audio, a Packet is an
///indivisible chunk of compressed data, for example an AAC packet will contain
///1024 sample frames.
///
///@field          mSampleRate
///The number of sample frames per second of the data in the stream.
///@field          mFormatID
///The AudioFormatID indicating the general kind of data in the stream.
///@field          mFormatFlags
///The AudioFormatFlags for the format indicated by mFormatID.
///@field          mBytesPerPacket
///The number of bytes in a packet of data.
///@field          mFramesPerPacket
///The number of sample frames in each packet of data.
///@field          mBytesPerFrame
///The number of bytes in a single sample frame of data.
///@field          mChannelsPerFrame
///The number of channels in each frame of data.
///@field          mBitsPerChannel
///The number of bits of sample data for each channel in a frame of data.
///@field          mReserved
///Pads the structure out to force an even 8 byte alignment.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioStreamBasicDescription {
    pub mSampleRate: Float64,
    pub mFormatID: AudioFormatID,
    pub mFormatFlags: AudioFormatFlags,
    pub mBytesPerPacket: UInt32,
    pub mFramesPerPacket: UInt32,
    pub mBytesPerFrame: UInt32,
    pub mChannelsPerFrame: UInt32,
    pub mBitsPerChannel: UInt32,
    pub mReserved: UInt32,
}
#[test]
fn bindgen_test_layout_AudioStreamBasicDescription() {
    assert_eq!(
        ::std::mem::size_of::<AudioStreamBasicDescription>(),
        40usize,
        concat!("Size of: ", stringify!(AudioStreamBasicDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioStreamBasicDescription>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioStreamBasicDescription))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamBasicDescription>())).mSampleRate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamBasicDescription),
            "::",
            stringify!(mSampleRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamBasicDescription>())).mFormatID as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamBasicDescription),
            "::",
            stringify!(mFormatID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamBasicDescription>())).mFormatFlags as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamBasicDescription),
            "::",
            stringify!(mFormatFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamBasicDescription>())).mBytesPerPacket as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamBasicDescription),
            "::",
            stringify!(mBytesPerPacket)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamBasicDescription>())).mFramesPerPacket as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamBasicDescription),
            "::",
            stringify!(mFramesPerPacket)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamBasicDescription>())).mBytesPerFrame as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamBasicDescription),
            "::",
            stringify!(mBytesPerFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamBasicDescription>())).mChannelsPerFrame as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamBasicDescription),
            "::",
            stringify!(mChannelsPerFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamBasicDescription>())).mBitsPerChannel as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamBasicDescription),
            "::",
            stringify!(mBitsPerChannel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamBasicDescription>())).mReserved as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamBasicDescription),
            "::",
            stringify!(mReserved)
        )
    );
}
pub const kAudioStreamAnyRate: Float64 = 0.0;
pub const kAudioFormatLinearPCM: _bindgen_ty_9 = 1819304813;
pub const kAudioFormatAC3: _bindgen_ty_9 = 1633889587;
pub const kAudioFormat60958AC3: _bindgen_ty_9 = 1667326771;
pub const kAudioFormatAppleIMA4: _bindgen_ty_9 = 1768775988;
pub const kAudioFormatMPEG4AAC: _bindgen_ty_9 = 1633772320;
pub const kAudioFormatMPEG4CELP: _bindgen_ty_9 = 1667591280;
pub const kAudioFormatMPEG4HVXC: _bindgen_ty_9 = 1752594531;
pub const kAudioFormatMPEG4TwinVQ: _bindgen_ty_9 = 1953986161;
pub const kAudioFormatMACE3: _bindgen_ty_9 = 1296122675;
pub const kAudioFormatMACE6: _bindgen_ty_9 = 1296122678;
pub const kAudioFormatULaw: _bindgen_ty_9 = 1970037111;
pub const kAudioFormatALaw: _bindgen_ty_9 = 1634492791;
pub const kAudioFormatQDesign: _bindgen_ty_9 = 1363430723;
pub const kAudioFormatQDesign2: _bindgen_ty_9 = 1363430706;
pub const kAudioFormatQUALCOMM: _bindgen_ty_9 = 1365470320;
pub const kAudioFormatMPEGLayer1: _bindgen_ty_9 = 778924081;
pub const kAudioFormatMPEGLayer2: _bindgen_ty_9 = 778924082;
pub const kAudioFormatMPEGLayer3: _bindgen_ty_9 = 778924083;
pub const kAudioFormatTimeCode: _bindgen_ty_9 = 1953066341;
pub const kAudioFormatMIDIStream: _bindgen_ty_9 = 1835623529;
pub const kAudioFormatParameterValueStream: _bindgen_ty_9 = 1634760307;
pub const kAudioFormatAppleLossless: _bindgen_ty_9 = 1634492771;
pub const kAudioFormatMPEG4AAC_HE: _bindgen_ty_9 = 1633772392;
pub const kAudioFormatMPEG4AAC_LD: _bindgen_ty_9 = 1633772396;
pub const kAudioFormatMPEG4AAC_ELD: _bindgen_ty_9 = 1633772389;
pub const kAudioFormatMPEG4AAC_ELD_SBR: _bindgen_ty_9 = 1633772390;
pub const kAudioFormatMPEG4AAC_ELD_V2: _bindgen_ty_9 = 1633772391;
pub const kAudioFormatMPEG4AAC_HE_V2: _bindgen_ty_9 = 1633772400;
pub const kAudioFormatMPEG4AAC_Spatial: _bindgen_ty_9 = 1633772403;
pub const kAudioFormatAMR: _bindgen_ty_9 = 1935764850;
pub const kAudioFormatAMR_WB: _bindgen_ty_9 = 1935767394;
pub const kAudioFormatAudible: _bindgen_ty_9 = 1096107074;
pub const kAudioFormatiLBC: _bindgen_ty_9 = 1768710755;
pub const kAudioFormatDVIIntelIMA: _bindgen_ty_9 = 1836253201;
pub const kAudioFormatMicrosoftGSM: _bindgen_ty_9 = 1836253233;
pub const kAudioFormatAES3: _bindgen_ty_9 = 1634038579;
pub const kAudioFormatEnhancedAC3: _bindgen_ty_9 = 1700998451;
pub const kAudioFormatFLAC: _bindgen_ty_9 = 1718378851;
pub const kAudioFormatOpus: _bindgen_ty_9 = 1869641075;
pub type _bindgen_ty_9 = u32;
pub const kAudioFormatFlagIsFloat: _bindgen_ty_10 = 1;
pub const kAudioFormatFlagIsBigEndian: _bindgen_ty_10 = 2;
pub const kAudioFormatFlagIsSignedInteger: _bindgen_ty_10 = 4;
pub const kAudioFormatFlagIsPacked: _bindgen_ty_10 = 8;
pub const kAudioFormatFlagIsAlignedHigh: _bindgen_ty_10 = 16;
pub const kAudioFormatFlagIsNonInterleaved: _bindgen_ty_10 = 32;
pub const kAudioFormatFlagIsNonMixable: _bindgen_ty_10 = 64;
pub const kAudioFormatFlagsAreAllClear: _bindgen_ty_10 = 2147483648;
pub const kLinearPCMFormatFlagIsFloat: _bindgen_ty_10 = 1;
pub const kLinearPCMFormatFlagIsBigEndian: _bindgen_ty_10 = 2;
pub const kLinearPCMFormatFlagIsSignedInteger: _bindgen_ty_10 = 4;
pub const kLinearPCMFormatFlagIsPacked: _bindgen_ty_10 = 8;
pub const kLinearPCMFormatFlagIsAlignedHigh: _bindgen_ty_10 = 16;
pub const kLinearPCMFormatFlagIsNonInterleaved: _bindgen_ty_10 = 32;
pub const kLinearPCMFormatFlagIsNonMixable: _bindgen_ty_10 = 64;
pub const kLinearPCMFormatFlagsSampleFractionShift: _bindgen_ty_10 = 7;
pub const kLinearPCMFormatFlagsSampleFractionMask: _bindgen_ty_10 = 8064;
pub const kLinearPCMFormatFlagsAreAllClear: _bindgen_ty_10 = 2147483648;
pub const kAppleLosslessFormatFlag_16BitSourceData: _bindgen_ty_10 = 1;
pub const kAppleLosslessFormatFlag_20BitSourceData: _bindgen_ty_10 = 2;
pub const kAppleLosslessFormatFlag_24BitSourceData: _bindgen_ty_10 = 3;
pub const kAppleLosslessFormatFlag_32BitSourceData: _bindgen_ty_10 = 4;
pub type _bindgen_ty_10 = u32;
pub const kAudioFormatFlagsNativeEndian: _bindgen_ty_11 = 0;
pub const kAudioFormatFlagsCanonical: _bindgen_ty_11 = 9;
pub const kAudioFormatFlagsAudioUnitCanonical: _bindgen_ty_11 = 41;
pub const kAudioFormatFlagsNativeFloatPacked: _bindgen_ty_11 = 9;
pub type _bindgen_ty_11 = u32;
///@struct         AudioStreamPacketDescription
///@abstract       This structure describes the packet layout of a buffer of data where the size of
///each packet may not be the same or where there is extraneous data between
///packets.
///@field          mStartOffset
///The number of bytes from the start of the buffer to the beginning of the
///packet.
///@field          mVariableFramesInPacket
///The number of sample frames of data in the packet. For formats with a
///constant number of frames per packet, this field is set to 0.
///@field          mDataByteSize
///The number of bytes in the packet.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioStreamPacketDescription {
    pub mStartOffset: SInt64,
    pub mVariableFramesInPacket: UInt32,
    pub mDataByteSize: UInt32,
}
#[test]
fn bindgen_test_layout_AudioStreamPacketDescription() {
    assert_eq!(
        ::std::mem::size_of::<AudioStreamPacketDescription>(),
        16usize,
        concat!("Size of: ", stringify!(AudioStreamPacketDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioStreamPacketDescription>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioStreamPacketDescription))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamPacketDescription>())).mStartOffset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamPacketDescription),
            "::",
            stringify!(mStartOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamPacketDescription>())).mVariableFramesInPacket
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamPacketDescription),
            "::",
            stringify!(mVariableFramesInPacket)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamPacketDescription>())).mDataByteSize as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamPacketDescription),
            "::",
            stringify!(mDataByteSize)
        )
    );
}
///@enum           SMPTE Time Types
///@abstract       Constants that describe the type of SMPTE time.
///@constant       kSMPTETimeType24
///24 Frame
///@constant       kSMPTETimeType25
///25 Frame
///@constant       kSMPTETimeType30Drop
///30 Drop Frame
///@constant       kSMPTETimeType30
///30 Frame
///@constant       kSMPTETimeType2997
///29.97 Frame
///@constant       kSMPTETimeType2997Drop
///29.97 Drop Frame
///@constant       kSMPTETimeType60
///60 Frame
///@constant       kSMPTETimeType5994
///59.94 Frame
///@constant       kSMPTETimeType60Drop
///60 Drop Frame
///@constant       kSMPTETimeType5994Drop
///59.94 Drop Frame
///@constant       kSMPTETimeType50
///50 Frame
///@constant       kSMPTETimeType2398
///23.98 Frame
pub type SMPTETimeType = UInt32;
pub const kSMPTETimeType24: _bindgen_ty_12 = 0;
pub const kSMPTETimeType25: _bindgen_ty_12 = 1;
pub const kSMPTETimeType30Drop: _bindgen_ty_12 = 2;
pub const kSMPTETimeType30: _bindgen_ty_12 = 3;
pub const kSMPTETimeType2997: _bindgen_ty_12 = 4;
pub const kSMPTETimeType2997Drop: _bindgen_ty_12 = 5;
pub const kSMPTETimeType60: _bindgen_ty_12 = 6;
pub const kSMPTETimeType5994: _bindgen_ty_12 = 7;
pub const kSMPTETimeType60Drop: _bindgen_ty_12 = 8;
pub const kSMPTETimeType5994Drop: _bindgen_ty_12 = 9;
pub const kSMPTETimeType50: _bindgen_ty_12 = 10;
pub const kSMPTETimeType2398: _bindgen_ty_12 = 11;
pub type _bindgen_ty_12 = u32;
///@enum           SMPTE State Flags
///@abstract       Flags that describe the SMPTE time state.
///@constant       kSMPTETimeValid
///The full time is valid.
///@constant       kSMPTETimeRunning
///Time is running.
pub type SMPTETimeFlags = UInt32;
pub const kSMPTETimeUnknown: _bindgen_ty_13 = 0;
pub const kSMPTETimeValid: _bindgen_ty_13 = 1;
pub const kSMPTETimeRunning: _bindgen_ty_13 = 2;
pub type _bindgen_ty_13 = u32;
///@struct         SMPTETime
///@abstract       A structure for holding a SMPTE time.
///@field          mSubframes
///The number of subframes in the full message.
///@field          mSubframeDivisor
///The number of subframes per frame (typically 80).
///@field          mCounter
///The total number of messages received.
///@field          mType
///The kind of SMPTE time using the SMPTE time type constants.
///@field          mFlags
///A set of flags that indicate the SMPTE state.
///@field          mHours
///The number of hours in the full message.
///@field          mMinutes
///The number of minutes in the full message.
///@field          mSeconds
///The number of seconds in the full message.
///@field          mFrames
///The number of frames in the full message.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SMPTETime {
    pub mSubframes: SInt16,
    pub mSubframeDivisor: SInt16,
    pub mCounter: UInt32,
    pub mType: SMPTETimeType,
    pub mFlags: SMPTETimeFlags,
    pub mHours: SInt16,
    pub mMinutes: SInt16,
    pub mSeconds: SInt16,
    pub mFrames: SInt16,
}
#[test]
fn bindgen_test_layout_SMPTETime() {
    assert_eq!(
        ::std::mem::size_of::<SMPTETime>(),
        24usize,
        concat!("Size of: ", stringify!(SMPTETime))
    );
    assert_eq!(
        ::std::mem::align_of::<SMPTETime>(),
        4usize,
        concat!("Alignment of ", stringify!(SMPTETime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETime>())).mSubframes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETime),
            "::",
            stringify!(mSubframes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETime>())).mSubframeDivisor as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETime),
            "::",
            stringify!(mSubframeDivisor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETime>())).mCounter as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETime),
            "::",
            stringify!(mCounter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETime>())).mType as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETime),
            "::",
            stringify!(mType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETime>())).mFlags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETime),
            "::",
            stringify!(mFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETime>())).mHours as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETime),
            "::",
            stringify!(mHours)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETime>())).mMinutes as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETime),
            "::",
            stringify!(mMinutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETime>())).mSeconds as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETime),
            "::",
            stringify!(mSeconds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SMPTETime>())).mFrames as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPTETime),
            "::",
            stringify!(mFrames)
        )
    );
}
///@enum           AudioTimeStamp Flags
///@abstract       The flags that indicate which fields in an AudioTimeStamp structure are valid.
///@constant       kAudioTimeStampSampleTimeValid
///The sample frame time is valid.
///@constant       kAudioTimeStampHostTimeValid
///The host time is valid.
///@constant       kAudioTimeStampRateScalarValid
///The rate scalar is valid.
///@constant       kAudioTimeStampWordClockTimeValid
///The word clock time is valid.
///@constant       kAudioTimeStampSMPTETimeValid
///The SMPTE time is valid.
///@constant       kAudioTimeStampSampleHostTimeValid
///The sample frame time and the host time are valid.
pub type AudioTimeStampFlags = UInt32;
pub const kAudioTimeStampNothingValid: _bindgen_ty_14 = 0;
pub const kAudioTimeStampSampleTimeValid: _bindgen_ty_14 = 1;
pub const kAudioTimeStampHostTimeValid: _bindgen_ty_14 = 2;
pub const kAudioTimeStampRateScalarValid: _bindgen_ty_14 = 4;
pub const kAudioTimeStampWordClockTimeValid: _bindgen_ty_14 = 8;
pub const kAudioTimeStampSMPTETimeValid: _bindgen_ty_14 = 16;
pub const kAudioTimeStampSampleHostTimeValid: _bindgen_ty_14 = 3;
pub type _bindgen_ty_14 = u32;
///@struct         AudioTimeStamp
///@abstract       A structure that holds different representations of the same point in time.
///@field          mSampleTime
///The absolute sample frame time.
///@field          mHostTime
///The host machine's time base, mach_absolute_time.
///@field          mRateScalar
///The ratio of actual host ticks per sample frame to the nominal host ticks
///per sample frame.
///@field          mWordClockTime
///The word clock time.
///@field          mSMPTETime
///The SMPTE time.
///@field          mFlags
///A set of flags indicating which representations of the time are valid.
///@field          mReserved
///Pads the structure out to force an even 8 byte alignment.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioTimeStamp {
    pub mSampleTime: Float64,
    pub mHostTime: UInt64,
    pub mRateScalar: Float64,
    pub mWordClockTime: UInt64,
    pub mSMPTETime: SMPTETime,
    pub mFlags: AudioTimeStampFlags,
    pub mReserved: UInt32,
}
#[test]
fn bindgen_test_layout_AudioTimeStamp() {
    assert_eq!(
        ::std::mem::size_of::<AudioTimeStamp>(),
        64usize,
        concat!("Size of: ", stringify!(AudioTimeStamp))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioTimeStamp>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioTimeStamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioTimeStamp>())).mSampleTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioTimeStamp),
            "::",
            stringify!(mSampleTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioTimeStamp>())).mHostTime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioTimeStamp),
            "::",
            stringify!(mHostTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioTimeStamp>())).mRateScalar as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioTimeStamp),
            "::",
            stringify!(mRateScalar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioTimeStamp>())).mWordClockTime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioTimeStamp),
            "::",
            stringify!(mWordClockTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioTimeStamp>())).mSMPTETime as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioTimeStamp),
            "::",
            stringify!(mSMPTETime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioTimeStamp>())).mFlags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioTimeStamp),
            "::",
            stringify!(mFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioTimeStamp>())).mReserved as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioTimeStamp),
            "::",
            stringify!(mReserved)
        )
    );
}
///@struct         AudioClassDescription
///@abstract       This structure is used to describe codecs installed on the system.
///@field          mType
///The four char code codec type.
///@field          mSubType
///The four char code codec subtype.
///@field          mManufacturer
///The four char code codec manufacturer.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioClassDescription {
    pub mType: OSType,
    pub mSubType: OSType,
    pub mManufacturer: OSType,
}
#[test]
fn bindgen_test_layout_AudioClassDescription() {
    assert_eq!(
        ::std::mem::size_of::<AudioClassDescription>(),
        12usize,
        concat!("Size of: ", stringify!(AudioClassDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioClassDescription>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioClassDescription))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioClassDescription>())).mType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioClassDescription),
            "::",
            stringify!(mType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioClassDescription>())).mSubType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioClassDescription),
            "::",
            stringify!(mSubType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioClassDescription>())).mManufacturer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioClassDescription),
            "::",
            stringify!(mManufacturer)
        )
    );
}
///@typedef        AudioChannelLabel
///@abstract       A tag identifying how the channel is to be used.
pub type AudioChannelLabel = UInt32;
///@typedef        AudioChannelLayoutTag
///@abstract       A tag identifying a particular pre-defined channel layout.
pub type AudioChannelLayoutTag = UInt32;
pub const kAudioChannelLabel_Unknown: _bindgen_ty_15 = 4294967295;
pub const kAudioChannelLabel_Unused: _bindgen_ty_15 = 0;
pub const kAudioChannelLabel_UseCoordinates: _bindgen_ty_15 = 100;
pub const kAudioChannelLabel_Left: _bindgen_ty_15 = 1;
pub const kAudioChannelLabel_Right: _bindgen_ty_15 = 2;
pub const kAudioChannelLabel_Center: _bindgen_ty_15 = 3;
pub const kAudioChannelLabel_LFEScreen: _bindgen_ty_15 = 4;
pub const kAudioChannelLabel_LeftSurround: _bindgen_ty_15 = 5;
pub const kAudioChannelLabel_RightSurround: _bindgen_ty_15 = 6;
pub const kAudioChannelLabel_LeftCenter: _bindgen_ty_15 = 7;
pub const kAudioChannelLabel_RightCenter: _bindgen_ty_15 = 8;
pub const kAudioChannelLabel_CenterSurround: _bindgen_ty_15 = 9;
pub const kAudioChannelLabel_LeftSurroundDirect: _bindgen_ty_15 = 10;
pub const kAudioChannelLabel_RightSurroundDirect: _bindgen_ty_15 = 11;
pub const kAudioChannelLabel_TopCenterSurround: _bindgen_ty_15 = 12;
pub const kAudioChannelLabel_VerticalHeightLeft: _bindgen_ty_15 = 13;
pub const kAudioChannelLabel_VerticalHeightCenter: _bindgen_ty_15 = 14;
pub const kAudioChannelLabel_VerticalHeightRight: _bindgen_ty_15 = 15;
pub const kAudioChannelLabel_TopBackLeft: _bindgen_ty_15 = 16;
pub const kAudioChannelLabel_TopBackCenter: _bindgen_ty_15 = 17;
pub const kAudioChannelLabel_TopBackRight: _bindgen_ty_15 = 18;
pub const kAudioChannelLabel_RearSurroundLeft: _bindgen_ty_15 = 33;
pub const kAudioChannelLabel_RearSurroundRight: _bindgen_ty_15 = 34;
pub const kAudioChannelLabel_LeftWide: _bindgen_ty_15 = 35;
pub const kAudioChannelLabel_RightWide: _bindgen_ty_15 = 36;
pub const kAudioChannelLabel_LFE2: _bindgen_ty_15 = 37;
pub const kAudioChannelLabel_LeftTotal: _bindgen_ty_15 = 38;
pub const kAudioChannelLabel_RightTotal: _bindgen_ty_15 = 39;
pub const kAudioChannelLabel_HearingImpaired: _bindgen_ty_15 = 40;
pub const kAudioChannelLabel_Narration: _bindgen_ty_15 = 41;
pub const kAudioChannelLabel_Mono: _bindgen_ty_15 = 42;
pub const kAudioChannelLabel_DialogCentricMix: _bindgen_ty_15 = 43;
pub const kAudioChannelLabel_CenterSurroundDirect: _bindgen_ty_15 = 44;
pub const kAudioChannelLabel_Haptic: _bindgen_ty_15 = 45;
pub const kAudioChannelLabel_Ambisonic_W: _bindgen_ty_15 = 200;
pub const kAudioChannelLabel_Ambisonic_X: _bindgen_ty_15 = 201;
pub const kAudioChannelLabel_Ambisonic_Y: _bindgen_ty_15 = 202;
pub const kAudioChannelLabel_Ambisonic_Z: _bindgen_ty_15 = 203;
pub const kAudioChannelLabel_MS_Mid: _bindgen_ty_15 = 204;
pub const kAudioChannelLabel_MS_Side: _bindgen_ty_15 = 205;
pub const kAudioChannelLabel_XY_X: _bindgen_ty_15 = 206;
pub const kAudioChannelLabel_XY_Y: _bindgen_ty_15 = 207;
pub const kAudioChannelLabel_BinauralLeft: _bindgen_ty_15 = 208;
pub const kAudioChannelLabel_BinauralRight: _bindgen_ty_15 = 209;
pub const kAudioChannelLabel_HeadphonesLeft: _bindgen_ty_15 = 301;
pub const kAudioChannelLabel_HeadphonesRight: _bindgen_ty_15 = 302;
pub const kAudioChannelLabel_ClickTrack: _bindgen_ty_15 = 304;
pub const kAudioChannelLabel_ForeignLanguage: _bindgen_ty_15 = 305;
pub const kAudioChannelLabel_Discrete: _bindgen_ty_15 = 400;
pub const kAudioChannelLabel_Discrete_0: _bindgen_ty_15 = 65536;
pub const kAudioChannelLabel_Discrete_1: _bindgen_ty_15 = 65537;
pub const kAudioChannelLabel_Discrete_2: _bindgen_ty_15 = 65538;
pub const kAudioChannelLabel_Discrete_3: _bindgen_ty_15 = 65539;
pub const kAudioChannelLabel_Discrete_4: _bindgen_ty_15 = 65540;
pub const kAudioChannelLabel_Discrete_5: _bindgen_ty_15 = 65541;
pub const kAudioChannelLabel_Discrete_6: _bindgen_ty_15 = 65542;
pub const kAudioChannelLabel_Discrete_7: _bindgen_ty_15 = 65543;
pub const kAudioChannelLabel_Discrete_8: _bindgen_ty_15 = 65544;
pub const kAudioChannelLabel_Discrete_9: _bindgen_ty_15 = 65545;
pub const kAudioChannelLabel_Discrete_10: _bindgen_ty_15 = 65546;
pub const kAudioChannelLabel_Discrete_11: _bindgen_ty_15 = 65547;
pub const kAudioChannelLabel_Discrete_12: _bindgen_ty_15 = 65548;
pub const kAudioChannelLabel_Discrete_13: _bindgen_ty_15 = 65549;
pub const kAudioChannelLabel_Discrete_14: _bindgen_ty_15 = 65550;
pub const kAudioChannelLabel_Discrete_15: _bindgen_ty_15 = 65551;
pub const kAudioChannelLabel_Discrete_65535: _bindgen_ty_15 = 131071;
pub const kAudioChannelLabel_HOA_ACN: _bindgen_ty_15 = 500;
pub const kAudioChannelLabel_HOA_ACN_0: _bindgen_ty_15 = 131072;
pub const kAudioChannelLabel_HOA_ACN_1: _bindgen_ty_15 = 131073;
pub const kAudioChannelLabel_HOA_ACN_2: _bindgen_ty_15 = 131074;
pub const kAudioChannelLabel_HOA_ACN_3: _bindgen_ty_15 = 131075;
pub const kAudioChannelLabel_HOA_ACN_4: _bindgen_ty_15 = 131076;
pub const kAudioChannelLabel_HOA_ACN_5: _bindgen_ty_15 = 131077;
pub const kAudioChannelLabel_HOA_ACN_6: _bindgen_ty_15 = 131078;
pub const kAudioChannelLabel_HOA_ACN_7: _bindgen_ty_15 = 131079;
pub const kAudioChannelLabel_HOA_ACN_8: _bindgen_ty_15 = 131080;
pub const kAudioChannelLabel_HOA_ACN_9: _bindgen_ty_15 = 131081;
pub const kAudioChannelLabel_HOA_ACN_10: _bindgen_ty_15 = 131082;
pub const kAudioChannelLabel_HOA_ACN_11: _bindgen_ty_15 = 131083;
pub const kAudioChannelLabel_HOA_ACN_12: _bindgen_ty_15 = 131084;
pub const kAudioChannelLabel_HOA_ACN_13: _bindgen_ty_15 = 131085;
pub const kAudioChannelLabel_HOA_ACN_14: _bindgen_ty_15 = 131086;
pub const kAudioChannelLabel_HOA_ACN_15: _bindgen_ty_15 = 131087;
pub const kAudioChannelLabel_HOA_ACN_65024: _bindgen_ty_15 = 196096;
pub const kAudioChannelLabel_BeginReserved: _bindgen_ty_15 = 4026531840;
pub const kAudioChannelLabel_EndReserved: _bindgen_ty_15 = 4294967294;
pub type _bindgen_ty_15 = u32;
///@enum           Channel Bitmap Constants
///@abstract       These constants are for use in the mChannelBitmap field of an
///AudioChannelLayout structure.
pub type AudioChannelBitmap = UInt32;
pub const kAudioChannelBit_Left: _bindgen_ty_16 = 1;
pub const kAudioChannelBit_Right: _bindgen_ty_16 = 2;
pub const kAudioChannelBit_Center: _bindgen_ty_16 = 4;
pub const kAudioChannelBit_LFEScreen: _bindgen_ty_16 = 8;
pub const kAudioChannelBit_LeftSurround: _bindgen_ty_16 = 16;
pub const kAudioChannelBit_RightSurround: _bindgen_ty_16 = 32;
pub const kAudioChannelBit_LeftCenter: _bindgen_ty_16 = 64;
pub const kAudioChannelBit_RightCenter: _bindgen_ty_16 = 128;
pub const kAudioChannelBit_CenterSurround: _bindgen_ty_16 = 256;
pub const kAudioChannelBit_LeftSurroundDirect: _bindgen_ty_16 = 512;
pub const kAudioChannelBit_RightSurroundDirect: _bindgen_ty_16 = 1024;
pub const kAudioChannelBit_TopCenterSurround: _bindgen_ty_16 = 2048;
pub const kAudioChannelBit_VerticalHeightLeft: _bindgen_ty_16 = 4096;
pub const kAudioChannelBit_VerticalHeightCenter: _bindgen_ty_16 = 8192;
pub const kAudioChannelBit_VerticalHeightRight: _bindgen_ty_16 = 16384;
pub const kAudioChannelBit_TopBackLeft: _bindgen_ty_16 = 32768;
pub const kAudioChannelBit_TopBackCenter: _bindgen_ty_16 = 65536;
pub const kAudioChannelBit_TopBackRight: _bindgen_ty_16 = 131072;
pub type _bindgen_ty_16 = u32;
///@enum           Channel Coordinate Flags
///@abstract       These constants are used in the mChannelFlags field of an
///AudioChannelDescription structure.
///@constant       kAudioChannelFlags_RectangularCoordinates
///The channel is specified by the cartesioan coordinates of the speaker
///position. This flag is mutally exclusive with
///kAudioChannelFlags_SphericalCoordinates.
///@constant       kAudioChannelFlags_SphericalCoordinates
///The channel is specified by the spherical coordinates of the speaker
///position. This flag is mutally exclusive with
///kAudioChannelFlags_RectangularCoordinates.
///@constant       kAudioChannelFlags_Meters
///Set to indicate the units are in meters, clear to indicate the units are
///relative to the unit cube or unit sphere.
pub type AudioChannelFlags = UInt32;
pub const kAudioChannelFlags_AllOff: _bindgen_ty_17 = 0;
pub const kAudioChannelFlags_RectangularCoordinates: _bindgen_ty_17 = 1;
pub const kAudioChannelFlags_SphericalCoordinates: _bindgen_ty_17 = 2;
pub const kAudioChannelFlags_Meters: _bindgen_ty_17 = 4;
pub type _bindgen_ty_17 = u32;
///@enum           Channel Coordinate Index Constants
///@abstract       Constants for indexing the mCoordinates array in an AudioChannelDescription
///structure.
///@constant       kAudioChannelCoordinates_LeftRight
///For rectangulare coordinates, negative is left and positive is right.
///@constant       kAudioChannelCoordinates_BackFront
///For rectangulare coordinates, negative is back and positive is front.
///@constant       kAudioChannelCoordinates_DownUp
///For rectangulare coordinates, negative is below ground level, 0 is ground
///level, and positive is above ground level.
///@constant       kAudioChannelCoordinates_Azimuth
///For spherical coordinates, 0 is front center, positive is right, negative is
///left. This is measured in degrees.
///@constant       kAudioChannelCoordinates_Elevation
///For spherical coordinates, +90 is zenith, 0 is horizontal, -90 is nadir.
///This is measured in degrees.
///@constant       kAudioChannelCoordinates_Distance
///For spherical coordinates, the units are described by flags.
pub type AudioChannelCoordinateIndex = UInt32;
pub const kAudioChannelCoordinates_LeftRight: _bindgen_ty_18 = 0;
pub const kAudioChannelCoordinates_BackFront: _bindgen_ty_18 = 1;
pub const kAudioChannelCoordinates_DownUp: _bindgen_ty_18 = 2;
pub const kAudioChannelCoordinates_Azimuth: _bindgen_ty_18 = 0;
pub const kAudioChannelCoordinates_Elevation: _bindgen_ty_18 = 1;
pub const kAudioChannelCoordinates_Distance: _bindgen_ty_18 = 2;
pub type _bindgen_ty_18 = u32;
pub const kAudioChannelLayoutTag_UseChannelDescriptions: _bindgen_ty_19 = 0;
pub const kAudioChannelLayoutTag_UseChannelBitmap: _bindgen_ty_19 = 65536;
pub const kAudioChannelLayoutTag_Mono: _bindgen_ty_19 = 6553601;
pub const kAudioChannelLayoutTag_Stereo: _bindgen_ty_19 = 6619138;
pub const kAudioChannelLayoutTag_StereoHeadphones: _bindgen_ty_19 = 6684674;
pub const kAudioChannelLayoutTag_MatrixStereo: _bindgen_ty_19 = 6750210;
pub const kAudioChannelLayoutTag_MidSide: _bindgen_ty_19 = 6815746;
pub const kAudioChannelLayoutTag_XY: _bindgen_ty_19 = 6881282;
pub const kAudioChannelLayoutTag_Binaural: _bindgen_ty_19 = 6946818;
pub const kAudioChannelLayoutTag_Ambisonic_B_Format: _bindgen_ty_19 = 7012356;
pub const kAudioChannelLayoutTag_Quadraphonic: _bindgen_ty_19 = 7077892;
pub const kAudioChannelLayoutTag_Pentagonal: _bindgen_ty_19 = 7143429;
pub const kAudioChannelLayoutTag_Hexagonal: _bindgen_ty_19 = 7208966;
pub const kAudioChannelLayoutTag_Octagonal: _bindgen_ty_19 = 7274504;
pub const kAudioChannelLayoutTag_Cube: _bindgen_ty_19 = 7340040;
pub const kAudioChannelLayoutTag_MPEG_1_0: _bindgen_ty_19 = 6553601;
pub const kAudioChannelLayoutTag_MPEG_2_0: _bindgen_ty_19 = 6619138;
pub const kAudioChannelLayoutTag_MPEG_3_0_A: _bindgen_ty_19 = 7405571;
pub const kAudioChannelLayoutTag_MPEG_3_0_B: _bindgen_ty_19 = 7471107;
pub const kAudioChannelLayoutTag_MPEG_4_0_A: _bindgen_ty_19 = 7536644;
pub const kAudioChannelLayoutTag_MPEG_4_0_B: _bindgen_ty_19 = 7602180;
pub const kAudioChannelLayoutTag_MPEG_5_0_A: _bindgen_ty_19 = 7667717;
pub const kAudioChannelLayoutTag_MPEG_5_0_B: _bindgen_ty_19 = 7733253;
pub const kAudioChannelLayoutTag_MPEG_5_0_C: _bindgen_ty_19 = 7798789;
pub const kAudioChannelLayoutTag_MPEG_5_0_D: _bindgen_ty_19 = 7864325;
pub const kAudioChannelLayoutTag_MPEG_5_1_A: _bindgen_ty_19 = 7929862;
pub const kAudioChannelLayoutTag_MPEG_5_1_B: _bindgen_ty_19 = 7995398;
pub const kAudioChannelLayoutTag_MPEG_5_1_C: _bindgen_ty_19 = 8060934;
pub const kAudioChannelLayoutTag_MPEG_5_1_D: _bindgen_ty_19 = 8126470;
pub const kAudioChannelLayoutTag_MPEG_6_1_A: _bindgen_ty_19 = 8192007;
pub const kAudioChannelLayoutTag_MPEG_7_1_A: _bindgen_ty_19 = 8257544;
pub const kAudioChannelLayoutTag_MPEG_7_1_B: _bindgen_ty_19 = 8323080;
pub const kAudioChannelLayoutTag_MPEG_7_1_C: _bindgen_ty_19 = 8388616;
pub const kAudioChannelLayoutTag_Emagic_Default_7_1: _bindgen_ty_19 = 8454152;
pub const kAudioChannelLayoutTag_SMPTE_DTV: _bindgen_ty_19 = 8519688;
pub const kAudioChannelLayoutTag_ITU_1_0: _bindgen_ty_19 = 6553601;
pub const kAudioChannelLayoutTag_ITU_2_0: _bindgen_ty_19 = 6619138;
pub const kAudioChannelLayoutTag_ITU_2_1: _bindgen_ty_19 = 8585219;
pub const kAudioChannelLayoutTag_ITU_2_2: _bindgen_ty_19 = 8650756;
pub const kAudioChannelLayoutTag_ITU_3_0: _bindgen_ty_19 = 7405571;
pub const kAudioChannelLayoutTag_ITU_3_1: _bindgen_ty_19 = 7536644;
pub const kAudioChannelLayoutTag_ITU_3_2: _bindgen_ty_19 = 7667717;
pub const kAudioChannelLayoutTag_ITU_3_2_1: _bindgen_ty_19 = 7929862;
pub const kAudioChannelLayoutTag_ITU_3_4_1: _bindgen_ty_19 = 8388616;
pub const kAudioChannelLayoutTag_DVD_0: _bindgen_ty_19 = 6553601;
pub const kAudioChannelLayoutTag_DVD_1: _bindgen_ty_19 = 6619138;
pub const kAudioChannelLayoutTag_DVD_2: _bindgen_ty_19 = 8585219;
pub const kAudioChannelLayoutTag_DVD_3: _bindgen_ty_19 = 8650756;
pub const kAudioChannelLayoutTag_DVD_4: _bindgen_ty_19 = 8716291;
pub const kAudioChannelLayoutTag_DVD_5: _bindgen_ty_19 = 8781828;
pub const kAudioChannelLayoutTag_DVD_6: _bindgen_ty_19 = 8847365;
pub const kAudioChannelLayoutTag_DVD_7: _bindgen_ty_19 = 7405571;
pub const kAudioChannelLayoutTag_DVD_8: _bindgen_ty_19 = 7536644;
pub const kAudioChannelLayoutTag_DVD_9: _bindgen_ty_19 = 7667717;
pub const kAudioChannelLayoutTag_DVD_10: _bindgen_ty_19 = 8912900;
pub const kAudioChannelLayoutTag_DVD_11: _bindgen_ty_19 = 8978437;
pub const kAudioChannelLayoutTag_DVD_12: _bindgen_ty_19 = 7929862;
pub const kAudioChannelLayoutTag_DVD_13: _bindgen_ty_19 = 7536644;
pub const kAudioChannelLayoutTag_DVD_14: _bindgen_ty_19 = 7667717;
pub const kAudioChannelLayoutTag_DVD_15: _bindgen_ty_19 = 8912900;
pub const kAudioChannelLayoutTag_DVD_16: _bindgen_ty_19 = 8978437;
pub const kAudioChannelLayoutTag_DVD_17: _bindgen_ty_19 = 7929862;
pub const kAudioChannelLayoutTag_DVD_18: _bindgen_ty_19 = 9043973;
pub const kAudioChannelLayoutTag_DVD_19: _bindgen_ty_19 = 7733253;
pub const kAudioChannelLayoutTag_DVD_20: _bindgen_ty_19 = 7995398;
pub const kAudioChannelLayoutTag_AudioUnit_4: _bindgen_ty_19 = 7077892;
pub const kAudioChannelLayoutTag_AudioUnit_5: _bindgen_ty_19 = 7143429;
pub const kAudioChannelLayoutTag_AudioUnit_6: _bindgen_ty_19 = 7208966;
pub const kAudioChannelLayoutTag_AudioUnit_8: _bindgen_ty_19 = 7274504;
pub const kAudioChannelLayoutTag_AudioUnit_5_0: _bindgen_ty_19 = 7733253;
pub const kAudioChannelLayoutTag_AudioUnit_6_0: _bindgen_ty_19 = 9109510;
pub const kAudioChannelLayoutTag_AudioUnit_7_0: _bindgen_ty_19 = 9175047;
pub const kAudioChannelLayoutTag_AudioUnit_7_0_Front: _bindgen_ty_19 = 9699335;
pub const kAudioChannelLayoutTag_AudioUnit_5_1: _bindgen_ty_19 = 7929862;
pub const kAudioChannelLayoutTag_AudioUnit_6_1: _bindgen_ty_19 = 8192007;
pub const kAudioChannelLayoutTag_AudioUnit_7_1: _bindgen_ty_19 = 8388616;
pub const kAudioChannelLayoutTag_AudioUnit_7_1_Front: _bindgen_ty_19 = 8257544;
pub const kAudioChannelLayoutTag_AAC_3_0: _bindgen_ty_19 = 7471107;
pub const kAudioChannelLayoutTag_AAC_Quadraphonic: _bindgen_ty_19 = 7077892;
pub const kAudioChannelLayoutTag_AAC_4_0: _bindgen_ty_19 = 7602180;
pub const kAudioChannelLayoutTag_AAC_5_0: _bindgen_ty_19 = 7864325;
pub const kAudioChannelLayoutTag_AAC_5_1: _bindgen_ty_19 = 8126470;
pub const kAudioChannelLayoutTag_AAC_6_0: _bindgen_ty_19 = 9240582;
pub const kAudioChannelLayoutTag_AAC_6_1: _bindgen_ty_19 = 9306119;
pub const kAudioChannelLayoutTag_AAC_7_0: _bindgen_ty_19 = 9371655;
pub const kAudioChannelLayoutTag_AAC_7_1: _bindgen_ty_19 = 8323080;
pub const kAudioChannelLayoutTag_AAC_7_1_B: _bindgen_ty_19 = 11993096;
pub const kAudioChannelLayoutTag_AAC_7_1_C: _bindgen_ty_19 = 12058632;
pub const kAudioChannelLayoutTag_AAC_Octagonal: _bindgen_ty_19 = 9437192;
pub const kAudioChannelLayoutTag_TMH_10_2_std: _bindgen_ty_19 = 9502736;
pub const kAudioChannelLayoutTag_TMH_10_2_full: _bindgen_ty_19 = 9568277;
pub const kAudioChannelLayoutTag_AC3_1_0_1: _bindgen_ty_19 = 9764866;
pub const kAudioChannelLayoutTag_AC3_3_0: _bindgen_ty_19 = 9830403;
pub const kAudioChannelLayoutTag_AC3_3_1: _bindgen_ty_19 = 9895940;
pub const kAudioChannelLayoutTag_AC3_3_0_1: _bindgen_ty_19 = 9961476;
pub const kAudioChannelLayoutTag_AC3_2_1_1: _bindgen_ty_19 = 10027012;
pub const kAudioChannelLayoutTag_AC3_3_1_1: _bindgen_ty_19 = 10092549;
pub const kAudioChannelLayoutTag_EAC_6_0_A: _bindgen_ty_19 = 10158086;
pub const kAudioChannelLayoutTag_EAC_7_0_A: _bindgen_ty_19 = 10223623;
pub const kAudioChannelLayoutTag_EAC3_6_1_A: _bindgen_ty_19 = 10289159;
pub const kAudioChannelLayoutTag_EAC3_6_1_B: _bindgen_ty_19 = 10354695;
pub const kAudioChannelLayoutTag_EAC3_6_1_C: _bindgen_ty_19 = 10420231;
pub const kAudioChannelLayoutTag_EAC3_7_1_A: _bindgen_ty_19 = 10485768;
pub const kAudioChannelLayoutTag_EAC3_7_1_B: _bindgen_ty_19 = 10551304;
pub const kAudioChannelLayoutTag_EAC3_7_1_C: _bindgen_ty_19 = 10616840;
pub const kAudioChannelLayoutTag_EAC3_7_1_D: _bindgen_ty_19 = 10682376;
pub const kAudioChannelLayoutTag_EAC3_7_1_E: _bindgen_ty_19 = 10747912;
pub const kAudioChannelLayoutTag_EAC3_7_1_F: _bindgen_ty_19 = 10813448;
pub const kAudioChannelLayoutTag_EAC3_7_1_G: _bindgen_ty_19 = 10878984;
pub const kAudioChannelLayoutTag_EAC3_7_1_H: _bindgen_ty_19 = 10944520;
pub const kAudioChannelLayoutTag_DTS_3_1: _bindgen_ty_19 = 11010052;
pub const kAudioChannelLayoutTag_DTS_4_1: _bindgen_ty_19 = 11075589;
pub const kAudioChannelLayoutTag_DTS_6_0_A: _bindgen_ty_19 = 11141126;
pub const kAudioChannelLayoutTag_DTS_6_0_B: _bindgen_ty_19 = 11206662;
pub const kAudioChannelLayoutTag_DTS_6_0_C: _bindgen_ty_19 = 11272198;
pub const kAudioChannelLayoutTag_DTS_6_1_A: _bindgen_ty_19 = 11337735;
pub const kAudioChannelLayoutTag_DTS_6_1_B: _bindgen_ty_19 = 11403271;
pub const kAudioChannelLayoutTag_DTS_6_1_C: _bindgen_ty_19 = 11468807;
pub const kAudioChannelLayoutTag_DTS_7_0: _bindgen_ty_19 = 11534343;
pub const kAudioChannelLayoutTag_DTS_7_1: _bindgen_ty_19 = 11599880;
pub const kAudioChannelLayoutTag_DTS_8_0_A: _bindgen_ty_19 = 11665416;
pub const kAudioChannelLayoutTag_DTS_8_0_B: _bindgen_ty_19 = 11730952;
pub const kAudioChannelLayoutTag_DTS_8_1_A: _bindgen_ty_19 = 11796489;
pub const kAudioChannelLayoutTag_DTS_8_1_B: _bindgen_ty_19 = 11862025;
pub const kAudioChannelLayoutTag_DTS_6_1_D: _bindgen_ty_19 = 11927559;
pub const kAudioChannelLayoutTag_HOA_ACN_SN3D: _bindgen_ty_19 = 12451840;
pub const kAudioChannelLayoutTag_HOA_ACN_N3D: _bindgen_ty_19 = 12517376;
pub const kAudioChannelLayoutTag_DiscreteInOrder: _bindgen_ty_19 = 9633792;
pub const kAudioChannelLayoutTag_BeginReserved: _bindgen_ty_19 = 4026531840;
pub const kAudioChannelLayoutTag_EndReserved: _bindgen_ty_19 = 4294901759;
pub const kAudioChannelLayoutTag_Unknown: _bindgen_ty_19 = 4294901760;
pub type _bindgen_ty_19 = u32;
///@struct         AudioChannelDescription
///@abstract       This structure describes a single channel.
///@field          mChannelLabel
///The AudioChannelLabel that describes the channel.
///@field          mChannelFlags
///Flags that control the interpretation of mCoordinates.
///@field          mCoordinates
///An ordered triple that specifies a precise speaker location.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioChannelDescription {
    pub mChannelLabel: AudioChannelLabel,
    pub mChannelFlags: AudioChannelFlags,
    pub mCoordinates: [Float32; 3usize],
}
#[test]
fn bindgen_test_layout_AudioChannelDescription() {
    assert_eq!(
        ::std::mem::size_of::<AudioChannelDescription>(),
        20usize,
        concat!("Size of: ", stringify!(AudioChannelDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioChannelDescription>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioChannelDescription))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioChannelDescription>())).mChannelLabel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioChannelDescription),
            "::",
            stringify!(mChannelLabel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioChannelDescription>())).mChannelFlags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioChannelDescription),
            "::",
            stringify!(mChannelFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioChannelDescription>())).mCoordinates as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioChannelDescription),
            "::",
            stringify!(mCoordinates)
        )
    );
}
///@struct         AudioChannelLayout
///@abstract       This structure is used to specify channel layouts in files and hardware.
///@field          mChannelLayoutTag
///The AudioChannelLayoutTag that indicates the layout.
///@field          mChannelBitmap
///If mChannelLayoutTag is set to kAudioChannelLayoutTag_UseChannelBitmap, this
///field is the channel usage bitmap.
///@field          mNumberChannelDescriptions
///The number of items in the mChannelDescriptions array.
///@field          mChannelDescriptions
///A variable length array of AudioChannelDescriptions that describe the
///layout.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioChannelLayout {
    pub mChannelLayoutTag: AudioChannelLayoutTag,
    pub mChannelBitmap: AudioChannelBitmap,
    pub mNumberChannelDescriptions: UInt32,
    pub mChannelDescriptions: [AudioChannelDescription; 1usize],
}
#[test]
fn bindgen_test_layout_AudioChannelLayout() {
    assert_eq!(
        ::std::mem::size_of::<AudioChannelLayout>(),
        32usize,
        concat!("Size of: ", stringify!(AudioChannelLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioChannelLayout>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioChannelLayout))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioChannelLayout>())).mChannelLayoutTag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioChannelLayout),
            "::",
            stringify!(mChannelLayoutTag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioChannelLayout>())).mChannelBitmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioChannelLayout),
            "::",
            stringify!(mChannelBitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioChannelLayout>())).mNumberChannelDescriptions as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioChannelLayout),
            "::",
            stringify!(mNumberChannelDescriptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioChannelLayout>())).mChannelDescriptions as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioChannelLayout),
            "::",
            stringify!(mChannelDescriptions)
        )
    );
}
/// @enum           MPEG-4 Audio Object IDs
///@deprecated     in version 10.5
///
///@abstract       Constants that describe the various kinds of MPEG-4 audio data.
///@discussion     These constants are used in the flags field of an AudioStreamBasicDescription
///that describes an MPEG-4 audio stream.
pub type MPEG4ObjectID = ::std::os::raw::c_long;
pub const kMPEG4Object_AAC_Main: _bindgen_ty_20 = 1;
pub const kMPEG4Object_AAC_LC: _bindgen_ty_20 = 2;
pub const kMPEG4Object_AAC_SSR: _bindgen_ty_20 = 3;
pub const kMPEG4Object_AAC_LTP: _bindgen_ty_20 = 4;
pub const kMPEG4Object_AAC_SBR: _bindgen_ty_20 = 5;
pub const kMPEG4Object_AAC_Scalable: _bindgen_ty_20 = 6;
pub const kMPEG4Object_TwinVQ: _bindgen_ty_20 = 7;
pub const kMPEG4Object_CELP: _bindgen_ty_20 = 8;
pub const kMPEG4Object_HVXC: _bindgen_ty_20 = 9;
pub type _bindgen_ty_20 = u32;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn __assert_rtn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    );
}
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
pub type wint_t = __darwin_wint_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneEntry() {
    assert_eq!(
        ::std::mem::size_of::<_RuneEntry>(),
        24usize,
        concat!("Size of: ", stringify!(_RuneEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneEntry>())).__min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneEntry>())).__max as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneEntry>())).__map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneEntry>())).__types as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__types)
        )
    );
}
impl Default for _RuneEntry {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneRange {
    pub __nranges: ::std::os::raw::c_int,
    pub __ranges: *mut _RuneEntry,
}
#[test]
fn bindgen_test_layout__RuneRange() {
    assert_eq!(
        ::std::mem::size_of::<_RuneRange>(),
        16usize,
        concat!("Size of: ", stringify!(_RuneRange))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneRange>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneRange>())).__nranges as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneRange),
            "::",
            stringify!(__nranges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneRange>())).__ranges as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneRange),
            "::",
            stringify!(__ranges)
        )
    );
}
impl Default for _RuneRange {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RuneCharClass {
    pub __name: [::std::os::raw::c_char; 14usize],
    pub __mask: __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneCharClass() {
    assert_eq!(
        ::std::mem::size_of::<_RuneCharClass>(),
        20usize,
        concat!("Size of: ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneCharClass>(),
        4usize,
        concat!("Alignment of ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneCharClass>())).__name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneCharClass),
            "::",
            stringify!(__name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneCharClass>())).__mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneCharClass),
            "::",
            stringify!(__mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RuneLocale {
    pub __magic: [::std::os::raw::c_char; 8usize],
    pub __encoding: [::std::os::raw::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: __darwin_size_t,
            arg3: *mut *const ::std::os::raw::c_char,
        ) -> __darwin_rune_t,
    >,
    pub __sputrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: __darwin_rune_t,
            arg2: *mut ::std::os::raw::c_char,
            arg3: __darwin_size_t,
            arg4: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::std::os::raw::c_void,
    pub __variable_len: ::std::os::raw::c_int,
    pub __ncharclasses: ::std::os::raw::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
#[test]
fn bindgen_test_layout__RuneLocale() {
    assert_eq!(
        ::std::mem::size_of::<_RuneLocale>(),
        3208usize,
        concat!("Size of: ", stringify!(_RuneLocale))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneLocale>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneLocale))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__encoding as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__sgetrune as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__sgetrune)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__sputrune as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__sputrune)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__invalid_rune as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__invalid_rune)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__runetype as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__runetype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__maplower as *const _ as usize },
        1084usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__maplower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__mapupper as *const _ as usize },
        2108usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__mapupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__runetype_ext as *const _ as usize },
        3136usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__runetype_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__maplower_ext as *const _ as usize },
        3152usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__maplower_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__mapupper_ext as *const _ as usize },
        3168usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__mapupper_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__variable as *const _ as usize },
        3184usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__variable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__variable_len as *const _ as usize },
        3192usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__variable_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__ncharclasses as *const _ as usize },
        3196usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__ncharclasses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__charclasses as *const _ as usize },
        3200usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__charclasses)
        )
    );
}
impl Default for _RuneLocale {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static mut _DefaultRuneLocale: _RuneLocale;
}
extern "C" {
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
}
extern "C" {
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __maskrune(
        arg1: __darwin_ct_rune_t,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lconv() {
    assert_eq!(
        ::std::mem::size_of::<lconv>(),
        96usize,
        concat!("Size of: ", stringify!(lconv))
    );
    assert_eq!(
        ::std::mem::align_of::<lconv>(),
        8usize,
        concat!("Alignment of ", stringify!(lconv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).decimal_point as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(decimal_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).thousands_sep as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(thousands_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).grouping as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(grouping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_curr_symbol as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_curr_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).currency_symbol as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(currency_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_decimal_point as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_decimal_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_thousands_sep as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_grouping as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_grouping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).positive_sign as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(positive_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).negative_sign as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(negative_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_frac_digits as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_frac_digits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).frac_digits as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(frac_digits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_cs_precedes as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_sep_by_space as *const _ as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_cs_precedes as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_sep_by_space as *const _ as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_sign_posn as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_sign_posn as *const _ as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_cs_precedes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_cs_precedes as *const _ as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_sep_by_space as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_sep_by_space as *const _ as usize },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_sign_posn as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_sign_posn as *const _ as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sign_posn)
        )
    );
}
impl Default for lconv {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn localeconv() -> *mut lconv;
}
extern "C" {
    pub fn setlocale(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn __inff() -> f32;
}
extern "C" {
    pub fn __inf() -> f64;
}
extern "C" {
    pub fn __infl() -> f64;
}
extern "C" {
    pub fn __nan() -> f32;
}
extern "C" {
    pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
    pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tanpi(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[test]
fn bindgen_test_layout___float2() {
    assert_eq!(
        ::std::mem::size_of::<__float2>(),
        8usize,
        concat!("Size of: ", stringify!(__float2))
    );
    assert_eq!(
        ::std::mem::align_of::<__float2>(),
        4usize,
        concat!("Alignment of ", stringify!(__float2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__float2>())).__sinval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__float2>())).__cosval as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__cosval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[test]
fn bindgen_test_layout___double2() {
    assert_eq!(
        ::std::mem::size_of::<__double2>(),
        16usize,
        concat!("Size of: ", stringify!(__double2))
    );
    assert_eq!(
        ::std::mem::align_of::<__double2>(),
        8usize,
        concat!("Alignment of ", stringify!(__double2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__double2>())).__sinval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__double2>())).__cosval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__cosval)
        )
    );
}
extern "C" {
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
extern "C" {
    pub fn rinttol(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn roundtol(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn finite(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn significand(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(
        ::std::mem::size_of::<exception>(),
        40usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        ::std::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).arg1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).arg2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).retval as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(retval)
        )
    );
}
impl Default for exception {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn matherr(arg1: *mut exception) -> ::std::os::raw::c_int;
}
pub type jmp_buf = [::std::os::raw::c_int; 37usize];
pub type sigjmp_buf = [::std::os::raw::c_int; 38usize];
extern "C" {
    pub fn setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut ::std::os::raw::c_int, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _longjmp(arg1: *mut ::std::os::raw::c_int, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sigsetjmp(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siglongjmp(arg1: *mut ::std::os::raw::c_int, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn longjmperror();
}
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_thread_state>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebx as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ecx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ecx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edx as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edi as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esi as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esp as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eflags as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eip as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__cs as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ds as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__es as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__fs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__gs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_fp_control {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_control>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_control))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_control>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_control))
    );
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __pc: ::std::os::raw::c_ushort,
        __rc: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let __pc: u16 = unsafe { ::std::mem::transmute(__pc) };
            __pc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let __rc: u16 = unsafe { ::std::mem::transmute(__rc) };
            __rc as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_fp_status {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_status>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_status))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_status>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_status))
    );
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __stkflt: ::std::os::raw::c_ushort,
        __errsumm: ::std::os::raw::c_ushort,
        __c0: ::std::os::raw::c_ushort,
        __c1: ::std::os::raw::c_ushort,
        __c2: ::std::os::raw::c_ushort,
        __tos: ::std::os::raw::c_ushort,
        __c3: ::std::os::raw::c_ushort,
        __busy: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let __stkflt: u16 = unsafe { ::std::mem::transmute(__stkflt) };
            __stkflt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __errsumm: u16 = unsafe { ::std::mem::transmute(__errsumm) };
            __errsumm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let __c0: u16 = unsafe { ::std::mem::transmute(__c0) };
            __c0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let __c1: u16 = unsafe { ::std::mem::transmute(__c1) };
            __c1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let __c2: u16 = unsafe { ::std::mem::transmute(__c2) };
            __c2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let __tos: u16 = unsafe { ::std::mem::transmute(__tos) };
            __tos as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let __c3: u16 = unsafe { ::std::mem::transmute(__c3) };
            __c3 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let __busy: u16 = unsafe { ::std::mem::transmute(__busy) };
            __busy as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mmst_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mmst_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_rsrv as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_rsrv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_xmm_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_xmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_xmm_reg>())).__xmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_xmm_reg),
            "::",
            stringify!(__xmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_ymm_reg {
    pub __ymm_reg: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout___darwin_ymm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ymm_reg>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ymm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ymm_reg>())).__ymm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ymm_reg),
            "::",
            stringify!(__ymm_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_zmm_reg {
    pub __zmm_reg: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout___darwin_zmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_zmm_reg>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_zmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_zmm_reg>())).__zmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_zmm_reg),
            "::",
            stringify!(__zmm_reg)
        )
    );
}
impl Default for __darwin_zmm_reg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_opmask_reg {
    pub __opmask_reg: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout___darwin_opmask_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_opmask_reg>(),
        8usize,
        concat!("Size of: ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_opmask_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_opmask_reg>())).__opmask_reg as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_opmask_reg),
            "::",
            stringify!(__opmask_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_float_state>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_float_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
impl Default for __darwin_i386_float_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx_state>(),
        716usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsrmask as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved1 as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__avx_reserved1 as *const _ as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
}
impl Default for __darwin_i386_avx_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx512_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx512_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx512_state>(),
        1036usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx512_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k0 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k1 as *const _ as usize
        },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k2 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k3 as *const _ as usize
        },
        740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k4 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k5 as *const _ as usize
        },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k6 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k7 as *const _ as usize
        },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh0 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh1 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh2 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh3 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh4 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh5 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh6 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh7 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
}
impl Default for __darwin_i386_avx512_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state32>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr3 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr4 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr5 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr6 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr7 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_thread_state64>(),
        168usize,
        concat!("Size of: ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rcx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdi as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsi as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbp as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsp as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r8 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r9 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r10 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r11 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r12 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r13 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r14 as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r15 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rip as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rflags as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__cs as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__fs as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__gs as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_float_state64>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_float_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
impl Default for __darwin_x86_float_state64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx_state64>(),
        844usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh10 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh11 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh12 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh13 as *const _ as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh14 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh15 as *const _ as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
}
impl Default for __darwin_x86_avx_state64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx512_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
    pub __fpu_zmmh8: __darwin_ymm_reg,
    pub __fpu_zmmh9: __darwin_ymm_reg,
    pub __fpu_zmmh10: __darwin_ymm_reg,
    pub __fpu_zmmh11: __darwin_ymm_reg,
    pub __fpu_zmmh12: __darwin_ymm_reg,
    pub __fpu_zmmh13: __darwin_ymm_reg,
    pub __fpu_zmmh14: __darwin_ymm_reg,
    pub __fpu_zmmh15: __darwin_ymm_reg,
    pub __fpu_zmm16: __darwin_zmm_reg,
    pub __fpu_zmm17: __darwin_zmm_reg,
    pub __fpu_zmm18: __darwin_zmm_reg,
    pub __fpu_zmm19: __darwin_zmm_reg,
    pub __fpu_zmm20: __darwin_zmm_reg,
    pub __fpu_zmm21: __darwin_zmm_reg,
    pub __fpu_zmm22: __darwin_zmm_reg,
    pub __fpu_zmm23: __darwin_zmm_reg,
    pub __fpu_zmm24: __darwin_zmm_reg,
    pub __fpu_zmm25: __darwin_zmm_reg,
    pub __fpu_zmm26: __darwin_zmm_reg,
    pub __fpu_zmm27: __darwin_zmm_reg,
    pub __fpu_zmm28: __darwin_zmm_reg,
    pub __fpu_zmm29: __darwin_zmm_reg,
    pub __fpu_zmm30: __darwin_zmm_reg,
    pub __fpu_zmm31: __darwin_zmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx512_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx512_state64>(),
        2444usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx512_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh10 as *const _
                as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh11 as *const _
                as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh12 as *const _
                as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh13 as *const _
                as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh14 as *const _
                as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh15 as *const _
                as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k0 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k1 as *const _ as usize
        },
        852usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k2 as *const _ as usize
        },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k3 as *const _ as usize
        },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k4 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k5 as *const _ as usize
        },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k6 as *const _ as usize
        },
        892usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k7 as *const _ as usize
        },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh0 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh1 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh2 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh3 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh4 as *const _ as usize
        },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh5 as *const _ as usize
        },
        1068usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh6 as *const _ as usize
        },
        1100usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh7 as *const _ as usize
        },
        1132usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh8 as *const _ as usize
        },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh9 as *const _ as usize
        },
        1196usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh10 as *const _
                as usize
        },
        1228usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh11 as *const _
                as usize
        },
        1260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh12 as *const _
                as usize
        },
        1292usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh13 as *const _
                as usize
        },
        1324usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh14 as *const _
                as usize
        },
        1356usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh15 as *const _
                as usize
        },
        1388usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm16 as *const _ as usize
        },
        1420usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm17 as *const _ as usize
        },
        1484usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm18 as *const _ as usize
        },
        1548usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm19 as *const _ as usize
        },
        1612usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm20 as *const _ as usize
        },
        1676usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm21 as *const _ as usize
        },
        1740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm22 as *const _ as usize
        },
        1804usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm22)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm23 as *const _ as usize
        },
        1868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm23)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm24 as *const _ as usize
        },
        1932usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm24)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm25 as *const _ as usize
        },
        1996usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm25)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm26 as *const _ as usize
        },
        2060usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm27 as *const _ as usize
        },
        2124usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm27)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm28 as *const _ as usize
        },
        2188usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm28)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm29 as *const _ as usize
        },
        2252usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm29)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm30 as *const _ as usize
        },
        2316usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm31 as *const _ as usize
        },
        2380usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm31)
        )
    );
}
impl Default for __darwin_x86_avx512_state64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state64>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr3 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr4 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr5 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr6 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr7 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_x86_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_x86_cpmu_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_cpmu_state64>())).__ctrs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        600usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx32>(),
        792usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext_avx32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx512_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_32>(),
        1112usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__ss as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__fs as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext_avx512_32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        712usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx64>(),
        1032usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext_avx64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_64>(),
        2632usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__ss as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__fs as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext_avx512_64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type mcontext_t = *mut __darwin_mcontext64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
impl Default for __darwin_sigaltstack {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_onstack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_sigmask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_stack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcontext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
impl Default for __darwin_ucontext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
impl Default for sigval {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify_function as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent>())).sigev_notify_attributes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
impl Default for sigevent {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_band as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).__pad as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
impl Default for __siginfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_sigaction as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
impl Default for __sigaction_u {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_tramp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
impl Default for __sigaction {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
impl Default for sigaction {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
impl Default for sigvec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
impl Default for sigstack {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub static mut sys_signame: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub static mut sys_siglist: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub fn raise(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsd_signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sighold(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigignore(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigrelse(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigset(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        arg1: *const sigset_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::std::os::raw::c_uint, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigvec(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sigvec,
        arg3: *mut sigvec,
    ) -> ::std::os::raw::c_int;
}
pub type max_align_t = f64;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
impl Default for __sbuf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._extra as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
impl Default for __sFILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_unused: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_logical_writes as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_lifetime_max_phys_footprint as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_instructions as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_cycles as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_energy as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_energy as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_unused as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_unused)
        )
    );
}
pub type rusage_info_current = rusage_info_v4;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_rate as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_T as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_S as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
impl Default for wait {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: usize) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__count: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__s1: *const ::std::os::raw::c_char, __n: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: usize,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: usize,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
impl Default for tm {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = u32;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
///@typedef CFArrayCallBacks
///Structure containing the callbacks of a CFArray.
///@field version The version number of the structure type being passed
///in as a parameter to the CFArray creation functions. This
///structure is version 0.
///@field retain The callback used to add a retain for the array on
///values as they are put into the array. This callback returns
///the value to store in the array, which is usually the value
///parameter passed to this callback, but may be a different
///value if a different value should be stored in the array.
///The array's allocator is passed as the first argument.
///@field release The callback used to remove a retain previously added
///for the array from values as they are removed from the
///array. The array's allocator is passed as the first
///argument.
///@field copyDescription The callback used to create a descriptive
///string representation of each value in the array. This is
///used by the CFCopyDescription() function.
///@field equal The callback used to compare values in the array for
///equality for some operations.
pub type CFArrayRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: CFAllocatorRef,
        value: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void,
>;
pub type CFArrayReleaseCallBack = ::std::option::Option<
    unsafe extern "C" fn(allocator: CFAllocatorRef, value: *const ::std::os::raw::c_void),
>;
pub type CFArrayCopyDescriptionCallBack = ::std::option::Option<
    unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFStringRef,
>;
pub type CFArrayEqualCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        value1: *const ::std::os::raw::c_void,
        value2: *const ::std::os::raw::c_void,
    ) -> Boolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFArrayCallBacks {
    pub version: CFIndex,
    pub retain: CFArrayRetainCallBack,
    pub release: CFArrayReleaseCallBack,
    pub copyDescription: CFArrayCopyDescriptionCallBack,
    pub equal: CFArrayEqualCallBack,
}
#[test]
fn bindgen_test_layout_CFArrayCallBacks() {
    assert_eq!(
        ::std::mem::size_of::<CFArrayCallBacks>(),
        40usize,
        concat!("Size of: ", stringify!(CFArrayCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFArrayCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFArrayCallBacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFArrayCallBacks>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFArrayCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFArrayCallBacks>())).retain as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFArrayCallBacks),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFArrayCallBacks>())).release as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFArrayCallBacks),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFArrayCallBacks>())).copyDescription as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFArrayCallBacks),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFArrayCallBacks>())).equal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFArrayCallBacks),
            "::",
            stringify!(equal)
        )
    );
}
impl Default for CFArrayCallBacks {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static kCFTypeArrayCallBacks: CFArrayCallBacks;
}
///@typedef CFArrayApplierFunction
///Type of the callback function used by the apply functions of
///CFArrays.
///@param value The current value from the array.
///@param context The user-defined context parameter given to the apply
///function.
pub type CFArrayApplierFunction = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFArray {
    _unused: [u8; 0],
}
///@typedef CFArrayRef
///This is the type of a reference to immutable CFArrays.
pub type CFArrayRef = *const __CFArray;
///@typedef CFMutableArrayRef
///This is the type of a reference to mutable CFArrays.
pub type CFMutableArrayRef = *mut __CFArray;
extern "C" {
    ///@function CFArrayGetTypeID
    ///Returns the type identifier of all CFArray instances.
    pub fn CFArrayGetTypeID() -> CFTypeID;
}
extern "C" {
    ///@function CFArrayCreate
    ///Creates a new immutable array with the given values.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the array and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param values A C array of the pointer-sized values to be in the
    ///array. The values in the array are ordered in the same order
    ///in which they appear in this C array. This parameter may be
    ///NULL if the numValues parameter is 0. This C array is not
    ///changed or freed by this function. If this parameter is not
    ///a valid pointer to a C array of at least numValues pointers,
    ///the behavior is undefined.
    ///@param numValues The number of values to copy from the values C
    ///array into the CFArray. This number will be the count of the
    ///array.
    ///If this parameter is negative, or greater than the number of
    ///values actually in the value's C array, the behavior is
    ///undefined.
    ///@param callBacks A pointer to a CFArrayCallBacks structure
    ///initialized with the callbacks for the array to use on each
    ///value in the array. The retain callback will be used within
    ///this function, for example, to retain all of the new values
    ///from the values C array. A copy of the contents of the
    ///callbacks structure is made, so that a pointer to a
    ///structure on the stack can be passed in, or can be reused
    ///for multiple array creations. If the version field of this
    ///callbacks structure is not one of the defined ones for
    ///CFArray, the behavior is undefined. The retain field may be
    ///NULL, in which case the CFArray will do nothing to add a
    ///retain to the contained values for the array. The release
    ///field may be NULL, in which case the CFArray will do nothing
    ///to remove the array's retain (if any) on the values when the
    ///array is destroyed. If the copyDescription field is NULL,
    ///the array will create a simple description for the value. If
    ///the equal field is NULL, the array will use pointer equality
    ///to test for equality of values. This callbacks parameter
    ///itself may be NULL, which is treated as if a valid structure
    ///of version 0 with all fields NULL had been passed in.
    ///Otherwise, if any of the fields are not valid pointers to
    ///functions of the correct type, or this parameter is not a
    ///valid pointer to a  CFArrayCallBacks callbacks structure,
    ///the behavior is undefined. If any of the values put into the
    ///array is not one understood by one of the callback functions
    ///the behavior when that callback function is used is
    ///undefined.
    ///@result A reference to the new immutable CFArray.
    pub fn CFArrayCreate(
        allocator: CFAllocatorRef,
        values: *mut *const ::std::os::raw::c_void,
        numValues: CFIndex,
        callBacks: *const CFArrayCallBacks,
    ) -> CFArrayRef;
}
extern "C" {
    ///@function CFArrayCreateCopy
    ///Creates a new immutable array with the values from the given array.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the array and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param theArray The array which is to be copied. The values from the
    ///array are copied as pointers into the new array (that is,
    ///the values themselves are copied, not that which the values
    ///point to, if anything). However, the values are also
    ///retained by the new array. The count of the new array will
    ///be the same as the given array. The new array uses the same
    ///callbacks as the array to be copied. If this parameter is
    ///not a valid CFArray, the behavior is undefined.
    ///@result A reference to the new immutable CFArray.
    pub fn CFArrayCreateCopy(allocator: CFAllocatorRef, theArray: CFArrayRef) -> CFArrayRef;
}
extern "C" {
    ///@function CFArrayCreateMutable
    ///Creates a new empty mutable array.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the array and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param capacity A hint about the number of values that will be held
    ///by the CFArray. Pass 0 for no hint. The implementation may
    ///ignore this hint, or may use it to optimize various
    ///operations. An array's actual capacity is only limited by
    ///address space and available memory constraints). If this
    ///parameter is negative, the behavior is undefined.
    ///@param callBacks A pointer to a CFArrayCallBacks structure
    ///initialized with the callbacks for the array to use on each
    ///value in the array. A copy of the contents of the
    ///callbacks structure is made, so that a pointer to a
    ///structure on the stack can be passed in, or can be reused
    ///for multiple array creations. If the version field of this
    ///callbacks structure is not one of the defined ones for
    ///CFArray, the behavior is undefined. The retain field may be
    ///NULL, in which case the CFArray will do nothing to add a
    ///retain to the contained values for the array. The release
    ///field may be NULL, in which case the CFArray will do nothing
    ///to remove the array's retain (if any) on the values when the
    ///array is destroyed. If the copyDescription field is NULL,
    ///the array will create a simple description for the value. If
    ///the equal field is NULL, the array will use pointer equality
    ///to test for equality of values. This callbacks parameter
    ///itself may be NULL, which is treated as if a valid structure
    ///of version 0 with all fields NULL had been passed in.
    ///Otherwise, if any of the fields are not valid pointers to
    ///functions of the correct type, or this parameter is not a
    ///valid pointer to a  CFArrayCallBacks callbacks structure,
    ///the behavior is undefined. If any of the values put into the
    ///array is not one understood by one of the callback functions
    ///the behavior when that callback function is used is
    ///undefined.
    ///@result A reference to the new mutable CFArray.
    pub fn CFArrayCreateMutable(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        callBacks: *const CFArrayCallBacks,
    ) -> CFMutableArrayRef;
}
extern "C" {
    ///@function CFArrayCreateMutableCopy
    ///Creates a new mutable array with the values from the given array.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the array and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param capacity A hint about the number of values that will be held
    ///by the CFArray. Pass 0 for no hint. The implementation may
    ///ignore this hint, or may use it to optimize various
    ///operations. An array's actual capacity is only limited by
    ///address space and available memory constraints).
    ///This parameter must be greater than or equal
    ///to the count of the array which is to be copied, or the
    ///behavior is undefined. If this parameter is negative, the
    ///behavior is undefined.
    ///@param theArray The array which is to be copied. The values from the
    ///array are copied as pointers into the new array (that is,
    ///the values themselves are copied, not that which the values
    ///point to, if anything). However, the values are also
    ///retained by the new array. The count of the new array will
    ///be the same as the given array. The new array uses the same
    ///callbacks as the array to be copied. If this parameter is
    ///not a valid CFArray, the behavior is undefined.
    ///@result A reference to the new mutable CFArray.
    pub fn CFArrayCreateMutableCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        theArray: CFArrayRef,
    ) -> CFMutableArrayRef;
}
extern "C" {
    ///@function CFArrayGetCount
    ///Returns the number of values currently in the array.
    ///@param theArray The array to be queried. If this parameter is not a valid
    ///CFArray, the behavior is undefined.
    ///@result The number of values in the array.
    pub fn CFArrayGetCount(theArray: CFArrayRef) -> CFIndex;
}
extern "C" {
    ///@function CFArrayGetCountOfValue
    ///Counts the number of times the given value occurs in the array.
    ///@param theArray The array to be searched. If this parameter is not a
    ///valid CFArray, the behavior is undefined.
    ///@param range The range within the array to search. If the range
    ///location or end point (defined by the location plus length
    ///minus 1) is outside the index space of the array (0 to
    ///N-1 inclusive, where N is the count of the array), the
    ///behavior is undefined. If the range length is negative, the
    ///behavior is undefined. The range may be empty (length 0).
    ///@param value The value for which to find matches in the array. The
    ///equal() callback provided when the array was created is
    ///used to compare. If the equal() callback was NULL, pointer
    ///equality (in C, ==) is used. If value, or any of the values
    ///in the array, are not understood by the equal() callback,
    ///the behavior is undefined.
    ///@result The number of times the given value occurs in the array,
    ///within the specified range.
    pub fn CFArrayGetCountOfValue(
        theArray: CFArrayRef,
        range: CFRange,
        value: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    ///@function CFArrayContainsValue
    ///Reports whether or not the value is in the array.
    ///@param theArray The array to be searched. If this parameter is not a
    ///valid CFArray, the behavior is undefined.
    ///@param range The range within the array to search. If the range
    ///location or end point (defined by the location plus length
    ///minus 1) is outside the index space of the array (0 to
    ///N-1 inclusive, where N is the count of the array), the
    ///behavior is undefined. If the range length is negative, the
    ///behavior is undefined. The range may be empty (length 0).
    ///@param value The value for which to find matches in the array. The
    ///equal() callback provided when the array was created is
    ///used to compare. If the equal() callback was NULL, pointer
    ///equality (in C, ==) is used. If value, or any of the values
    ///in the array, are not understood by the equal() callback,
    ///the behavior is undefined.
    ///@result true, if the value is in the specified range of the array,
    ///otherwise false.
    pub fn CFArrayContainsValue(
        theArray: CFArrayRef,
        range: CFRange,
        value: *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    ///@function CFArrayGetValueAtIndex
    ///Retrieves the value at the given index.
    ///@param theArray The array to be queried. If this parameter is not a
    ///valid CFArray, the behavior is undefined.
    ///@param idx The index of the value to retrieve. If the index is
    ///outside the index space of the array (0 to N-1 inclusive,
    ///where N is the count of the array), the behavior is
    ///undefined.
    ///@result The value with the given index in the array.
    pub fn CFArrayGetValueAtIndex(
        theArray: CFArrayRef,
        idx: CFIndex,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    ///@function CFArrayGetValues
    ///Fills the buffer with values from the array.
    ///@param theArray The array to be queried. If this parameter is not a
    ///valid CFArray, the behavior is undefined.
    ///@param range The range of values within the array to retrieve. If
    ///the range location or end point (defined by the location
    ///plus length minus 1) is outside the index space of the
    ///array (0 to N-1 inclusive, where N is the count of the
    ///array), the behavior is undefined. If the range length is
    ///negative, the behavior is undefined. The range may be empty
    ///(length 0), in which case no values are put into the buffer.
    ///@param values A C array of pointer-sized values to be filled with
    ///values from the array. The values in the C array are ordered
    ///in the same order in which they appear in the array. If this
    ///parameter is not a valid pointer to a C array of at least
    ///range.length pointers, the behavior is undefined.
    pub fn CFArrayGetValues(
        theArray: CFArrayRef,
        range: CFRange,
        values: *mut *const ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFArrayApplyFunction
    ///Calls a function once for each value in the array.
    ///@param theArray The array to be operated upon. If this parameter is not
    ///a valid CFArray, the behavior is undefined.
    ///@param range The range of values within the array to which to apply
    ///the function. If the range location or end point (defined by
    ///the location plus length minus 1) is outside the index
    ///space of the array (0 to N-1 inclusive, where N is the count
    ///of the array), the behavior is undefined. If the range
    ///length is negative, the behavior is undefined. The range may
    ///be empty (length 0).
    ///@param applier The callback function to call once for each value in
    ///the given range in the array. If this parameter is not a
    ///pointer to a function of the correct prototype, the behavior
    ///is undefined. If there are values in the range which the
    ///applier function does not expect or cannot properly apply
    ///to, the behavior is undefined.
    ///@param context A pointer-sized user-defined value, which is passed
    ///as the second parameter to the applier function, but is
    ///otherwise unused by this function. If the context is not
    ///what is expected by the applier function, the behavior is
    ///undefined.
    pub fn CFArrayApplyFunction(
        theArray: CFArrayRef,
        range: CFRange,
        applier: CFArrayApplierFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFArrayGetFirstIndexOfValue
    ///Searches the array for the value.
    ///@param theArray The array to be searched. If this parameter is not a
    ///valid CFArray, the behavior is undefined.
    ///@param range The range within the array to search. If the range
    ///location or end point (defined by the location plus length
    ///minus 1) is outside the index space of the array (0 to
    ///N-1 inclusive, where N is the count of the array), the
    ///behavior is undefined. If the range length is negative, the
    ///behavior is undefined. The range may be empty (length 0).
    ///The search progresses from the smallest index defined by
    ///the range to the largest.
    ///@param value The value for which to find a match in the array. The
    ///equal() callback provided when the array was created is
    ///used to compare. If the equal() callback was NULL, pointer
    ///equality (in C, ==) is used. If value, or any of the values
    ///in the array, are not understood by the equal() callback,
    ///the behavior is undefined.
    ///@result The lowest index of the matching values in the range, or
    ///kCFNotFound if no value in the range matched.
    pub fn CFArrayGetFirstIndexOfValue(
        theArray: CFArrayRef,
        range: CFRange,
        value: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    ///@function CFArrayGetLastIndexOfValue
    ///Searches the array for the value.
    ///@param theArray The array to be searched. If this parameter is not a
    ///valid CFArray, the behavior is undefined.
    ///@param range The range within the array to search. If the range
    ///location or end point (defined by the location plus length
    ///minus 1) is outside the index space of the array (0 to
    ///N-1 inclusive, where N is the count of the array), the
    ///behavior is undefined. If the range length is negative, the
    ///behavior is undefined. The range may be empty (length 0).
    ///The search progresses from the largest index defined by the
    ///range to the smallest.
    ///@param value The value for which to find a match in the array. The
    ///equal() callback provided when the array was created is
    ///used to compare. If the equal() callback was NULL, pointer
    ///equality (in C, ==) is used. If value, or any of the values
    ///in the array, are not understood by the equal() callback,
    ///the behavior is undefined.
    ///@result The highest index of the matching values in the range, or
    ///kCFNotFound if no value in the range matched.
    pub fn CFArrayGetLastIndexOfValue(
        theArray: CFArrayRef,
        range: CFRange,
        value: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    ///@function CFArrayBSearchValues
    ///Searches the array for the value using a binary search algorithm.
    ///@param theArray The array to be searched. If this parameter is not a
    ///valid CFArray, the behavior is undefined. If the array is
    ///not sorted from least to greatest according to the
    ///comparator function, the behavior is undefined.
    ///@param range The range within the array to search. If the range
    ///location or end point (defined by the location plus length
    ///minus 1) is outside the index space of the array (0 to
    ///N-1 inclusive, where N is the count of the array), the
    ///behavior is undefined. If the range length is negative, the
    ///behavior is undefined. The range may be empty (length 0).
    ///@param value The value for which to find a match in the array. If
    ///value, or any of the values in the array, are not understood
    ///by the comparator callback, the behavior is undefined.
    ///@param comparator The function with the comparator function type
    ///signature which is used in the binary search operation to
    ///compare values in the array with the given value. If this
    ///parameter is not a pointer to a function of the correct
    ///prototype, the behavior is undefined. If there are values
    ///in the range which the comparator function does not expect
    ///or cannot properly compare, the behavior is undefined.
    ///@param context A pointer-sized user-defined value, which is passed
    ///as the third parameter to the comparator function, but is
    ///otherwise unused by this function. If the context is not
    ///what is expected by the comparator function, the behavior is
    ///undefined.
    ///@result The return value is either 1) the index of a value that
    ///matched, if the target value matches one or more in the
    ///range, 2) greater than or equal to the end point of the
    ///range, if the value is greater than all the values in the
    ///range, or 3) the index of the value greater than the target
    ///value, if the value lies between two of (or less than all
    ///of) the values in the range.
    pub fn CFArrayBSearchValues(
        theArray: CFArrayRef,
        range: CFRange,
        value: *const ::std::os::raw::c_void,
        comparator: CFComparatorFunction,
        context: *mut ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    ///@function CFArrayAppendValue
    ///Adds the value to the array giving it a new largest index.
    ///@param theArray The array to which the value is to be added. If this
    ///parameter is not a valid mutable CFArray, the behavior is
    ///undefined.
    ///@param value The value to add to the array. The value is retained by
    ///the array using the retain callback provided when the array
    ///was created. If the value is not of the sort expected by the
    ///retain callback, the behavior is undefined. The value is
    ///assigned to the index one larger than the previous largest
    ///index, and the count of the array is increased by one.
    pub fn CFArrayAppendValue(theArray: CFMutableArrayRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    ///@function CFArrayInsertValueAtIndex
    ///Adds the value to the array, giving it the given index.
    ///@param theArray The array to which the value is to be added. If this
    ///parameter is not a valid mutable CFArray, the behavior is
    ///undefined.
    ///@param idx The index to which to add the new value. If the index is
    ///outside the index space of the array (0 to N inclusive,
    ///where N is the count of the array before the operation), the
    ///behavior is undefined. If the index is the same as N, this
    ///function has the same effect as CFArrayAppendValue().
    ///@param value The value to add to the array. The value is retained by
    ///the array using the retain callback provided when the array
    ///was created. If the value is not of the sort expected by the
    ///retain callback, the behavior is undefined. The value is
    ///assigned to the given index, and all values with equal and
    ///larger indices have their indexes increased by one.
    pub fn CFArrayInsertValueAtIndex(
        theArray: CFMutableArrayRef,
        idx: CFIndex,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFArraySetValueAtIndex
    ///Changes the value with the given index in the array.
    ///@param theArray The array in which the value is to be changed. If this
    ///parameter is not a valid mutable CFArray, the behavior is
    ///undefined.
    ///@param idx The index to which to set the new value. If the index is
    ///outside the index space of the array (0 to N inclusive,
    ///where N is the count of the array before the operation), the
    ///behavior is undefined. If the index is the same as N, this
    ///function has the same effect as CFArrayAppendValue().
    ///@param value The value to set in the array. The value is retained by
    ///the array using the retain callback provided when the array
    ///was created, and the previous value with that index is
    ///released. If the value is not of the sort expected by the
    ///retain callback, the behavior is undefined. The indices of
    ///other values is not affected.
    pub fn CFArraySetValueAtIndex(
        theArray: CFMutableArrayRef,
        idx: CFIndex,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFArrayRemoveValueAtIndex
    ///Removes the value with the given index from the array.
    ///@param theArray The array from which the value is to be removed. If
    ///this parameter is not a valid mutable CFArray, the behavior
    ///is undefined.
    ///@param idx The index from which to remove the value. If the index is
    ///outside the index space of the array (0 to N-1 inclusive,
    ///where N is the count of the array before the operation), the
    ///behavior is undefined.
    pub fn CFArrayRemoveValueAtIndex(theArray: CFMutableArrayRef, idx: CFIndex);
}
extern "C" {
    ///@function CFArrayRemoveAllValues
    ///Removes all the values from the array, making it empty.
    ///@param theArray The array from which all of the values are to be
    ///removed. If this parameter is not a valid mutable CFArray,
    ///the behavior is undefined.
    pub fn CFArrayRemoveAllValues(theArray: CFMutableArrayRef);
}
extern "C" {
    ///@function CFArrayReplaceValues
    ///Replaces a range of values in the array.
    ///@param theArray The array from which all of the values are to be
    ///removed. If this parameter is not a valid mutable CFArray,
    ///the behavior is undefined.
    ///@param range The range of values within the array to replace. If the
    ///range location or end point (defined by the location plus
    ///length minus 1) is outside the index space of the array (0
    ///to N inclusive, where N is the count of the array), the
    ///behavior is undefined. If the range length is negative, the
    ///behavior is undefined. The range may be empty (length 0),
    ///in which case the new values are merely inserted at the
    ///range location.
    ///@param newValues A C array of the pointer-sized values to be placed
    ///into the array. The new values in the array are ordered in
    ///the same order in which they appear in this C array. This
    ///parameter may be NULL if the newCount parameter is 0. This
    ///C array is not changed or freed by this function. If this
    ///parameter is not a valid pointer to a C array of at least
    ///newCount pointers, the behavior is undefined.
    ///@param newCount The number of values to copy from the values C
    ///array into the CFArray. If this parameter is different than
    ///the range length, the excess newCount values will be
    ///inserted after the range, or the excess range values will be
    ///deleted. This parameter may be 0, in which case no new
    ///values are replaced into the array and the values in the
    ///range are simply removed. If this parameter is negative, or
    ///greater than the number of values actually in the newValues
    ///C array, the behavior is undefined.
    pub fn CFArrayReplaceValues(
        theArray: CFMutableArrayRef,
        range: CFRange,
        newValues: *mut *const ::std::os::raw::c_void,
        newCount: CFIndex,
    );
}
extern "C" {
    ///@function CFArrayExchangeValuesAtIndices
    ///Exchanges the values at two indices of the array.
    ///@param theArray The array of which the values are to be swapped. If
    ///this parameter is not a valid mutable CFArray, the behavior
    ///is undefined.
    ///@param idx1 The first index whose values should be swapped. If the
    ///index is outside the index space of the array (0 to N-1
    ///inclusive, where N is the count of the array before the
    ///operation), the behavior is undefined.
    ///@param idx2 The second index whose values should be swapped. If the
    ///index is outside the index space of the array (0 to N-1
    ///inclusive, where N is the count of the array before the
    ///operation), the behavior is undefined.
    pub fn CFArrayExchangeValuesAtIndices(
        theArray: CFMutableArrayRef,
        idx1: CFIndex,
        idx2: CFIndex,
    );
}
extern "C" {
    ///@function CFArraySortValues
    ///Sorts the values in the array using the given comparison function.
    ///@param theArray The array whose values are to be sorted. If this
    ///parameter is not a valid mutable CFArray, the behavior is
    ///undefined.
    ///@param range The range of values within the array to sort. If the
    ///range location or end point (defined by the location plus
    ///length minus 1) is outside the index space of the array (0
    ///to N-1 inclusive, where N is the count of the array), the
    ///behavior is undefined. If the range length is negative, the
    ///behavior is undefined. The range may be empty (length 0).
    ///@param comparator The function with the comparator function type
    ///signature which is used in the sort operation to compare
    ///values in the array with the given value. If this parameter
    ///is not a pointer to a function of the correct prototype, the
    ///the behavior is undefined. If there are values in the array
    ///which the comparator function does not expect or cannot
    ///properly compare, the behavior is undefined. The values in
    ///the range are sorted from least to greatest according to
    ///this function.
    ///@param context A pointer-sized user-defined value, which is passed
    ///as the third parameter to the comparator function, but is
    ///otherwise unused by this function. If the context is not
    ///what is expected by the comparator function, the behavior is
    ///undefined.
    pub fn CFArraySortValues(
        theArray: CFMutableArrayRef,
        range: CFRange,
        comparator: CFComparatorFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFArrayAppendArray
    ///Adds the values from an array to another array.
    ///@param theArray The array to which values from the otherArray are to
    ///be added. If this parameter is not a valid mutable CFArray,
    ///the behavior is undefined.
    ///@param otherArray The array providing the values to be added to the
    ///array. If this parameter is not a valid CFArray, the
    ///behavior is undefined.
    ///@param otherRange The range within the otherArray from which to add
    ///the values to the array. If the range location or end point
    ///(defined by the location plus length minus 1) is outside
    ///the index space of the otherArray (0 to N-1 inclusive, where
    ///N is the count of the otherArray), the behavior is
    ///undefined. The new values are retained by the array using
    ///the retain callback provided when the array was created. If
    ///the values are not of the sort expected by the retain
    ///callback, the behavior is undefined. The values are assigned
    ///to the indices one larger than the previous largest index
    ///in the array, and beyond, and the count of the array is
    ///increased by range.length. The values are assigned new
    ///indices in the array from smallest to largest index in the
    ///order in which they appear in the otherArray.
    pub fn CFArrayAppendArray(
        theArray: CFMutableArrayRef,
        otherArray: CFArrayRef,
        otherRange: CFRange,
    );
}
pub type CFBagRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: CFAllocatorRef,
        value: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void,
>;
pub type CFBagReleaseCallBack = ::std::option::Option<
    unsafe extern "C" fn(allocator: CFAllocatorRef, value: *const ::std::os::raw::c_void),
>;
pub type CFBagCopyDescriptionCallBack = ::std::option::Option<
    unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFStringRef,
>;
pub type CFBagEqualCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        value1: *const ::std::os::raw::c_void,
        value2: *const ::std::os::raw::c_void,
    ) -> Boolean,
>;
pub type CFBagHashCallBack =
    ::std::option::Option<unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFHashCode>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFBagCallBacks {
    pub version: CFIndex,
    pub retain: CFBagRetainCallBack,
    pub release: CFBagReleaseCallBack,
    pub copyDescription: CFBagCopyDescriptionCallBack,
    pub equal: CFBagEqualCallBack,
    pub hash: CFBagHashCallBack,
}
#[test]
fn bindgen_test_layout_CFBagCallBacks() {
    assert_eq!(
        ::std::mem::size_of::<CFBagCallBacks>(),
        48usize,
        concat!("Size of: ", stringify!(CFBagCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFBagCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFBagCallBacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFBagCallBacks>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBagCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFBagCallBacks>())).retain as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBagCallBacks),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFBagCallBacks>())).release as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBagCallBacks),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFBagCallBacks>())).copyDescription as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBagCallBacks),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFBagCallBacks>())).equal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBagCallBacks),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFBagCallBacks>())).hash as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBagCallBacks),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for CFBagCallBacks {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static kCFTypeBagCallBacks: CFBagCallBacks;
}
extern "C" {
    pub static kCFCopyStringBagCallBacks: CFBagCallBacks;
}
pub type CFBagApplierFunction = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFBag {
    _unused: [u8; 0],
}
pub type CFBagRef = *const __CFBag;
pub type CFMutableBagRef = *mut __CFBag;
extern "C" {
    pub fn CFBagGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFBagCreate(
        allocator: CFAllocatorRef,
        values: *mut *const ::std::os::raw::c_void,
        numValues: CFIndex,
        callBacks: *const CFBagCallBacks,
    ) -> CFBagRef;
}
extern "C" {
    pub fn CFBagCreateCopy(allocator: CFAllocatorRef, theBag: CFBagRef) -> CFBagRef;
}
extern "C" {
    pub fn CFBagCreateMutable(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        callBacks: *const CFBagCallBacks,
    ) -> CFMutableBagRef;
}
extern "C" {
    pub fn CFBagCreateMutableCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        theBag: CFBagRef,
    ) -> CFMutableBagRef;
}
extern "C" {
    pub fn CFBagGetCount(theBag: CFBagRef) -> CFIndex;
}
extern "C" {
    pub fn CFBagGetCountOfValue(theBag: CFBagRef, value: *const ::std::os::raw::c_void) -> CFIndex;
}
extern "C" {
    pub fn CFBagContainsValue(theBag: CFBagRef, value: *const ::std::os::raw::c_void) -> Boolean;
}
extern "C" {
    pub fn CFBagGetValue(
        theBag: CFBagRef,
        value: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFBagGetValueIfPresent(
        theBag: CFBagRef,
        candidate: *const ::std::os::raw::c_void,
        value: *mut *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    pub fn CFBagGetValues(theBag: CFBagRef, values: *mut *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn CFBagApplyFunction(
        theBag: CFBagRef,
        applier: CFBagApplierFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFBagAddValue(theBag: CFMutableBagRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn CFBagReplaceValue(theBag: CFMutableBagRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn CFBagSetValue(theBag: CFMutableBagRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn CFBagRemoveValue(theBag: CFMutableBagRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn CFBagRemoveAllValues(theBag: CFMutableBagRef);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFBinaryHeapCompareContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub release: ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFBinaryHeapCompareContext() {
    assert_eq!(
        ::std::mem::size_of::<CFBinaryHeapCompareContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFBinaryHeapCompareContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFBinaryHeapCompareContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFBinaryHeapCompareContext))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFBinaryHeapCompareContext>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCompareContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFBinaryHeapCompareContext>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCompareContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFBinaryHeapCompareContext>())).retain as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCompareContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFBinaryHeapCompareContext>())).release as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCompareContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFBinaryHeapCompareContext>())).copyDescription as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCompareContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
impl Default for CFBinaryHeapCompareContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@typedef CFBinaryHeapCallBacks
///Structure containing the callbacks for values of a CFBinaryHeap.
///@field version The version number of the structure type being passed
///in as a parameter to the CFBinaryHeap creation functions.
///This structure is version 0.
///@field retain The callback used to add a retain for the binary heap
///on values as they are put into the binary heap.
///This callback returns the value to use as the value in the
///binary heap, which is usually the value parameter passed to
///this callback, but may be a different value if a different
///value should be added to the binary heap. The binary heap's
///allocator is passed as the first argument.
///@field release The callback used to remove a retain previously added
///for the binary heap from values as they are removed from
///the binary heap. The binary heap's allocator is passed as the
///first argument.
///@field copyDescription The callback used to create a descriptive
///string representation of each value in the binary heap. This
///is used by the CFCopyDescription() function.
///@field compare The callback used to compare values in the binary heap for
///equality in some operations.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFBinaryHeapCallBacks {
    pub version: CFIndex,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(
            allocator: CFAllocatorRef,
            ptr: *const ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub release: ::std::option::Option<
        unsafe extern "C" fn(allocator: CFAllocatorRef, ptr: *const ::std::os::raw::c_void),
    >,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(ptr: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
    pub compare: ::std::option::Option<
        unsafe extern "C" fn(
            ptr1: *const ::std::os::raw::c_void,
            ptr2: *const ::std::os::raw::c_void,
            context: *mut ::std::os::raw::c_void,
        ) -> CFComparisonResult,
    >,
}
#[test]
fn bindgen_test_layout_CFBinaryHeapCallBacks() {
    assert_eq!(
        ::std::mem::size_of::<CFBinaryHeapCallBacks>(),
        40usize,
        concat!("Size of: ", stringify!(CFBinaryHeapCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFBinaryHeapCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFBinaryHeapCallBacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFBinaryHeapCallBacks>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFBinaryHeapCallBacks>())).retain as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCallBacks),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFBinaryHeapCallBacks>())).release as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCallBacks),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFBinaryHeapCallBacks>())).copyDescription as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCallBacks),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFBinaryHeapCallBacks>())).compare as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFBinaryHeapCallBacks),
            "::",
            stringify!(compare)
        )
    );
}
impl Default for CFBinaryHeapCallBacks {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static kCFStringBinaryHeapCallBacks: CFBinaryHeapCallBacks;
}
///@typedef CFBinaryHeapApplierFunction
///Type of the callback function used by the apply functions of
///CFBinaryHeap.
///@param val The current value from the binary heap.
///@param context The user-defined context parameter given to the apply
///function.
pub type CFBinaryHeapApplierFunction = ::std::option::Option<
    unsafe extern "C" fn(val: *const ::std::os::raw::c_void, context: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFBinaryHeap {
    _unused: [u8; 0],
}
///@typedef CFBinaryHeapRef
///This is the type of a reference to CFBinaryHeaps.
pub type CFBinaryHeapRef = *mut __CFBinaryHeap;
extern "C" {
    ///@function CFBinaryHeapGetTypeID
    ///Returns the type identifier of all CFBinaryHeap instances.
    pub fn CFBinaryHeapGetTypeID() -> CFTypeID;
}
extern "C" {
    ///@function CFBinaryHeapCreate
    ///Creates a new mutable binary heap with the given values.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the binary heap and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param capacity A hint about the number of values that will be held
    ///by the CFBinaryHeap. Pass 0 for no hint. The implementation may
    ///ignore this hint, or may use it to optimize various
    ///operations. A heap's actual capacity is only limited by
    ///address space and available memory constraints). If this
    ///parameter is negative, the behavior is undefined.
    ///@param callBacks A pointer to a CFBinaryHeapCallBacks structure
    ///initialized with the callbacks for the binary heap to use on
    ///each value in the binary heap. A copy of the contents of the
    ///callbacks structure is made, so that a pointer to a structure
    ///on the stack can be passed in, or can be reused for multiple
    ///binary heap creations. If the version field of this callbacks
    ///structure is not one of the defined ones for CFBinaryHeap, the
    ///behavior is undefined. The retain field may be NULL, in which
    ///case the CFBinaryHeap will do nothing to add a retain to values
    ///as they are put into the binary heap. The release field may be
    ///NULL, in which case the CFBinaryHeap will do nothing to remove
    ///the binary heap's retain (if any) on the values when the
    ///heap is destroyed or a key-value pair is removed. If the
    ///copyDescription field is NULL, the binary heap will create a
    ///simple description for a value. If the equal field is NULL, the
    ///binary heap will use pointer equality to test for equality of
    ///values. This callbacks parameter itself may be NULL, which is
    ///treated as if a valid structure of version 0 with all fields
    ///NULL had been passed in. Otherwise,
    ///if any of the fields are not valid pointers to functions
    ///of the correct type, or this parameter is not a valid
    ///pointer to a CFBinaryHeapCallBacks callbacks structure,
    ///the behavior is undefined. If any of the values put into the
    ///binary heap is not one understood by one of the callback functions
    ///the behavior when that callback function is used is undefined.
    ///@param compareContext A pointer to a CFBinaryHeapCompareContext structure.
    ///@result A reference to the new CFBinaryHeap.
    pub fn CFBinaryHeapCreate(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        callBacks: *const CFBinaryHeapCallBacks,
        compareContext: *const CFBinaryHeapCompareContext,
    ) -> CFBinaryHeapRef;
}
extern "C" {
    ///@function CFBinaryHeapCreateCopy
    ///Creates a new mutable binary heap with the values from the given binary heap.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the binary heap and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param capacity A hint about the number of values that will be held
    ///by the CFBinaryHeap. Pass 0 for no hint. The implementation may
    ///ignore this hint, or may use it to optimize various
    ///operations. A heap's actual capacity is only limited by
    ///address space and available memory constraints).
    ///This parameter must be greater than or equal
    ///to the count of the heap which is to be copied, or the
    ///behavior is undefined. If this parameter is negative, the
    ///behavior is undefined.
    ///@param heap The binary heap which is to be copied. The values from the
    ///binary heap are copied as pointers into the new binary heap (that is,
    ///the values themselves are copied, not that which the values
    ///point to, if anything). However, the values are also
    ///retained by the new binary heap. The count of the new binary will
    ///be the same as the given binary heap. The new binary heap uses the same
    ///callbacks as the binary heap to be copied. If this parameter is
    ///not a valid CFBinaryHeap, the behavior is undefined.
    ///@result A reference to the new mutable binary heap.
    pub fn CFBinaryHeapCreateCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        heap: CFBinaryHeapRef,
    ) -> CFBinaryHeapRef;
}
extern "C" {
    ///@function CFBinaryHeapGetCount
    ///Returns the number of values currently in the binary heap.
    ///@param heap The binary heap to be queried. If this parameter is not a valid
    ///CFBinaryHeap, the behavior is undefined.
    ///@result The number of values in the binary heap.
    pub fn CFBinaryHeapGetCount(heap: CFBinaryHeapRef) -> CFIndex;
}
extern "C" {
    ///@function CFBinaryHeapGetCountOfValue
    ///Counts the number of times the given value occurs in the binary heap.
    ///@param heap The binary heap to be searched. If this parameter is not a
    ///valid CFBinaryHeap, the behavior is undefined.
    ///@param value The value for which to find matches in the binary heap. The
    ///compare() callback provided when the binary heap was created is
    ///used to compare. If the compare() callback was NULL, pointer
    ///equality (in C, ==) is used. If value, or any of the values
    ///in the binary heap, are not understood by the compare() callback,
    ///the behavior is undefined.
    ///@result The number of times the given value occurs in the binary heap.
    pub fn CFBinaryHeapGetCountOfValue(
        heap: CFBinaryHeapRef,
        value: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    ///@function CFBinaryHeapContainsValue
    ///Reports whether or not the value is in the binary heap.
    ///@param heap The binary heap to be searched. If this parameter is not a
    ///valid CFBinaryHeap, the behavior is undefined.
    ///@param value The value for which to find matches in the binary heap. The
    ///compare() callback provided when the binary heap was created is
    ///used to compare. If the compare() callback was NULL, pointer
    ///equality (in C, ==) is used. If value, or any of the values
    ///in the binary heap, are not understood by the compare() callback,
    ///the behavior is undefined.
    ///@result true, if the value is in the specified binary heap, otherwise false.
    pub fn CFBinaryHeapContainsValue(
        heap: CFBinaryHeapRef,
        value: *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    ///@function CFBinaryHeapGetMinimum
    ///Returns the minimum value is in the binary heap.  If the heap contains several equal
    ///minimum values, any one may be returned.
    ///@param heap The binary heap to be searched. If this parameter is not a
    ///valid CFBinaryHeap, the behavior is undefined.
    ///@result A reference to the minimum value in the binary heap, or NULL if the
    ///binary heap contains no values.
    pub fn CFBinaryHeapGetMinimum(heap: CFBinaryHeapRef) -> *const ::std::os::raw::c_void;
}
extern "C" {
    ///@function CFBinaryHeapGetMinimumIfPresent
    ///Returns the minimum value is in the binary heap, if present.  If the heap contains several equal
    ///minimum values, any one may be returned.
    ///@param heap The binary heap to be searched. If this parameter is not a
    ///valid CFBinaryHeap, the behavior is undefined.
    ///@param value A C pointer to pointer-sized storage to be filled with the minimum value in
    ///the binary heap.  If this value is not a valid C pointer to a pointer-sized block
    ///of storage, the result is undefined.  If the result of the function is false, the value
    ///stored at this address is undefined.
    ///@result true, if a minimum value was found in the specified binary heap, otherwise false.
    pub fn CFBinaryHeapGetMinimumIfPresent(
        heap: CFBinaryHeapRef,
        value: *mut *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    ///@function CFBinaryHeapGetValues
    ///Fills the buffer with values from the binary heap.
    ///@param heap The binary heap to be queried. If this parameter is not a
    ///valid CFBinaryHeap, the behavior is undefined.
    ///@param values A C array of pointer-sized values to be filled with
    ///values from the binary heap. The values in the C array are ordered
    ///from least to greatest. If this parameter is not a valid pointer to a
    ///C array of at least CFBinaryHeapGetCount() pointers, the behavior is undefined.
    pub fn CFBinaryHeapGetValues(heap: CFBinaryHeapRef, values: *mut *const ::std::os::raw::c_void);
}
extern "C" {
    ///@function CFBinaryHeapApplyFunction
    ///Calls a function once for each value in the binary heap.
    ///@param heap The binary heap to be operated upon. If this parameter is not a
    ///valid CFBinaryHeap, the behavior is undefined.
    ///@param applier The callback function to call once for each value in
    ///the given binary heap. If this parameter is not a
    ///pointer to a function of the correct prototype, the behavior
    ///is undefined. If there are values in the binary heap which the
    ///applier function does not expect or cannot properly apply
    ///to, the behavior is undefined.
    ///@param context A pointer-sized user-defined value, which is passed
    ///as the second parameter to the applier function, but is
    ///otherwise unused by this function. If the context is not
    ///what is expected by the applier function, the behavior is
    ///undefined.
    pub fn CFBinaryHeapApplyFunction(
        heap: CFBinaryHeapRef,
        applier: CFBinaryHeapApplierFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFBinaryHeapAddValue
    ///Adds the value to the binary heap.
    ///@param heap The binary heap to which the value is to be added. If this parameter is not a
    ///valid mutable CFBinaryHeap, the behavior is undefined.
    ///@param value The value to add to the binary heap. The value is retained by
    ///the binary heap using the retain callback provided when the binary heap
    ///was created. If the value is not of the sort expected by the
    ///retain callback, the behavior is undefined.
    pub fn CFBinaryHeapAddValue(heap: CFBinaryHeapRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    ///@function CFBinaryHeapRemoveMinimumValue
    ///Removes the minimum value from the binary heap.
    ///@param heap The binary heap from which the minimum value is to be removed. If this
    ///parameter is not a valid mutable CFBinaryHeap, the behavior is undefined.
    pub fn CFBinaryHeapRemoveMinimumValue(heap: CFBinaryHeapRef);
}
extern "C" {
    ///@function CFBinaryHeapRemoveAllValues
    ///Removes all the values from the binary heap, making it empty.
    ///@param heap The binary heap from which all of the values are to be
    ///removed. If this parameter is not a valid mutable CFBinaryHeap,
    ///the behavior is undefined.
    pub fn CFBinaryHeapRemoveAllValues(heap: CFBinaryHeapRef);
}
pub type CFBit = UInt32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFBitVector {
    _unused: [u8; 0],
}
pub type CFBitVectorRef = *const __CFBitVector;
pub type CFMutableBitVectorRef = *mut __CFBitVector;
extern "C" {
    pub fn CFBitVectorGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFBitVectorCreate(
        allocator: CFAllocatorRef,
        bytes: *const UInt8,
        numBits: CFIndex,
    ) -> CFBitVectorRef;
}
extern "C" {
    pub fn CFBitVectorCreateCopy(allocator: CFAllocatorRef, bv: CFBitVectorRef) -> CFBitVectorRef;
}
extern "C" {
    pub fn CFBitVectorCreateMutable(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
    ) -> CFMutableBitVectorRef;
}
extern "C" {
    pub fn CFBitVectorCreateMutableCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        bv: CFBitVectorRef,
    ) -> CFMutableBitVectorRef;
}
extern "C" {
    pub fn CFBitVectorGetCount(bv: CFBitVectorRef) -> CFIndex;
}
extern "C" {
    pub fn CFBitVectorGetCountOfBit(bv: CFBitVectorRef, range: CFRange, value: CFBit) -> CFIndex;
}
extern "C" {
    pub fn CFBitVectorContainsBit(bv: CFBitVectorRef, range: CFRange, value: CFBit) -> Boolean;
}
extern "C" {
    pub fn CFBitVectorGetBitAtIndex(bv: CFBitVectorRef, idx: CFIndex) -> CFBit;
}
extern "C" {
    pub fn CFBitVectorGetBits(bv: CFBitVectorRef, range: CFRange, bytes: *mut UInt8);
}
extern "C" {
    pub fn CFBitVectorGetFirstIndexOfBit(
        bv: CFBitVectorRef,
        range: CFRange,
        value: CFBit,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFBitVectorGetLastIndexOfBit(
        bv: CFBitVectorRef,
        range: CFRange,
        value: CFBit,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFBitVectorSetCount(bv: CFMutableBitVectorRef, count: CFIndex);
}
extern "C" {
    pub fn CFBitVectorFlipBitAtIndex(bv: CFMutableBitVectorRef, idx: CFIndex);
}
extern "C" {
    pub fn CFBitVectorFlipBits(bv: CFMutableBitVectorRef, range: CFRange);
}
extern "C" {
    pub fn CFBitVectorSetBitAtIndex(bv: CFMutableBitVectorRef, idx: CFIndex, value: CFBit);
}
extern "C" {
    pub fn CFBitVectorSetBits(bv: CFMutableBitVectorRef, range: CFRange, value: CFBit);
}
extern "C" {
    pub fn CFBitVectorSetAllBits(bv: CFMutableBitVectorRef, value: CFBit);
}
pub const OSUnknownByteOrder: _bindgen_ty_21 = 0;
pub const OSLittleEndian: _bindgen_ty_21 = 1;
pub const OSBigEndian: _bindgen_ty_21 = 2;
pub type _bindgen_ty_21 = u32;
pub const __CFByteOrder_CFByteOrderUnknown: __CFByteOrder = 0;
pub const __CFByteOrder_CFByteOrderLittleEndian: __CFByteOrder = 1;
pub const __CFByteOrder_CFByteOrderBigEndian: __CFByteOrder = 2;
pub type __CFByteOrder = u32;
pub type CFByteOrder = CFIndex;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CFSwappedFloat32 {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_CFSwappedFloat32() {
    assert_eq!(
        ::std::mem::size_of::<CFSwappedFloat32>(),
        4usize,
        concat!("Size of: ", stringify!(CFSwappedFloat32))
    );
    assert_eq!(
        ::std::mem::align_of::<CFSwappedFloat32>(),
        4usize,
        concat!("Alignment of ", stringify!(CFSwappedFloat32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSwappedFloat32>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSwappedFloat32),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CFSwappedFloat64 {
    pub v: u64,
}
#[test]
fn bindgen_test_layout_CFSwappedFloat64() {
    assert_eq!(
        ::std::mem::size_of::<CFSwappedFloat64>(),
        8usize,
        concat!("Size of: ", stringify!(CFSwappedFloat64))
    );
    assert_eq!(
        ::std::mem::align_of::<CFSwappedFloat64>(),
        8usize,
        concat!("Alignment of ", stringify!(CFSwappedFloat64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSwappedFloat64>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSwappedFloat64),
            "::",
            stringify!(v)
        )
    );
}
///@typedef CFDictionaryKeyCallBacks
///Structure containing the callbacks for keys of a CFDictionary.
///@field version The version number of the structure type being passed
///in as a parameter to the CFDictionary creation functions.
///This structure is version 0.
///@field retain The callback used to add a retain for the dictionary
///on keys as they are used to put values into the dictionary.
///This callback returns the value to use as the key in the
///dictionary, which is usually the value parameter passed to
///this callback, but may be a different value if a different
///value should be used as the key. The dictionary's allocator
///is passed as the first argument.
///@field release The callback used to remove a retain previously added
///for the dictionary from keys as their values are removed from
///the dictionary. The dictionary's allocator is passed as the
///first argument.
///@field copyDescription The callback used to create a descriptive
///string representation of each key in the dictionary. This
///is used by the CFCopyDescription() function.
///@field equal The callback used to compare keys in the dictionary for
///equality.
///@field hash The callback used to compute a hash code for keys as they
///are used to access, add, or remove values in the dictionary.
pub type CFDictionaryRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: CFAllocatorRef,
        value: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void,
>;
pub type CFDictionaryReleaseCallBack = ::std::option::Option<
    unsafe extern "C" fn(allocator: CFAllocatorRef, value: *const ::std::os::raw::c_void),
>;
pub type CFDictionaryCopyDescriptionCallBack = ::std::option::Option<
    unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFStringRef,
>;
pub type CFDictionaryEqualCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        value1: *const ::std::os::raw::c_void,
        value2: *const ::std::os::raw::c_void,
    ) -> Boolean,
>;
pub type CFDictionaryHashCallBack =
    ::std::option::Option<unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFHashCode>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFDictionaryKeyCallBacks {
    pub version: CFIndex,
    pub retain: CFDictionaryRetainCallBack,
    pub release: CFDictionaryReleaseCallBack,
    pub copyDescription: CFDictionaryCopyDescriptionCallBack,
    pub equal: CFDictionaryEqualCallBack,
    pub hash: CFDictionaryHashCallBack,
}
#[test]
fn bindgen_test_layout_CFDictionaryKeyCallBacks() {
    assert_eq!(
        ::std::mem::size_of::<CFDictionaryKeyCallBacks>(),
        48usize,
        concat!("Size of: ", stringify!(CFDictionaryKeyCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFDictionaryKeyCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFDictionaryKeyCallBacks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFDictionaryKeyCallBacks>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryKeyCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFDictionaryKeyCallBacks>())).retain as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryKeyCallBacks),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFDictionaryKeyCallBacks>())).release as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryKeyCallBacks),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFDictionaryKeyCallBacks>())).copyDescription as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryKeyCallBacks),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFDictionaryKeyCallBacks>())).equal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryKeyCallBacks),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFDictionaryKeyCallBacks>())).hash as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryKeyCallBacks),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for CFDictionaryKeyCallBacks {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static kCFTypeDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
}
extern "C" {
    pub static kCFCopyStringDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
}
///@typedef CFDictionaryValueCallBacks
///Structure containing the callbacks for values of a CFDictionary.
///@field version The version number of the structure type being passed
///in as a parameter to the CFDictionary creation functions.
///This structure is version 0.
///@field retain The callback used to add a retain for the dictionary
///on values as they are put into the dictionary.
///This callback returns the value to use as the value in the
///dictionary, which is usually the value parameter passed to
///this callback, but may be a different value if a different
///value should be added to the dictionary. The dictionary's
///allocator is passed as the first argument.
///@field release The callback used to remove a retain previously added
///for the dictionary from values as they are removed from
///the dictionary. The dictionary's allocator is passed as the
///first argument.
///@field copyDescription The callback used to create a descriptive
///string representation of each value in the dictionary. This
///is used by the CFCopyDescription() function.
///@field equal The callback used to compare values in the dictionary for
///equality in some operations.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFDictionaryValueCallBacks {
    pub version: CFIndex,
    pub retain: CFDictionaryRetainCallBack,
    pub release: CFDictionaryReleaseCallBack,
    pub copyDescription: CFDictionaryCopyDescriptionCallBack,
    pub equal: CFDictionaryEqualCallBack,
}
#[test]
fn bindgen_test_layout_CFDictionaryValueCallBacks() {
    assert_eq!(
        ::std::mem::size_of::<CFDictionaryValueCallBacks>(),
        40usize,
        concat!("Size of: ", stringify!(CFDictionaryValueCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFDictionaryValueCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFDictionaryValueCallBacks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFDictionaryValueCallBacks>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryValueCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFDictionaryValueCallBacks>())).retain as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryValueCallBacks),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFDictionaryValueCallBacks>())).release as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryValueCallBacks),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFDictionaryValueCallBacks>())).copyDescription as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryValueCallBacks),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFDictionaryValueCallBacks>())).equal as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFDictionaryValueCallBacks),
            "::",
            stringify!(equal)
        )
    );
}
impl Default for CFDictionaryValueCallBacks {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static kCFTypeDictionaryValueCallBacks: CFDictionaryValueCallBacks;
}
///@typedef CFDictionaryApplierFunction
///Type of the callback function used by the apply functions of
///CFDictionarys.
///@param key The current key for the value.
///@param value The current value from the dictionary.
///@param context The user-defined context parameter given to the apply
///function.
pub type CFDictionaryApplierFunction = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFDictionary {
    _unused: [u8; 0],
}
///@typedef CFDictionaryRef
///This is the type of a reference to immutable CFDictionarys.
pub type CFDictionaryRef = *const __CFDictionary;
///@typedef CFMutableDictionaryRef
///This is the type of a reference to mutable CFDictionarys.
pub type CFMutableDictionaryRef = *mut __CFDictionary;
extern "C" {
    ///@function CFDictionaryGetTypeID
    ///Returns the type identifier of all CFDictionary instances.
    pub fn CFDictionaryGetTypeID() -> CFTypeID;
}
extern "C" {
    ///@function CFDictionaryCreate
    ///Creates a new immutable dictionary with the given values.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the dictionary and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param keys A C array of the pointer-sized keys to be used for
    ///the parallel C array of values to be put into the dictionary.
    ///This parameter may be NULL if the numValues parameter is 0.
    ///This C array is not changed or freed by this function. If
    ///this parameter is not a valid pointer to a C array of at
    ///least numValues pointers, the behavior is undefined.
    ///@param values A C array of the pointer-sized values to be in the
    ///dictionary. This parameter may be NULL if the numValues
    ///parameter is 0. This C array is not changed or freed by
    ///this function. If this parameter is not a valid pointer to
    ///a C array of at least numValues pointers, the behavior is
    ///undefined.
    ///@param numValues The number of values to copy from the keys and
    ///values C arrays into the CFDictionary. This number will be
    ///the count of the dictionary. If this parameter is
    ///negative, or greater than the number of values actually
    ///in the keys or values C arrays, the behavior is undefined.
    ///@param keyCallBacks A pointer to a CFDictionaryKeyCallBacks structure
    ///initialized with the callbacks for the dictionary to use on
    ///each key in the dictionary. The retain callback will be used
    ///within this function, for example, to retain all of the new
    ///keys from the keys C array. A copy of the contents of the
    ///callbacks structure is made, so that a pointer to a structure
    ///on the stack can be passed in, or can be reused for multiple
    ///dictionary creations. If the version field of this
    ///callbacks structure is not one of the defined ones for
    ///CFDictionary, the behavior is undefined. The retain field may
    ///be NULL, in which case the CFDictionary will do nothing to add
    ///a retain to the keys of the contained values. The release field
    ///may be NULL, in which case the CFDictionary will do nothing
    ///to remove the dictionary's retain (if any) on the keys when the
    ///dictionary is destroyed or a key-value pair is removed. If the
    ///copyDescription field is NULL, the dictionary will create a
    ///simple description for a key. If the equal field is NULL, the
    ///dictionary will use pointer equality to test for equality of
    ///keys. If the hash field is NULL, a key will be converted from
    ///a pointer to an integer to compute the hash code. This callbacks
    ///parameter itself may be NULL, which is treated as if a valid
    ///structure of version 0 with all fields NULL had been passed in.
    ///Otherwise, if any of the fields are not valid pointers to
    ///functions of the correct type, or this parameter is not a
    ///valid pointer to a CFDictionaryKeyCallBacks callbacks structure,
    ///the behavior is undefined. If any of the keys put into the
    ///dictionary is not one understood by one of the callback functions
    ///the behavior when that callback function is used is undefined.
    ///@param valueCallBacks A pointer to a CFDictionaryValueCallBacks structure
    ///initialized with the callbacks for the dictionary to use on
    ///each value in the dictionary. The retain callback will be used
    ///within this function, for example, to retain all of the new
    ///values from the values C array. A copy of the contents of the
    ///callbacks structure is made, so that a pointer to a structure
    ///on the stack can be passed in, or can be reused for multiple
    ///dictionary creations. If the version field of this callbacks
    ///structure is not one of the defined ones for CFDictionary, the
    ///behavior is undefined. The retain field may be NULL, in which
    ///case the CFDictionary will do nothing to add a retain to values
    ///as they are put into the dictionary. The release field may be
    ///NULL, in which case the CFDictionary will do nothing to remove
    ///the dictionary's retain (if any) on the values when the
    ///dictionary is destroyed or a key-value pair is removed. If the
    ///copyDescription field is NULL, the dictionary will create a
    ///simple description for a value. If the equal field is NULL, the
    ///dictionary will use pointer equality to test for equality of
    ///values. This callbacks parameter itself may be NULL, which is
    ///treated as if a valid structure of version 0 with all fields
    ///NULL had been passed in. Otherwise,
    ///if any of the fields are not valid pointers to functions
    ///of the correct type, or this parameter is not a valid
    ///pointer to a CFDictionaryValueCallBacks callbacks structure,
    ///the behavior is undefined. If any of the values put into the
    ///dictionary is not one understood by one of the callback functions
    ///the behavior when that callback function is used is undefined.
    ///@result A reference to the new immutable CFDictionary.
    pub fn CFDictionaryCreate(
        allocator: CFAllocatorRef,
        keys: *mut *const ::std::os::raw::c_void,
        values: *mut *const ::std::os::raw::c_void,
        numValues: CFIndex,
        keyCallBacks: *const CFDictionaryKeyCallBacks,
        valueCallBacks: *const CFDictionaryValueCallBacks,
    ) -> CFDictionaryRef;
}
extern "C" {
    ///@function CFDictionaryCreateCopy
    ///Creates a new immutable dictionary with the key-value pairs from
    ///the given dictionary.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the dictionary and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param theDict The dictionary which is to be copied. The keys and values
    ///from the dictionary are copied as pointers into the new
    ///dictionary (that is, the values themselves are copied, not
    ///that which the values point to, if anything). However, the
    ///keys and values are also retained by the new dictionary using
    ///the retain function of the original dictionary.
    ///The count of the new dictionary will be the same as the
    ///given dictionary. The new dictionary uses the same callbacks
    ///as the dictionary to be copied. If this parameter is
    ///not a valid CFDictionary, the behavior is undefined.
    ///@result A reference to the new immutable CFDictionary.
    pub fn CFDictionaryCreateCopy(
        allocator: CFAllocatorRef,
        theDict: CFDictionaryRef,
    ) -> CFDictionaryRef;
}
extern "C" {
    ///@function CFDictionaryCreateMutable
    ///Creates a new mutable dictionary.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the dictionary and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param capacity A hint about the number of values that will be held
    ///by the CFDictionary. Pass 0 for no hint. The implementation may
    ///ignore this hint, or may use it to optimize various
    ///operations. A dictionary's actual capacity is only limited by
    ///address space and available memory constraints). If this
    ///parameter is negative, the behavior is undefined.
    ///@param keyCallBacks A pointer to a CFDictionaryKeyCallBacks structure
    ///initialized with the callbacks for the dictionary to use on
    ///each key in the dictionary. A copy of the contents of the
    ///callbacks structure is made, so that a pointer to a structure
    ///on the stack can be passed in, or can be reused for multiple
    ///dictionary creations. If the version field of this
    ///callbacks structure is not one of the defined ones for
    ///CFDictionary, the behavior is undefined. The retain field may
    ///be NULL, in which case the CFDictionary will do nothing to add
    ///a retain to the keys of the contained values. The release field
    ///may be NULL, in which case the CFDictionary will do nothing
    ///to remove the dictionary's retain (if any) on the keys when the
    ///dictionary is destroyed or a key-value pair is removed. If the
    ///copyDescription field is NULL, the dictionary will create a
    ///simple description for a key. If the equal field is NULL, the
    ///dictionary will use pointer equality to test for equality of
    ///keys. If the hash field is NULL, a key will be converted from
    ///a pointer to an integer to compute the hash code. This callbacks
    ///parameter itself may be NULL, which is treated as if a valid
    ///structure of version 0 with all fields NULL had been passed in.
    ///Otherwise, if any of the fields are not valid pointers to
    ///functions of the correct type, or this parameter is not a
    ///valid pointer to a CFDictionaryKeyCallBacks callbacks structure,
    ///the behavior is undefined. If any of the keys put into the
    ///dictionary is not one understood by one of the callback functions
    ///the behavior when that callback function is used is undefined.
    ///@param valueCallBacks A pointer to a CFDictionaryValueCallBacks structure
    ///initialized with the callbacks for the dictionary to use on
    ///each value in the dictionary. The retain callback will be used
    ///within this function, for example, to retain all of the new
    ///values from the values C array. A copy of the contents of the
    ///callbacks structure is made, so that a pointer to a structure
    ///on the stack can be passed in, or can be reused for multiple
    ///dictionary creations. If the version field of this callbacks
    ///structure is not one of the defined ones for CFDictionary, the
    ///behavior is undefined. The retain field may be NULL, in which
    ///case the CFDictionary will do nothing to add a retain to values
    ///as they are put into the dictionary. The release field may be
    ///NULL, in which case the CFDictionary will do nothing to remove
    ///the dictionary's retain (if any) on the values when the
    ///dictionary is destroyed or a key-value pair is removed. If the
    ///copyDescription field is NULL, the dictionary will create a
    ///simple description for a value. If the equal field is NULL, the
    ///dictionary will use pointer equality to test for equality of
    ///values. This callbacks parameter itself may be NULL, which is
    ///treated as if a valid structure of version 0 with all fields
    ///NULL had been passed in. Otherwise,
    ///if any of the fields are not valid pointers to functions
    ///of the correct type, or this parameter is not a valid
    ///pointer to a CFDictionaryValueCallBacks callbacks structure,
    ///the behavior is undefined. If any of the values put into the
    ///dictionary is not one understood by one of the callback functions
    ///the behavior when that callback function is used is undefined.
    ///@result A reference to the new mutable CFDictionary.
    pub fn CFDictionaryCreateMutable(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        keyCallBacks: *const CFDictionaryKeyCallBacks,
        valueCallBacks: *const CFDictionaryValueCallBacks,
    ) -> CFMutableDictionaryRef;
}
extern "C" {
    ///@function CFDictionaryCreateMutableCopy
    ///Creates a new mutable dictionary with the key-value pairs from
    ///the given dictionary.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the dictionary and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param capacity A hint about the number of values that will be held
    ///by the CFDictionary. Pass 0 for no hint. The implementation may
    ///ignore this hint, or may use it to optimize various
    ///operations. A dictionary's actual capacity is only limited by
    ///address space and available memory constraints).
    ///This parameter must be greater than or equal
    ///to the count of the dictionary which is to be copied, or the
    ///behavior is undefined. If this parameter is negative, the
    ///behavior is undefined.
    ///@param theDict The dictionary which is to be copied. The keys and values
    ///from the dictionary are copied as pointers into the new
    ///dictionary (that is, the values themselves are copied, not
    ///that which the values point to, if anything). However, the
    ///keys and values are also retained by the new dictionary using
    ///the retain function of the original dictionary.
    ///The count of the new dictionary will be the same as the
    ///given dictionary. The new dictionary uses the same callbacks
    ///as the dictionary to be copied. If this parameter is
    ///not a valid CFDictionary, the behavior is undefined.
    ///@result A reference to the new mutable CFDictionary.
    pub fn CFDictionaryCreateMutableCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        theDict: CFDictionaryRef,
    ) -> CFMutableDictionaryRef;
}
extern "C" {
    ///@function CFDictionaryGetCount
    ///Returns the number of values currently in the dictionary.
    ///@param theDict The dictionary to be queried. If this parameter is
    ///not a valid CFDictionary, the behavior is undefined.
    ///@result The number of values in the dictionary.
    pub fn CFDictionaryGetCount(theDict: CFDictionaryRef) -> CFIndex;
}
extern "C" {
    ///@function CFDictionaryGetCountOfKey
    ///Counts the number of times the given key occurs in the dictionary.
    ///@param theDict The dictionary to be searched. If this parameter is
    ///not a valid CFDictionary, the behavior is undefined.
    ///@param key The key for which to find matches in the dictionary. The
    ///hash() and equal() key callbacks provided when the dictionary
    ///was created are used to compare. If the hash() key callback
    ///was NULL, the key is treated as a pointer and converted to
    ///an integer. If the equal() key callback was NULL, pointer
    ///equality (in C, ==) is used. If key, or any of the keys in
    ///the dictionary, are not understood by the equal() callback,
    ///the behavior is undefined.
    ///@result Returns 1 if a matching key is used by the dictionary,
    ///0 otherwise.
    pub fn CFDictionaryGetCountOfKey(
        theDict: CFDictionaryRef,
        key: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    ///@function CFDictionaryGetCountOfValue
    ///Counts the number of times the given value occurs in the dictionary.
    ///@param theDict The dictionary to be searched. If this parameter is
    ///not a valid CFDictionary, the behavior is undefined.
    ///@param value The value for which to find matches in the dictionary. The
    ///equal() callback provided when the dictionary was created is
    ///used to compare. If the equal() value callback was NULL, pointer
    ///equality (in C, ==) is used. If value, or any of the values in
    ///the dictionary, are not understood by the equal() callback,
    ///the behavior is undefined.
    ///@result The number of times the given value occurs in the dictionary.
    pub fn CFDictionaryGetCountOfValue(
        theDict: CFDictionaryRef,
        value: *const ::std::os::raw::c_void,
    ) -> CFIndex;
}
extern "C" {
    ///@function CFDictionaryContainsKey
    ///Reports whether or not the key is in the dictionary.
    ///@param theDict The dictionary to be searched. If this parameter is
    ///not a valid CFDictionary, the behavior is undefined.
    ///@param key The key for which to find matches in the dictionary. The
    ///hash() and equal() key callbacks provided when the dictionary
    ///was created are used to compare. If the hash() key callback
    ///was NULL, the key is treated as a pointer and converted to
    ///an integer. If the equal() key callback was NULL, pointer
    ///equality (in C, ==) is used. If key, or any of the keys in
    ///the dictionary, are not understood by the equal() callback,
    ///the behavior is undefined.
    ///@result true, if the key is in the dictionary, otherwise false.
    pub fn CFDictionaryContainsKey(
        theDict: CFDictionaryRef,
        key: *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    ///@function CFDictionaryContainsValue
    ///Reports whether or not the value is in the dictionary.
    ///@param theDict The dictionary to be searched. If this parameter is
    ///not a valid CFDictionary, the behavior is undefined.
    ///@param value The value for which to find matches in the dictionary. The
    ///equal() callback provided when the dictionary was created is
    ///used to compare. If the equal() callback was NULL, pointer
    ///equality (in C, ==) is used. If value, or any of the values
    ///in the dictionary, are not understood by the equal() callback,
    ///the behavior is undefined.
    ///@result true, if the value is in the dictionary, otherwise false.
    pub fn CFDictionaryContainsValue(
        theDict: CFDictionaryRef,
        value: *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    ///@function CFDictionaryGetValue
    ///Retrieves the value associated with the given key.
    ///@param theDict The dictionary to be queried. If this parameter is
    ///not a valid CFDictionary, the behavior is undefined.
    ///@param key The key for which to find a match in the dictionary. The
    ///hash() and equal() key callbacks provided when the dictionary
    ///was created are used to compare. If the hash() key callback
    ///was NULL, the key is treated as a pointer and converted to
    ///an integer. If the equal() key callback was NULL, pointer
    ///equality (in C, ==) is used. If key, or any of the keys in
    ///the dictionary, are not understood by the equal() callback,
    ///the behavior is undefined.
    ///@result The value with the given key in the dictionary, or NULL if
    ///no key-value pair with a matching key exists. Since NULL
    ///can be a valid value in some dictionaries, the function
    ///CFDictionaryGetValueIfPresent() must be used to distinguish
    ///NULL-no-found from NULL-is-the-value.
    pub fn CFDictionaryGetValue(
        theDict: CFDictionaryRef,
        key: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    ///@function CFDictionaryGetValueIfPresent
    ///Retrieves the value associated with the given key.
    ///@param theDict The dictionary to be queried. If this parameter is
    ///not a valid CFDictionary, the behavior is undefined.
    ///@param key The key for which to find a match in the dictionary. The
    ///hash() and equal() key callbacks provided when the dictionary
    ///was created are used to compare. If the hash() key callback
    ///was NULL, the key is treated as a pointer and converted to
    ///an integer. If the equal() key callback was NULL, pointer
    ///equality (in C, ==) is used. If key, or any of the keys in
    ///the dictionary, are not understood by the equal() callback,
    ///the behavior is undefined.
    ///@param value A pointer to memory which should be filled with the
    ///pointer-sized value if a matching key is found. If no key
    ///match is found, the contents of the storage pointed to by
    ///this parameter are undefined. This parameter may be NULL,
    ///in which case the value from the dictionary is not returned
    ///(but the return value of this function still indicates
    ///whether or not the key-value pair was present).
    ///@result true, if a matching key was found, false otherwise.
    pub fn CFDictionaryGetValueIfPresent(
        theDict: CFDictionaryRef,
        key: *const ::std::os::raw::c_void,
        value: *mut *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    ///@function CFDictionaryGetKeysAndValues
    ///Fills the two buffers with the keys and values from the dictionary.
    ///@param theDict The dictionary to be queried. If this parameter is
    ///not a valid CFDictionary, the behavior is undefined.
    ///@param keys A C array of pointer-sized values to be filled with keys
    ///from the dictionary. The keys and values C arrays are parallel
    ///to each other (that is, the items at the same indices form a
    ///key-value pair from the dictionary). This parameter may be NULL
    ///if the keys are not desired. If this parameter is not a valid
    ///pointer to a C array of at least CFDictionaryGetCount() pointers,
    ///or NULL, the behavior is undefined.
    ///@param values A C array of pointer-sized values to be filled with values
    ///from the dictionary. The keys and values C arrays are parallel
    ///to each other (that is, the items at the same indices form a
    ///key-value pair from the dictionary). This parameter may be NULL
    ///if the values are not desired. If this parameter is not a valid
    ///pointer to a C array of at least CFDictionaryGetCount() pointers,
    ///or NULL, the behavior is undefined.
    pub fn CFDictionaryGetKeysAndValues(
        theDict: CFDictionaryRef,
        keys: *mut *const ::std::os::raw::c_void,
        values: *mut *const ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFDictionaryApplyFunction
    ///Calls a function once for each value in the dictionary.
    ///@param theDict The dictionary to be queried. If this parameter is
    ///not a valid CFDictionary, the behavior is undefined.
    ///@param applier The callback function to call once for each value in
    ///the dictionary. If this parameter is not a
    ///pointer to a function of the correct prototype, the behavior
    ///is undefined. If there are keys or values which the
    ///applier function does not expect or cannot properly apply
    ///to, the behavior is undefined.
    ///@param context A pointer-sized user-defined value, which is passed
    ///as the third parameter to the applier function, but is
    ///otherwise unused by this function. If the context is not
    ///what is expected by the applier function, the behavior is
    ///undefined.
    pub fn CFDictionaryApplyFunction(
        theDict: CFDictionaryRef,
        applier: CFDictionaryApplierFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFDictionaryAddValue
    ///Adds the key-value pair to the dictionary if no such key already exists.
    ///@param theDict The dictionary to which the value is to be added. If this
    ///parameter is not a valid mutable CFDictionary, the behavior is
    ///undefined.
    ///@param key The key of the value to add to the dictionary. The key is
    ///retained by the dictionary using the retain callback provided
    ///when the dictionary was created. If the key is not of the sort
    ///expected by the retain callback, the behavior is undefined. If
    ///a key which matches this key is already present in the dictionary,
    ///this function does nothing ("add if absent").
    ///@param value The value to add to the dictionary. The value is retained
    ///by the dictionary using the retain callback provided when the
    ///dictionary was created. If the value is not of the sort expected
    ///by the retain callback, the behavior is undefined.
    pub fn CFDictionaryAddValue(
        theDict: CFMutableDictionaryRef,
        key: *const ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFDictionarySetValue
    ///Sets the value of the key in the dictionary.
    ///@param theDict The dictionary to which the value is to be set. If this
    ///parameter is not a valid mutable CFDictionary, the behavior is
    ///undefined.
    ///@param key The key of the value to set into the dictionary. If a key
    ///which matches this key is already present in the dictionary, only
    ///the value is changed ("add if absent, replace if present"). If
    ///no key matches the given key, the key-value pair is added to the
    ///dictionary. If added, the key is retained by the dictionary,
    ///using the retain callback provided
    ///when the dictionary was created. If the key is not of the sort
    ///expected by the key retain callback, the behavior is undefined.
    ///@param value The value to add to or replace into the dictionary. The value
    ///is retained by the dictionary using the retain callback provided
    ///when the dictionary was created, and the previous value if any is
    ///released. If the value is not of the sort expected by the
    ///retain or release callbacks, the behavior is undefined.
    pub fn CFDictionarySetValue(
        theDict: CFMutableDictionaryRef,
        key: *const ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFDictionaryReplaceValue
    ///Replaces the value of the key in the dictionary.
    ///@param theDict The dictionary to which the value is to be replaced. If this
    ///parameter is not a valid mutable CFDictionary, the behavior is
    ///undefined.
    ///@param key The key of the value to replace in the dictionary. If a key
    ///which matches this key is present in the dictionary, the value
    ///is changed to the given value, otherwise this function does
    ///nothing ("replace if present").
    ///@param value The value to replace into the dictionary. The value
    ///is retained by the dictionary using the retain callback provided
    ///when the dictionary was created, and the previous value is
    ///released. If the value is not of the sort expected by the
    ///retain or release callbacks, the behavior is undefined.
    pub fn CFDictionaryReplaceValue(
        theDict: CFMutableDictionaryRef,
        key: *const ::std::os::raw::c_void,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFDictionaryRemoveValue
    ///Removes the value of the key from the dictionary.
    ///@param theDict The dictionary from which the value is to be removed. If this
    ///parameter is not a valid mutable CFDictionary, the behavior is
    ///undefined.
    ///@param key The key of the value to remove from the dictionary. If a key
    ///which matches this key is present in the dictionary, the key-value
    ///pair is removed from the dictionary, otherwise this function does
    ///nothing ("remove if present").
    pub fn CFDictionaryRemoveValue(
        theDict: CFMutableDictionaryRef,
        key: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFDictionaryRemoveAllValues
    ///Removes all the values from the dictionary, making it empty.
    ///@param theDict The dictionary from which all of the values are to be
    ///removed. If this parameter is not a valid mutable
    ///CFDictionary, the behavior is undefined.
    pub fn CFDictionaryRemoveAllValues(theDict: CFMutableDictionaryRef);
}
pub type CFNotificationName = CFStringRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFNotificationCenter {
    _unused: [u8; 0],
}
pub type CFNotificationCenterRef = *mut __CFNotificationCenter;
pub type CFNotificationCallback = ::std::option::Option<
    unsafe extern "C" fn(
        center: CFNotificationCenterRef,
        observer: *mut ::std::os::raw::c_void,
        name: CFNotificationName,
        object: *const ::std::os::raw::c_void,
        userInfo: CFDictionaryRef,
    ),
>;
pub type CFNotificationSuspensionBehavior = CFIndex;
pub const CFNotificationSuspensionBehaviorDrop: _bindgen_ty_22 = 1;
pub const CFNotificationSuspensionBehaviorCoalesce: _bindgen_ty_22 = 2;
pub const CFNotificationSuspensionBehaviorHold: _bindgen_ty_22 = 3;
pub const CFNotificationSuspensionBehaviorDeliverImmediately: _bindgen_ty_22 = 4;
pub type _bindgen_ty_22 = u32;
extern "C" {
    pub fn CFNotificationCenterGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFNotificationCenterGetLocalCenter() -> CFNotificationCenterRef;
}
extern "C" {
    pub fn CFNotificationCenterGetDistributedCenter() -> CFNotificationCenterRef;
}
extern "C" {
    pub fn CFNotificationCenterGetDarwinNotifyCenter() -> CFNotificationCenterRef;
}
extern "C" {
    pub fn CFNotificationCenterAddObserver(
        center: CFNotificationCenterRef,
        observer: *const ::std::os::raw::c_void,
        callBack: CFNotificationCallback,
        name: CFStringRef,
        object: *const ::std::os::raw::c_void,
        suspensionBehavior: CFNotificationSuspensionBehavior,
    );
}
extern "C" {
    pub fn CFNotificationCenterRemoveObserver(
        center: CFNotificationCenterRef,
        observer: *const ::std::os::raw::c_void,
        name: CFNotificationName,
        object: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFNotificationCenterRemoveEveryObserver(
        center: CFNotificationCenterRef,
        observer: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFNotificationCenterPostNotification(
        center: CFNotificationCenterRef,
        name: CFNotificationName,
        object: *const ::std::os::raw::c_void,
        userInfo: CFDictionaryRef,
        deliverImmediately: Boolean,
    );
}
pub const kCFNotificationDeliverImmediately: _bindgen_ty_23 = 1;
pub const kCFNotificationPostToAllSessions: _bindgen_ty_23 = 2;
pub type _bindgen_ty_23 = u32;
extern "C" {
    pub fn CFNotificationCenterPostNotificationWithOptions(
        center: CFNotificationCenterRef,
        name: CFNotificationName,
        object: *const ::std::os::raw::c_void,
        userInfo: CFDictionaryRef,
        options: CFOptionFlags,
    );
}
pub type CFLocaleIdentifier = CFStringRef;
pub type CFLocaleKey = CFStringRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFLocale {
    _unused: [u8; 0],
}
pub type CFLocaleRef = *const __CFLocale;
extern "C" {
    pub fn CFLocaleGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFLocaleGetSystem() -> CFLocaleRef;
}
extern "C" {
    pub fn CFLocaleCopyCurrent() -> CFLocaleRef;
}
extern "C" {
    pub fn CFLocaleCopyAvailableLocaleIdentifiers() -> CFArrayRef;
}
extern "C" {
    pub fn CFLocaleCopyISOLanguageCodes() -> CFArrayRef;
}
extern "C" {
    pub fn CFLocaleCopyISOCountryCodes() -> CFArrayRef;
}
extern "C" {
    pub fn CFLocaleCopyISOCurrencyCodes() -> CFArrayRef;
}
extern "C" {
    pub fn CFLocaleCopyCommonISOCurrencyCodes() -> CFArrayRef;
}
extern "C" {
    pub fn CFLocaleCopyPreferredLanguages() -> CFArrayRef;
}
extern "C" {
    pub fn CFLocaleCreateCanonicalLanguageIdentifierFromString(
        allocator: CFAllocatorRef,
        localeIdentifier: CFStringRef,
    ) -> CFLocaleIdentifier;
}
extern "C" {
    pub fn CFLocaleCreateCanonicalLocaleIdentifierFromString(
        allocator: CFAllocatorRef,
        localeIdentifier: CFStringRef,
    ) -> CFLocaleIdentifier;
}
extern "C" {
    pub fn CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(
        allocator: CFAllocatorRef,
        lcode: LangCode,
        rcode: RegionCode,
    ) -> CFLocaleIdentifier;
}
extern "C" {
    pub fn CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode(
        allocator: CFAllocatorRef,
        lcid: u32,
    ) -> CFLocaleIdentifier;
}
extern "C" {
    pub fn CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier(
        localeIdentifier: CFLocaleIdentifier,
    ) -> u32;
}
pub type CFLocaleLanguageDirection = CFIndex;
pub const kCFLocaleLanguageDirectionUnknown: _bindgen_ty_24 = 0;
pub const kCFLocaleLanguageDirectionLeftToRight: _bindgen_ty_24 = 1;
pub const kCFLocaleLanguageDirectionRightToLeft: _bindgen_ty_24 = 2;
pub const kCFLocaleLanguageDirectionTopToBottom: _bindgen_ty_24 = 3;
pub const kCFLocaleLanguageDirectionBottomToTop: _bindgen_ty_24 = 4;
pub type _bindgen_ty_24 = u32;
extern "C" {
    pub fn CFLocaleGetLanguageCharacterDirection(
        isoLangCode: CFStringRef,
    ) -> CFLocaleLanguageDirection;
}
extern "C" {
    pub fn CFLocaleGetLanguageLineDirection(isoLangCode: CFStringRef) -> CFLocaleLanguageDirection;
}
extern "C" {
    pub fn CFLocaleCreateComponentsFromLocaleIdentifier(
        allocator: CFAllocatorRef,
        localeID: CFLocaleIdentifier,
    ) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFLocaleCreateLocaleIdentifierFromComponents(
        allocator: CFAllocatorRef,
        dictionary: CFDictionaryRef,
    ) -> CFLocaleIdentifier;
}
extern "C" {
    pub fn CFLocaleCreate(
        allocator: CFAllocatorRef,
        localeIdentifier: CFLocaleIdentifier,
    ) -> CFLocaleRef;
}
extern "C" {
    pub fn CFLocaleCreateCopy(allocator: CFAllocatorRef, locale: CFLocaleRef) -> CFLocaleRef;
}
extern "C" {
    pub fn CFLocaleGetIdentifier(locale: CFLocaleRef) -> CFLocaleIdentifier;
}
extern "C" {
    pub fn CFLocaleGetValue(locale: CFLocaleRef, key: CFLocaleKey) -> CFTypeRef;
}
extern "C" {
    pub fn CFLocaleCopyDisplayNameForPropertyValue(
        displayLocale: CFLocaleRef,
        key: CFLocaleKey,
        value: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub static kCFLocaleCurrentLocaleDidChangeNotification: CFNotificationName;
}
extern "C" {
    pub static kCFLocaleIdentifier: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleLanguageCode: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCountryCode: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleScriptCode: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleVariantCode: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleExemplarCharacterSet: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCalendarIdentifier: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCalendar: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCollationIdentifier: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleUsesMetricSystem: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleMeasurementSystem: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleDecimalSeparator: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleGroupingSeparator: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCurrencySymbol: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCurrencyCode: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleCollatorIdentifier: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleQuotationBeginDelimiterKey: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleQuotationEndDelimiterKey: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleAlternateQuotationBeginDelimiterKey: CFLocaleKey;
}
extern "C" {
    pub static kCFLocaleAlternateQuotationEndDelimiterKey: CFLocaleKey;
}
pub type CFCalendarIdentifier = CFStringRef;
extern "C" {
    pub static kCFGregorianCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFBuddhistCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFChineseCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFHebrewCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFIslamicCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFIslamicCivilCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFJapaneseCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFRepublicOfChinaCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFPersianCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFIndianCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFISO8601Calendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFIslamicTabularCalendar: CFCalendarIdentifier;
}
extern "C" {
    pub static kCFIslamicUmmAlQuraCalendar: CFCalendarIdentifier;
}
pub type CFTimeInterval = f64;
pub type CFAbsoluteTime = CFTimeInterval;
extern "C" {
    pub fn CFAbsoluteTimeGetCurrent() -> CFAbsoluteTime;
}
extern "C" {
    pub static kCFAbsoluteTimeIntervalSince1970: CFTimeInterval;
}
extern "C" {
    pub static kCFAbsoluteTimeIntervalSince1904: CFTimeInterval;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFDate {
    _unused: [u8; 0],
}
pub type CFDateRef = *const __CFDate;
extern "C" {
    pub fn CFDateGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFDateCreate(allocator: CFAllocatorRef, at: CFAbsoluteTime) -> CFDateRef;
}
extern "C" {
    pub fn CFDateGetAbsoluteTime(theDate: CFDateRef) -> CFAbsoluteTime;
}
extern "C" {
    pub fn CFDateGetTimeIntervalSinceDate(
        theDate: CFDateRef,
        otherDate: CFDateRef,
    ) -> CFTimeInterval;
}
extern "C" {
    pub fn CFDateCompare(
        theDate: CFDateRef,
        otherDate: CFDateRef,
        context: *mut ::std::os::raw::c_void,
    ) -> CFComparisonResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFTimeZone {
    _unused: [u8; 0],
}
pub type CFTimeZoneRef = *const __CFTimeZone;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CFGregorianDate {
    pub year: SInt32,
    pub month: SInt8,
    pub day: SInt8,
    pub hour: SInt8,
    pub minute: SInt8,
    pub second: f64,
}
#[test]
fn bindgen_test_layout_CFGregorianDate() {
    assert_eq!(
        ::std::mem::size_of::<CFGregorianDate>(),
        16usize,
        concat!("Size of: ", stringify!(CFGregorianDate))
    );
    assert_eq!(
        ::std::mem::align_of::<CFGregorianDate>(),
        8usize,
        concat!("Alignment of ", stringify!(CFGregorianDate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFGregorianDate>())).year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianDate),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFGregorianDate>())).month as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianDate),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFGregorianDate>())).day as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianDate),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFGregorianDate>())).hour as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianDate),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFGregorianDate>())).minute as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianDate),
            "::",
            stringify!(minute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFGregorianDate>())).second as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianDate),
            "::",
            stringify!(second)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CFGregorianUnits {
    pub years: SInt32,
    pub months: SInt32,
    pub days: SInt32,
    pub hours: SInt32,
    pub minutes: SInt32,
    pub seconds: f64,
}
#[test]
fn bindgen_test_layout_CFGregorianUnits() {
    assert_eq!(
        ::std::mem::size_of::<CFGregorianUnits>(),
        32usize,
        concat!("Size of: ", stringify!(CFGregorianUnits))
    );
    assert_eq!(
        ::std::mem::align_of::<CFGregorianUnits>(),
        8usize,
        concat!("Alignment of ", stringify!(CFGregorianUnits))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFGregorianUnits>())).years as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianUnits),
            "::",
            stringify!(years)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFGregorianUnits>())).months as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianUnits),
            "::",
            stringify!(months)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFGregorianUnits>())).days as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianUnits),
            "::",
            stringify!(days)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFGregorianUnits>())).hours as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianUnits),
            "::",
            stringify!(hours)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFGregorianUnits>())).minutes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianUnits),
            "::",
            stringify!(minutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFGregorianUnits>())).seconds as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFGregorianUnits),
            "::",
            stringify!(seconds)
        )
    );
}
pub type CFGregorianUnitFlags = CFOptionFlags;
pub const kCFGregorianUnitsYears: _bindgen_ty_25 = 1;
pub const kCFGregorianUnitsMonths: _bindgen_ty_25 = 2;
pub const kCFGregorianUnitsDays: _bindgen_ty_25 = 4;
pub const kCFGregorianUnitsHours: _bindgen_ty_25 = 8;
pub const kCFGregorianUnitsMinutes: _bindgen_ty_25 = 16;
pub const kCFGregorianUnitsSeconds: _bindgen_ty_25 = 32;
pub const kCFGregorianAllUnits: _bindgen_ty_25 = 16777215;
pub type _bindgen_ty_25 = u32;
extern "C" {
    pub fn CFGregorianDateIsValid(gdate: CFGregorianDate, unitFlags: CFOptionFlags) -> Boolean;
}
extern "C" {
    pub fn CFGregorianDateGetAbsoluteTime(
        gdate: CFGregorianDate,
        tz: CFTimeZoneRef,
    ) -> CFAbsoluteTime;
}
extern "C" {
    pub fn CFAbsoluteTimeGetGregorianDate(at: CFAbsoluteTime, tz: CFTimeZoneRef)
        -> CFGregorianDate;
}
extern "C" {
    pub fn CFAbsoluteTimeAddGregorianUnits(
        at: CFAbsoluteTime,
        tz: CFTimeZoneRef,
        units: CFGregorianUnits,
    ) -> CFAbsoluteTime;
}
extern "C" {
    pub fn CFAbsoluteTimeGetDifferenceAsGregorianUnits(
        at1: CFAbsoluteTime,
        at2: CFAbsoluteTime,
        tz: CFTimeZoneRef,
        unitFlags: CFOptionFlags,
    ) -> CFGregorianUnits;
}
extern "C" {
    pub fn CFAbsoluteTimeGetDayOfWeek(at: CFAbsoluteTime, tz: CFTimeZoneRef) -> SInt32;
}
extern "C" {
    pub fn CFAbsoluteTimeGetDayOfYear(at: CFAbsoluteTime, tz: CFTimeZoneRef) -> SInt32;
}
extern "C" {
    pub fn CFAbsoluteTimeGetWeekOfYear(at: CFAbsoluteTime, tz: CFTimeZoneRef) -> SInt32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFData {
    _unused: [u8; 0],
}
pub type CFDataRef = *const __CFData;
pub type CFMutableDataRef = *mut __CFData;
extern "C" {
    pub fn CFDataGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFDataCreate(
        allocator: CFAllocatorRef,
        bytes: *const UInt8,
        length: CFIndex,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFDataCreateWithBytesNoCopy(
        allocator: CFAllocatorRef,
        bytes: *const UInt8,
        length: CFIndex,
        bytesDeallocator: CFAllocatorRef,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFDataCreateCopy(allocator: CFAllocatorRef, theData: CFDataRef) -> CFDataRef;
}
extern "C" {
    pub fn CFDataCreateMutable(allocator: CFAllocatorRef, capacity: CFIndex) -> CFMutableDataRef;
}
extern "C" {
    pub fn CFDataCreateMutableCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        theData: CFDataRef,
    ) -> CFMutableDataRef;
}
extern "C" {
    pub fn CFDataGetLength(theData: CFDataRef) -> CFIndex;
}
extern "C" {
    pub fn CFDataGetBytePtr(theData: CFDataRef) -> *const UInt8;
}
extern "C" {
    pub fn CFDataGetMutableBytePtr(theData: CFMutableDataRef) -> *mut UInt8;
}
extern "C" {
    pub fn CFDataGetBytes(theData: CFDataRef, range: CFRange, buffer: *mut UInt8);
}
extern "C" {
    pub fn CFDataSetLength(theData: CFMutableDataRef, length: CFIndex);
}
extern "C" {
    pub fn CFDataIncreaseLength(theData: CFMutableDataRef, extraLength: CFIndex);
}
extern "C" {
    pub fn CFDataAppendBytes(theData: CFMutableDataRef, bytes: *const UInt8, length: CFIndex);
}
extern "C" {
    pub fn CFDataReplaceBytes(
        theData: CFMutableDataRef,
        range: CFRange,
        newBytes: *const UInt8,
        newLength: CFIndex,
    );
}
extern "C" {
    pub fn CFDataDeleteBytes(theData: CFMutableDataRef, range: CFRange);
}
pub type CFDataSearchFlags = CFOptionFlags;
pub const kCFDataSearchBackwards: _bindgen_ty_26 = 1;
pub const kCFDataSearchAnchored: _bindgen_ty_26 = 2;
pub type _bindgen_ty_26 = u32;
extern "C" {
    pub fn CFDataFind(
        theData: CFDataRef,
        dataToFind: CFDataRef,
        searchRange: CFRange,
        compareOptions: CFDataSearchFlags,
    ) -> CFRange;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFCharacterSet {
    _unused: [u8; 0],
}
///@typedef CFCharacterSetRef
///This is the type of a reference to immutable CFCharacterSets.
pub type CFCharacterSetRef = *const __CFCharacterSet;
///@typedef CFMutableCharacterSetRef
///This is the type of a reference to mutable CFMutableCharacterSets.
pub type CFMutableCharacterSetRef = *mut __CFCharacterSet;
///@typedef CFCharacterSetPredefinedSet
///Type of the predefined CFCharacterSet selector values.
pub type CFCharacterSetPredefinedSet = CFIndex;
pub const kCFCharacterSetControl: _bindgen_ty_27 = 1;
pub const kCFCharacterSetWhitespace: _bindgen_ty_27 = 2;
pub const kCFCharacterSetWhitespaceAndNewline: _bindgen_ty_27 = 3;
pub const kCFCharacterSetDecimalDigit: _bindgen_ty_27 = 4;
pub const kCFCharacterSetLetter: _bindgen_ty_27 = 5;
pub const kCFCharacterSetLowercaseLetter: _bindgen_ty_27 = 6;
pub const kCFCharacterSetUppercaseLetter: _bindgen_ty_27 = 7;
pub const kCFCharacterSetNonBase: _bindgen_ty_27 = 8;
pub const kCFCharacterSetDecomposable: _bindgen_ty_27 = 9;
pub const kCFCharacterSetAlphaNumeric: _bindgen_ty_27 = 10;
pub const kCFCharacterSetPunctuation: _bindgen_ty_27 = 11;
pub const kCFCharacterSetCapitalizedLetter: _bindgen_ty_27 = 13;
pub const kCFCharacterSetSymbol: _bindgen_ty_27 = 14;
pub const kCFCharacterSetNewline: _bindgen_ty_27 = 15;
pub const kCFCharacterSetIllegal: _bindgen_ty_27 = 12;
pub type _bindgen_ty_27 = u32;
extern "C" {
    ///@function CFCharacterSetGetTypeID
    ///Returns the type identifier of all CFCharacterSet instances.
    pub fn CFCharacterSetGetTypeID() -> CFTypeID;
}
extern "C" {
    ///@function CFCharacterSetGetPredefined
    ///Returns a predefined CFCharacterSet instance.
    ///@param theSetIdentifier The CFCharacterSetPredefinedSet selector
    ///which specifies the predefined character set.  If the
    ///value is not in CFCharacterSetPredefinedSet, the behavior
    ///is undefined.
    ///@result A reference to the predefined immutable CFCharacterSet.
    ///This instance is owned by CF.
    pub fn CFCharacterSetGetPredefined(
        theSetIdentifier: CFCharacterSetPredefinedSet,
    ) -> CFCharacterSetRef;
}
extern "C" {
    ///@function CFCharacterSetCreateWithCharactersInRange
    ///Creates a new immutable character set with the values from the given range.
    ///@param alloc The CFAllocator which should be used to allocate
    ///memory for the array and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param theRange The CFRange which should be used to specify the
    ///Unicode range the character set is filled with.  It
    ///accepts the range in 32-bit in the UTF-32 format.  The
    ///valid character point range is from 0x00000 to 0x10FFFF.
    ///If the range is outside of the valid Unicode character
    ///point, the behavior is undefined.
    ///@result A reference to the new immutable CFCharacterSet.
    pub fn CFCharacterSetCreateWithCharactersInRange(
        alloc: CFAllocatorRef,
        theRange: CFRange,
    ) -> CFCharacterSetRef;
}
extern "C" {
    ///@function CFCharacterSetCreateWithCharactersInString
    ///Creates a new immutable character set with the values in the given string.
    ///@param alloc The CFAllocator which should be used to allocate
    ///memory for the array and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param theString The CFString which should be used to specify
    ///the Unicode characters the character set is filled with.
    ///If this parameter is not a valid CFString, the behavior
    ///is undefined.
    ///@result A reference to the new immutable CFCharacterSet.
    pub fn CFCharacterSetCreateWithCharactersInString(
        alloc: CFAllocatorRef,
        theString: CFStringRef,
    ) -> CFCharacterSetRef;
}
extern "C" {
    ///@function CFCharacterSetCreateWithBitmapRepresentation
    ///Creates a new immutable character set with the bitmap representtion in the given data.
    ///@param alloc The CFAllocator which should be used to allocate
    ///memory for the array and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param theData The CFData which should be used to specify the
    ///bitmap representation of the Unicode character points
    ///the character set is filled with.  The bitmap
    ///representation could contain all the Unicode character
    ///range starting from BMP to Plane 16.  The first 8192 bytes
    ///of the data represent the BMP range.  The BMP range 8192
    ///bytes can be followed by zero to sixteen 8192 byte
    ///bitmaps, each one with the plane index byte prepended.
    ///For example, the bitmap representing the BMP and Plane 2
    ///has the size of 16385 bytes (8192 bytes for BMP, 1 byte
    ///index + 8192 bytes bitmap for Plane 2).  The plane index
    ///byte, in this case, contains the integer value two.  If
    ///this parameter is not a valid CFData or it contains a
    ///Plane index byte outside of the valid Plane range
    ///(1 to 16), the behavior is undefined.
    ///@result A reference to the new immutable CFCharacterSet.
    pub fn CFCharacterSetCreateWithBitmapRepresentation(
        alloc: CFAllocatorRef,
        theData: CFDataRef,
    ) -> CFCharacterSetRef;
}
extern "C" {
    ///@function CFCharacterSetCreateInvertedSet
    ///Creates a new immutable character set that is the invert of the specified character set.
    ///@param alloc The CFAllocator which should be used to allocate
    ///memory for the array and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param theSet The CFCharacterSet which is to be inverted.  If this
    ///parameter is not a valid CFCharacterSet, the behavior is
    ///undefined.
    ///@result A reference to the new immutable CFCharacterSet.
    pub fn CFCharacterSetCreateInvertedSet(
        alloc: CFAllocatorRef,
        theSet: CFCharacterSetRef,
    ) -> CFCharacterSetRef;
}
extern "C" {
    ///@function CFCharacterSetIsSupersetOfSet
    ///Reports whether or not the character set is a superset of the character set specified as the second parameter.
    ///@param theSet  The character set to be checked for the membership of theOtherSet.
    ///If this parameter is not a valid CFCharacterSet, the behavior is undefined.
    ///@param theOtherset  The character set to be checked whether or not it is a subset of theSet.
    ///If this parameter is not a valid CFCharacterSet, the behavior is undefined.
    pub fn CFCharacterSetIsSupersetOfSet(
        theSet: CFCharacterSetRef,
        theOtherset: CFCharacterSetRef,
    ) -> Boolean;
}
extern "C" {
    ///@function CFCharacterSetHasMemberInPlane
    ///Reports whether or not the character set contains at least one member character in the specified plane.
    ///@param theSet  The character set to be checked for the membership.  If this
    ///parameter is not a valid CFCharacterSet, the behavior is undefined.
    ///@param thePlane  The plane number to be checked for the membership.
    ///The valid value range is from 0 to 16.  If the value is outside of the valid
    ///plane number range, the behavior is undefined.
    pub fn CFCharacterSetHasMemberInPlane(theSet: CFCharacterSetRef, thePlane: CFIndex) -> Boolean;
}
extern "C" {
    ///@function CFCharacterSetCreateMutable
    ///Creates a new empty mutable character set.
    ///@param alloc The CFAllocator which should be used to allocate
    ///memory for the array and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@result A reference to the new mutable CFCharacterSet.
    pub fn CFCharacterSetCreateMutable(alloc: CFAllocatorRef) -> CFMutableCharacterSetRef;
}
extern "C" {
    ///@function CFCharacterSetCreateCopy
    ///Creates a new character set with the values from the given character set.  This function tries to compact the backing store where applicable.
    ///@param alloc The CFAllocator which should be used to allocate
    ///memory for the array and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param theSet The CFCharacterSet which is to be copied.  If this
    ///parameter is not a valid CFCharacterSet, the behavior is
    ///undefined.
    ///@result A reference to the new CFCharacterSet.
    pub fn CFCharacterSetCreateCopy(
        alloc: CFAllocatorRef,
        theSet: CFCharacterSetRef,
    ) -> CFCharacterSetRef;
}
extern "C" {
    ///@function CFCharacterSetCreateMutableCopy
    ///Creates a new mutable character set with the values from the given character set.
    ///@param alloc The CFAllocator which should be used to allocate
    ///memory for the array and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param theSet The CFCharacterSet which is to be copied.  If this
    ///parameter is not a valid CFCharacterSet, the behavior is
    ///undefined.
    ///@result A reference to the new mutable CFCharacterSet.
    pub fn CFCharacterSetCreateMutableCopy(
        alloc: CFAllocatorRef,
        theSet: CFCharacterSetRef,
    ) -> CFMutableCharacterSetRef;
}
extern "C" {
    ///@function CFCharacterSetIsCharacterMember
    ///Reports whether or not the Unicode character is in the character set.
    ///@param theSet The character set to be searched. If this parameter
    ///is not a valid CFCharacterSet, the behavior is undefined.
    ///@param theChar The Unicode character for which to test against the
    ///character set.  Note that this function takes 16-bit Unicode
    ///character value; hence, it does not support access to the
    ///non-BMP planes.
    ///@result true, if the value is in the character set, otherwise false.
    pub fn CFCharacterSetIsCharacterMember(theSet: CFCharacterSetRef, theChar: UniChar) -> Boolean;
}
extern "C" {
    ///@function CFCharacterSetIsLongCharacterMember
    ///Reports whether or not the UTF-32 character is in the character set.
    ///@param theSet The character set to be searched. If this parameter
    ///is not a valid CFCharacterSet, the behavior is undefined.
    ///@param theChar The UTF-32 character for which to test against the
    ///character set.
    ///@result true, if the value is in the character set, otherwise false.
    pub fn CFCharacterSetIsLongCharacterMember(
        theSet: CFCharacterSetRef,
        theChar: UTF32Char,
    ) -> Boolean;
}
extern "C" {
    ///@function CFCharacterSetCreateBitmapRepresentation
    ///Creates a new immutable data with the bitmap representation from the given character set.
    ///@param alloc The CFAllocator which should be used to allocate
    ///memory for the array and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param theSet The CFCharacterSet which is to be used create the
    ///bitmap representation from.  Refer to the comments for
    ///CFCharacterSetCreateWithBitmapRepresentation for the
    ///detailed discussion of the bitmap representation format.
    ///If this parameter is not a valid CFCharacterSet, the
    ///behavior is undefined.
    ///@result A reference to the new immutable CFData.
    pub fn CFCharacterSetCreateBitmapRepresentation(
        alloc: CFAllocatorRef,
        theSet: CFCharacterSetRef,
    ) -> CFDataRef;
}
extern "C" {
    ///@function CFCharacterSetAddCharactersInRange
    ///Adds the given range to the charaacter set.
    ///@param theSet The character set to which the range is to be added.
    ///If this parameter is not a valid mutable CFCharacterSet,
    ///the behavior is undefined.
    ///@param theRange The range to add to the character set.  It accepts
    ///the range in 32-bit in the UTF-32 format.  The valid
    ///character point range is from 0x00000 to 0x10FFFF.  If the
    ///range is outside of the valid Unicode character point,
    ///the behavior is undefined.
    pub fn CFCharacterSetAddCharactersInRange(theSet: CFMutableCharacterSetRef, theRange: CFRange);
}
extern "C" {
    ///@function CFCharacterSetRemoveCharactersInRange
    ///Removes the given range from the charaacter set.
    ///@param theSet The character set from which the range is to be
    ///removed.  If this parameter is not a valid mutable
    ///CFCharacterSet, the behavior is undefined.
    ///@param theRange The range to remove from the character set.
    ///It accepts the range in 32-bit in the UTF-32 format.
    ///The valid character point range is from 0x00000 to 0x10FFFF.
    ///If the range is outside of the valid Unicode character point,
    ///the behavior is undefined.
    pub fn CFCharacterSetRemoveCharactersInRange(
        theSet: CFMutableCharacterSetRef,
        theRange: CFRange,
    );
}
extern "C" {
    ///@function CFCharacterSetAddCharactersInString
    ///Adds the characters in the given string to the charaacter set.
    ///@param theSet The character set to which the characters in the
    ///string are to be added.  If this parameter is not a
    ///valid mutable CFCharacterSet, the behavior is undefined.
    ///@param theString The string to add to the character set.
    ///If this parameter is not a valid CFString, the behavior
    ///is undefined.
    pub fn CFCharacterSetAddCharactersInString(
        theSet: CFMutableCharacterSetRef,
        theString: CFStringRef,
    );
}
extern "C" {
    ///@function CFCharacterSetRemoveCharactersInString
    ///Removes the characters in the given string from the charaacter set.
    ///@param theSet The character set from which the characters in the
    ///string are to be remove.  If this parameter is not a
    ///valid mutable CFCharacterSet, the behavior is undefined.
    ///@param theString The string to remove from the character set.
    ///If this parameter is not a valid CFString, the behavior
    ///is undefined.
    pub fn CFCharacterSetRemoveCharactersInString(
        theSet: CFMutableCharacterSetRef,
        theString: CFStringRef,
    );
}
extern "C" {
    ///@function CFCharacterSetUnion
    ///Forms the union with the given character set.
    ///@param theSet The destination character set into which the
    ///union of the two character sets is stored.  If this
    ///parameter is not a valid mutable CFCharacterSet, the
    ///behavior is undefined.
    ///@param theOtherSet The character set with which the union is
    ///formed.  If this parameter is not a valid CFCharacterSet,
    ///the behavior is undefined.
    pub fn CFCharacterSetUnion(theSet: CFMutableCharacterSetRef, theOtherSet: CFCharacterSetRef);
}
extern "C" {
    ///@function CFCharacterSetIntersect
    ///Forms the intersection with the given character set.
    ///@param theSet The destination character set into which the
    ///intersection of the two character sets is stored.
    ///If this parameter is not a valid mutable CFCharacterSet,
    ///the behavior is undefined.
    ///@param theOtherSet The character set with which the intersection
    ///is formed.  If this parameter is not a valid CFCharacterSet,
    ///the behavior is undefined.
    pub fn CFCharacterSetIntersect(
        theSet: CFMutableCharacterSetRef,
        theOtherSet: CFCharacterSetRef,
    );
}
extern "C" {
    ///@function CFCharacterSetInvert
    ///Inverts the content of the given character set.
    ///@param theSet The character set to be inverted.
    ///If this parameter is not a valid mutable CFCharacterSet,
    ///the behavior is undefined.
    pub fn CFCharacterSetInvert(theSet: CFMutableCharacterSetRef);
}
pub type CFStringEncoding = UInt32;
pub type CFStringBuiltInEncodings = CFStringEncoding;
pub const kCFStringEncodingMacRoman: _bindgen_ty_28 = 0;
pub const kCFStringEncodingWindowsLatin1: _bindgen_ty_28 = 1280;
pub const kCFStringEncodingISOLatin1: _bindgen_ty_28 = 513;
pub const kCFStringEncodingNextStepLatin: _bindgen_ty_28 = 2817;
pub const kCFStringEncodingASCII: _bindgen_ty_28 = 1536;
pub const kCFStringEncodingUnicode: _bindgen_ty_28 = 256;
pub const kCFStringEncodingUTF8: _bindgen_ty_28 = 134217984;
pub const kCFStringEncodingNonLossyASCII: _bindgen_ty_28 = 3071;
pub const kCFStringEncodingUTF16: _bindgen_ty_28 = 256;
pub const kCFStringEncodingUTF16BE: _bindgen_ty_28 = 268435712;
pub const kCFStringEncodingUTF16LE: _bindgen_ty_28 = 335544576;
pub const kCFStringEncodingUTF32: _bindgen_ty_28 = 201326848;
pub const kCFStringEncodingUTF32BE: _bindgen_ty_28 = 402653440;
pub const kCFStringEncodingUTF32LE: _bindgen_ty_28 = 469762304;
pub type _bindgen_ty_28 = u32;
extern "C" {
    pub fn CFStringGetTypeID() -> CFTypeID;
}
extern "C" {
    /// Immutable string creation functions
    pub fn CFStringCreateWithPascalString(
        alloc: CFAllocatorRef,
        pStr: ConstStr255Param,
        encoding: CFStringEncoding,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithCString(
        alloc: CFAllocatorRef,
        cStr: *const ::std::os::raw::c_char,
        encoding: CFStringEncoding,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithBytes(
        alloc: CFAllocatorRef,
        bytes: *const UInt8,
        numBytes: CFIndex,
        encoding: CFStringEncoding,
        isExternalRepresentation: Boolean,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithCharacters(
        alloc: CFAllocatorRef,
        chars: *const UniChar,
        numChars: CFIndex,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithPascalStringNoCopy(
        alloc: CFAllocatorRef,
        pStr: ConstStr255Param,
        encoding: CFStringEncoding,
        contentsDeallocator: CFAllocatorRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithCStringNoCopy(
        alloc: CFAllocatorRef,
        cStr: *const ::std::os::raw::c_char,
        encoding: CFStringEncoding,
        contentsDeallocator: CFAllocatorRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithBytesNoCopy(
        alloc: CFAllocatorRef,
        bytes: *const UInt8,
        numBytes: CFIndex,
        encoding: CFStringEncoding,
        isExternalRepresentation: Boolean,
        contentsDeallocator: CFAllocatorRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithCharactersNoCopy(
        alloc: CFAllocatorRef,
        chars: *const UniChar,
        numChars: CFIndex,
        contentsDeallocator: CFAllocatorRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithSubstring(
        alloc: CFAllocatorRef,
        str: CFStringRef,
        range: CFRange,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateCopy(alloc: CFAllocatorRef, theString: CFStringRef) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithFormat(
        alloc: CFAllocatorRef,
        formatOptions: CFDictionaryRef,
        format: CFStringRef,
        ...
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateWithFormatAndArguments(
        alloc: CFAllocatorRef,
        formatOptions: CFDictionaryRef,
        format: CFStringRef,
        arguments: *mut __va_list_tag,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateMutable(alloc: CFAllocatorRef, maxLength: CFIndex) -> CFMutableStringRef;
}
extern "C" {
    pub fn CFStringCreateMutableCopy(
        alloc: CFAllocatorRef,
        maxLength: CFIndex,
        theString: CFStringRef,
    ) -> CFMutableStringRef;
}
extern "C" {
    pub fn CFStringCreateMutableWithExternalCharactersNoCopy(
        alloc: CFAllocatorRef,
        chars: *mut UniChar,
        numChars: CFIndex,
        capacity: CFIndex,
        externalCharactersAllocator: CFAllocatorRef,
    ) -> CFMutableStringRef;
}
extern "C" {
    /// Basic accessors for the contents
    pub fn CFStringGetLength(theString: CFStringRef) -> CFIndex;
}
extern "C" {
    pub fn CFStringGetCharacterAtIndex(theString: CFStringRef, idx: CFIndex) -> UniChar;
}
extern "C" {
    pub fn CFStringGetCharacters(theString: CFStringRef, range: CFRange, buffer: *mut UniChar);
}
extern "C" {
    pub fn CFStringGetPascalString(
        theString: CFStringRef,
        buffer: StringPtr,
        bufferSize: CFIndex,
        encoding: CFStringEncoding,
    ) -> Boolean;
}
extern "C" {
    pub fn CFStringGetCString(
        theString: CFStringRef,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: CFIndex,
        encoding: CFStringEncoding,
    ) -> Boolean;
}
extern "C" {
    pub fn CFStringGetPascalStringPtr(
        theString: CFStringRef,
        encoding: CFStringEncoding,
    ) -> ConstStringPtr;
}
extern "C" {
    pub fn CFStringGetCStringPtr(
        theString: CFStringRef,
        encoding: CFStringEncoding,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn CFStringGetCharactersPtr(theString: CFStringRef) -> *const UniChar;
}
extern "C" {
    pub fn CFStringGetBytes(
        theString: CFStringRef,
        range: CFRange,
        encoding: CFStringEncoding,
        lossByte: UInt8,
        isExternalRepresentation: Boolean,
        buffer: *mut UInt8,
        maxBufLen: CFIndex,
        usedBufLen: *mut CFIndex,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFStringCreateFromExternalRepresentation(
        alloc: CFAllocatorRef,
        data: CFDataRef,
        encoding: CFStringEncoding,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateExternalRepresentation(
        alloc: CFAllocatorRef,
        theString: CFStringRef,
        encoding: CFStringEncoding,
        lossByte: UInt8,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFStringGetSmallestEncoding(theString: CFStringRef) -> CFStringEncoding;
}
extern "C" {
    pub fn CFStringGetFastestEncoding(theString: CFStringRef) -> CFStringEncoding;
}
extern "C" {
    pub fn CFStringGetSystemEncoding() -> CFStringEncoding;
}
extern "C" {
    pub fn CFStringGetMaximumSizeForEncoding(
        length: CFIndex,
        encoding: CFStringEncoding,
    ) -> CFIndex;
}
extern "C" {
    /// FileSystem path conversion functions
    pub fn CFStringGetFileSystemRepresentation(
        string: CFStringRef,
        buffer: *mut ::std::os::raw::c_char,
        maxBufLen: CFIndex,
    ) -> Boolean;
}
extern "C" {
    pub fn CFStringGetMaximumSizeOfFileSystemRepresentation(string: CFStringRef) -> CFIndex;
}
extern "C" {
    pub fn CFStringCreateWithFileSystemRepresentation(
        alloc: CFAllocatorRef,
        buffer: *const ::std::os::raw::c_char,
    ) -> CFStringRef;
}
pub type CFStringCompareFlags = CFOptionFlags;
pub const kCFCompareCaseInsensitive: _bindgen_ty_29 = 1;
pub const kCFCompareBackwards: _bindgen_ty_29 = 4;
pub const kCFCompareAnchored: _bindgen_ty_29 = 8;
pub const kCFCompareNonliteral: _bindgen_ty_29 = 16;
pub const kCFCompareLocalized: _bindgen_ty_29 = 32;
pub const kCFCompareNumerically: _bindgen_ty_29 = 64;
pub const kCFCompareDiacriticInsensitive: _bindgen_ty_29 = 128;
pub const kCFCompareWidthInsensitive: _bindgen_ty_29 = 256;
pub const kCFCompareForcedOrdering: _bindgen_ty_29 = 512;
pub type _bindgen_ty_29 = u32;
extern "C" {
    pub fn CFStringCompareWithOptionsAndLocale(
        theString1: CFStringRef,
        theString2: CFStringRef,
        rangeToCompare: CFRange,
        compareOptions: CFStringCompareFlags,
        locale: CFLocaleRef,
    ) -> CFComparisonResult;
}
extern "C" {
    pub fn CFStringCompareWithOptions(
        theString1: CFStringRef,
        theString2: CFStringRef,
        rangeToCompare: CFRange,
        compareOptions: CFStringCompareFlags,
    ) -> CFComparisonResult;
}
extern "C" {
    pub fn CFStringCompare(
        theString1: CFStringRef,
        theString2: CFStringRef,
        compareOptions: CFStringCompareFlags,
    ) -> CFComparisonResult;
}
extern "C" {
    pub fn CFStringFindWithOptionsAndLocale(
        theString: CFStringRef,
        stringToFind: CFStringRef,
        rangeToSearch: CFRange,
        searchOptions: CFStringCompareFlags,
        locale: CFLocaleRef,
        result: *mut CFRange,
    ) -> Boolean;
}
extern "C" {
    pub fn CFStringFindWithOptions(
        theString: CFStringRef,
        stringToFind: CFStringRef,
        rangeToSearch: CFRange,
        searchOptions: CFStringCompareFlags,
        result: *mut CFRange,
    ) -> Boolean;
}
extern "C" {
    pub fn CFStringCreateArrayWithFindResults(
        alloc: CFAllocatorRef,
        theString: CFStringRef,
        stringToFind: CFStringRef,
        rangeToSearch: CFRange,
        compareOptions: CFStringCompareFlags,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFStringFind(
        theString: CFStringRef,
        stringToFind: CFStringRef,
        compareOptions: CFStringCompareFlags,
    ) -> CFRange;
}
extern "C" {
    pub fn CFStringHasPrefix(theString: CFStringRef, prefix: CFStringRef) -> Boolean;
}
extern "C" {
    pub fn CFStringHasSuffix(theString: CFStringRef, suffix: CFStringRef) -> Boolean;
}
extern "C" {
    ///@function CFStringGetRangeOfComposedCharactersAtIndex
    ///Returns the range of the composed character sequence at the specified index.
    ///@param theString The CFString which is to be searched.  If this
    ///parameter is not a valid CFString, the behavior is
    ///undefined.
    ///@param theIndex The index of the character contained in the
    ///composed character sequence.  If the index is
    ///outside the index space of the string (0 to N-1 inclusive,
    ///where N is the length of the string), the behavior is
    ///undefined.
    ///@result The range of the composed character sequence.
    pub fn CFStringGetRangeOfComposedCharactersAtIndex(
        theString: CFStringRef,
        theIndex: CFIndex,
    ) -> CFRange;
}
extern "C" {
    ///@function CFStringFindCharacterFromSet
    ///Query the range of the first character contained in the specified character set.
    ///@param theString The CFString which is to be searched.  If this
    ///parameter is not a valid CFString, the behavior is
    ///undefined.
    ///@param theSet The CFCharacterSet against which the membership
    ///of characters is checked.  If this parameter is not a valid
    ///CFCharacterSet, the behavior is undefined.
    ///@param rangeToSearch The range of characters within the string to search. If
    ///the range location or end point (defined by the location
    ///plus length minus 1) are outside the index space of the
    ///string (0 to N-1 inclusive, where N is the length of the
    ///string), the behavior is undefined. If the range length is
    ///negative, the behavior is undefined. The range may be empty
    ///(length 0), in which case no search is performed.
    ///@param searchOptions The bitwise-or'ed option flags to control
    ///the search behavior.  The supported options are
    ///kCFCompareBackwards andkCFCompareAnchored.
    ///If other option flags are specified, the behavior
    ///is undefined.
    ///@param result The pointer to a CFRange supplied by the caller in
    ///which the search result is stored.  Note that the length
    ///of this range can be more than 1, if for instance the
    ///result is a composed character. If a pointer to an invalid
    ///memory is specified, the behavior is undefined.
    ///@result true, if at least a character which is a member of the character
    ///set is found and result is filled, otherwise, false.
    pub fn CFStringFindCharacterFromSet(
        theString: CFStringRef,
        theSet: CFCharacterSetRef,
        rangeToSearch: CFRange,
        searchOptions: CFStringCompareFlags,
        result: *mut CFRange,
    ) -> Boolean;
}
extern "C" {
    pub fn CFStringGetLineBounds(
        theString: CFStringRef,
        range: CFRange,
        lineBeginIndex: *mut CFIndex,
        lineEndIndex: *mut CFIndex,
        contentsEndIndex: *mut CFIndex,
    );
}
extern "C" {
    pub fn CFStringGetParagraphBounds(
        string: CFStringRef,
        range: CFRange,
        parBeginIndex: *mut CFIndex,
        parEndIndex: *mut CFIndex,
        contentsEndIndex: *mut CFIndex,
    );
}
extern "C" {
    ///@function CFStringGetHyphenationLocationBeforeIndex
    ///Retrieve the first potential hyphenation location found before the specified location.
    ///@param string The CFString which is to be hyphenated.  If this
    ///parameter is not a valid CFString, the behavior is
    ///undefined.
    ///@param location An index in the string.  If a valid hyphen index is returned, it
    ///will be before this index.
    ///@param limitRange The range of characters within the string to search. If
    ///the range location or end point (defined by the location
    ///plus length minus 1) are outside the index space of the
    ///string (0 to N-1 inclusive, where N is the length of the
    ///string), the behavior is undefined. If the range length is
    ///negative, the behavior is undefined. The range may be empty
    ///(length 0), in which case no hyphen location is generated.
    ///@param options Reserved for future use.
    ///@param locale Specifies which language's hyphenation conventions to use.
    ///This must be a valid locale.  Hyphenation data is not available
    ///for all locales.  You can use CFStringIsHyphenationAvailableForLocale
    ///to test for availability of hyphenation data.
    ///@param character The suggested hyphen character to insert.  Pass NULL if you
    ///do not need this information.
    ///@result an index in the string where it is appropriate to insert a hyphen, if
    ///one exists; else kCFNotFound
    pub fn CFStringGetHyphenationLocationBeforeIndex(
        string: CFStringRef,
        location: CFIndex,
        limitRange: CFRange,
        options: CFOptionFlags,
        locale: CFLocaleRef,
        character: *mut UTF32Char,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFStringIsHyphenationAvailableForLocale(locale: CFLocaleRef) -> Boolean;
}
extern "C" {
    /// Exploding and joining strings with a separator string
    pub fn CFStringCreateByCombiningStrings(
        alloc: CFAllocatorRef,
        theArray: CFArrayRef,
        separatorString: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFStringCreateArrayBySeparatingStrings(
        alloc: CFAllocatorRef,
        theString: CFStringRef,
        separatorString: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    /// Parsing non-localized numbers from strings
    pub fn CFStringGetIntValue(str: CFStringRef) -> SInt32;
}
extern "C" {
    pub fn CFStringGetDoubleValue(str: CFStringRef) -> f64;
}
extern "C" {
    /// MutableString functions
    pub fn CFStringAppend(theString: CFMutableStringRef, appendedString: CFStringRef);
}
extern "C" {
    pub fn CFStringAppendCharacters(
        theString: CFMutableStringRef,
        chars: *const UniChar,
        numChars: CFIndex,
    );
}
extern "C" {
    pub fn CFStringAppendPascalString(
        theString: CFMutableStringRef,
        pStr: ConstStr255Param,
        encoding: CFStringEncoding,
    );
}
extern "C" {
    pub fn CFStringAppendCString(
        theString: CFMutableStringRef,
        cStr: *const ::std::os::raw::c_char,
        encoding: CFStringEncoding,
    );
}
extern "C" {
    pub fn CFStringAppendFormat(
        theString: CFMutableStringRef,
        formatOptions: CFDictionaryRef,
        format: CFStringRef,
        ...
    );
}
extern "C" {
    pub fn CFStringAppendFormatAndArguments(
        theString: CFMutableStringRef,
        formatOptions: CFDictionaryRef,
        format: CFStringRef,
        arguments: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn CFStringInsert(str: CFMutableStringRef, idx: CFIndex, insertedStr: CFStringRef);
}
extern "C" {
    pub fn CFStringDelete(theString: CFMutableStringRef, range: CFRange);
}
extern "C" {
    pub fn CFStringReplace(theString: CFMutableStringRef, range: CFRange, replacement: CFStringRef);
}
extern "C" {
    pub fn CFStringReplaceAll(theString: CFMutableStringRef, replacement: CFStringRef);
}
extern "C" {
    pub fn CFStringFindAndReplace(
        theString: CFMutableStringRef,
        stringToFind: CFStringRef,
        replacementString: CFStringRef,
        rangeToSearch: CFRange,
        compareOptions: CFStringCompareFlags,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFStringSetExternalCharactersNoCopy(
        theString: CFMutableStringRef,
        chars: *mut UniChar,
        length: CFIndex,
        capacity: CFIndex,
    );
}
extern "C" {
    pub fn CFStringPad(
        theString: CFMutableStringRef,
        padString: CFStringRef,
        length: CFIndex,
        indexIntoPad: CFIndex,
    );
}
extern "C" {
    pub fn CFStringTrim(theString: CFMutableStringRef, trimString: CFStringRef);
}
extern "C" {
    pub fn CFStringTrimWhitespace(theString: CFMutableStringRef);
}
extern "C" {
    pub fn CFStringLowercase(theString: CFMutableStringRef, locale: CFLocaleRef);
}
extern "C" {
    pub fn CFStringUppercase(theString: CFMutableStringRef, locale: CFLocaleRef);
}
extern "C" {
    pub fn CFStringCapitalize(theString: CFMutableStringRef, locale: CFLocaleRef);
}
///@typedef CFStringNormalizationForm
///This is the type of Unicode normalization forms as described in
///Unicode Technical Report #15. To normalize for use with file
///system calls, use CFStringGetFileSystemRepresentation().
pub type CFStringNormalizationForm = CFIndex;
pub const kCFStringNormalizationFormD: _bindgen_ty_30 = 0;
pub const kCFStringNormalizationFormKD: _bindgen_ty_30 = 1;
pub const kCFStringNormalizationFormC: _bindgen_ty_30 = 2;
pub const kCFStringNormalizationFormKC: _bindgen_ty_30 = 3;
pub type _bindgen_ty_30 = u32;
extern "C" {
    ///@function CFStringNormalize
    ///Normalizes the string into the specified form as described in
    ///Unicode Technical Report #15.
    ///@param theString  The string which is to be normalized.  If this
    ///parameter is not a valid mutable CFString, the behavior is
    ///undefined.
    ///@param theForm  The form into which the string is to be normalized.
    ///If this parameter is not a valid CFStringNormalizationForm value,
    ///the behavior is undefined.
    pub fn CFStringNormalize(theString: CFMutableStringRef, theForm: CFStringNormalizationForm);
}
extern "C" {
    ///@function CFStringFold
    ///Folds the string into the form specified by the flags.
    ///Character foldings are operations that convert any of a set of characters
    ///sharing similar semantics into a single representative from that set.
    ///This function can be used to preprocess strings that are to be compared,
    ///searched, or indexed.
    ///Note that folding does not include normalization, so it is necessary
    ///to use CFStringNormalize in addition to CFStringFold in order to obtain
    ///the effect of kCFCompareNonliteral.
    ///@param theString  The string which is to be folded.  If this parameter is not
    ///a valid mutable CFString, the behavior is undefined.
    ///@param theFlags  The equivalency flags which describes the character folding form.
    ///Only those flags containing the word "insensitive" are recognized here; other flags are ignored.
    ///Folding with kCFCompareCaseInsensitive removes case distinctions in accordance with the mapping
    ///specified by ftp://ftp.unicode.org/Public/UNIDATA/CaseFolding.txt.  Folding with
    ///kCFCompareDiacriticInsensitive removes distinctions of accents and other diacritics.  Folding
    ///with kCFCompareWidthInsensitive removes character width distinctions by mapping characters in
    ///the range U+FF00-U+FFEF to their ordinary equivalents.
    ///@param theLocale The locale tailoring the character folding behavior. If NULL,
    ///it's considered to be the system locale returned from CFLocaleGetSystem().
    ///If non-NULL and not a valid CFLocale object, the behavior is undefined.
    pub fn CFStringFold(
        theString: CFMutableStringRef,
        theFlags: CFStringCompareFlags,
        theLocale: CFLocaleRef,
    );
}
extern "C" {
    pub fn CFStringTransform(
        string: CFMutableStringRef,
        range: *mut CFRange,
        transform: CFStringRef,
        reverse: Boolean,
    ) -> Boolean;
}
extern "C" {
    pub static kCFStringTransformStripCombiningMarks: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformToLatin: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformFullwidthHalfwidth: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinKatakana: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinHiragana: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformHiraganaKatakana: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformMandarinLatin: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinHangul: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinArabic: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinHebrew: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinThai: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinCyrillic: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformLatinGreek: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformToXMLHex: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformToUnicodeName: CFStringRef;
}
extern "C" {
    pub static kCFStringTransformStripDiacritics: CFStringRef;
}
extern "C" {
    /// General encoding related functionality
    pub fn CFStringIsEncodingAvailable(encoding: CFStringEncoding) -> Boolean;
}
extern "C" {
    pub fn CFStringGetListOfAvailableEncodings() -> *const CFStringEncoding;
}
extern "C" {
    pub fn CFStringGetNameOfEncoding(encoding: CFStringEncoding) -> CFStringRef;
}
extern "C" {
    pub fn CFStringConvertEncodingToNSStringEncoding(
        encoding: CFStringEncoding,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn CFStringConvertNSStringEncodingToEncoding(
        encoding: ::std::os::raw::c_ulong,
    ) -> CFStringEncoding;
}
extern "C" {
    pub fn CFStringConvertEncodingToWindowsCodepage(encoding: CFStringEncoding) -> UInt32;
}
extern "C" {
    pub fn CFStringConvertWindowsCodepageToEncoding(codepage: UInt32) -> CFStringEncoding;
}
extern "C" {
    pub fn CFStringConvertIANACharSetNameToEncoding(theString: CFStringRef) -> CFStringEncoding;
}
extern "C" {
    pub fn CFStringConvertEncodingToIANACharSetName(encoding: CFStringEncoding) -> CFStringRef;
}
extern "C" {
    pub fn CFStringGetMostCompatibleMacStringEncoding(
        encoding: CFStringEncoding,
    ) -> CFStringEncoding;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CFStringInlineBuffer {
    pub buffer: [UniChar; 64usize],
    pub theString: CFStringRef,
    pub directUniCharBuffer: *const UniChar,
    pub directCStringBuffer: *const ::std::os::raw::c_char,
    pub rangeToBuffer: CFRange,
    pub bufferedRangeStart: CFIndex,
    pub bufferedRangeEnd: CFIndex,
}
#[test]
fn bindgen_test_layout_CFStringInlineBuffer() {
    assert_eq!(
        ::std::mem::size_of::<CFStringInlineBuffer>(),
        184usize,
        concat!("Size of: ", stringify!(CFStringInlineBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<CFStringInlineBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(CFStringInlineBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFStringInlineBuffer>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFStringInlineBuffer>())).theString as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(theString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFStringInlineBuffer>())).directUniCharBuffer as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(directUniCharBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFStringInlineBuffer>())).directCStringBuffer as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(directCStringBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFStringInlineBuffer>())).rangeToBuffer as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(rangeToBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFStringInlineBuffer>())).bufferedRangeStart as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(bufferedRangeStart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFStringInlineBuffer>())).bufferedRangeEnd as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStringInlineBuffer),
            "::",
            stringify!(bufferedRangeEnd)
        )
    );
}
impl Default for CFStringInlineBuffer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn CFShow(obj: CFTypeRef);
}
extern "C" {
    pub fn CFShowStr(str: CFStringRef);
}
extern "C" {
    pub fn __CFStringMakeConstantString(cStr: *const ::std::os::raw::c_char) -> CFStringRef;
}
extern "C" {
    pub fn CFTimeZoneGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFTimeZoneCopySystem() -> CFTimeZoneRef;
}
extern "C" {
    pub fn CFTimeZoneResetSystem();
}
extern "C" {
    pub fn CFTimeZoneCopyDefault() -> CFTimeZoneRef;
}
extern "C" {
    pub fn CFTimeZoneSetDefault(tz: CFTimeZoneRef);
}
extern "C" {
    pub fn CFTimeZoneCopyKnownNames() -> CFArrayRef;
}
extern "C" {
    pub fn CFTimeZoneCopyAbbreviationDictionary() -> CFDictionaryRef;
}
extern "C" {
    pub fn CFTimeZoneSetAbbreviationDictionary(dict: CFDictionaryRef);
}
extern "C" {
    pub fn CFTimeZoneCreate(
        allocator: CFAllocatorRef,
        name: CFStringRef,
        data: CFDataRef,
    ) -> CFTimeZoneRef;
}
extern "C" {
    pub fn CFTimeZoneCreateWithTimeIntervalFromGMT(
        allocator: CFAllocatorRef,
        ti: CFTimeInterval,
    ) -> CFTimeZoneRef;
}
extern "C" {
    pub fn CFTimeZoneCreateWithName(
        allocator: CFAllocatorRef,
        name: CFStringRef,
        tryAbbrev: Boolean,
    ) -> CFTimeZoneRef;
}
extern "C" {
    pub fn CFTimeZoneGetName(tz: CFTimeZoneRef) -> CFStringRef;
}
extern "C" {
    pub fn CFTimeZoneGetData(tz: CFTimeZoneRef) -> CFDataRef;
}
extern "C" {
    pub fn CFTimeZoneGetSecondsFromGMT(tz: CFTimeZoneRef, at: CFAbsoluteTime) -> CFTimeInterval;
}
extern "C" {
    pub fn CFTimeZoneCopyAbbreviation(tz: CFTimeZoneRef, at: CFAbsoluteTime) -> CFStringRef;
}
extern "C" {
    pub fn CFTimeZoneIsDaylightSavingTime(tz: CFTimeZoneRef, at: CFAbsoluteTime) -> Boolean;
}
extern "C" {
    pub fn CFTimeZoneGetDaylightSavingTimeOffset(
        tz: CFTimeZoneRef,
        at: CFAbsoluteTime,
    ) -> CFTimeInterval;
}
extern "C" {
    pub fn CFTimeZoneGetNextDaylightSavingTimeTransition(
        tz: CFTimeZoneRef,
        at: CFAbsoluteTime,
    ) -> CFAbsoluteTime;
}
pub type CFTimeZoneNameStyle = CFIndex;
pub const kCFTimeZoneNameStyleStandard: _bindgen_ty_31 = 0;
pub const kCFTimeZoneNameStyleShortStandard: _bindgen_ty_31 = 1;
pub const kCFTimeZoneNameStyleDaylightSaving: _bindgen_ty_31 = 2;
pub const kCFTimeZoneNameStyleShortDaylightSaving: _bindgen_ty_31 = 3;
pub const kCFTimeZoneNameStyleGeneric: _bindgen_ty_31 = 4;
pub const kCFTimeZoneNameStyleShortGeneric: _bindgen_ty_31 = 5;
pub type _bindgen_ty_31 = u32;
extern "C" {
    pub fn CFTimeZoneCopyLocalizedName(
        tz: CFTimeZoneRef,
        style: CFTimeZoneNameStyle,
        locale: CFLocaleRef,
    ) -> CFStringRef;
}
extern "C" {
    pub static kCFTimeZoneSystemTimeZoneDidChangeNotification: CFNotificationName;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFCalendar {
    _unused: [u8; 0],
}
pub type CFCalendarRef = *mut __CFCalendar;
extern "C" {
    pub fn CFCalendarGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFCalendarCopyCurrent() -> CFCalendarRef;
}
extern "C" {
    pub fn CFCalendarCreateWithIdentifier(
        allocator: CFAllocatorRef,
        identifier: CFCalendarIdentifier,
    ) -> CFCalendarRef;
}
extern "C" {
    pub fn CFCalendarGetIdentifier(calendar: CFCalendarRef) -> CFCalendarIdentifier;
}
extern "C" {
    pub fn CFCalendarCopyLocale(calendar: CFCalendarRef) -> CFLocaleRef;
}
extern "C" {
    pub fn CFCalendarSetLocale(calendar: CFCalendarRef, locale: CFLocaleRef);
}
extern "C" {
    pub fn CFCalendarCopyTimeZone(calendar: CFCalendarRef) -> CFTimeZoneRef;
}
extern "C" {
    pub fn CFCalendarSetTimeZone(calendar: CFCalendarRef, tz: CFTimeZoneRef);
}
extern "C" {
    pub fn CFCalendarGetFirstWeekday(calendar: CFCalendarRef) -> CFIndex;
}
extern "C" {
    pub fn CFCalendarSetFirstWeekday(calendar: CFCalendarRef, wkdy: CFIndex);
}
extern "C" {
    pub fn CFCalendarGetMinimumDaysInFirstWeek(calendar: CFCalendarRef) -> CFIndex;
}
extern "C" {
    pub fn CFCalendarSetMinimumDaysInFirstWeek(calendar: CFCalendarRef, mwd: CFIndex);
}
pub type CFCalendarUnit = CFOptionFlags;
pub const kCFCalendarUnitEra: _bindgen_ty_32 = 2;
pub const kCFCalendarUnitYear: _bindgen_ty_32 = 4;
pub const kCFCalendarUnitMonth: _bindgen_ty_32 = 8;
pub const kCFCalendarUnitDay: _bindgen_ty_32 = 16;
pub const kCFCalendarUnitHour: _bindgen_ty_32 = 32;
pub const kCFCalendarUnitMinute: _bindgen_ty_32 = 64;
pub const kCFCalendarUnitSecond: _bindgen_ty_32 = 128;
pub const kCFCalendarUnitWeek: _bindgen_ty_32 = 256;
pub const kCFCalendarUnitWeekday: _bindgen_ty_32 = 512;
pub const kCFCalendarUnitWeekdayOrdinal: _bindgen_ty_32 = 1024;
pub const kCFCalendarUnitQuarter: _bindgen_ty_32 = 2048;
pub const kCFCalendarUnitWeekOfMonth: _bindgen_ty_32 = 4096;
pub const kCFCalendarUnitWeekOfYear: _bindgen_ty_32 = 8192;
pub const kCFCalendarUnitYearForWeekOfYear: _bindgen_ty_32 = 16384;
pub type _bindgen_ty_32 = u32;
extern "C" {
    pub fn CFCalendarGetMinimumRangeOfUnit(
        calendar: CFCalendarRef,
        unit: CFCalendarUnit,
    ) -> CFRange;
}
extern "C" {
    pub fn CFCalendarGetMaximumRangeOfUnit(
        calendar: CFCalendarRef,
        unit: CFCalendarUnit,
    ) -> CFRange;
}
extern "C" {
    pub fn CFCalendarGetRangeOfUnit(
        calendar: CFCalendarRef,
        smallerUnit: CFCalendarUnit,
        biggerUnit: CFCalendarUnit,
        at: CFAbsoluteTime,
    ) -> CFRange;
}
extern "C" {
    pub fn CFCalendarGetOrdinalityOfUnit(
        calendar: CFCalendarRef,
        smallerUnit: CFCalendarUnit,
        biggerUnit: CFCalendarUnit,
        at: CFAbsoluteTime,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFCalendarGetTimeRangeOfUnit(
        calendar: CFCalendarRef,
        unit: CFCalendarUnit,
        at: CFAbsoluteTime,
        startp: *mut CFAbsoluteTime,
        tip: *mut CFTimeInterval,
    ) -> Boolean;
}
extern "C" {
    pub fn CFCalendarComposeAbsoluteTime(
        calendar: CFCalendarRef,
        at: *mut CFAbsoluteTime,
        componentDesc: *const ::std::os::raw::c_char,
        ...
    ) -> Boolean;
}
extern "C" {
    pub fn CFCalendarDecomposeAbsoluteTime(
        calendar: CFCalendarRef,
        at: CFAbsoluteTime,
        componentDesc: *const ::std::os::raw::c_char,
        ...
    ) -> Boolean;
}
pub const kCFCalendarComponentsWrap: _bindgen_ty_33 = 1;
pub type _bindgen_ty_33 = u32;
extern "C" {
    pub fn CFCalendarAddComponents(
        calendar: CFCalendarRef,
        at: *mut CFAbsoluteTime,
        options: CFOptionFlags,
        componentDesc: *const ::std::os::raw::c_char,
        ...
    ) -> Boolean;
}
extern "C" {
    pub fn CFCalendarGetComponentDifference(
        calendar: CFCalendarRef,
        startingAT: CFAbsoluteTime,
        resultAT: CFAbsoluteTime,
        options: CFOptionFlags,
        componentDesc: *const ::std::os::raw::c_char,
        ...
    ) -> Boolean;
}
pub type CFDateFormatterKey = CFStringRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFDateFormatter {
    _unused: [u8; 0],
}
pub type CFDateFormatterRef = *mut __CFDateFormatter;
extern "C" {
    pub fn CFDateFormatterCreateDateFormatFromTemplate(
        allocator: CFAllocatorRef,
        tmplate: CFStringRef,
        options: CFOptionFlags,
        locale: CFLocaleRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFDateFormatterGetTypeID() -> CFTypeID;
}
pub type CFDateFormatterStyle = CFIndex;
pub const kCFDateFormatterNoStyle: _bindgen_ty_34 = 0;
pub const kCFDateFormatterShortStyle: _bindgen_ty_34 = 1;
pub const kCFDateFormatterMediumStyle: _bindgen_ty_34 = 2;
pub const kCFDateFormatterLongStyle: _bindgen_ty_34 = 3;
pub const kCFDateFormatterFullStyle: _bindgen_ty_34 = 4;
pub type _bindgen_ty_34 = u32;
pub type CFISO8601DateFormatOptions = CFOptionFlags;
pub const kCFISO8601DateFormatWithYear: _bindgen_ty_35 = 1;
pub const kCFISO8601DateFormatWithMonth: _bindgen_ty_35 = 2;
pub const kCFISO8601DateFormatWithWeekOfYear: _bindgen_ty_35 = 4;
pub const kCFISO8601DateFormatWithDay: _bindgen_ty_35 = 16;
pub const kCFISO8601DateFormatWithTime: _bindgen_ty_35 = 32;
pub const kCFISO8601DateFormatWithTimeZone: _bindgen_ty_35 = 64;
pub const kCFISO8601DateFormatWithSpaceBetweenDateAndTime: _bindgen_ty_35 = 128;
pub const kCFISO8601DateFormatWithDashSeparatorInDate: _bindgen_ty_35 = 256;
pub const kCFISO8601DateFormatWithColonSeparatorInTime: _bindgen_ty_35 = 512;
pub const kCFISO8601DateFormatWithColonSeparatorInTimeZone: _bindgen_ty_35 = 1024;
pub const kCFISO8601DateFormatWithFractionalSeconds: _bindgen_ty_35 = 2048;
pub const kCFISO8601DateFormatWithFullDate: _bindgen_ty_35 = 275;
pub const kCFISO8601DateFormatWithFullTime: _bindgen_ty_35 = 1632;
pub const kCFISO8601DateFormatWithInternetDateTime: _bindgen_ty_35 = 1907;
pub type _bindgen_ty_35 = u32;
extern "C" {
    pub fn CFDateFormatterCreateISO8601Formatter(
        allocator: CFAllocatorRef,
        formatOptions: CFISO8601DateFormatOptions,
    ) -> CFDateFormatterRef;
}
extern "C" {
    pub fn CFDateFormatterCreate(
        allocator: CFAllocatorRef,
        locale: CFLocaleRef,
        dateStyle: CFDateFormatterStyle,
        timeStyle: CFDateFormatterStyle,
    ) -> CFDateFormatterRef;
}
extern "C" {
    pub fn CFDateFormatterGetLocale(formatter: CFDateFormatterRef) -> CFLocaleRef;
}
extern "C" {
    pub fn CFDateFormatterGetDateStyle(formatter: CFDateFormatterRef) -> CFDateFormatterStyle;
}
extern "C" {
    pub fn CFDateFormatterGetTimeStyle(formatter: CFDateFormatterRef) -> CFDateFormatterStyle;
}
extern "C" {
    pub fn CFDateFormatterGetFormat(formatter: CFDateFormatterRef) -> CFStringRef;
}
extern "C" {
    pub fn CFDateFormatterSetFormat(formatter: CFDateFormatterRef, formatString: CFStringRef);
}
extern "C" {
    pub fn CFDateFormatterCreateStringWithDate(
        allocator: CFAllocatorRef,
        formatter: CFDateFormatterRef,
        date: CFDateRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFDateFormatterCreateStringWithAbsoluteTime(
        allocator: CFAllocatorRef,
        formatter: CFDateFormatterRef,
        at: CFAbsoluteTime,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFDateFormatterCreateDateFromString(
        allocator: CFAllocatorRef,
        formatter: CFDateFormatterRef,
        string: CFStringRef,
        rangep: *mut CFRange,
    ) -> CFDateRef;
}
extern "C" {
    pub fn CFDateFormatterGetAbsoluteTimeFromString(
        formatter: CFDateFormatterRef,
        string: CFStringRef,
        rangep: *mut CFRange,
        atp: *mut CFAbsoluteTime,
    ) -> Boolean;
}
extern "C" {
    pub fn CFDateFormatterSetProperty(
        formatter: CFDateFormatterRef,
        key: CFStringRef,
        value: CFTypeRef,
    );
}
extern "C" {
    pub fn CFDateFormatterCopyProperty(
        formatter: CFDateFormatterRef,
        key: CFDateFormatterKey,
    ) -> CFTypeRef;
}
extern "C" {
    pub static kCFDateFormatterIsLenient: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterTimeZone: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterCalendarName: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterDefaultFormat: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterTwoDigitStartDate: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterDefaultDate: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterCalendar: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterEraSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterMonthSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterShortMonthSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterWeekdaySymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterShortWeekdaySymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterAMSymbol: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterPMSymbol: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterLongEraSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterVeryShortMonthSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterStandaloneMonthSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterShortStandaloneMonthSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterVeryShortStandaloneMonthSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterVeryShortWeekdaySymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterStandaloneWeekdaySymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterShortStandaloneWeekdaySymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterVeryShortStandaloneWeekdaySymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterQuarterSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterShortQuarterSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterStandaloneQuarterSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterShortStandaloneQuarterSymbols: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterGregorianStartDate: CFDateFormatterKey;
}
extern "C" {
    pub static kCFDateFormatterDoesRelativeDateFormattingKey: CFDateFormatterKey;
}
pub type CFErrorDomain = CFStringRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFError {
    _unused: [u8; 0],
}
///@typedef CFErrorRef
///This is the type of a reference to CFErrors.  CFErrorRef is toll-free bridged with NSError.
pub type CFErrorRef = *mut __CFError;
extern "C" {
    ///@function CFErrorGetTypeID
    ///Returns the type identifier of all CFError instances.
    pub fn CFErrorGetTypeID() -> CFTypeID;
}
extern "C" {
    pub static kCFErrorDomainPOSIX: CFErrorDomain;
}
extern "C" {
    pub static kCFErrorDomainOSStatus: CFErrorDomain;
}
extern "C" {
    pub static kCFErrorDomainMach: CFErrorDomain;
}
extern "C" {
    pub static kCFErrorDomainCocoa: CFErrorDomain;
}
extern "C" {
    pub static kCFErrorLocalizedDescriptionKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorLocalizedFailureKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorLocalizedFailureReasonKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorLocalizedRecoverySuggestionKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorDescriptionKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorUnderlyingErrorKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorURLKey: CFStringRef;
}
extern "C" {
    pub static kCFErrorFilePathKey: CFStringRef;
}
extern "C" {
    ///@function CFErrorCreate
    ///@abstract Creates a new CFError.
    ///@param allocator The CFAllocator which should be used to allocate memory for the error. This parameter may be NULL in which case the
    ///current default CFAllocator is used. If this reference is not a valid CFAllocator, the behavior is undefined.
    ///@param domain A CFString identifying the error domain. If this reference is NULL or is otherwise not a valid CFString, the behavior is undefined.
    ///@param code A CFIndex identifying the error code. The code is interpreted within the context of the error domain.
    ///@param userInfo A CFDictionary created with kCFCopyStringDictionaryKeyCallBacks and kCFTypeDictionaryValueCallBacks. It will be copied with CFDictionaryCreateCopy().
    ///If no userInfo dictionary is desired, NULL may be passed in as a convenience, in which case an empty userInfo dictionary will be assigned.
    ///@result A reference to the new CFError.
    pub fn CFErrorCreate(
        allocator: CFAllocatorRef,
        domain: CFErrorDomain,
        code: CFIndex,
        userInfo: CFDictionaryRef,
    ) -> CFErrorRef;
}
extern "C" {
    ///@function CFErrorCreateWithUserInfoKeysAndValues
    ///@abstract Creates a new CFError without having to create an intermediate userInfo dictionary.
    ///@param allocator The CFAllocator which should be used to allocate memory for the error. This parameter may be NULL in which case the
    ///current default CFAllocator is used. If this reference is not a valid CFAllocator, the behavior is undefined.
    ///@param domain A CFString identifying the error domain. If this reference is NULL or is otherwise not a valid CFString, the behavior is undefined.
    ///@param code A CFIndex identifying the error code. The code is interpreted within the context of the error domain.
    ///@param userInfoKeys An array of numUserInfoValues CFStrings used as keys in creating the userInfo dictionary. NULL is valid only if numUserInfoValues is 0.
    ///@param userInfoValues An array of numUserInfoValues CF types used as values in creating the userInfo dictionary.  NULL is valid only if numUserInfoValues is 0.
    ///@param numUserInfoValues CFIndex representing the number of keys and values in the userInfoKeys and userInfoValues arrays.
    ///@result A reference to the new CFError. numUserInfoValues CF types are gathered from each of userInfoKeys and userInfoValues to create the userInfo dictionary.
    pub fn CFErrorCreateWithUserInfoKeysAndValues(
        allocator: CFAllocatorRef,
        domain: CFErrorDomain,
        code: CFIndex,
        userInfoKeys: *const *const ::std::os::raw::c_void,
        userInfoValues: *const *const ::std::os::raw::c_void,
        numUserInfoValues: CFIndex,
    ) -> CFErrorRef;
}
extern "C" {
    ///@function CFErrorGetDomain
    ///@abstract Returns the error domain the CFError was created with.
    ///@param err The CFError whose error domain is to be returned. If this reference is not a valid CFError, the behavior is undefined.
    ///@result The error domain of the CFError. Since this is a "Get" function, the caller shouldn't CFRelease the return value.
    pub fn CFErrorGetDomain(err: CFErrorRef) -> CFErrorDomain;
}
extern "C" {
    ///@function CFErrorGetCode
    ///@abstract Returns the error code the CFError was created with.
    ///@param err The CFError whose error code is to be returned. If this reference is not a valid CFError, the behavior is undefined.
    ///@result The error code of the CFError (not an error return for the current call).
    pub fn CFErrorGetCode(err: CFErrorRef) -> CFIndex;
}
extern "C" {
    ///@function CFErrorCopyUserInfo
    ///@abstract Returns CFError userInfo dictionary.
    ///@discussion Returns a dictionary containing the same keys and values as in the userInfo dictionary the CFError was created with. Returns an empty dictionary if NULL was supplied to CFErrorCreate().
    ///@param err The CFError whose error user info is to be returned. If this reference is not a valid CFError, the behavior is undefined.
    ///@result The user info of the CFError.
    pub fn CFErrorCopyUserInfo(err: CFErrorRef) -> CFDictionaryRef;
}
extern "C" {
    ///@function CFErrorCopyDescription
    ///@abstract Returns a human-presentable description for the error. CFError creators should strive to make sure the return value is human-presentable and localized by providing a value for kCFErrorLocalizedDescriptionKey at the time of CFError creation.
    ///@discussion This is a complete sentence or two which says what failed and why it failed. Please refer to header comments for -[NSError localizedDescription] for details on the steps used to compute this; but roughly:
    ///- Use value of kCFErrorLocalizedDescriptionKey as-is if provided.
    ///- Use value of kCFErrorLocalizedFailureKey if provided, optionally followed by kCFErrorLocalizedFailureReasonKey if available.
    ///- Use value of kCFErrorLocalizedFailureReasonKey, combining with a generic failure message such as: "Operation code not be completed. " + kCFErrorLocalizedFailureReasonKey.
    ///- If all of the above fail, generate a semi-user presentable string from kCFErrorDescriptionKey, the domain, and code. Something like: "Operation could not be completed. Error domain/code occurred. " or "Operation could not be completed. " + kCFErrorDescriptionKey + " (Error domain/code)"
    ///Toll-free bridged NSError instances might provide additional behaviors for manufacturing a description string.  Do not count on the exact contents or format of the returned string, it might change.
    ///@param err The CFError whose description is to be returned. If this reference is not a valid CFError, the behavior is undefined.
    ///@result A CFString with human-presentable description of the CFError. Never NULL.
    pub fn CFErrorCopyDescription(err: CFErrorRef) -> CFStringRef;
}
extern "C" {
    ///@function CFErrorCopyFailureReason
    ///@abstract Returns a human-presentable failure reason for the error.  May return NULL.  CFError creators should strive to make sure the return value is human-presentable and localized by providing a value for kCFErrorLocalizedFailureReasonKey at the time of CFError creation.
    ///@discussion This is a complete sentence which describes why the operation failed. In many cases this will be just the "because" part of the description (but as a complete sentence, which makes localization easier). By default this looks for kCFErrorLocalizedFailureReasonKey in the user info. Toll-free bridged NSError instances might provide additional behaviors for manufacturing this value. If no user-presentable string is available, returns NULL.
    ///Example Description: "Could not save file 'Letter' in folder 'Documents' because the volume 'MyDisk' doesn't have enough space."
    ///Corresponding FailureReason: "The volume 'MyDisk' doesn't have enough space."
    ///@param err The CFError whose failure reason is to be returned. If this reference is not a valid CFError, the behavior is undefined.
    ///@result A CFString with the localized, end-user presentable failure reason of the CFError, or NULL.
    pub fn CFErrorCopyFailureReason(err: CFErrorRef) -> CFStringRef;
}
extern "C" {
    ///@function CFErrorCopyRecoverySuggestion
    ///@abstract Returns a human presentable recovery suggestion for the error.  May return NULL.  CFError creators should strive to make sure the return value is human-presentable and localized by providing a value for kCFErrorLocalizedRecoverySuggestionKey at the time of CFError creation.
    ///@discussion This is the string that can be displayed as the "informative" (aka "secondary") message on an alert panel. By default this looks for kCFErrorLocalizedRecoverySuggestionKey in the user info. Toll-free bridged NSError instances might provide additional behaviors for manufacturing this value. If no user-presentable string is available, returns NULL.
    ///Example Description: "Could not save file 'Letter' in folder 'Documents' because the volume 'MyDisk' doesn't have enough space."
    ///Corresponding RecoverySuggestion: "Remove some files from the volume and try again."
    ///@param err The CFError whose recovery suggestion is to be returned. If this reference is not a valid CFError, the behavior is undefined.
    ///@result A CFString with the localized, end-user presentable recovery suggestion of the CFError, or NULL.
    pub fn CFErrorCopyRecoverySuggestion(err: CFErrorRef) -> CFStringRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFBoolean {
    _unused: [u8; 0],
}
pub type CFBooleanRef = *const __CFBoolean;
extern "C" {
    pub static kCFBooleanTrue: CFBooleanRef;
}
extern "C" {
    pub static kCFBooleanFalse: CFBooleanRef;
}
extern "C" {
    pub fn CFBooleanGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFBooleanGetValue(boolean: CFBooleanRef) -> Boolean;
}
pub type CFNumberType = CFIndex;
pub const kCFNumberSInt8Type: _bindgen_ty_36 = 1;
pub const kCFNumberSInt16Type: _bindgen_ty_36 = 2;
pub const kCFNumberSInt32Type: _bindgen_ty_36 = 3;
pub const kCFNumberSInt64Type: _bindgen_ty_36 = 4;
pub const kCFNumberFloat32Type: _bindgen_ty_36 = 5;
pub const kCFNumberFloat64Type: _bindgen_ty_36 = 6;
pub const kCFNumberCharType: _bindgen_ty_36 = 7;
pub const kCFNumberShortType: _bindgen_ty_36 = 8;
pub const kCFNumberIntType: _bindgen_ty_36 = 9;
pub const kCFNumberLongType: _bindgen_ty_36 = 10;
pub const kCFNumberLongLongType: _bindgen_ty_36 = 11;
pub const kCFNumberFloatType: _bindgen_ty_36 = 12;
pub const kCFNumberDoubleType: _bindgen_ty_36 = 13;
pub const kCFNumberCFIndexType: _bindgen_ty_36 = 14;
pub const kCFNumberNSIntegerType: _bindgen_ty_36 = 15;
pub const kCFNumberCGFloatType: _bindgen_ty_36 = 16;
pub const kCFNumberMaxType: _bindgen_ty_36 = 16;
pub type _bindgen_ty_36 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFNumber {
    _unused: [u8; 0],
}
pub type CFNumberRef = *const __CFNumber;
extern "C" {
    pub static kCFNumberPositiveInfinity: CFNumberRef;
}
extern "C" {
    pub static kCFNumberNegativeInfinity: CFNumberRef;
}
extern "C" {
    pub static kCFNumberNaN: CFNumberRef;
}
extern "C" {
    pub fn CFNumberGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFNumberCreate(
        allocator: CFAllocatorRef,
        theType: CFNumberType,
        valuePtr: *const ::std::os::raw::c_void,
    ) -> CFNumberRef;
}
extern "C" {
    pub fn CFNumberGetType(number: CFNumberRef) -> CFNumberType;
}
extern "C" {
    pub fn CFNumberGetByteSize(number: CFNumberRef) -> CFIndex;
}
extern "C" {
    pub fn CFNumberIsFloatType(number: CFNumberRef) -> Boolean;
}
extern "C" {
    pub fn CFNumberGetValue(
        number: CFNumberRef,
        theType: CFNumberType,
        valuePtr: *mut ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    pub fn CFNumberCompare(
        number: CFNumberRef,
        otherNumber: CFNumberRef,
        context: *mut ::std::os::raw::c_void,
    ) -> CFComparisonResult;
}
pub type CFNumberFormatterKey = CFStringRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFNumberFormatter {
    _unused: [u8; 0],
}
pub type CFNumberFormatterRef = *mut __CFNumberFormatter;
extern "C" {
    pub fn CFNumberFormatterGetTypeID() -> CFTypeID;
}
pub type CFNumberFormatterStyle = CFIndex;
pub const kCFNumberFormatterNoStyle: _bindgen_ty_37 = 0;
pub const kCFNumberFormatterDecimalStyle: _bindgen_ty_37 = 1;
pub const kCFNumberFormatterCurrencyStyle: _bindgen_ty_37 = 2;
pub const kCFNumberFormatterPercentStyle: _bindgen_ty_37 = 3;
pub const kCFNumberFormatterScientificStyle: _bindgen_ty_37 = 4;
pub const kCFNumberFormatterSpellOutStyle: _bindgen_ty_37 = 5;
pub const kCFNumberFormatterOrdinalStyle: _bindgen_ty_37 = 6;
pub const kCFNumberFormatterCurrencyISOCodeStyle: _bindgen_ty_37 = 8;
pub const kCFNumberFormatterCurrencyPluralStyle: _bindgen_ty_37 = 9;
pub const kCFNumberFormatterCurrencyAccountingStyle: _bindgen_ty_37 = 10;
pub type _bindgen_ty_37 = u32;
extern "C" {
    pub fn CFNumberFormatterCreate(
        allocator: CFAllocatorRef,
        locale: CFLocaleRef,
        style: CFNumberFormatterStyle,
    ) -> CFNumberFormatterRef;
}
extern "C" {
    pub fn CFNumberFormatterGetLocale(formatter: CFNumberFormatterRef) -> CFLocaleRef;
}
extern "C" {
    pub fn CFNumberFormatterGetStyle(formatter: CFNumberFormatterRef) -> CFNumberFormatterStyle;
}
extern "C" {
    pub fn CFNumberFormatterGetFormat(formatter: CFNumberFormatterRef) -> CFStringRef;
}
extern "C" {
    pub fn CFNumberFormatterSetFormat(formatter: CFNumberFormatterRef, formatString: CFStringRef);
}
extern "C" {
    pub fn CFNumberFormatterCreateStringWithNumber(
        allocator: CFAllocatorRef,
        formatter: CFNumberFormatterRef,
        number: CFNumberRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFNumberFormatterCreateStringWithValue(
        allocator: CFAllocatorRef,
        formatter: CFNumberFormatterRef,
        numberType: CFNumberType,
        valuePtr: *const ::std::os::raw::c_void,
    ) -> CFStringRef;
}
pub type CFNumberFormatterOptionFlags = CFOptionFlags;
pub const kCFNumberFormatterParseIntegersOnly: _bindgen_ty_38 = 1;
pub type _bindgen_ty_38 = u32;
extern "C" {
    pub fn CFNumberFormatterCreateNumberFromString(
        allocator: CFAllocatorRef,
        formatter: CFNumberFormatterRef,
        string: CFStringRef,
        rangep: *mut CFRange,
        options: CFOptionFlags,
    ) -> CFNumberRef;
}
extern "C" {
    pub fn CFNumberFormatterGetValueFromString(
        formatter: CFNumberFormatterRef,
        string: CFStringRef,
        rangep: *mut CFRange,
        numberType: CFNumberType,
        valuePtr: *mut ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    pub fn CFNumberFormatterSetProperty(
        formatter: CFNumberFormatterRef,
        key: CFNumberFormatterKey,
        value: CFTypeRef,
    );
}
extern "C" {
    pub fn CFNumberFormatterCopyProperty(
        formatter: CFNumberFormatterRef,
        key: CFNumberFormatterKey,
    ) -> CFTypeRef;
}
extern "C" {
    pub static kCFNumberFormatterCurrencyCode: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterDecimalSeparator: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterCurrencyDecimalSeparator: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterAlwaysShowDecimalSeparator: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterGroupingSeparator: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterUseGroupingSeparator: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPercentSymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterZeroSymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterNaNSymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterInfinitySymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMinusSign: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPlusSign: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterCurrencySymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterExponentSymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMinIntegerDigits: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMaxIntegerDigits: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMinFractionDigits: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMaxFractionDigits: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterGroupingSize: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterSecondaryGroupingSize: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterRoundingMode: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterRoundingIncrement: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterFormatWidth: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPaddingPosition: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPaddingCharacter: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterDefaultFormat: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMultiplier: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPositivePrefix: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPositiveSuffix: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterNegativePrefix: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterNegativeSuffix: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterPerMillSymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterInternationalCurrencySymbol: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterCurrencyGroupingSeparator: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterIsLenient: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterUseSignificantDigits: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMinSignificantDigits: CFNumberFormatterKey;
}
extern "C" {
    pub static kCFNumberFormatterMaxSignificantDigits: CFNumberFormatterKey;
}
pub type CFNumberFormatterRoundingMode = CFIndex;
pub const kCFNumberFormatterRoundCeiling: _bindgen_ty_39 = 0;
pub const kCFNumberFormatterRoundFloor: _bindgen_ty_39 = 1;
pub const kCFNumberFormatterRoundDown: _bindgen_ty_39 = 2;
pub const kCFNumberFormatterRoundUp: _bindgen_ty_39 = 3;
pub const kCFNumberFormatterRoundHalfEven: _bindgen_ty_39 = 4;
pub const kCFNumberFormatterRoundHalfDown: _bindgen_ty_39 = 5;
pub const kCFNumberFormatterRoundHalfUp: _bindgen_ty_39 = 6;
pub type _bindgen_ty_39 = u32;
pub type CFNumberFormatterPadPosition = CFIndex;
pub const kCFNumberFormatterPadBeforePrefix: _bindgen_ty_40 = 0;
pub const kCFNumberFormatterPadAfterPrefix: _bindgen_ty_40 = 1;
pub const kCFNumberFormatterPadBeforeSuffix: _bindgen_ty_40 = 2;
pub const kCFNumberFormatterPadAfterSuffix: _bindgen_ty_40 = 3;
pub type _bindgen_ty_40 = u32;
extern "C" {
    pub fn CFNumberFormatterGetDecimalInfoForCurrencyCode(
        currencyCode: CFStringRef,
        defaultFractionDigits: *mut i32,
        roundingIncrement: *mut f64,
    ) -> Boolean;
}
extern "C" {
    pub static kCFPreferencesAnyApplication: CFStringRef;
}
extern "C" {
    pub static kCFPreferencesCurrentApplication: CFStringRef;
}
extern "C" {
    pub static kCFPreferencesAnyHost: CFStringRef;
}
extern "C" {
    pub static kCFPreferencesCurrentHost: CFStringRef;
}
extern "C" {
    pub static kCFPreferencesAnyUser: CFStringRef;
}
extern "C" {
    pub static kCFPreferencesCurrentUser: CFStringRef;
}
extern "C" {
    pub fn CFPreferencesCopyAppValue(
        key: CFStringRef,
        applicationID: CFStringRef,
    ) -> CFPropertyListRef;
}
extern "C" {
    pub fn CFPreferencesGetAppBooleanValue(
        key: CFStringRef,
        applicationID: CFStringRef,
        keyExistsAndHasValidFormat: *mut Boolean,
    ) -> Boolean;
}
extern "C" {
    pub fn CFPreferencesGetAppIntegerValue(
        key: CFStringRef,
        applicationID: CFStringRef,
        keyExistsAndHasValidFormat: *mut Boolean,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFPreferencesSetAppValue(
        key: CFStringRef,
        value: CFPropertyListRef,
        applicationID: CFStringRef,
    );
}
extern "C" {
    pub fn CFPreferencesAddSuitePreferencesToApp(applicationID: CFStringRef, suiteID: CFStringRef);
}
extern "C" {
    pub fn CFPreferencesRemoveSuitePreferencesFromApp(
        applicationID: CFStringRef,
        suiteID: CFStringRef,
    );
}
extern "C" {
    pub fn CFPreferencesAppSynchronize(applicationID: CFStringRef) -> Boolean;
}
extern "C" {
    pub fn CFPreferencesCopyValue(
        key: CFStringRef,
        applicationID: CFStringRef,
        userName: CFStringRef,
        hostName: CFStringRef,
    ) -> CFPropertyListRef;
}
extern "C" {
    pub fn CFPreferencesCopyMultiple(
        keysToFetch: CFArrayRef,
        applicationID: CFStringRef,
        userName: CFStringRef,
        hostName: CFStringRef,
    ) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFPreferencesSetValue(
        key: CFStringRef,
        value: CFPropertyListRef,
        applicationID: CFStringRef,
        userName: CFStringRef,
        hostName: CFStringRef,
    );
}
extern "C" {
    pub fn CFPreferencesSetMultiple(
        keysToSet: CFDictionaryRef,
        keysToRemove: CFArrayRef,
        applicationID: CFStringRef,
        userName: CFStringRef,
        hostName: CFStringRef,
    );
}
extern "C" {
    pub fn CFPreferencesSynchronize(
        applicationID: CFStringRef,
        userName: CFStringRef,
        hostName: CFStringRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFPreferencesCopyApplicationList(
        userName: CFStringRef,
        hostName: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFPreferencesCopyKeyList(
        applicationID: CFStringRef,
        userName: CFStringRef,
        hostName: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFPreferencesAppValueIsForced(key: CFStringRef, applicationID: CFStringRef) -> Boolean;
}
pub type CFURLPathStyle = CFIndex;
pub const kCFURLPOSIXPathStyle: _bindgen_ty_41 = 0;
pub const kCFURLHFSPathStyle: _bindgen_ty_41 = 1;
pub const kCFURLWindowsPathStyle: _bindgen_ty_41 = 2;
pub type _bindgen_ty_41 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFURL {
    _unused: [u8; 0],
}
pub type CFURLRef = *const __CFURL;
extern "C" {
    pub fn CFURLGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFURLCreateWithBytes(
        allocator: CFAllocatorRef,
        URLBytes: *const UInt8,
        length: CFIndex,
        encoding: CFStringEncoding,
        baseURL: CFURLRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateData(
        allocator: CFAllocatorRef,
        url: CFURLRef,
        encoding: CFStringEncoding,
        escapeWhitespace: Boolean,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFURLCreateWithString(
        allocator: CFAllocatorRef,
        URLString: CFStringRef,
        baseURL: CFURLRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateAbsoluteURLWithBytes(
        alloc: CFAllocatorRef,
        relativeURLBytes: *const UInt8,
        length: CFIndex,
        encoding: CFStringEncoding,
        baseURL: CFURLRef,
        useCompatibilityMode: Boolean,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateWithFileSystemPath(
        allocator: CFAllocatorRef,
        filePath: CFStringRef,
        pathStyle: CFURLPathStyle,
        isDirectory: Boolean,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateFromFileSystemRepresentation(
        allocator: CFAllocatorRef,
        buffer: *const UInt8,
        bufLen: CFIndex,
        isDirectory: Boolean,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateWithFileSystemPathRelativeToBase(
        allocator: CFAllocatorRef,
        filePath: CFStringRef,
        pathStyle: CFURLPathStyle,
        isDirectory: Boolean,
        baseURL: CFURLRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateFromFileSystemRepresentationRelativeToBase(
        allocator: CFAllocatorRef,
        buffer: *const UInt8,
        bufLen: CFIndex,
        isDirectory: Boolean,
        baseURL: CFURLRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLGetFileSystemRepresentation(
        url: CFURLRef,
        resolveAgainstBase: Boolean,
        buffer: *mut UInt8,
        maxBufLen: CFIndex,
    ) -> Boolean;
}
extern "C" {
    pub fn CFURLCopyAbsoluteURL(relativeURL: CFURLRef) -> CFURLRef;
}
extern "C" {
    pub fn CFURLGetString(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLGetBaseURL(anURL: CFURLRef) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCanBeDecomposed(anURL: CFURLRef) -> Boolean;
}
extern "C" {
    pub fn CFURLCopyScheme(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyNetLocation(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyPath(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyStrictPath(anURL: CFURLRef, isAbsolute: *mut Boolean) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyFileSystemPath(anURL: CFURLRef, pathStyle: CFURLPathStyle) -> CFStringRef;
}
extern "C" {
    pub fn CFURLHasDirectoryPath(anURL: CFURLRef) -> Boolean;
}
extern "C" {
    pub fn CFURLCopyResourceSpecifier(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyHostName(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLGetPortNumber(anURL: CFURLRef) -> SInt32;
}
extern "C" {
    pub fn CFURLCopyUserName(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyPassword(anURL: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyParameterString(
        anURL: CFURLRef,
        charactersToLeaveEscaped: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyQueryString(
        anURL: CFURLRef,
        charactersToLeaveEscaped: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyFragment(anURL: CFURLRef, charactersToLeaveEscaped: CFStringRef)
        -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyLastPathComponent(url: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCopyPathExtension(url: CFURLRef) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCreateCopyAppendingPathComponent(
        allocator: CFAllocatorRef,
        url: CFURLRef,
        pathComponent: CFStringRef,
        isDirectory: Boolean,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateCopyDeletingLastPathComponent(
        allocator: CFAllocatorRef,
        url: CFURLRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateCopyAppendingPathExtension(
        allocator: CFAllocatorRef,
        url: CFURLRef,
        extension: CFStringRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateCopyDeletingPathExtension(
        allocator: CFAllocatorRef,
        url: CFURLRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLGetBytes(url: CFURLRef, buffer: *mut UInt8, bufferLength: CFIndex) -> CFIndex;
}
pub type CFURLComponentType = CFIndex;
pub const kCFURLComponentScheme: _bindgen_ty_42 = 1;
pub const kCFURLComponentNetLocation: _bindgen_ty_42 = 2;
pub const kCFURLComponentPath: _bindgen_ty_42 = 3;
pub const kCFURLComponentResourceSpecifier: _bindgen_ty_42 = 4;
pub const kCFURLComponentUser: _bindgen_ty_42 = 5;
pub const kCFURLComponentPassword: _bindgen_ty_42 = 6;
pub const kCFURLComponentUserInfo: _bindgen_ty_42 = 7;
pub const kCFURLComponentHost: _bindgen_ty_42 = 8;
pub const kCFURLComponentPort: _bindgen_ty_42 = 9;
pub const kCFURLComponentParameterString: _bindgen_ty_42 = 10;
pub const kCFURLComponentQuery: _bindgen_ty_42 = 11;
pub const kCFURLComponentFragment: _bindgen_ty_42 = 12;
pub type _bindgen_ty_42 = u32;
extern "C" {
    pub fn CFURLGetByteRangeForComponent(
        url: CFURLRef,
        component: CFURLComponentType,
        rangeIncludingSeparators: *mut CFRange,
    ) -> CFRange;
}
extern "C" {
    pub fn CFURLCreateStringByReplacingPercentEscapes(
        allocator: CFAllocatorRef,
        originalString: CFStringRef,
        charactersToLeaveEscaped: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCreateStringByReplacingPercentEscapesUsingEncoding(
        allocator: CFAllocatorRef,
        origString: CFStringRef,
        charsToLeaveEscaped: CFStringRef,
        encoding: CFStringEncoding,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFURLCreateStringByAddingPercentEscapes(
        allocator: CFAllocatorRef,
        originalString: CFStringRef,
        charactersToLeaveUnescaped: CFStringRef,
        legalURLCharactersToBeEscaped: CFStringRef,
        encoding: CFStringEncoding,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFURLIsFileReferenceURL(url: CFURLRef) -> Boolean;
}
extern "C" {
    pub fn CFURLCreateFileReferenceURL(
        allocator: CFAllocatorRef,
        url: CFURLRef,
        error: *mut CFErrorRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateFilePathURL(
        allocator: CFAllocatorRef,
        url: CFURLRef,
        error: *mut CFErrorRef,
    ) -> CFURLRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSRef {
    _unused: [u8; 0],
}
extern "C" {
    pub fn CFURLCreateFromFSRef(allocator: CFAllocatorRef, fsRef: *const FSRef) -> CFURLRef;
}
extern "C" {
    pub fn CFURLGetFSRef(url: CFURLRef, fsRef: *mut FSRef) -> Boolean;
}
extern "C" {
    pub fn CFURLCopyResourcePropertyForKey(
        url: CFURLRef,
        key: CFStringRef,
        propertyValueTypeRefPtr: *mut ::std::os::raw::c_void,
        error: *mut CFErrorRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFURLCopyResourcePropertiesForKeys(
        url: CFURLRef,
        keys: CFArrayRef,
        error: *mut CFErrorRef,
    ) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFURLSetResourcePropertyForKey(
        url: CFURLRef,
        key: CFStringRef,
        propertyValue: CFTypeRef,
        error: *mut CFErrorRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFURLSetResourcePropertiesForKeys(
        url: CFURLRef,
        keyedPropertyValues: CFDictionaryRef,
        error: *mut CFErrorRef,
    ) -> Boolean;
}
extern "C" {
    pub static kCFURLKeysOfUnsetValuesKey: CFStringRef;
}
extern "C" {
    pub fn CFURLClearResourcePropertyCacheForKey(url: CFURLRef, key: CFStringRef);
}
extern "C" {
    pub fn CFURLClearResourcePropertyCache(url: CFURLRef);
}
extern "C" {
    pub fn CFURLSetTemporaryResourcePropertyForKey(
        url: CFURLRef,
        key: CFStringRef,
        propertyValue: CFTypeRef,
    );
}
extern "C" {
    pub fn CFURLResourceIsReachable(url: CFURLRef, error: *mut CFErrorRef) -> Boolean;
}
extern "C" {
    pub static kCFURLNameKey: CFStringRef;
}
extern "C" {
    pub static kCFURLLocalizedNameKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsRegularFileKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsDirectoryKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsSymbolicLinkKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsVolumeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsPackageKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsApplicationKey: CFStringRef;
}
extern "C" {
    pub static kCFURLApplicationIsScriptableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsSystemImmutableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsUserImmutableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsHiddenKey: CFStringRef;
}
extern "C" {
    pub static kCFURLHasHiddenExtensionKey: CFStringRef;
}
extern "C" {
    pub static kCFURLCreationDateKey: CFStringRef;
}
extern "C" {
    pub static kCFURLContentAccessDateKey: CFStringRef;
}
extern "C" {
    pub static kCFURLContentModificationDateKey: CFStringRef;
}
extern "C" {
    pub static kCFURLAttributeModificationDateKey: CFStringRef;
}
extern "C" {
    pub static kCFURLLinkCountKey: CFStringRef;
}
extern "C" {
    pub static kCFURLParentDirectoryURLKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeURLKey: CFStringRef;
}
extern "C" {
    pub static kCFURLTypeIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFURLLocalizedTypeDescriptionKey: CFStringRef;
}
extern "C" {
    pub static kCFURLLabelNumberKey: CFStringRef;
}
extern "C" {
    pub static kCFURLLabelColorKey: CFStringRef;
}
extern "C" {
    pub static kCFURLLocalizedLabelKey: CFStringRef;
}
extern "C" {
    pub static kCFURLEffectiveIconKey: CFStringRef;
}
extern "C" {
    pub static kCFURLCustomIconKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFURLPreferredIOBlockSizeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsReadableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsWritableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsExecutableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileSecurityKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsExcludedFromBackupKey: CFStringRef;
}
extern "C" {
    pub static kCFURLTagNamesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLPathKey: CFStringRef;
}
extern "C" {
    pub static kCFURLCanonicalPathKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsMountTriggerKey: CFStringRef;
}
extern "C" {
    pub static kCFURLGenerationIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFURLDocumentIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFURLAddedToDirectoryDateKey: CFStringRef;
}
extern "C" {
    pub static kCFURLQuarantinePropertiesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeNamedPipe: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeCharacterSpecial: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeDirectory: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeBlockSpecial: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeRegular: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeSymbolicLink: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeSocket: CFStringRef;
}
extern "C" {
    pub static kCFURLFileResourceTypeUnknown: CFStringRef;
}
extern "C" {
    pub static kCFURLFileSizeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileAllocatedSizeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLTotalFileSizeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLTotalFileAllocatedSizeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsAliasFileKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileProtectionKey: CFStringRef;
}
extern "C" {
    pub static kCFURLFileProtectionNone: CFStringRef;
}
extern "C" {
    pub static kCFURLFileProtectionComplete: CFStringRef;
}
extern "C" {
    pub static kCFURLFileProtectionCompleteUnlessOpen: CFStringRef;
}
extern "C" {
    pub static kCFURLFileProtectionCompleteUntilFirstUserAuthentication: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeLocalizedFormatDescriptionKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeTotalCapacityKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeAvailableCapacityKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeAvailableCapacityForImportantUsageKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeAvailableCapacityForOpportunisticUsageKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeResourceCountKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsPersistentIDsKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsSymbolicLinksKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsHardLinksKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsJournalingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsJournalingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsSparseFilesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsZeroRunsKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsCaseSensitiveNamesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsCasePreservedNamesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsRootDirectoryDatesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsVolumeSizesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsRenamingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsAdvisoryFileLockingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsExtendedSecurityKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsBrowsableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeMaximumFileSizeKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsEjectableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsRemovableKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsInternalKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsAutomountedKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsLocalKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsReadOnlyKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeCreationDateKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeURLForRemountingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeUUIDStringKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeNameKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeLocalizedNameKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsEncryptedKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeIsRootFileSystemKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsCompressionKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsFileCloningKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsSwapRenamingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsExclusiveRenamingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsImmutableFilesKey: CFStringRef;
}
extern "C" {
    pub static kCFURLVolumeSupportsAccessPermissionsKey: CFStringRef;
}
extern "C" {
    pub static kCFURLIsUbiquitousItemKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemHasUnresolvedConflictsKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemIsDownloadedKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemIsDownloadingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemIsUploadedKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemIsUploadingKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemPercentDownloadedKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemPercentUploadedKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemDownloadingStatusKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemDownloadingErrorKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemUploadingErrorKey: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemDownloadingStatusNotDownloaded: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemDownloadingStatusDownloaded: CFStringRef;
}
extern "C" {
    pub static kCFURLUbiquitousItemDownloadingStatusCurrent: CFStringRef;
}
pub type CFURLBookmarkCreationOptions = CFOptionFlags;
pub const kCFURLBookmarkCreationMinimalBookmarkMask: _bindgen_ty_43 = 512;
pub const kCFURLBookmarkCreationSuitableForBookmarkFile: _bindgen_ty_43 = 1024;
pub const kCFURLBookmarkCreationWithSecurityScope: _bindgen_ty_43 = 2048;
pub const kCFURLBookmarkCreationSecurityScopeAllowOnlyReadAccess: _bindgen_ty_43 = 4096;
pub const kCFURLBookmarkCreationPreferFileIDResolutionMask: _bindgen_ty_43 = 256;
pub type _bindgen_ty_43 = u32;
pub type CFURLBookmarkResolutionOptions = CFOptionFlags;
pub const kCFURLBookmarkResolutionWithoutUIMask: _bindgen_ty_44 = 256;
pub const kCFURLBookmarkResolutionWithoutMountingMask: _bindgen_ty_44 = 512;
pub const kCFURLBookmarkResolutionWithSecurityScope: _bindgen_ty_44 = 1024;
pub const kCFBookmarkResolutionWithoutUIMask: _bindgen_ty_44 = 256;
pub const kCFBookmarkResolutionWithoutMountingMask: _bindgen_ty_44 = 512;
pub type _bindgen_ty_44 = u32;
pub type CFURLBookmarkFileCreationOptions = CFOptionFlags;
extern "C" {
    pub fn CFURLCreateBookmarkData(
        allocator: CFAllocatorRef,
        url: CFURLRef,
        options: CFURLBookmarkCreationOptions,
        resourcePropertiesToInclude: CFArrayRef,
        relativeToURL: CFURLRef,
        error: *mut CFErrorRef,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFURLCreateByResolvingBookmarkData(
        allocator: CFAllocatorRef,
        bookmark: CFDataRef,
        options: CFURLBookmarkResolutionOptions,
        relativeToURL: CFURLRef,
        resourcePropertiesToInclude: CFArrayRef,
        isStale: *mut Boolean,
        error: *mut CFErrorRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFURLCreateResourcePropertiesForKeysFromBookmarkData(
        allocator: CFAllocatorRef,
        resourcePropertiesToReturn: CFArrayRef,
        bookmark: CFDataRef,
    ) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFURLCreateResourcePropertyForKeyFromBookmarkData(
        allocator: CFAllocatorRef,
        resourcePropertyKey: CFStringRef,
        bookmark: CFDataRef,
    ) -> CFTypeRef;
}
extern "C" {
    pub fn CFURLCreateBookmarkDataFromFile(
        allocator: CFAllocatorRef,
        fileURL: CFURLRef,
        errorRef: *mut CFErrorRef,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFURLWriteBookmarkDataToFile(
        bookmarkRef: CFDataRef,
        fileURL: CFURLRef,
        options: CFURLBookmarkFileCreationOptions,
        errorRef: *mut CFErrorRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFURLCreateBookmarkDataFromAliasRecord(
        allocatorRef: CFAllocatorRef,
        aliasRecordDataRef: CFDataRef,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFURLStartAccessingSecurityScopedResource(url: CFURLRef) -> Boolean;
}
extern "C" {
    pub fn CFURLStopAccessingSecurityScopedResource(url: CFURLRef);
}
pub type boolean_t = ::std::os::raw::c_uint;
pub type natural_t = __darwin_natural_t;
pub type integer_t = ::std::os::raw::c_int;
pub type vm_offset_t = usize;
pub type vm_size_t = usize;
pub type mach_vm_address_t = u64;
pub type mach_vm_offset_t = u64;
pub type mach_vm_size_t = u64;
pub type vm_map_offset_t = u64;
pub type vm_map_address_t = u64;
pub type vm_map_size_t = u64;
pub type mach_port_context_t = mach_vm_address_t;
pub type mach_port_name_t = natural_t;
pub type mach_port_name_array_t = *mut mach_port_name_t;
pub type mach_port_t = __darwin_mach_port_t;
pub type mach_port_array_t = *mut mach_port_t;
pub type mach_port_right_t = natural_t;
pub type mach_port_type_t = natural_t;
pub type mach_port_type_array_t = *mut mach_port_type_t;
pub type mach_port_urefs_t = natural_t;
pub type mach_port_delta_t = integer_t;
pub type mach_port_seqno_t = natural_t;
pub type mach_port_mscount_t = natural_t;
pub type mach_port_msgcount_t = natural_t;
pub type mach_port_rights_t = natural_t;
pub type mach_port_srights_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_port_status {
    pub mps_pset: mach_port_rights_t,
    pub mps_seqno: mach_port_seqno_t,
    pub mps_mscount: mach_port_mscount_t,
    pub mps_qlimit: mach_port_msgcount_t,
    pub mps_msgcount: mach_port_msgcount_t,
    pub mps_sorights: mach_port_rights_t,
    pub mps_srights: boolean_t,
    pub mps_pdrequest: boolean_t,
    pub mps_nsrequest: boolean_t,
    pub mps_flags: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_status() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_status>(),
        40usize,
        concat!("Size of: ", stringify!(mach_port_status))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_status>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_status>())).mps_pset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_pset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_status>())).mps_seqno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_seqno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_status>())).mps_mscount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_mscount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_status>())).mps_qlimit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_qlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_status>())).mps_msgcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_msgcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_status>())).mps_sorights as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_sorights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_status>())).mps_srights as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_srights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_status>())).mps_pdrequest as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_pdrequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_status>())).mps_nsrequest as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_nsrequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_status>())).mps_flags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_status),
            "::",
            stringify!(mps_flags)
        )
    );
}
pub type mach_port_status_t = mach_port_status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_port_limits {
    pub mpl_qlimit: mach_port_msgcount_t,
}
#[test]
fn bindgen_test_layout_mach_port_limits() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_limits>(),
        4usize,
        concat!("Size of: ", stringify!(mach_port_limits))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_limits>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_limits))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_limits>())).mpl_qlimit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_limits),
            "::",
            stringify!(mpl_qlimit)
        )
    );
}
pub type mach_port_limits_t = mach_port_limits;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_port_info_ext {
    pub mpie_status: mach_port_status_t,
    pub mpie_boost_cnt: mach_port_msgcount_t,
    pub reserved: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_mach_port_info_ext() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_info_ext>(),
        68usize,
        concat!("Size of: ", stringify!(mach_port_info_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_info_ext>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_info_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_info_ext>())).mpie_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_info_ext),
            "::",
            stringify!(mpie_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_port_info_ext>())).mpie_boost_cnt as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_info_ext),
            "::",
            stringify!(mpie_boost_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_info_ext>())).reserved as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_info_ext),
            "::",
            stringify!(reserved)
        )
    );
}
pub type mach_port_info_ext_t = mach_port_info_ext;
pub type mach_port_info_t = *mut integer_t;
pub type mach_port_flavor_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_port_qos {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub len: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_qos() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_qos>(),
        8usize,
        concat!("Size of: ", stringify!(mach_port_qos))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_qos>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_qos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_qos>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_qos),
            "::",
            stringify!(len)
        )
    );
}
impl mach_port_qos {
    #[inline]
    pub fn name(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_name(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prealloc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_prealloc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        name: ::std::os::raw::c_uint,
        prealloc: ::std::os::raw::c_uint,
        pad1: boolean_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let name: u32 = unsafe { ::std::mem::transmute(name) };
            name as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let prealloc: u32 = unsafe { ::std::mem::transmute(prealloc) };
            prealloc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type mach_port_qos_t = mach_port_qos;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_port_options {
    pub flags: u32,
    pub mpl: mach_port_limits_t,
    pub reserved: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_mach_port_options() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_options>(),
        24usize,
        concat!("Size of: ", stringify!(mach_port_options))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_options>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_options))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_options>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_options>())).mpl as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options),
            "::",
            stringify!(mpl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_port_options>())).reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_port_options),
            "::",
            stringify!(reserved)
        )
    );
}
pub type mach_port_options_t = mach_port_options;
pub type mach_port_options_ptr_t = *mut mach_port_options_t;
pub const mach_port_guard_exception_codes_kGUARD_EXC_DESTROY: mach_port_guard_exception_codes = 1;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MOD_REFS: mach_port_guard_exception_codes = 2;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SET_CONTEXT: mach_port_guard_exception_codes =
    4;
pub const mach_port_guard_exception_codes_kGUARD_EXC_UNGUARDED: mach_port_guard_exception_codes = 8;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INCORRECT_GUARD:
    mach_port_guard_exception_codes = 16;
pub type mach_port_guard_exception_codes = u32;
pub type CFRunLoopMode = CFStringRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFRunLoop {
    _unused: [u8; 0],
}
pub type CFRunLoopRef = *mut __CFRunLoop;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFRunLoopSource {
    _unused: [u8; 0],
}
pub type CFRunLoopSourceRef = *mut __CFRunLoopSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFRunLoopObserver {
    _unused: [u8; 0],
}
pub type CFRunLoopObserverRef = *mut __CFRunLoopObserver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFRunLoopTimer {
    _unused: [u8; 0],
}
pub type CFRunLoopTimerRef = *mut __CFRunLoopTimer;
pub type CFRunLoopRunResult = SInt32;
pub const kCFRunLoopRunFinished: _bindgen_ty_45 = 1;
pub const kCFRunLoopRunStopped: _bindgen_ty_45 = 2;
pub const kCFRunLoopRunTimedOut: _bindgen_ty_45 = 3;
pub const kCFRunLoopRunHandledSource: _bindgen_ty_45 = 4;
pub type _bindgen_ty_45 = u32;
pub type CFRunLoopActivity = CFOptionFlags;
pub const kCFRunLoopEntry: _bindgen_ty_46 = 1;
pub const kCFRunLoopBeforeTimers: _bindgen_ty_46 = 2;
pub const kCFRunLoopBeforeSources: _bindgen_ty_46 = 4;
pub const kCFRunLoopBeforeWaiting: _bindgen_ty_46 = 32;
pub const kCFRunLoopAfterWaiting: _bindgen_ty_46 = 64;
pub const kCFRunLoopExit: _bindgen_ty_46 = 128;
pub const kCFRunLoopAllActivities: _bindgen_ty_46 = 268435455;
pub type _bindgen_ty_46 = u32;
extern "C" {
    pub static kCFRunLoopDefaultMode: CFRunLoopMode;
}
extern "C" {
    pub static kCFRunLoopCommonModes: CFRunLoopMode;
}
extern "C" {
    pub fn CFRunLoopGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFRunLoopGetCurrent() -> CFRunLoopRef;
}
extern "C" {
    pub fn CFRunLoopGetMain() -> CFRunLoopRef;
}
extern "C" {
    pub fn CFRunLoopCopyCurrentMode(rl: CFRunLoopRef) -> CFRunLoopMode;
}
extern "C" {
    pub fn CFRunLoopCopyAllModes(rl: CFRunLoopRef) -> CFArrayRef;
}
extern "C" {
    pub fn CFRunLoopAddCommonMode(rl: CFRunLoopRef, mode: CFRunLoopMode);
}
extern "C" {
    pub fn CFRunLoopGetNextTimerFireDate(rl: CFRunLoopRef, mode: CFRunLoopMode) -> CFAbsoluteTime;
}
extern "C" {
    pub fn CFRunLoopRun();
}
extern "C" {
    pub fn CFRunLoopRunInMode(
        mode: CFRunLoopMode,
        seconds: CFTimeInterval,
        returnAfterSourceHandled: Boolean,
    ) -> CFRunLoopRunResult;
}
extern "C" {
    pub fn CFRunLoopIsWaiting(rl: CFRunLoopRef) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopWakeUp(rl: CFRunLoopRef);
}
extern "C" {
    pub fn CFRunLoopStop(rl: CFRunLoopRef);
}
extern "C" {
    pub fn CFRunLoopPerformBlock(
        rl: CFRunLoopRef,
        mode: CFTypeRef,
        block: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFRunLoopContainsSource(
        rl: CFRunLoopRef,
        source: CFRunLoopSourceRef,
        mode: CFRunLoopMode,
    ) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopAddSource(rl: CFRunLoopRef, source: CFRunLoopSourceRef, mode: CFRunLoopMode);
}
extern "C" {
    pub fn CFRunLoopRemoveSource(rl: CFRunLoopRef, source: CFRunLoopSourceRef, mode: CFRunLoopMode);
}
extern "C" {
    pub fn CFRunLoopContainsObserver(
        rl: CFRunLoopRef,
        observer: CFRunLoopObserverRef,
        mode: CFRunLoopMode,
    ) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopAddObserver(
        rl: CFRunLoopRef,
        observer: CFRunLoopObserverRef,
        mode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFRunLoopRemoveObserver(
        rl: CFRunLoopRef,
        observer: CFRunLoopObserverRef,
        mode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFRunLoopContainsTimer(
        rl: CFRunLoopRef,
        timer: CFRunLoopTimerRef,
        mode: CFRunLoopMode,
    ) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopAddTimer(rl: CFRunLoopRef, timer: CFRunLoopTimerRef, mode: CFRunLoopMode);
}
extern "C" {
    pub fn CFRunLoopRemoveTimer(rl: CFRunLoopRef, timer: CFRunLoopTimerRef, mode: CFRunLoopMode);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFRunLoopSourceContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub release: ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(
            info1: *const ::std::os::raw::c_void,
            info2: *const ::std::os::raw::c_void,
        ) -> Boolean,
    >,
    pub hash: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFHashCode,
    >,
    pub schedule: ::std::option::Option<
        unsafe extern "C" fn(
            info: *mut ::std::os::raw::c_void,
            rl: CFRunLoopRef,
            mode: CFRunLoopMode,
        ),
    >,
    pub cancel: ::std::option::Option<
        unsafe extern "C" fn(
            info: *mut ::std::os::raw::c_void,
            rl: CFRunLoopRef,
            mode: CFRunLoopMode,
        ),
    >,
    pub perform: ::std::option::Option<unsafe extern "C" fn(info: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_CFRunLoopSourceContext() {
    assert_eq!(
        ::std::mem::size_of::<CFRunLoopSourceContext>(),
        80usize,
        concat!("Size of: ", stringify!(CFRunLoopSourceContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFRunLoopSourceContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFRunLoopSourceContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext>())).retain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFRunLoopSourceContext>())).copyDescription as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext>())).equal as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext>())).hash as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext>())).schedule as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(schedule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext>())).cancel as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(cancel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext>())).perform as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext),
            "::",
            stringify!(perform)
        )
    );
}
impl Default for CFRunLoopSourceContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFRunLoopSourceContext1 {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub release: ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(
            info1: *const ::std::os::raw::c_void,
            info2: *const ::std::os::raw::c_void,
        ) -> Boolean,
    >,
    pub hash: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFHashCode,
    >,
    pub getPort: ::std::option::Option<
        unsafe extern "C" fn(info: *mut ::std::os::raw::c_void) -> mach_port_t,
    >,
    pub perform: ::std::option::Option<
        unsafe extern "C" fn(
            msg: *mut ::std::os::raw::c_void,
            size: CFIndex,
            allocator: CFAllocatorRef,
            info: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
}
#[test]
fn bindgen_test_layout_CFRunLoopSourceContext1() {
    assert_eq!(
        ::std::mem::size_of::<CFRunLoopSourceContext1>(),
        72usize,
        concat!("Size of: ", stringify!(CFRunLoopSourceContext1))
    );
    assert_eq!(
        ::std::mem::align_of::<CFRunLoopSourceContext1>(),
        8usize,
        concat!("Alignment of ", stringify!(CFRunLoopSourceContext1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext1>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext1>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext1>())).retain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext1>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFRunLoopSourceContext1>())).copyDescription as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext1>())).equal as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext1>())).hash as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext1>())).getPort as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(getPort)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopSourceContext1>())).perform as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopSourceContext1),
            "::",
            stringify!(perform)
        )
    );
}
impl Default for CFRunLoopSourceContext1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn CFRunLoopSourceGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFRunLoopSourceCreate(
        allocator: CFAllocatorRef,
        order: CFIndex,
        context: *mut CFRunLoopSourceContext,
    ) -> CFRunLoopSourceRef;
}
extern "C" {
    pub fn CFRunLoopSourceGetOrder(source: CFRunLoopSourceRef) -> CFIndex;
}
extern "C" {
    pub fn CFRunLoopSourceInvalidate(source: CFRunLoopSourceRef);
}
extern "C" {
    pub fn CFRunLoopSourceIsValid(source: CFRunLoopSourceRef) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopSourceGetContext(
        source: CFRunLoopSourceRef,
        context: *mut CFRunLoopSourceContext,
    );
}
extern "C" {
    pub fn CFRunLoopSourceSignal(source: CFRunLoopSourceRef);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFRunLoopObserverContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub release: ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFRunLoopObserverContext() {
    assert_eq!(
        ::std::mem::size_of::<CFRunLoopObserverContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFRunLoopObserverContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFRunLoopObserverContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFRunLoopObserverContext))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFRunLoopObserverContext>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopObserverContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopObserverContext>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopObserverContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopObserverContext>())).retain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopObserverContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFRunLoopObserverContext>())).release as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopObserverContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFRunLoopObserverContext>())).copyDescription as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopObserverContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
impl Default for CFRunLoopObserverContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CFRunLoopObserverCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        observer: CFRunLoopObserverRef,
        activity: CFRunLoopActivity,
        info: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn CFRunLoopObserverGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFRunLoopObserverCreate(
        allocator: CFAllocatorRef,
        activities: CFOptionFlags,
        repeats: Boolean,
        order: CFIndex,
        callout: CFRunLoopObserverCallBack,
        context: *mut CFRunLoopObserverContext,
    ) -> CFRunLoopObserverRef;
}
extern "C" {
    pub fn CFRunLoopObserverCreateWithHandler(
        allocator: CFAllocatorRef,
        activities: CFOptionFlags,
        repeats: Boolean,
        order: CFIndex,
        block: *mut ::std::os::raw::c_void,
    ) -> CFRunLoopObserverRef;
}
extern "C" {
    pub fn CFRunLoopObserverGetActivities(observer: CFRunLoopObserverRef) -> CFOptionFlags;
}
extern "C" {
    pub fn CFRunLoopObserverDoesRepeat(observer: CFRunLoopObserverRef) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopObserverGetOrder(observer: CFRunLoopObserverRef) -> CFIndex;
}
extern "C" {
    pub fn CFRunLoopObserverInvalidate(observer: CFRunLoopObserverRef);
}
extern "C" {
    pub fn CFRunLoopObserverIsValid(observer: CFRunLoopObserverRef) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopObserverGetContext(
        observer: CFRunLoopObserverRef,
        context: *mut CFRunLoopObserverContext,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFRunLoopTimerContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub release: ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFRunLoopTimerContext() {
    assert_eq!(
        ::std::mem::size_of::<CFRunLoopTimerContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFRunLoopTimerContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFRunLoopTimerContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFRunLoopTimerContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopTimerContext>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopTimerContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopTimerContext>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopTimerContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopTimerContext>())).retain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopTimerContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFRunLoopTimerContext>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopTimerContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFRunLoopTimerContext>())).copyDescription as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFRunLoopTimerContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
impl Default for CFRunLoopTimerContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CFRunLoopTimerCallBack = ::std::option::Option<
    unsafe extern "C" fn(timer: CFRunLoopTimerRef, info: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn CFRunLoopTimerGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFRunLoopTimerCreate(
        allocator: CFAllocatorRef,
        fireDate: CFAbsoluteTime,
        interval: CFTimeInterval,
        flags: CFOptionFlags,
        order: CFIndex,
        callout: CFRunLoopTimerCallBack,
        context: *mut CFRunLoopTimerContext,
    ) -> CFRunLoopTimerRef;
}
extern "C" {
    pub fn CFRunLoopTimerCreateWithHandler(
        allocator: CFAllocatorRef,
        fireDate: CFAbsoluteTime,
        interval: CFTimeInterval,
        flags: CFOptionFlags,
        order: CFIndex,
        block: *mut ::std::os::raw::c_void,
    ) -> CFRunLoopTimerRef;
}
extern "C" {
    pub fn CFRunLoopTimerGetNextFireDate(timer: CFRunLoopTimerRef) -> CFAbsoluteTime;
}
extern "C" {
    pub fn CFRunLoopTimerSetNextFireDate(timer: CFRunLoopTimerRef, fireDate: CFAbsoluteTime);
}
extern "C" {
    pub fn CFRunLoopTimerGetInterval(timer: CFRunLoopTimerRef) -> CFTimeInterval;
}
extern "C" {
    pub fn CFRunLoopTimerDoesRepeat(timer: CFRunLoopTimerRef) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopTimerGetOrder(timer: CFRunLoopTimerRef) -> CFIndex;
}
extern "C" {
    pub fn CFRunLoopTimerInvalidate(timer: CFRunLoopTimerRef);
}
extern "C" {
    pub fn CFRunLoopTimerIsValid(timer: CFRunLoopTimerRef) -> Boolean;
}
extern "C" {
    pub fn CFRunLoopTimerGetContext(timer: CFRunLoopTimerRef, context: *mut CFRunLoopTimerContext);
}
extern "C" {
    pub fn CFRunLoopTimerGetTolerance(timer: CFRunLoopTimerRef) -> CFTimeInterval;
}
extern "C" {
    pub fn CFRunLoopTimerSetTolerance(timer: CFRunLoopTimerRef, tolerance: CFTimeInterval);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFSocket {
    _unused: [u8; 0],
}
pub type CFSocketRef = *mut __CFSocket;
pub type CFSocketError = CFIndex;
pub const kCFSocketSuccess: _bindgen_ty_47 = 0;
pub const kCFSocketError: _bindgen_ty_47 = -1;
pub const kCFSocketTimeout: _bindgen_ty_47 = -2;
pub type _bindgen_ty_47 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFSocketSignature {
    pub protocolFamily: SInt32,
    pub socketType: SInt32,
    pub protocol: SInt32,
    pub address: CFDataRef,
}
#[test]
fn bindgen_test_layout_CFSocketSignature() {
    assert_eq!(
        ::std::mem::size_of::<CFSocketSignature>(),
        24usize,
        concat!("Size of: ", stringify!(CFSocketSignature))
    );
    assert_eq!(
        ::std::mem::align_of::<CFSocketSignature>(),
        8usize,
        concat!("Alignment of ", stringify!(CFSocketSignature))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFSocketSignature>())).protocolFamily as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketSignature),
            "::",
            stringify!(protocolFamily)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSocketSignature>())).socketType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketSignature),
            "::",
            stringify!(socketType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSocketSignature>())).protocol as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketSignature),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSocketSignature>())).address as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketSignature),
            "::",
            stringify!(address)
        )
    );
}
impl Default for CFSocketSignature {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CFSocketCallBackType = CFOptionFlags;
pub const kCFSocketNoCallBack: _bindgen_ty_48 = 0;
pub const kCFSocketReadCallBack: _bindgen_ty_48 = 1;
pub const kCFSocketAcceptCallBack: _bindgen_ty_48 = 2;
pub const kCFSocketDataCallBack: _bindgen_ty_48 = 3;
pub const kCFSocketConnectCallBack: _bindgen_ty_48 = 4;
pub const kCFSocketWriteCallBack: _bindgen_ty_48 = 8;
pub type _bindgen_ty_48 = u32;
pub const kCFSocketAutomaticallyReenableReadCallBack: _bindgen_ty_49 = 1;
pub const kCFSocketAutomaticallyReenableAcceptCallBack: _bindgen_ty_49 = 2;
pub const kCFSocketAutomaticallyReenableDataCallBack: _bindgen_ty_49 = 3;
pub const kCFSocketAutomaticallyReenableWriteCallBack: _bindgen_ty_49 = 8;
pub const kCFSocketLeaveErrors: _bindgen_ty_49 = 64;
pub const kCFSocketCloseOnInvalidate: _bindgen_ty_49 = 128;
pub type _bindgen_ty_49 = u32;
pub type CFSocketCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        s: CFSocketRef,
        type_: CFSocketCallBackType,
        address: CFDataRef,
        data: *const ::std::os::raw::c_void,
        info: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFSocketContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub release: ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFSocketContext() {
    assert_eq!(
        ::std::mem::size_of::<CFSocketContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFSocketContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFSocketContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFSocketContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSocketContext>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSocketContext>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSocketContext>())).retain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSocketContext>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSocketContext>())).copyDescription as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSocketContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
impl Default for CFSocketContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CFSocketNativeHandle = ::std::os::raw::c_int;
extern "C" {
    pub fn CFSocketGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFSocketCreate(
        allocator: CFAllocatorRef,
        protocolFamily: SInt32,
        socketType: SInt32,
        protocol: SInt32,
        callBackTypes: CFOptionFlags,
        callout: CFSocketCallBack,
        context: *const CFSocketContext,
    ) -> CFSocketRef;
}
extern "C" {
    pub fn CFSocketCreateWithNative(
        allocator: CFAllocatorRef,
        sock: CFSocketNativeHandle,
        callBackTypes: CFOptionFlags,
        callout: CFSocketCallBack,
        context: *const CFSocketContext,
    ) -> CFSocketRef;
}
extern "C" {
    pub fn CFSocketCreateWithSocketSignature(
        allocator: CFAllocatorRef,
        signature: *const CFSocketSignature,
        callBackTypes: CFOptionFlags,
        callout: CFSocketCallBack,
        context: *const CFSocketContext,
    ) -> CFSocketRef;
}
extern "C" {
    pub fn CFSocketCreateConnectedToSocketSignature(
        allocator: CFAllocatorRef,
        signature: *const CFSocketSignature,
        callBackTypes: CFOptionFlags,
        callout: CFSocketCallBack,
        context: *const CFSocketContext,
        timeout: CFTimeInterval,
    ) -> CFSocketRef;
}
extern "C" {
    pub fn CFSocketSetAddress(s: CFSocketRef, address: CFDataRef) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketConnectToAddress(
        s: CFSocketRef,
        address: CFDataRef,
        timeout: CFTimeInterval,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketInvalidate(s: CFSocketRef);
}
extern "C" {
    pub fn CFSocketIsValid(s: CFSocketRef) -> Boolean;
}
extern "C" {
    pub fn CFSocketCopyAddress(s: CFSocketRef) -> CFDataRef;
}
extern "C" {
    pub fn CFSocketCopyPeerAddress(s: CFSocketRef) -> CFDataRef;
}
extern "C" {
    pub fn CFSocketGetContext(s: CFSocketRef, context: *mut CFSocketContext);
}
extern "C" {
    pub fn CFSocketGetNative(s: CFSocketRef) -> CFSocketNativeHandle;
}
extern "C" {
    pub fn CFSocketCreateRunLoopSource(
        allocator: CFAllocatorRef,
        s: CFSocketRef,
        order: CFIndex,
    ) -> CFRunLoopSourceRef;
}
extern "C" {
    pub fn CFSocketGetSocketFlags(s: CFSocketRef) -> CFOptionFlags;
}
extern "C" {
    pub fn CFSocketSetSocketFlags(s: CFSocketRef, flags: CFOptionFlags);
}
extern "C" {
    pub fn CFSocketDisableCallBacks(s: CFSocketRef, callBackTypes: CFOptionFlags);
}
extern "C" {
    pub fn CFSocketEnableCallBacks(s: CFSocketRef, callBackTypes: CFOptionFlags);
}
extern "C" {
    pub fn CFSocketSendData(
        s: CFSocketRef,
        address: CFDataRef,
        data: CFDataRef,
        timeout: CFTimeInterval,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketRegisterValue(
        nameServerSignature: *const CFSocketSignature,
        timeout: CFTimeInterval,
        name: CFStringRef,
        value: CFPropertyListRef,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketCopyRegisteredValue(
        nameServerSignature: *const CFSocketSignature,
        timeout: CFTimeInterval,
        name: CFStringRef,
        value: *mut CFPropertyListRef,
        nameServerAddress: *mut CFDataRef,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketRegisterSocketSignature(
        nameServerSignature: *const CFSocketSignature,
        timeout: CFTimeInterval,
        name: CFStringRef,
        signature: *const CFSocketSignature,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketCopyRegisteredSocketSignature(
        nameServerSignature: *const CFSocketSignature,
        timeout: CFTimeInterval,
        name: CFStringRef,
        signature: *mut CFSocketSignature,
        nameServerAddress: *mut CFDataRef,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketUnregister(
        nameServerSignature: *const CFSocketSignature,
        timeout: CFTimeInterval,
        name: CFStringRef,
    ) -> CFSocketError;
}
extern "C" {
    pub fn CFSocketSetDefaultNameRegistryPortNumber(port: UInt16);
}
extern "C" {
    pub fn CFSocketGetDefaultNameRegistryPortNumber() -> UInt16;
}
extern "C" {
    pub static kCFSocketCommandKey: CFStringRef;
}
extern "C" {
    pub static kCFSocketNameKey: CFStringRef;
}
extern "C" {
    pub static kCFSocketValueKey: CFStringRef;
}
extern "C" {
    pub static kCFSocketResultKey: CFStringRef;
}
extern "C" {
    pub static kCFSocketErrorKey: CFStringRef;
}
extern "C" {
    pub static kCFSocketRegisterCommand: CFStringRef;
}
extern "C" {
    pub static kCFSocketRetrieveCommand: CFStringRef;
}
pub type os_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type os_block_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct accessx_descriptor {
    pub ad_name_offset: ::std::os::raw::c_uint,
    pub ad_flags: ::std::os::raw::c_int,
    pub ad_pad: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_accessx_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<accessx_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<accessx_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<accessx_descriptor>())).ad_name_offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_name_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<accessx_descriptor>())).ad_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<accessx_descriptor>())).ad_pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_pad)
        )
    );
}
extern "C" {
    pub fn getattrlistbulk(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: usize,
        arg6: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: usize,
        arg6: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: uid_t,
        arg4: gid_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn access(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn chdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn close(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execve(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn fpathconf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getcwd(arg1: *mut ::std::os::raw::c_char, arg2: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getgroups(arg1: ::std::os::raw::c_int, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn isatty(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(arg1: ::std::os::raw::c_int, arg2: off_t, arg3: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    pub fn pathconf(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pipe(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn rmdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgid(arg1: pid_t, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn setuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sysconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn tcgetpgrp(arg1: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(arg1: ::std::os::raw::c_int, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: usize,
    ) -> isize;
}
extern "C" {
    pub fn confstr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn getopt(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(arg1: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn chroot(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn encrypt(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fchdir(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lchown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbyte: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn sbrk(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setpgrp() -> pid_t;
}
extern "C" {
    pub fn setregid(arg1: gid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(arg1: uid_t, arg2: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn truncate(arg1: *const ::std::os::raw::c_char, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ualarm(arg1: useconds_t, arg2: useconds_t) -> useconds_t;
}
extern "C" {
    pub fn usleep(arg1: useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(arg1: ::std::os::raw::c_int, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin_r(arg1: *mut ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(arg1: ::std::os::raw::c_int, arg2: uid_t, arg3: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(arg1: *mut ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn setegid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
pub type uuid_t = __darwin_uuid_t;
extern "C" {
    pub fn accessx_np(
        arg1: *const accessx_descriptor,
        arg2: usize,
        arg3: *mut ::std::os::raw::c_int,
        arg4: uid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn execvP(
        __file: *const ::std::os::raw::c_char,
        __searchpath: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflagstostr(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getdomainname(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getgrouplist(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostuuid(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getmode(arg1: *const ::std::os::raw::c_void, arg2: mode_t) -> mode_t;
}
extern "C" {
    pub fn getpeereid(
        arg1: ::std::os::raw::c_int,
        arg2: *mut uid_t,
        arg3: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initgroups(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn issetugid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mknod(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
        arg3: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpath_np(path: *const ::std::os::raw::c_char, omode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpathat_np(
        dfd: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        omode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp(
        path: *mut ::std::os::raw::c_char,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp_dprotected_np(
        path: *mut ::std::os::raw::c_char,
        dpclass: ::std::os::raw::c_int,
        dpflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtempat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nfssvc(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setugid_np(arg1: uid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getugid_np(arg1: *mut uid_t, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reboot(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd_af(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport_af(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok_sa(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgroups(arg1: ::std::os::raw::c_int, arg2: *const gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn sethostname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setmode(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setrgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setruid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn setwgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtofflags(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swapon(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn undelete(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unwhiteout(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syscall(arg1: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exchangedata(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentriesattr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
        arg7: *mut ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fssearchblock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct searchstate {
    _unused: [u8; 0],
}
extern "C" {
    pub fn searchfs(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut fssearchblock,
        arg3: *mut ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: *mut searchstate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsctl(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsctl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync_volume_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync_volume_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optreset: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flock {
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        24usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_pid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_type as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_whence as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_whence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flocktimeout {
    pub fl: flock,
    pub timeout: timespec,
}
#[test]
fn bindgen_test_layout_flocktimeout() {
    assert_eq!(
        ::std::mem::size_of::<flocktimeout>(),
        40usize,
        concat!("Size of: ", stringify!(flocktimeout))
    );
    assert_eq!(
        ::std::mem::align_of::<flocktimeout>(),
        8usize,
        concat!("Alignment of ", stringify!(flocktimeout))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flocktimeout>())).fl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flocktimeout),
            "::",
            stringify!(fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flocktimeout>())).timeout as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flocktimeout),
            "::",
            stringify!(timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct radvisory {
    pub ra_offset: off_t,
    pub ra_count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_radvisory() {
    assert_eq!(
        ::std::mem::size_of::<radvisory>(),
        16usize,
        concat!("Size of: ", stringify!(radvisory))
    );
    assert_eq!(
        ::std::mem::align_of::<radvisory>(),
        8usize,
        concat!("Alignment of ", stringify!(radvisory))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<radvisory>())).ra_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radvisory),
            "::",
            stringify!(ra_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<radvisory>())).ra_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(radvisory),
            "::",
            stringify!(ra_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fcodeblobs {
    pub f_cd_hash: *mut ::std::os::raw::c_void,
    pub f_hash_size: usize,
    pub f_cd_buffer: *mut ::std::os::raw::c_void,
    pub f_cd_size: usize,
    pub f_out_size: *mut ::std::os::raw::c_uint,
    pub f_arch: ::std::os::raw::c_int,
    pub __padding: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fcodeblobs() {
    assert_eq!(
        ::std::mem::size_of::<fcodeblobs>(),
        48usize,
        concat!("Size of: ", stringify!(fcodeblobs))
    );
    assert_eq!(
        ::std::mem::align_of::<fcodeblobs>(),
        8usize,
        concat!("Alignment of ", stringify!(fcodeblobs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).f_cd_hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(f_cd_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).f_hash_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(f_hash_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).f_cd_buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(f_cd_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).f_cd_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(f_cd_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).f_out_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(f_out_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).f_arch as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(f_arch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).__padding as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(__padding)
        )
    );
}
impl Default for fcodeblobs {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type fcodeblobs_t = fcodeblobs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsignatures {
    pub fs_file_start: off_t,
    pub fs_blob_start: *mut ::std::os::raw::c_void,
    pub fs_blob_size: usize,
}
#[test]
fn bindgen_test_layout_fsignatures() {
    assert_eq!(
        ::std::mem::size_of::<fsignatures>(),
        24usize,
        concat!("Size of: ", stringify!(fsignatures))
    );
    assert_eq!(
        ::std::mem::align_of::<fsignatures>(),
        8usize,
        concat!("Alignment of ", stringify!(fsignatures))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsignatures>())).fs_file_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fsignatures),
            "::",
            stringify!(fs_file_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsignatures>())).fs_blob_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fsignatures),
            "::",
            stringify!(fs_blob_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsignatures>())).fs_blob_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fsignatures),
            "::",
            stringify!(fs_blob_size)
        )
    );
}
impl Default for fsignatures {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type fsignatures_t = fsignatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fchecklv {
    pub lv_file_start: off_t,
    pub lv_error_message_size: usize,
    pub lv_error_message: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_fchecklv() {
    assert_eq!(
        ::std::mem::size_of::<fchecklv>(),
        24usize,
        concat!("Size of: ", stringify!(fchecklv))
    );
    assert_eq!(
        ::std::mem::align_of::<fchecklv>(),
        8usize,
        concat!("Alignment of ", stringify!(fchecklv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fchecklv>())).lv_file_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fchecklv),
            "::",
            stringify!(lv_file_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fchecklv>())).lv_error_message_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fchecklv),
            "::",
            stringify!(lv_error_message_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fchecklv>())).lv_error_message as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fchecklv),
            "::",
            stringify!(lv_error_message)
        )
    );
}
impl Default for fchecklv {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type fchecklv_t = fchecklv;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fstore {
    pub fst_flags: ::std::os::raw::c_uint,
    pub fst_posmode: ::std::os::raw::c_int,
    pub fst_offset: off_t,
    pub fst_length: off_t,
    pub fst_bytesalloc: off_t,
}
#[test]
fn bindgen_test_layout_fstore() {
    assert_eq!(
        ::std::mem::size_of::<fstore>(),
        32usize,
        concat!("Size of: ", stringify!(fstore))
    );
    assert_eq!(
        ::std::mem::align_of::<fstore>(),
        8usize,
        concat!("Alignment of ", stringify!(fstore))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstore>())).fst_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstore>())).fst_posmode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_posmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstore>())).fst_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstore>())).fst_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstore>())).fst_bytesalloc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_bytesalloc)
        )
    );
}
pub type fstore_t = fstore;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fpunchhole {
    pub fp_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fp_offset: off_t,
    pub fp_length: off_t,
}
#[test]
fn bindgen_test_layout_fpunchhole() {
    assert_eq!(
        ::std::mem::size_of::<fpunchhole>(),
        24usize,
        concat!("Size of: ", stringify!(fpunchhole))
    );
    assert_eq!(
        ::std::mem::align_of::<fpunchhole>(),
        8usize,
        concat!("Alignment of ", stringify!(fpunchhole))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpunchhole>())).fp_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpunchhole),
            "::",
            stringify!(fp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpunchhole>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fpunchhole),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpunchhole>())).fp_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpunchhole),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpunchhole>())).fp_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpunchhole),
            "::",
            stringify!(fp_length)
        )
    );
}
pub type fpunchhole_t = fpunchhole;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ftrimactivefile {
    pub fta_offset: off_t,
    pub fta_length: off_t,
}
#[test]
fn bindgen_test_layout_ftrimactivefile() {
    assert_eq!(
        ::std::mem::size_of::<ftrimactivefile>(),
        16usize,
        concat!("Size of: ", stringify!(ftrimactivefile))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrimactivefile>(),
        8usize,
        concat!("Alignment of ", stringify!(ftrimactivefile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrimactivefile>())).fta_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrimactivefile),
            "::",
            stringify!(fta_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrimactivefile>())).fta_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrimactivefile),
            "::",
            stringify!(fta_length)
        )
    );
}
pub type ftrimactivefile_t = ftrimactivefile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fbootstraptransfer {
    pub fbt_offset: off_t,
    pub fbt_length: usize,
    pub fbt_buffer: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_fbootstraptransfer() {
    assert_eq!(
        ::std::mem::size_of::<fbootstraptransfer>(),
        24usize,
        concat!("Size of: ", stringify!(fbootstraptransfer))
    );
    assert_eq!(
        ::std::mem::align_of::<fbootstraptransfer>(),
        8usize,
        concat!("Alignment of ", stringify!(fbootstraptransfer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fbootstraptransfer>())).fbt_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fbootstraptransfer),
            "::",
            stringify!(fbt_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fbootstraptransfer>())).fbt_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fbootstraptransfer),
            "::",
            stringify!(fbt_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fbootstraptransfer>())).fbt_buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fbootstraptransfer),
            "::",
            stringify!(fbt_buffer)
        )
    );
}
impl Default for fbootstraptransfer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type fbootstraptransfer_t = fbootstraptransfer;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct log2phys {
    pub _bindgen_opaque_blob: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_log2phys() {
    assert_eq!(
        ::std::mem::size_of::<log2phys>(),
        20usize,
        concat!("Size of: ", stringify!(log2phys))
    );
    assert_eq!(
        ::std::mem::align_of::<log2phys>(),
        4usize,
        concat!("Alignment of ", stringify!(log2phys))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _filesec {
    _unused: [u8; 0],
}
pub type filesec_t = *mut _filesec;
pub const filesec_property_t_FILESEC_OWNER: filesec_property_t = 1;
pub const filesec_property_t_FILESEC_GROUP: filesec_property_t = 2;
pub const filesec_property_t_FILESEC_UUID: filesec_property_t = 3;
pub const filesec_property_t_FILESEC_MODE: filesec_property_t = 4;
pub const filesec_property_t_FILESEC_ACL: filesec_property_t = 5;
pub const filesec_property_t_FILESEC_GRPUUID: filesec_property_t = 6;
pub const filesec_property_t_FILESEC_ACL_RAW: filesec_property_t = 100;
pub const filesec_property_t_FILESEC_ACL_ALLOCSIZE: filesec_property_t = 101;
pub type filesec_property_t = u32;
extern "C" {
    pub fn open(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn creat(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcntl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open_dprotected_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flock(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_init() -> filesec_t;
}
extern "C" {
    pub fn filesec_dup(arg1: filesec_t) -> filesec_t;
}
extern "C" {
    pub fn filesec_free(arg1: filesec_t);
}
extern "C" {
    pub fn filesec_get_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_query_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_set_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_unset_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn os_retain(object: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn os_release(object: *mut ::std::os::raw::c_void);
}
pub type dispatch_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct time_value {
    pub seconds: integer_t,
    pub microseconds: integer_t,
}
#[test]
fn bindgen_test_layout_time_value() {
    assert_eq!(
        ::std::mem::size_of::<time_value>(),
        8usize,
        concat!("Size of: ", stringify!(time_value))
    );
    assert_eq!(
        ::std::mem::align_of::<time_value>(),
        4usize,
        concat!("Alignment of ", stringify!(time_value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<time_value>())).seconds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(time_value),
            "::",
            stringify!(seconds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<time_value>())).microseconds as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(time_value),
            "::",
            stringify!(microseconds)
        )
    );
}
pub type time_value_t = time_value;
pub type alarm_type_t = ::std::os::raw::c_int;
pub type sleep_type_t = ::std::os::raw::c_int;
pub type clock_id_t = ::std::os::raw::c_int;
pub type clock_flavor_t = ::std::os::raw::c_int;
pub type clock_attr_t = *mut ::std::os::raw::c_int;
pub type clock_res_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_timespec {
    pub tv_sec: ::std::os::raw::c_uint,
    pub tv_nsec: clock_res_t,
}
#[test]
fn bindgen_test_layout_mach_timespec() {
    assert_eq!(
        ::std::mem::size_of::<mach_timespec>(),
        8usize,
        concat!("Size of: ", stringify!(mach_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_timespec>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_timespec>())).tv_nsec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type mach_timespec_t = mach_timespec;
pub type dispatch_time_t = u64;
extern "C" {
    pub fn dispatch_time(when: dispatch_time_t, delta: i64) -> dispatch_time_t;
}
extern "C" {
    pub fn dispatch_walltime(when: *const timespec, delta: i64) -> dispatch_time_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dispatch_object_t {
    pub _os_obj: *mut _os_object_s,
    pub _do: *mut dispatch_object_s,
    pub _dc: *mut dispatch_continuation_s,
    pub _dq: *mut dispatch_queue_s,
    pub _dqa: *mut dispatch_queue_attr_s,
    pub _dg: *mut dispatch_group_s,
    pub _ds: *mut dispatch_source_s,
    pub _dm: *mut dispatch_mach_s,
    pub _dmsg: *mut dispatch_mach_msg_s,
    pub _dsa: *mut dispatch_source_attr_s,
    pub _dsema: *mut dispatch_semaphore_s,
    pub _ddata: *mut dispatch_data_s,
    pub _dchannel: *mut dispatch_io_s,
    pub _doperation: *mut dispatch_operation_s,
    pub _ddisk: *mut dispatch_disk_s,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_dispatch_object_t() {
    assert_eq!(
        ::std::mem::size_of::<dispatch_object_t>(),
        8usize,
        concat!("Size of: ", stringify!(dispatch_object_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dispatch_object_t>(),
        8usize,
        concat!("Alignment of ", stringify!(dispatch_object_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._os_obj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_os_obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._do as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_do)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._dc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._dq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._dqa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dqa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._dg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._ds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._dm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._dmsg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dmsg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._dsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._dsema as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dsema)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._ddata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_ddata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._dchannel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_dchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._doperation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_doperation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatch_object_t>()))._ddisk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatch_object_t),
            "::",
            stringify!(_ddisk)
        )
    );
}
impl Default for dispatch_object_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type dispatch_block_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn dispatch_retain(object: dispatch_object_t);
}
extern "C" {
    pub fn dispatch_release(object: dispatch_object_t);
}
extern "C" {
    pub fn dispatch_get_context(object: dispatch_object_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dispatch_set_context(object: dispatch_object_t, context: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn dispatch_set_finalizer_f(object: dispatch_object_t, finalizer: dispatch_function_t);
}
extern "C" {
    pub fn dispatch_activate(object: dispatch_object_t);
}
extern "C" {
    pub fn dispatch_suspend(object: dispatch_object_t);
}
extern "C" {
    pub fn dispatch_resume(object: dispatch_object_t);
}
extern "C" {
    pub fn dispatch_wait(
        object: *mut ::std::os::raw::c_void,
        timeout: dispatch_time_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dispatch_notify(
        object: *mut ::std::os::raw::c_void,
        queue: dispatch_object_t,
        notification_block: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_cancel(object: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn dispatch_testcancel(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dispatch_debug(object: dispatch_object_t, message: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn dispatch_debugv(
        object: dispatch_object_t,
        message: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_50 = 33;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_50 = 25;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_50 = 21;
pub const QOS_CLASS_UTILITY: _bindgen_ty_50 = 17;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_50 = 9;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_50 = 0;
pub type _bindgen_ty_50 = u32;
pub type qos_class_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn qos_class_self() -> qos_class_t;
}
extern "C" {
    pub fn qos_class_main() -> qos_class_t;
}
pub type dispatch_queue_t = *mut dispatch_queue_s;
extern "C" {
    pub fn dispatch_async(queue: dispatch_queue_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_async_f(
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_sync(queue: dispatch_queue_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_sync_f(
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_apply(
        iterations: usize,
        queue: dispatch_queue_t,
        block: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn dispatch_apply_f(
        iterations: usize,
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: usize),
        >,
    );
}
extern "C" {
    pub fn dispatch_get_current_queue() -> dispatch_queue_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_queue_s {
    pub _address: u8,
}
extern "C" {
    pub static mut _dispatch_main_q: dispatch_queue_s;
}
pub type dispatch_queue_priority_t = ::std::os::raw::c_long;
pub type dispatch_qos_class_t = qos_class_t;
extern "C" {
    pub fn dispatch_get_global_queue(
        identifier: ::std::os::raw::c_long,
        flags: ::std::os::raw::c_ulong,
    ) -> dispatch_queue_t;
}
pub type dispatch_queue_attr_t = *mut dispatch_queue_attr_s;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_queue_attr_s {
    pub _address: u8,
}
extern "C" {
    pub static mut _dispatch_queue_attr_concurrent: dispatch_queue_attr_s;
}
extern "C" {
    pub fn dispatch_queue_attr_make_initially_inactive(
        attr: dispatch_queue_attr_t,
    ) -> dispatch_queue_attr_t;
}
pub const DISPATCH_AUTORELEASE_FREQUENCY_INHERIT: _bindgen_ty_51 = 0;
pub const DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM: _bindgen_ty_51 = 1;
pub const DISPATCH_AUTORELEASE_FREQUENCY_NEVER: _bindgen_ty_51 = 2;
pub type _bindgen_ty_51 = u32;
pub type dispatch_autorelease_frequency_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn dispatch_queue_attr_make_with_autorelease_frequency(
        attr: dispatch_queue_attr_t,
        frequency: dispatch_autorelease_frequency_t,
    ) -> dispatch_queue_attr_t;
}
extern "C" {
    pub fn dispatch_queue_attr_make_with_qos_class(
        attr: dispatch_queue_attr_t,
        qos_class: dispatch_qos_class_t,
        relative_priority: ::std::os::raw::c_int,
    ) -> dispatch_queue_attr_t;
}
extern "C" {
    pub fn dispatch_queue_create_with_target(
        label: *const ::std::os::raw::c_char,
        attr: dispatch_queue_attr_t,
        target: dispatch_queue_t,
    ) -> dispatch_queue_t;
}
extern "C" {
    pub fn dispatch_queue_create(
        label: *const ::std::os::raw::c_char,
        attr: dispatch_queue_attr_t,
    ) -> dispatch_queue_t;
}
extern "C" {
    pub fn dispatch_queue_get_label(queue: dispatch_queue_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn dispatch_queue_get_qos_class(
        queue: dispatch_queue_t,
        relative_priority_ptr: *mut ::std::os::raw::c_int,
    ) -> dispatch_qos_class_t;
}
extern "C" {
    pub fn dispatch_set_target_queue(object: dispatch_object_t, queue: dispatch_queue_t);
}
extern "C" {
    pub fn dispatch_main();
}
extern "C" {
    pub fn dispatch_after(when: dispatch_time_t, queue: dispatch_queue_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_after_f(
        when: dispatch_time_t,
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_barrier_async(queue: dispatch_queue_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_barrier_async_f(
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_barrier_sync(queue: dispatch_queue_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_barrier_sync_f(
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_queue_set_specific(
        queue: dispatch_queue_t,
        key: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
        destructor: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_queue_get_specific(
        queue: dispatch_queue_t,
        key: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dispatch_get_specific(key: *const ::std::os::raw::c_void)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dispatch_assert_queue(queue: dispatch_queue_t);
}
extern "C" {
    pub fn dispatch_assert_queue_barrier(queue: dispatch_queue_t);
}
extern "C" {
    pub fn dispatch_assert_queue_not(queue: dispatch_queue_t);
}
pub const DISPATCH_BLOCK_BARRIER: _bindgen_ty_52 = 1;
pub const DISPATCH_BLOCK_DETACHED: _bindgen_ty_52 = 2;
pub const DISPATCH_BLOCK_ASSIGN_CURRENT: _bindgen_ty_52 = 4;
pub const DISPATCH_BLOCK_NO_QOS_CLASS: _bindgen_ty_52 = 8;
pub const DISPATCH_BLOCK_INHERIT_QOS_CLASS: _bindgen_ty_52 = 16;
pub const DISPATCH_BLOCK_ENFORCE_QOS_CLASS: _bindgen_ty_52 = 32;
pub type _bindgen_ty_52 = u32;
pub type dispatch_block_flags_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn dispatch_block_create(
        flags: dispatch_block_flags_t,
        block: dispatch_block_t,
    ) -> dispatch_block_t;
}
extern "C" {
    pub fn dispatch_block_create_with_qos_class(
        flags: dispatch_block_flags_t,
        qos_class: dispatch_qos_class_t,
        relative_priority: ::std::os::raw::c_int,
        block: dispatch_block_t,
    ) -> dispatch_block_t;
}
extern "C" {
    pub fn dispatch_block_perform(flags: dispatch_block_flags_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_block_wait(
        block: dispatch_block_t,
        timeout: dispatch_time_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dispatch_block_notify(
        block: dispatch_block_t,
        queue: dispatch_queue_t,
        notification_block: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_block_cancel(block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_block_testcancel(block: dispatch_block_t) -> ::std::os::raw::c_long;
}
pub type kern_return_t = ::std::os::raw::c_int;
pub type mach_msg_timeout_t = natural_t;
pub type mach_msg_bits_t = ::std::os::raw::c_uint;
pub type mach_msg_size_t = natural_t;
pub type mach_msg_id_t = integer_t;
pub type mach_msg_priority_t = ::std::os::raw::c_uint;
pub type mach_msg_type_name_t = ::std::os::raw::c_uint;
pub type mach_msg_copy_options_t = ::std::os::raw::c_uint;
pub type mach_msg_descriptor_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_type_descriptor_t {
    pub pad1: natural_t,
    pub pad2: mach_msg_size_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_mach_msg_type_descriptor_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_type_descriptor_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_type_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_type_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_type_descriptor_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_type_descriptor_t>())).pad1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_type_descriptor_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_type_descriptor_t>())).pad2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_type_descriptor_t),
            "::",
            stringify!(pad2)
        )
    );
}
impl mach_msg_type_descriptor_t {
    #[inline]
    pub fn pad3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pad3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pad3: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let pad3: u32 = unsafe { ::std::mem::transmute(pad3) };
            pad3 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_port_descriptor_t {
    pub name: mach_port_t,
    pub pad1: mach_msg_size_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_mach_msg_port_descriptor_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_port_descriptor_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_port_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_port_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_port_descriptor_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_port_descriptor_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_port_descriptor_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_port_descriptor_t>())).pad1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_port_descriptor_t),
            "::",
            stringify!(pad1)
        )
    );
}
impl mach_msg_port_descriptor_t {
    #[inline]
    pub fn pad2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_pad2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pad2: ::std::os::raw::c_uint,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let pad2: u32 = unsafe { ::std::mem::transmute(pad2) };
            pad2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_ool_descriptor32_t {
    pub address: u32,
    pub size: mach_msg_size_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor32_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_descriptor32_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_ool_descriptor32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_descriptor32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_descriptor32_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_ool_descriptor32_t>())).address as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor32_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_ool_descriptor32_t>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_descriptor32_t),
            "::",
            stringify!(size)
        )
    );
}
impl mach_msg_ool_descriptor32_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        pad1: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_ool_descriptor64_t {
    pub _bindgen_opaque_blob: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor64_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_descriptor64_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_descriptor64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_descriptor64_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_descriptor64_t))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_ool_descriptor_t {
    pub _bindgen_opaque_blob: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_descriptor_t))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_ool_ports_descriptor32_t {
    pub address: u32,
    pub count: mach_msg_size_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor32_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_ports_descriptor32_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_ports_descriptor32_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_ool_ports_descriptor32_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_ool_ports_descriptor32_t>())).address as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor32_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_ool_ports_descriptor32_t>())).count as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_ool_ports_descriptor32_t),
            "::",
            stringify!(count)
        )
    );
}
impl mach_msg_ool_ports_descriptor32_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_ool_ports_descriptor64_t {
    pub _bindgen_opaque_blob: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor64_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_ports_descriptor64_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_ports_descriptor64_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_ool_ports_descriptor64_t)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_ool_ports_descriptor_t {
    pub _bindgen_opaque_blob: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_ports_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_ports_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_ports_descriptor_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mach_msg_descriptor_t {
    pub port: mach_msg_port_descriptor_t,
    pub out_of_line: mach_msg_ool_descriptor_t,
    pub ool_ports: mach_msg_ool_ports_descriptor_t,
    pub type_: mach_msg_type_descriptor_t,
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_mach_msg_descriptor_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_descriptor_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_descriptor_t>())).port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_descriptor_t>())).out_of_line as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(out_of_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_descriptor_t>())).ool_ports as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(ool_ports)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_descriptor_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_descriptor_t),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for mach_msg_descriptor_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_body_t {
    pub msgh_descriptor_count: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_body_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_body_t>(),
        4usize,
        concat!("Size of: ", stringify!(mach_msg_body_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_body_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_body_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_body_t>())).msgh_descriptor_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_body_t),
            "::",
            stringify!(msgh_descriptor_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_header_t {
    pub msgh_bits: mach_msg_bits_t,
    pub msgh_size: mach_msg_size_t,
    pub msgh_remote_port: mach_port_t,
    pub msgh_local_port: mach_port_t,
    pub msgh_voucher_port: mach_port_name_t,
    pub msgh_id: mach_msg_id_t,
}
#[test]
fn bindgen_test_layout_mach_msg_header_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_header_t>(),
        24usize,
        concat!("Size of: ", stringify!(mach_msg_header_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_header_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_header_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_header_t>())).msgh_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_header_t>())).msgh_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_header_t>())).msgh_remote_port as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_remote_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_header_t>())).msgh_local_port as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_local_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_header_t>())).msgh_voucher_port as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_voucher_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_header_t>())).msgh_id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_header_t),
            "::",
            stringify!(msgh_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_base_t {
    pub header: mach_msg_header_t,
    pub body: mach_msg_body_t,
}
#[test]
fn bindgen_test_layout_mach_msg_base_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_base_t>(),
        28usize,
        concat!("Size of: ", stringify!(mach_msg_base_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_base_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_base_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_base_t>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_base_t),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_base_t>())).body as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_base_t),
            "::",
            stringify!(body)
        )
    );
}
pub type mach_msg_trailer_type_t = ::std::os::raw::c_uint;
pub type mach_msg_trailer_size_t = ::std::os::raw::c_uint;
pub type mach_msg_trailer_info_t = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_trailer_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_trailer_t>(),
        8usize,
        concat!("Size of: ", stringify!(mach_msg_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_trailer_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_trailer_t>())).msgh_trailer_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_trailer_t>())).msgh_trailer_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_seqno_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
}
#[test]
fn bindgen_test_layout_mach_msg_seqno_trailer_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_seqno_trailer_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_seqno_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_seqno_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_seqno_trailer_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_seqno_trailer_t>())).msgh_trailer_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_seqno_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_seqno_trailer_t>())).msgh_trailer_size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_seqno_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_seqno_trailer_t>())).msgh_seqno as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_seqno_trailer_t),
            "::",
            stringify!(msgh_seqno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct security_token_t {
    pub val: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_security_token_t() {
    assert_eq!(
        ::std::mem::size_of::<security_token_t>(),
        8usize,
        concat!("Size of: ", stringify!(security_token_t))
    );
    assert_eq!(
        ::std::mem::align_of::<security_token_t>(),
        4usize,
        concat!("Alignment of ", stringify!(security_token_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<security_token_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(security_token_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_security_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
}
#[test]
fn bindgen_test_layout_mach_msg_security_trailer_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_security_trailer_t>(),
        20usize,
        concat!("Size of: ", stringify!(mach_msg_security_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_security_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_security_trailer_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_security_trailer_t>())).msgh_trailer_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_security_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_security_trailer_t>())).msgh_trailer_size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_security_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_security_trailer_t>())).msgh_seqno as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_security_trailer_t),
            "::",
            stringify!(msgh_seqno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_security_trailer_t>())).msgh_sender as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_security_trailer_t),
            "::",
            stringify!(msgh_sender)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audit_token_t {
    pub val: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout_audit_token_t() {
    assert_eq!(
        ::std::mem::size_of::<audit_token_t>(),
        32usize,
        concat!("Size of: ", stringify!(audit_token_t))
    );
    assert_eq!(
        ::std::mem::align_of::<audit_token_t>(),
        4usize,
        concat!("Alignment of ", stringify!(audit_token_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<audit_token_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audit_token_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_audit_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
    pub msgh_audit: audit_token_t,
}
#[test]
fn bindgen_test_layout_mach_msg_audit_trailer_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_audit_trailer_t>(),
        52usize,
        concat!("Size of: ", stringify!(mach_msg_audit_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_audit_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_audit_trailer_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_audit_trailer_t>())).msgh_trailer_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_trailer_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_audit_trailer_t>())).msgh_trailer_size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_trailer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_audit_trailer_t>())).msgh_seqno as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_seqno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_audit_trailer_t>())).msgh_sender as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_sender)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mach_msg_audit_trailer_t>())).msgh_audit as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_audit_trailer_t),
            "::",
            stringify!(msgh_audit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_context_trailer_t {
    pub _bindgen_opaque_blob: [u32; 15usize],
}
#[test]
fn bindgen_test_layout_mach_msg_context_trailer_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_context_trailer_t>(),
        60usize,
        concat!("Size of: ", stringify!(mach_msg_context_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_context_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_context_trailer_t))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct msg_labels_t {
    pub sender: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_msg_labels_t() {
    assert_eq!(
        ::std::mem::size_of::<msg_labels_t>(),
        4usize,
        concat!("Size of: ", stringify!(msg_labels_t))
    );
    assert_eq!(
        ::std::mem::align_of::<msg_labels_t>(),
        4usize,
        concat!("Alignment of ", stringify!(msg_labels_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msg_labels_t>())).sender as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msg_labels_t),
            "::",
            stringify!(sender)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_mac_trailer_t {
    pub _bindgen_opaque_blob: [u32; 17usize],
}
#[test]
fn bindgen_test_layout_mach_msg_mac_trailer_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_mac_trailer_t>(),
        68usize,
        concat!("Size of: ", stringify!(mach_msg_mac_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_mac_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_mac_trailer_t))
    );
}
pub type mach_msg_max_trailer_t = mach_msg_mac_trailer_t;
pub type mach_msg_format_0_trailer_t = mach_msg_security_trailer_t;
extern "C" {
    pub static mut KERNEL_SECURITY_TOKEN: security_token_t;
}
extern "C" {
    pub static mut KERNEL_AUDIT_TOKEN: audit_token_t;
}
pub type mach_msg_options_t = integer_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_empty_send_t {
    pub header: mach_msg_header_t,
}
#[test]
fn bindgen_test_layout_mach_msg_empty_send_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_empty_send_t>(),
        24usize,
        concat!("Size of: ", stringify!(mach_msg_empty_send_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_empty_send_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_empty_send_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_empty_send_t>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_send_t),
            "::",
            stringify!(header)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_msg_empty_rcv_t {
    pub header: mach_msg_header_t,
    pub trailer: mach_msg_trailer_t,
}
#[test]
fn bindgen_test_layout_mach_msg_empty_rcv_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_empty_rcv_t>(),
        32usize,
        concat!("Size of: ", stringify!(mach_msg_empty_rcv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_empty_rcv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_empty_rcv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_empty_rcv_t>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_rcv_t),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_empty_rcv_t>())).trailer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_rcv_t),
            "::",
            stringify!(trailer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mach_msg_empty_t {
    pub send: mach_msg_empty_send_t,
    pub rcv: mach_msg_empty_rcv_t,
    _bindgen_union_align: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_mach_msg_empty_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_empty_t>(),
        32usize,
        concat!("Size of: ", stringify!(mach_msg_empty_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_empty_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_empty_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_empty_t>())).send as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_t),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mach_msg_empty_t>())).rcv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mach_msg_empty_t),
            "::",
            stringify!(rcv)
        )
    );
}
impl Default for mach_msg_empty_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type mach_msg_type_size_t = natural_t;
pub type mach_msg_type_number_t = natural_t;
pub type mach_msg_option_t = integer_t;
pub type mach_msg_return_t = kern_return_t;
extern "C" {
    pub fn mach_msg_overwrite(
        msg: *mut mach_msg_header_t,
        option: mach_msg_option_t,
        send_size: mach_msg_size_t,
        rcv_size: mach_msg_size_t,
        rcv_name: mach_port_name_t,
        timeout: mach_msg_timeout_t,
        notify: mach_port_name_t,
        rcv_msg: *mut mach_msg_header_t,
        rcv_limit: mach_msg_size_t,
    ) -> mach_msg_return_t;
}
extern "C" {
    pub fn mach_msg(
        msg: *mut mach_msg_header_t,
        option: mach_msg_option_t,
        send_size: mach_msg_size_t,
        rcv_size: mach_msg_size_t,
        rcv_name: mach_port_name_t,
        timeout: mach_msg_timeout_t,
        notify: mach_port_name_t,
    ) -> mach_msg_return_t;
}
extern "C" {
    pub fn mach_voucher_deallocate(voucher: mach_port_name_t) -> kern_return_t;
}
pub type dispatch_source_t = *mut dispatch_source_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatch_source_type_s {
    _unused: [u8; 0],
}
pub type dispatch_source_type_t = *const dispatch_source_type_s;
extern "C" {
    pub static _dispatch_source_type_data_add: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_data_or: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_data_replace: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_mach_send: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_mach_recv: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_memorypressure: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_proc: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_read: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_signal: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_timer: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_vnode: dispatch_source_type_s;
}
extern "C" {
    pub static _dispatch_source_type_write: dispatch_source_type_s;
}
pub type dispatch_source_mach_send_flags_t = ::std::os::raw::c_ulong;
pub type dispatch_source_memorypressure_flags_t = ::std::os::raw::c_ulong;
pub type dispatch_source_proc_flags_t = ::std::os::raw::c_ulong;
pub type dispatch_source_vnode_flags_t = ::std::os::raw::c_ulong;
pub type dispatch_source_timer_flags_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn dispatch_source_create(
        type_: dispatch_source_type_t,
        handle: usize,
        mask: ::std::os::raw::c_ulong,
        queue: dispatch_queue_t,
    ) -> dispatch_source_t;
}
extern "C" {
    pub fn dispatch_source_set_event_handler(source: dispatch_source_t, handler: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_source_set_event_handler_f(
        source: dispatch_source_t,
        handler: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_source_set_cancel_handler(source: dispatch_source_t, handler: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_source_set_cancel_handler_f(
        source: dispatch_source_t,
        handler: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_source_cancel(source: dispatch_source_t);
}
extern "C" {
    pub fn dispatch_source_testcancel(source: dispatch_source_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dispatch_source_get_handle(source: dispatch_source_t) -> usize;
}
extern "C" {
    pub fn dispatch_source_get_mask(source: dispatch_source_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn dispatch_source_get_data(source: dispatch_source_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn dispatch_source_merge_data(source: dispatch_source_t, value: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn dispatch_source_set_timer(
        source: dispatch_source_t,
        start: dispatch_time_t,
        interval: u64,
        leeway: u64,
    );
}
extern "C" {
    pub fn dispatch_source_set_registration_handler(
        source: dispatch_source_t,
        handler: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_source_set_registration_handler_f(
        source: dispatch_source_t,
        handler: dispatch_function_t,
    );
}
pub type dispatch_group_t = *mut dispatch_group_s;
extern "C" {
    pub fn dispatch_group_create() -> dispatch_group_t;
}
extern "C" {
    pub fn dispatch_group_async(
        group: dispatch_group_t,
        queue: dispatch_queue_t,
        block: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_group_async_f(
        group: dispatch_group_t,
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_group_wait(
        group: dispatch_group_t,
        timeout: dispatch_time_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dispatch_group_notify(
        group: dispatch_group_t,
        queue: dispatch_queue_t,
        block: dispatch_block_t,
    );
}
extern "C" {
    pub fn dispatch_group_notify_f(
        group: dispatch_group_t,
        queue: dispatch_queue_t,
        context: *mut ::std::os::raw::c_void,
        work: dispatch_function_t,
    );
}
extern "C" {
    pub fn dispatch_group_enter(group: dispatch_group_t);
}
extern "C" {
    pub fn dispatch_group_leave(group: dispatch_group_t);
}
pub type dispatch_semaphore_t = *mut dispatch_semaphore_s;
extern "C" {
    pub fn dispatch_semaphore_create(value: ::std::os::raw::c_long) -> dispatch_semaphore_t;
}
extern "C" {
    pub fn dispatch_semaphore_wait(
        dsema: dispatch_semaphore_t,
        timeout: dispatch_time_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dispatch_semaphore_signal(dsema: dispatch_semaphore_t) -> ::std::os::raw::c_long;
}
pub type dispatch_once_t = ::std::os::raw::c_long;
extern "C" {
    pub fn dispatch_once(predicate: *mut dispatch_once_t, block: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_once_f(
        predicate: *mut dispatch_once_t,
        context: *mut ::std::os::raw::c_void,
        function: dispatch_function_t,
    );
}
pub type dispatch_data_t = *mut dispatch_data_s;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_data_s {
    pub _address: u8,
}
extern "C" {
    pub static mut _dispatch_data_empty: dispatch_data_s;
}
extern "C" {
    pub static _dispatch_data_destructor_free: dispatch_block_t;
}
extern "C" {
    pub static _dispatch_data_destructor_munmap: dispatch_block_t;
}
extern "C" {
    pub fn dispatch_data_create(
        buffer: *const ::std::os::raw::c_void,
        size: usize,
        queue: dispatch_queue_t,
        destructor: dispatch_block_t,
    ) -> dispatch_data_t;
}
extern "C" {
    pub fn dispatch_data_get_size(data: dispatch_data_t) -> usize;
}
extern "C" {
    pub fn dispatch_data_create_map(
        data: dispatch_data_t,
        buffer_ptr: *mut *const ::std::os::raw::c_void,
        size_ptr: *mut usize,
    ) -> dispatch_data_t;
}
extern "C" {
    pub fn dispatch_data_create_concat(
        data1: dispatch_data_t,
        data2: dispatch_data_t,
    ) -> dispatch_data_t;
}
extern "C" {
    pub fn dispatch_data_create_subrange(
        data: dispatch_data_t,
        offset: usize,
        length: usize,
    ) -> dispatch_data_t;
}
pub type dispatch_data_applier_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn dispatch_data_apply(data: dispatch_data_t, applier: dispatch_data_applier_t) -> bool;
}
extern "C" {
    pub fn dispatch_data_copy_region(
        data: dispatch_data_t,
        location: usize,
        offset_ptr: *mut usize,
    ) -> dispatch_data_t;
}
pub type dispatch_fd_t = ::std::os::raw::c_int;
extern "C" {
    pub fn dispatch_read(
        fd: dispatch_fd_t,
        length: usize,
        queue: dispatch_queue_t,
        handler: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn dispatch_write(
        fd: dispatch_fd_t,
        data: dispatch_data_t,
        queue: dispatch_queue_t,
        handler: *mut ::std::os::raw::c_void,
    );
}
pub type dispatch_io_t = *mut dispatch_io_s;
pub type dispatch_io_type_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn dispatch_io_create(
        type_: dispatch_io_type_t,
        fd: dispatch_fd_t,
        queue: dispatch_queue_t,
        cleanup_handler: *mut ::std::os::raw::c_void,
    ) -> dispatch_io_t;
}
extern "C" {
    pub fn dispatch_io_create_with_path(
        type_: dispatch_io_type_t,
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
        mode: mode_t,
        queue: dispatch_queue_t,
        cleanup_handler: *mut ::std::os::raw::c_void,
    ) -> dispatch_io_t;
}
extern "C" {
    pub fn dispatch_io_create_with_io(
        type_: dispatch_io_type_t,
        io: dispatch_io_t,
        queue: dispatch_queue_t,
        cleanup_handler: *mut ::std::os::raw::c_void,
    ) -> dispatch_io_t;
}
pub type dispatch_io_handler_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn dispatch_io_read(
        channel: dispatch_io_t,
        offset: off_t,
        length: usize,
        queue: dispatch_queue_t,
        io_handler: dispatch_io_handler_t,
    );
}
extern "C" {
    pub fn dispatch_io_write(
        channel: dispatch_io_t,
        offset: off_t,
        data: dispatch_data_t,
        queue: dispatch_queue_t,
        io_handler: dispatch_io_handler_t,
    );
}
pub type dispatch_io_close_flags_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn dispatch_io_close(channel: dispatch_io_t, flags: dispatch_io_close_flags_t);
}
extern "C" {
    pub fn dispatch_io_barrier(channel: dispatch_io_t, barrier: dispatch_block_t);
}
extern "C" {
    pub fn dispatch_io_get_descriptor(channel: dispatch_io_t) -> dispatch_fd_t;
}
extern "C" {
    pub fn dispatch_io_set_high_water(channel: dispatch_io_t, high_water: usize);
}
extern "C" {
    pub fn dispatch_io_set_low_water(channel: dispatch_io_t, low_water: usize);
}
pub type dispatch_io_interval_flags_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn dispatch_io_set_interval(
        channel: dispatch_io_t,
        interval: u64,
        flags: dispatch_io_interval_flags_t,
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CFStreamError {
    pub domain: CFIndex,
    pub error: SInt32,
}
#[test]
fn bindgen_test_layout_CFStreamError() {
    assert_eq!(
        ::std::mem::size_of::<CFStreamError>(),
        16usize,
        concat!("Size of: ", stringify!(CFStreamError))
    );
    assert_eq!(
        ::std::mem::align_of::<CFStreamError>(),
        8usize,
        concat!("Alignment of ", stringify!(CFStreamError))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFStreamError>())).domain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFStreamError>())).error as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamError),
            "::",
            stringify!(error)
        )
    );
}
pub type CFStreamPropertyKey = CFStringRef;
pub type CFStreamStatus = CFIndex;
pub const kCFStreamStatusNotOpen: _bindgen_ty_53 = 0;
pub const kCFStreamStatusOpening: _bindgen_ty_53 = 1;
pub const kCFStreamStatusOpen: _bindgen_ty_53 = 2;
pub const kCFStreamStatusReading: _bindgen_ty_53 = 3;
pub const kCFStreamStatusWriting: _bindgen_ty_53 = 4;
pub const kCFStreamStatusAtEnd: _bindgen_ty_53 = 5;
pub const kCFStreamStatusClosed: _bindgen_ty_53 = 6;
pub const kCFStreamStatusError: _bindgen_ty_53 = 7;
pub type _bindgen_ty_53 = u32;
pub type CFStreamEventType = CFOptionFlags;
pub const kCFStreamEventNone: _bindgen_ty_54 = 0;
pub const kCFStreamEventOpenCompleted: _bindgen_ty_54 = 1;
pub const kCFStreamEventHasBytesAvailable: _bindgen_ty_54 = 2;
pub const kCFStreamEventCanAcceptBytes: _bindgen_ty_54 = 4;
pub const kCFStreamEventErrorOccurred: _bindgen_ty_54 = 8;
pub const kCFStreamEventEndEncountered: _bindgen_ty_54 = 16;
pub type _bindgen_ty_54 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFStreamClientContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(info: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
    pub release: ::std::option::Option<unsafe extern "C" fn(info: *mut ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *mut ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFStreamClientContext() {
    assert_eq!(
        ::std::mem::size_of::<CFStreamClientContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFStreamClientContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFStreamClientContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFStreamClientContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFStreamClientContext>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFStreamClientContext>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFStreamClientContext>())).retain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFStreamClientContext>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFStreamClientContext>())).copyDescription as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
impl Default for CFStreamClientContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFReadStream {
    _unused: [u8; 0],
}
pub type CFReadStreamRef = *mut __CFReadStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFWriteStream {
    _unused: [u8; 0],
}
pub type CFWriteStreamRef = *mut __CFWriteStream;
pub type CFReadStreamClientCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        stream: CFReadStreamRef,
        type_: CFStreamEventType,
        clientCallBackInfo: *mut ::std::os::raw::c_void,
    ),
>;
pub type CFWriteStreamClientCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        stream: CFWriteStreamRef,
        type_: CFStreamEventType,
        clientCallBackInfo: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn CFReadStreamGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFWriteStreamGetTypeID() -> CFTypeID;
}
extern "C" {
    pub static mut kCFStreamPropertyDataWritten: CFStreamPropertyKey;
}
extern "C" {
    pub fn CFReadStreamCreateWithBytesNoCopy(
        alloc: CFAllocatorRef,
        bytes: *const UInt8,
        length: CFIndex,
        bytesDeallocator: CFAllocatorRef,
    ) -> CFReadStreamRef;
}
extern "C" {
    pub fn CFWriteStreamCreateWithBuffer(
        alloc: CFAllocatorRef,
        buffer: *mut UInt8,
        bufferCapacity: CFIndex,
    ) -> CFWriteStreamRef;
}
extern "C" {
    pub fn CFWriteStreamCreateWithAllocatedBuffers(
        alloc: CFAllocatorRef,
        bufferAllocator: CFAllocatorRef,
    ) -> CFWriteStreamRef;
}
extern "C" {
    pub fn CFReadStreamCreateWithFile(alloc: CFAllocatorRef, fileURL: CFURLRef) -> CFReadStreamRef;
}
extern "C" {
    pub fn CFWriteStreamCreateWithFile(
        alloc: CFAllocatorRef,
        fileURL: CFURLRef,
    ) -> CFWriteStreamRef;
}
extern "C" {
    pub fn CFStreamCreateBoundPair(
        alloc: CFAllocatorRef,
        readStream: *mut CFReadStreamRef,
        writeStream: *mut CFWriteStreamRef,
        transferBufferSize: CFIndex,
    );
}
extern "C" {
    pub static mut kCFStreamPropertyAppendToFile: CFStreamPropertyKey;
}
extern "C" {
    pub static mut kCFStreamPropertyFileCurrentOffset: CFStreamPropertyKey;
}
extern "C" {
    pub static mut kCFStreamPropertySocketNativeHandle: CFStreamPropertyKey;
}
extern "C" {
    pub static mut kCFStreamPropertySocketRemoteHostName: CFStreamPropertyKey;
}
extern "C" {
    pub static mut kCFStreamPropertySocketRemotePortNumber: CFStreamPropertyKey;
}
extern "C" {
    pub static kCFStreamErrorDomainSOCKS: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut kCFStreamPropertySOCKSProxy: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamPropertySOCKSProxyHost: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamPropertySOCKSProxyPort: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamPropertySOCKSVersion: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSOCKSVersion4: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSOCKSVersion5: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamPropertySOCKSUser: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamPropertySOCKSPassword: CFStringRef;
}
extern "C" {
    pub static kCFStreamErrorDomainSSL: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut kCFStreamPropertySocketSecurityLevel: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSecurityLevelNone: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSecurityLevelSSLv2: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSecurityLevelSSLv3: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSecurityLevelTLSv1: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamSocketSecurityLevelNegotiatedSSL: CFStringRef;
}
extern "C" {
    pub static mut kCFStreamPropertyShouldCloseNativeSocket: CFStringRef;
}
extern "C" {
    pub fn CFStreamCreatePairWithSocket(
        alloc: CFAllocatorRef,
        sock: CFSocketNativeHandle,
        readStream: *mut CFReadStreamRef,
        writeStream: *mut CFWriteStreamRef,
    );
}
extern "C" {
    pub fn CFStreamCreatePairWithSocketToHost(
        alloc: CFAllocatorRef,
        host: CFStringRef,
        port: UInt32,
        readStream: *mut CFReadStreamRef,
        writeStream: *mut CFWriteStreamRef,
    );
}
extern "C" {
    pub fn CFStreamCreatePairWithPeerSocketSignature(
        alloc: CFAllocatorRef,
        signature: *const CFSocketSignature,
        readStream: *mut CFReadStreamRef,
        writeStream: *mut CFWriteStreamRef,
    );
}
extern "C" {
    pub fn CFReadStreamGetStatus(stream: CFReadStreamRef) -> CFStreamStatus;
}
extern "C" {
    pub fn CFWriteStreamGetStatus(stream: CFWriteStreamRef) -> CFStreamStatus;
}
extern "C" {
    pub fn CFReadStreamCopyError(stream: CFReadStreamRef) -> CFErrorRef;
}
extern "C" {
    pub fn CFWriteStreamCopyError(stream: CFWriteStreamRef) -> CFErrorRef;
}
extern "C" {
    pub fn CFReadStreamOpen(stream: CFReadStreamRef) -> Boolean;
}
extern "C" {
    pub fn CFWriteStreamOpen(stream: CFWriteStreamRef) -> Boolean;
}
extern "C" {
    pub fn CFReadStreamClose(stream: CFReadStreamRef);
}
extern "C" {
    pub fn CFWriteStreamClose(stream: CFWriteStreamRef);
}
extern "C" {
    pub fn CFReadStreamHasBytesAvailable(stream: CFReadStreamRef) -> Boolean;
}
extern "C" {
    pub fn CFReadStreamRead(
        stream: CFReadStreamRef,
        buffer: *mut UInt8,
        bufferLength: CFIndex,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFReadStreamGetBuffer(
        stream: CFReadStreamRef,
        maxBytesToRead: CFIndex,
        numBytesRead: *mut CFIndex,
    ) -> *const UInt8;
}
extern "C" {
    pub fn CFWriteStreamCanAcceptBytes(stream: CFWriteStreamRef) -> Boolean;
}
extern "C" {
    pub fn CFWriteStreamWrite(
        stream: CFWriteStreamRef,
        buffer: *const UInt8,
        bufferLength: CFIndex,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFReadStreamCopyProperty(
        stream: CFReadStreamRef,
        propertyName: CFStreamPropertyKey,
    ) -> CFTypeRef;
}
extern "C" {
    pub fn CFWriteStreamCopyProperty(
        stream: CFWriteStreamRef,
        propertyName: CFStreamPropertyKey,
    ) -> CFTypeRef;
}
extern "C" {
    pub fn CFReadStreamSetProperty(
        stream: CFReadStreamRef,
        propertyName: CFStreamPropertyKey,
        propertyValue: CFTypeRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFWriteStreamSetProperty(
        stream: CFWriteStreamRef,
        propertyName: CFStreamPropertyKey,
        propertyValue: CFTypeRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFReadStreamSetClient(
        stream: CFReadStreamRef,
        streamEvents: CFOptionFlags,
        clientCB: CFReadStreamClientCallBack,
        clientContext: *mut CFStreamClientContext,
    ) -> Boolean;
}
extern "C" {
    pub fn CFWriteStreamSetClient(
        stream: CFWriteStreamRef,
        streamEvents: CFOptionFlags,
        clientCB: CFWriteStreamClientCallBack,
        clientContext: *mut CFStreamClientContext,
    ) -> Boolean;
}
extern "C" {
    pub fn CFReadStreamScheduleWithRunLoop(
        stream: CFReadStreamRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFWriteStreamScheduleWithRunLoop(
        stream: CFWriteStreamRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFReadStreamUnscheduleFromRunLoop(
        stream: CFReadStreamRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFWriteStreamUnscheduleFromRunLoop(
        stream: CFWriteStreamRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFRunLoopMode,
    );
}
extern "C" {
    pub fn CFReadStreamSetDispatchQueue(stream: CFReadStreamRef, q: dispatch_queue_t);
}
extern "C" {
    pub fn CFWriteStreamSetDispatchQueue(stream: CFWriteStreamRef, q: dispatch_queue_t);
}
extern "C" {
    pub fn CFReadStreamCopyDispatchQueue(stream: CFReadStreamRef) -> dispatch_queue_t;
}
extern "C" {
    pub fn CFWriteStreamCopyDispatchQueue(stream: CFWriteStreamRef) -> dispatch_queue_t;
}
pub type CFStreamErrorDomain = CFIndex;
pub const kCFStreamErrorDomainCustom: _bindgen_ty_55 = -1;
pub const kCFStreamErrorDomainPOSIX: _bindgen_ty_55 = 1;
pub const kCFStreamErrorDomainMacOSStatus: _bindgen_ty_55 = 2;
pub type _bindgen_ty_55 = i32;
extern "C" {
    pub fn CFReadStreamGetError(stream: CFReadStreamRef) -> CFStreamError;
}
extern "C" {
    pub fn CFWriteStreamGetError(stream: CFWriteStreamRef) -> CFStreamError;
}
pub type CFPropertyListMutabilityOptions = CFOptionFlags;
pub const kCFPropertyListImmutable: _bindgen_ty_56 = 0;
pub const kCFPropertyListMutableContainers: _bindgen_ty_56 = 1;
pub const kCFPropertyListMutableContainersAndLeaves: _bindgen_ty_56 = 2;
pub type _bindgen_ty_56 = u32;
extern "C" {
    pub fn CFPropertyListCreateFromXMLData(
        allocator: CFAllocatorRef,
        xmlData: CFDataRef,
        mutabilityOption: CFOptionFlags,
        errorString: *mut CFStringRef,
    ) -> CFPropertyListRef;
}
extern "C" {
    pub fn CFPropertyListCreateXMLData(
        allocator: CFAllocatorRef,
        propertyList: CFPropertyListRef,
    ) -> CFDataRef;
}
extern "C" {
    pub fn CFPropertyListCreateDeepCopy(
        allocator: CFAllocatorRef,
        propertyList: CFPropertyListRef,
        mutabilityOption: CFOptionFlags,
    ) -> CFPropertyListRef;
}
pub type CFPropertyListFormat = CFIndex;
pub const kCFPropertyListOpenStepFormat: _bindgen_ty_57 = 1;
pub const kCFPropertyListXMLFormat_v1_0: _bindgen_ty_57 = 100;
pub const kCFPropertyListBinaryFormat_v1_0: _bindgen_ty_57 = 200;
pub type _bindgen_ty_57 = u32;
extern "C" {
    pub fn CFPropertyListIsValid(plist: CFPropertyListRef, format: CFPropertyListFormat)
        -> Boolean;
}
extern "C" {
    pub fn CFPropertyListWriteToStream(
        propertyList: CFPropertyListRef,
        stream: CFWriteStreamRef,
        format: CFPropertyListFormat,
        errorString: *mut CFStringRef,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFPropertyListCreateFromStream(
        allocator: CFAllocatorRef,
        stream: CFReadStreamRef,
        streamLength: CFIndex,
        mutabilityOption: CFOptionFlags,
        format: *mut CFPropertyListFormat,
        errorString: *mut CFStringRef,
    ) -> CFPropertyListRef;
}
pub const kCFPropertyListReadCorruptError: _bindgen_ty_58 = 3840;
pub const kCFPropertyListReadUnknownVersionError: _bindgen_ty_58 = 3841;
pub const kCFPropertyListReadStreamError: _bindgen_ty_58 = 3842;
pub const kCFPropertyListWriteStreamError: _bindgen_ty_58 = 3851;
pub type _bindgen_ty_58 = u32;
extern "C" {
    pub fn CFPropertyListCreateWithData(
        allocator: CFAllocatorRef,
        data: CFDataRef,
        options: CFOptionFlags,
        format: *mut CFPropertyListFormat,
        error: *mut CFErrorRef,
    ) -> CFPropertyListRef;
}
extern "C" {
    pub fn CFPropertyListCreateWithStream(
        allocator: CFAllocatorRef,
        stream: CFReadStreamRef,
        streamLength: CFIndex,
        options: CFOptionFlags,
        format: *mut CFPropertyListFormat,
        error: *mut CFErrorRef,
    ) -> CFPropertyListRef;
}
extern "C" {
    pub fn CFPropertyListWrite(
        propertyList: CFPropertyListRef,
        stream: CFWriteStreamRef,
        format: CFPropertyListFormat,
        options: CFOptionFlags,
        error: *mut CFErrorRef,
    ) -> CFIndex;
}
extern "C" {
    pub fn CFPropertyListCreateData(
        allocator: CFAllocatorRef,
        propertyList: CFPropertyListRef,
        format: CFPropertyListFormat,
        options: CFOptionFlags,
        error: *mut CFErrorRef,
    ) -> CFDataRef;
}
///@typedef CFSetRetainCallBack
///Type of the callback function used by CFSets for retaining values.
///@param allocator The allocator of the CFSet.
///@param value The value to retain.
///@result The value to store in the set, which is usually the value
///parameter passed to this callback, but may be a different
///value if a different value should be stored in the set.
pub type CFSetRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: CFAllocatorRef,
        value: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void,
>;
///@typedef CFSetReleaseCallBack
///Type of the callback function used by CFSets for releasing a retain on values.
///@param allocator The allocator of the CFSet.
///@param value The value to release.
pub type CFSetReleaseCallBack = ::std::option::Option<
    unsafe extern "C" fn(allocator: CFAllocatorRef, value: *const ::std::os::raw::c_void),
>;
///@typedef CFSetCopyDescriptionCallBack
///Type of the callback function used by CFSets for describing values.
///@param value The value to describe.
///@result A description of the specified value.
pub type CFSetCopyDescriptionCallBack = ::std::option::Option<
    unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFStringRef,
>;
///@typedef CFSetEqualCallBack
///Type of the callback function used by CFSets for comparing values.
///@param value1 The first value to compare.
///@param value2 The second value to compare.
///@result True if the values are equal, otherwise false.
pub type CFSetEqualCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        value1: *const ::std::os::raw::c_void,
        value2: *const ::std::os::raw::c_void,
    ) -> Boolean,
>;
///@typedef CFSetHashCallBack
///Type of the callback function used by CFSets for hashing values.
///@param value The value to hash.
///@result The hash of the value.
pub type CFSetHashCallBack =
    ::std::option::Option<unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> CFHashCode>;
///@typedef CFSetCallBacks
///Structure containing the callbacks of a CFSet.
///@field version The version number of the structure type being passed
///in as a parameter to the CFSet creation functions. This
///structure is version 0.
///@field retain The callback used to add a retain for the set on
///values as they are put into the set. This callback returns
///the value to store in the set, which is usually the value
///parameter passed to this callback, but may be a different
///value if a different value should be stored in the set.
///The set's allocator is passed as the first argument.
///@field release The callback used to remove a retain previously added
///for the set from values as they are removed from the
///set. The set's allocator is passed as the first
///argument.
///@field copyDescription The callback used to create a descriptive
///string representation of each value in the set. This is
///used by the CFCopyDescription() function.
///@field equal The callback used to compare values in the set for
///equality for some operations.
///@field hash The callback used to compare values in the set for
///uniqueness for some operations.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFSetCallBacks {
    pub version: CFIndex,
    pub retain: CFSetRetainCallBack,
    pub release: CFSetReleaseCallBack,
    pub copyDescription: CFSetCopyDescriptionCallBack,
    pub equal: CFSetEqualCallBack,
    pub hash: CFSetHashCallBack,
}
#[test]
fn bindgen_test_layout_CFSetCallBacks() {
    assert_eq!(
        ::std::mem::size_of::<CFSetCallBacks>(),
        48usize,
        concat!("Size of: ", stringify!(CFSetCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFSetCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFSetCallBacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSetCallBacks>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSetCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSetCallBacks>())).retain as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSetCallBacks),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSetCallBacks>())).release as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSetCallBacks),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSetCallBacks>())).copyDescription as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSetCallBacks),
            "::",
            stringify!(copyDescription)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSetCallBacks>())).equal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSetCallBacks),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFSetCallBacks>())).hash as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFSetCallBacks),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for CFSetCallBacks {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static kCFTypeSetCallBacks: CFSetCallBacks;
}
extern "C" {
    pub static kCFCopyStringSetCallBacks: CFSetCallBacks;
}
///@typedef CFSetApplierFunction
///Type of the callback function used by the apply functions of
///CFSets.
///@param value The current value from the set.
///@param context The user-defined context parameter given to the apply
///function.
pub type CFSetApplierFunction = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFSet {
    _unused: [u8; 0],
}
///@typedef CFSetRef
///This is the type of a reference to immutable CFSets.
pub type CFSetRef = *const __CFSet;
///@typedef CFMutableSetRef
///This is the type of a reference to mutable CFSets.
pub type CFMutableSetRef = *mut __CFSet;
extern "C" {
    ///@function CFSetGetTypeID
    ///Returns the type identifier of all CFSet instances.
    pub fn CFSetGetTypeID() -> CFTypeID;
}
extern "C" {
    ///@function CFSetCreate
    ///Creates a new immutable set with the given values.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the set and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param values A C array of the pointer-sized values to be in the
    ///set.  This C array is not changed or freed by this function.
    ///If this parameter is not a valid pointer to a C array of at
    ///least numValues pointers, the behavior is undefined.
    ///@param numValues The number of values to copy from the values C
    ///array into the CFSet. This number will be the count of the
    ///set.  If this parameter is zero, negative, or greater than
    ///the number of values actually in the values C array, the
    ///behavior is undefined.
    ///@param callBacks A C pointer to a CFSetCallBacks structure
    ///initialized with the callbacks for the set to use on each
    ///value in the set. A copy of the contents of the
    ///callbacks structure is made, so that a pointer to a
    ///structure on the stack can be passed in, or can be reused
    ///for multiple set creations. If the version field of this
    ///callbacks structure is not one of the defined ones for
    ///CFSet, the behavior is undefined. The retain field may be
    ///NULL, in which case the CFSet will do nothing to add a
    ///retain to the contained values for the set. The release
    ///field may be NULL, in which case the CFSet will do nothing
    ///to remove the set's retain (if any) on the values when the
    ///set is destroyed. If the copyDescription field is NULL,
    ///the set will create a simple description for the value. If
    ///the equal field is NULL, the set will use pointer equality
    ///to test for equality of values. The hash field may be NULL,
    ///in which case the CFSet will determine uniqueness by pointer
    ///equality. This callbacks parameter
    ///itself may be NULL, which is treated as if a valid structure
    ///of version 0 with all fields NULL had been passed in.
    ///Otherwise, if any of the fields are not valid pointers to
    ///functions of the correct type, or this parameter is not a
    ///valid pointer to a  CFSetCallBacks callbacks structure,
    ///the behavior is undefined. If any of the values put into the
    ///set is not one understood by one of the callback functions
    ///the behavior when that callback function is used is
    ///undefined.
    ///@result A reference to the new immutable CFSet.
    pub fn CFSetCreate(
        allocator: CFAllocatorRef,
        values: *mut *const ::std::os::raw::c_void,
        numValues: CFIndex,
        callBacks: *const CFSetCallBacks,
    ) -> CFSetRef;
}
extern "C" {
    ///@function CFSetCreateCopy
    ///Creates a new immutable set with the values from the given set.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the set and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param theSet The set which is to be copied. The values from the
    ///set are copied as pointers into the new set (that is,
    ///the values themselves are copied, not that which the values
    ///point to, if anything). However, the values are also
    ///retained by the new set. The count of the new set will
    ///be the same as the copied set. The new set uses the same
    ///callbacks as the set to be copied. If this parameter is
    ///not a valid CFSet, the behavior is undefined.
    ///@result A reference to the new immutable CFSet.
    pub fn CFSetCreateCopy(allocator: CFAllocatorRef, theSet: CFSetRef) -> CFSetRef;
}
extern "C" {
    ///@function CFSetCreateMutable
    ///Creates a new empty mutable set.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the set and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param capacity A hint about the number of values that will be held
    ///by the CFSet. Pass 0 for no hint. The implementation may
    ///ignore this hint, or may use it to optimize various
    ///operations. A set's actual capacity is only limited by
    ///address space and available memory constraints). If this
    ///parameter is negative, the behavior is undefined.
    ///@param callBacks A C pointer to a CFSetCallBacks structure
    ///initialized with the callbacks for the set to use on each
    ///value in the set. A copy of the contents of the
    ///callbacks structure is made, so that a pointer to a
    ///structure on the stack can be passed in, or can be reused
    ///for multiple set creations. If the version field of this
    ///callbacks structure is not one of the defined ones for
    ///CFSet, the behavior is undefined. The retain field may be
    ///NULL, in which case the CFSet will do nothing to add a
    ///retain to the contained values for the set. The release
    ///field may be NULL, in which case the CFSet will do nothing
    ///to remove the set's retain (if any) on the values when the
    ///set is destroyed. If the copyDescription field is NULL,
    ///the set will create a simple description for the value. If
    ///the equal field is NULL, the set will use pointer equality
    ///to test for equality of values. The hash field may be NULL,
    ///in which case the CFSet will determine uniqueness by pointer
    ///equality. This callbacks parameter
    ///itself may be NULL, which is treated as if a valid structure
    ///of version 0 with all fields NULL had been passed in.
    ///Otherwise, if any of the fields are not valid pointers to
    ///functions of the correct type, or this parameter is not a
    ///valid pointer to a  CFSetCallBacks callbacks structure,
    ///the behavior is undefined. If any of the values put into the
    ///set is not one understood by one of the callback functions
    ///the behavior when that callback function is used is
    ///undefined.
    ///@result A reference to the new mutable CFSet.
    pub fn CFSetCreateMutable(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        callBacks: *const CFSetCallBacks,
    ) -> CFMutableSetRef;
}
extern "C" {
    ///@function CFSetCreateMutableCopy
    ///Creates a new immutable set with the values from the given set.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the set and its storage for values. This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used. If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param capacity A hint about the number of values that will be held
    ///by the CFSet. Pass 0 for no hint. The implementation may
    ///ignore this hint, or may use it to optimize various
    ///operations. A set's actual capacity is only limited by
    ///address space and available memory constraints).
    ///This parameter must be greater than or equal
    ///to the count of the set which is to be copied, or the
    ///behavior is undefined. If this parameter is negative, the
    ///behavior is undefined.
    ///@param theSet The set which is to be copied. The values from the
    ///set are copied as pointers into the new set (that is,
    ///the values themselves are copied, not that which the values
    ///point to, if anything). However, the values are also
    ///retained by the new set. The count of the new set will
    ///be the same as the copied set. The new set uses the same
    ///callbacks as the set to be copied. If this parameter is
    ///not a valid CFSet, the behavior is undefined.
    ///@result A reference to the new mutable CFSet.
    pub fn CFSetCreateMutableCopy(
        allocator: CFAllocatorRef,
        capacity: CFIndex,
        theSet: CFSetRef,
    ) -> CFMutableSetRef;
}
extern "C" {
    ///@function CFSetGetCount
    ///Returns the number of values currently in the set.
    ///@param theSet The set to be queried. If this parameter is not a valid
    ///CFSet, the behavior is undefined.
    ///@result The number of values in the set.
    pub fn CFSetGetCount(theSet: CFSetRef) -> CFIndex;
}
extern "C" {
    ///@function CFSetGetCountOfValue
    ///Counts the number of times the given value occurs in the set. Since
    ///sets by definition contain only one instance of a value, this function
    ///is synonymous to CFSetContainsValue.
    ///@param theSet The set to be searched. If this parameter is not a
    ///valid CFSet, the behavior is undefined.
    ///@param value The value for which to find matches in the set. The
    ///equal() callback provided when the set was created is
    ///used to compare. If the equal() callback was NULL, pointer
    ///equality (in C, ==) is used. If value, or any of the values
    ///in the set, are not understood by the equal() callback,
    ///the behavior is undefined.
    ///@result The number of times the given value occurs in the set.
    pub fn CFSetGetCountOfValue(theSet: CFSetRef, value: *const ::std::os::raw::c_void) -> CFIndex;
}
extern "C" {
    ///@function CFSetContainsValue
    ///Reports whether or not the value is in the set.
    ///@param theSet The set to be searched. If this parameter is not a
    ///valid CFSet, the behavior is undefined.
    ///@param value The value for which to find matches in the set. The
    ///equal() callback provided when the set was created is
    ///used to compare. If the equal() callback was NULL, pointer
    ///equality (in C, ==) is used. If value, or any of the values
    ///in the set, are not understood by the equal() callback,
    ///the behavior is undefined.
    ///@result true, if the value is in the set, otherwise false.
    pub fn CFSetContainsValue(theSet: CFSetRef, value: *const ::std::os::raw::c_void) -> Boolean;
}
extern "C" {
    ///@function CFSetGetValue
    ///Retrieves a value in the set which hashes the same as the specified value.
    ///@param theSet The set to be queried. If this parameter is not a
    ///valid CFSet, the behavior is undefined.
    ///@param value The value to retrieve. The equal() callback provided when
    ///the set was created is used to compare. If the equal() callback
    ///was NULL, pointer equality (in C, ==) is used. If a value, or
    ///any of the values in the set, are not understood by the equal()
    ///callback, the behavior is undefined.
    ///@result The value in the set with the given hash.
    pub fn CFSetGetValue(
        theSet: CFSetRef,
        value: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    ///@function CFSetGetValueIfPresent
    ///Retrieves a value in the set which hashes the same as the specified value,
    ///if present.
    ///@param theSet The set to be queried. If this parameter is not a
    ///valid CFSet, the behavior is undefined.
    ///@param candidate This value is hashed and compared with values in the
    ///set to determine which value to retrieve. The equal() callback provided when
    ///the set was created is used to compare. If the equal() callback
    ///was NULL, pointer equality (in C, ==) is used. If a value, or
    ///any of the values in the set, are not understood by the equal()
    ///callback, the behavior is undefined.
    ///@param value A pointer to memory which should be filled with the
    ///pointer-sized value if a matching value is found. If no
    ///match is found, the contents of the storage pointed to by
    ///this parameter are undefined. This parameter may be NULL,
    ///in which case the value from the dictionary is not returned
    ///(but the return value of this function still indicates
    ///whether or not the value was present).
    ///@result True if the value was present in the set, otherwise false.
    pub fn CFSetGetValueIfPresent(
        theSet: CFSetRef,
        candidate: *const ::std::os::raw::c_void,
        value: *mut *const ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    ///@function CFSetGetValues
    ///Fills the buffer with values from the set.
    ///@param theSet The set to be queried. If this parameter is not a
    ///valid CFSet, the behavior is undefined.
    ///@param values A C array of pointer-sized values to be filled with
    ///values from the set. The values in the C array are ordered
    ///in the same order in which they appear in the set. If this
    ///parameter is not a valid pointer to a C array of at least
    ///CFSetGetCount() pointers, the behavior is undefined.
    pub fn CFSetGetValues(theSet: CFSetRef, values: *mut *const ::std::os::raw::c_void);
}
extern "C" {
    ///@function CFSetApplyFunction
    ///Calls a function once for each value in the set.
    ///@param theSet The set to be operated upon. If this parameter is not
    ///a valid CFSet, the behavior is undefined.
    ///@param applier The callback function to call once for each value in
    ///the given set. If this parameter is not a
    ///pointer to a function of the correct prototype, the behavior
    ///is undefined. If there are values in the set which the
    ///applier function does not expect or cannot properly apply
    ///to, the behavior is undefined.
    ///@param context A pointer-sized user-defined value, which is passed
    ///as the second parameter to the applier function, but is
    ///otherwise unused by this function. If the context is not
    ///what is expected by the applier function, the behavior is
    ///undefined.
    pub fn CFSetApplyFunction(
        theSet: CFSetRef,
        applier: CFSetApplierFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFSetAddValue
    ///Adds the value to the set if it is not already present.
    ///@param theSet The set to which the value is to be added. If this
    ///parameter is not a valid mutable CFSet, the behavior is
    ///undefined.
    ///@param value The value to add to the set. The value is retained by
    ///the set using the retain callback provided when the set
    ///was created. If the value is not of the sort expected by the
    ///retain callback, the behavior is undefined. The count of the
    ///set is increased by one.
    pub fn CFSetAddValue(theSet: CFMutableSetRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    ///@function CFSetReplaceValue
    ///Replaces the value in the set if it is present.
    ///@param theSet The set to which the value is to be replaced. If this
    ///parameter is not a valid mutable CFSet, the behavior is
    ///undefined.
    ///@param value The value to replace in the set. The equal() callback provided when
    ///the set was created is used to compare. If the equal() callback
    ///was NULL, pointer equality (in C, ==) is used. If a value, or
    ///any of the values in the set, are not understood by the equal()
    ///callback, the behavior is undefined. The value is retained by
    ///the set using the retain callback provided when the set
    ///was created. If the value is not of the sort expected by the
    ///retain callback, the behavior is undefined. The count of the
    ///set is increased by one.
    pub fn CFSetReplaceValue(theSet: CFMutableSetRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    ///@function CFSetSetValue
    ///Replaces the value in the set if it is present, or adds the value to
    ///the set if it is absent.
    ///@param theSet The set to which the value is to be replaced. If this
    ///parameter is not a valid mutable CFSet, the behavior is
    ///undefined.
    ///@param value The value to set in the CFSet. The equal() callback provided when
    ///the set was created is used to compare. If the equal() callback
    ///was NULL, pointer equality (in C, ==) is used. If a value, or
    ///any of the values in the set, are not understood by the equal()
    ///callback, the behavior is undefined. The value is retained by
    ///the set using the retain callback provided when the set
    ///was created. If the value is not of the sort expected by the
    ///retain callback, the behavior is undefined. The count of the
    ///set is increased by one.
    pub fn CFSetSetValue(theSet: CFMutableSetRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    ///@function CFSetRemoveValue
    ///Removes the specified value from the set.
    ///@param theSet The set from which the value is to be removed.
    ///If this parameter is not a valid mutable CFSet,
    ///the behavior is undefined.
    ///@param value The value to remove. The equal() callback provided when
    ///the set was created is used to compare. If the equal() callback
    ///was NULL, pointer equality (in C, ==) is used. If a value, or
    ///any of the values in the set, are not understood by the equal()
    ///callback, the behavior is undefined.
    pub fn CFSetRemoveValue(theSet: CFMutableSetRef, value: *const ::std::os::raw::c_void);
}
extern "C" {
    ///@function CFSetRemoveAllValues
    ///Removes all the values from the set, making it empty.
    ///@param theSet The set from which all of the values are to be
    ///removed. If this parameter is not a valid mutable CFSet,
    ///the behavior is undefined.
    pub fn CFSetRemoveAllValues(theSet: CFMutableSetRef);
}
pub type CFStringEncodings = CFIndex;
pub const kCFStringEncodingMacJapanese: _bindgen_ty_59 = 1;
pub const kCFStringEncodingMacChineseTrad: _bindgen_ty_59 = 2;
pub const kCFStringEncodingMacKorean: _bindgen_ty_59 = 3;
pub const kCFStringEncodingMacArabic: _bindgen_ty_59 = 4;
pub const kCFStringEncodingMacHebrew: _bindgen_ty_59 = 5;
pub const kCFStringEncodingMacGreek: _bindgen_ty_59 = 6;
pub const kCFStringEncodingMacCyrillic: _bindgen_ty_59 = 7;
pub const kCFStringEncodingMacDevanagari: _bindgen_ty_59 = 9;
pub const kCFStringEncodingMacGurmukhi: _bindgen_ty_59 = 10;
pub const kCFStringEncodingMacGujarati: _bindgen_ty_59 = 11;
pub const kCFStringEncodingMacOriya: _bindgen_ty_59 = 12;
pub const kCFStringEncodingMacBengali: _bindgen_ty_59 = 13;
pub const kCFStringEncodingMacTamil: _bindgen_ty_59 = 14;
pub const kCFStringEncodingMacTelugu: _bindgen_ty_59 = 15;
pub const kCFStringEncodingMacKannada: _bindgen_ty_59 = 16;
pub const kCFStringEncodingMacMalayalam: _bindgen_ty_59 = 17;
pub const kCFStringEncodingMacSinhalese: _bindgen_ty_59 = 18;
pub const kCFStringEncodingMacBurmese: _bindgen_ty_59 = 19;
pub const kCFStringEncodingMacKhmer: _bindgen_ty_59 = 20;
pub const kCFStringEncodingMacThai: _bindgen_ty_59 = 21;
pub const kCFStringEncodingMacLaotian: _bindgen_ty_59 = 22;
pub const kCFStringEncodingMacGeorgian: _bindgen_ty_59 = 23;
pub const kCFStringEncodingMacArmenian: _bindgen_ty_59 = 24;
pub const kCFStringEncodingMacChineseSimp: _bindgen_ty_59 = 25;
pub const kCFStringEncodingMacTibetan: _bindgen_ty_59 = 26;
pub const kCFStringEncodingMacMongolian: _bindgen_ty_59 = 27;
pub const kCFStringEncodingMacEthiopic: _bindgen_ty_59 = 28;
pub const kCFStringEncodingMacCentralEurRoman: _bindgen_ty_59 = 29;
pub const kCFStringEncodingMacVietnamese: _bindgen_ty_59 = 30;
pub const kCFStringEncodingMacExtArabic: _bindgen_ty_59 = 31;
pub const kCFStringEncodingMacSymbol: _bindgen_ty_59 = 33;
pub const kCFStringEncodingMacDingbats: _bindgen_ty_59 = 34;
pub const kCFStringEncodingMacTurkish: _bindgen_ty_59 = 35;
pub const kCFStringEncodingMacCroatian: _bindgen_ty_59 = 36;
pub const kCFStringEncodingMacIcelandic: _bindgen_ty_59 = 37;
pub const kCFStringEncodingMacRomanian: _bindgen_ty_59 = 38;
pub const kCFStringEncodingMacCeltic: _bindgen_ty_59 = 39;
pub const kCFStringEncodingMacGaelic: _bindgen_ty_59 = 40;
pub const kCFStringEncodingMacFarsi: _bindgen_ty_59 = 140;
pub const kCFStringEncodingMacUkrainian: _bindgen_ty_59 = 152;
pub const kCFStringEncodingMacInuit: _bindgen_ty_59 = 236;
pub const kCFStringEncodingMacVT100: _bindgen_ty_59 = 252;
pub const kCFStringEncodingMacHFS: _bindgen_ty_59 = 255;
pub const kCFStringEncodingISOLatin2: _bindgen_ty_59 = 514;
pub const kCFStringEncodingISOLatin3: _bindgen_ty_59 = 515;
pub const kCFStringEncodingISOLatin4: _bindgen_ty_59 = 516;
pub const kCFStringEncodingISOLatinCyrillic: _bindgen_ty_59 = 517;
pub const kCFStringEncodingISOLatinArabic: _bindgen_ty_59 = 518;
pub const kCFStringEncodingISOLatinGreek: _bindgen_ty_59 = 519;
pub const kCFStringEncodingISOLatinHebrew: _bindgen_ty_59 = 520;
pub const kCFStringEncodingISOLatin5: _bindgen_ty_59 = 521;
pub const kCFStringEncodingISOLatin6: _bindgen_ty_59 = 522;
pub const kCFStringEncodingISOLatinThai: _bindgen_ty_59 = 523;
pub const kCFStringEncodingISOLatin7: _bindgen_ty_59 = 525;
pub const kCFStringEncodingISOLatin8: _bindgen_ty_59 = 526;
pub const kCFStringEncodingISOLatin9: _bindgen_ty_59 = 527;
pub const kCFStringEncodingISOLatin10: _bindgen_ty_59 = 528;
pub const kCFStringEncodingDOSLatinUS: _bindgen_ty_59 = 1024;
pub const kCFStringEncodingDOSGreek: _bindgen_ty_59 = 1029;
pub const kCFStringEncodingDOSBalticRim: _bindgen_ty_59 = 1030;
pub const kCFStringEncodingDOSLatin1: _bindgen_ty_59 = 1040;
pub const kCFStringEncodingDOSGreek1: _bindgen_ty_59 = 1041;
pub const kCFStringEncodingDOSLatin2: _bindgen_ty_59 = 1042;
pub const kCFStringEncodingDOSCyrillic: _bindgen_ty_59 = 1043;
pub const kCFStringEncodingDOSTurkish: _bindgen_ty_59 = 1044;
pub const kCFStringEncodingDOSPortuguese: _bindgen_ty_59 = 1045;
pub const kCFStringEncodingDOSIcelandic: _bindgen_ty_59 = 1046;
pub const kCFStringEncodingDOSHebrew: _bindgen_ty_59 = 1047;
pub const kCFStringEncodingDOSCanadianFrench: _bindgen_ty_59 = 1048;
pub const kCFStringEncodingDOSArabic: _bindgen_ty_59 = 1049;
pub const kCFStringEncodingDOSNordic: _bindgen_ty_59 = 1050;
pub const kCFStringEncodingDOSRussian: _bindgen_ty_59 = 1051;
pub const kCFStringEncodingDOSGreek2: _bindgen_ty_59 = 1052;
pub const kCFStringEncodingDOSThai: _bindgen_ty_59 = 1053;
pub const kCFStringEncodingDOSJapanese: _bindgen_ty_59 = 1056;
pub const kCFStringEncodingDOSChineseSimplif: _bindgen_ty_59 = 1057;
pub const kCFStringEncodingDOSKorean: _bindgen_ty_59 = 1058;
pub const kCFStringEncodingDOSChineseTrad: _bindgen_ty_59 = 1059;
pub const kCFStringEncodingWindowsLatin2: _bindgen_ty_59 = 1281;
pub const kCFStringEncodingWindowsCyrillic: _bindgen_ty_59 = 1282;
pub const kCFStringEncodingWindowsGreek: _bindgen_ty_59 = 1283;
pub const kCFStringEncodingWindowsLatin5: _bindgen_ty_59 = 1284;
pub const kCFStringEncodingWindowsHebrew: _bindgen_ty_59 = 1285;
pub const kCFStringEncodingWindowsArabic: _bindgen_ty_59 = 1286;
pub const kCFStringEncodingWindowsBalticRim: _bindgen_ty_59 = 1287;
pub const kCFStringEncodingWindowsVietnamese: _bindgen_ty_59 = 1288;
pub const kCFStringEncodingWindowsKoreanJohab: _bindgen_ty_59 = 1296;
pub const kCFStringEncodingANSEL: _bindgen_ty_59 = 1537;
pub const kCFStringEncodingJIS_X0201_76: _bindgen_ty_59 = 1568;
pub const kCFStringEncodingJIS_X0208_83: _bindgen_ty_59 = 1569;
pub const kCFStringEncodingJIS_X0208_90: _bindgen_ty_59 = 1570;
pub const kCFStringEncodingJIS_X0212_90: _bindgen_ty_59 = 1571;
pub const kCFStringEncodingJIS_C6226_78: _bindgen_ty_59 = 1572;
pub const kCFStringEncodingShiftJIS_X0213: _bindgen_ty_59 = 1576;
pub const kCFStringEncodingShiftJIS_X0213_MenKuTen: _bindgen_ty_59 = 1577;
pub const kCFStringEncodingGB_2312_80: _bindgen_ty_59 = 1584;
pub const kCFStringEncodingGBK_95: _bindgen_ty_59 = 1585;
pub const kCFStringEncodingGB_18030_2000: _bindgen_ty_59 = 1586;
pub const kCFStringEncodingKSC_5601_87: _bindgen_ty_59 = 1600;
pub const kCFStringEncodingKSC_5601_92_Johab: _bindgen_ty_59 = 1601;
pub const kCFStringEncodingCNS_11643_92_P1: _bindgen_ty_59 = 1617;
pub const kCFStringEncodingCNS_11643_92_P2: _bindgen_ty_59 = 1618;
pub const kCFStringEncodingCNS_11643_92_P3: _bindgen_ty_59 = 1619;
pub const kCFStringEncodingISO_2022_JP: _bindgen_ty_59 = 2080;
pub const kCFStringEncodingISO_2022_JP_2: _bindgen_ty_59 = 2081;
pub const kCFStringEncodingISO_2022_JP_1: _bindgen_ty_59 = 2082;
pub const kCFStringEncodingISO_2022_JP_3: _bindgen_ty_59 = 2083;
pub const kCFStringEncodingISO_2022_CN: _bindgen_ty_59 = 2096;
pub const kCFStringEncodingISO_2022_CN_EXT: _bindgen_ty_59 = 2097;
pub const kCFStringEncodingISO_2022_KR: _bindgen_ty_59 = 2112;
pub const kCFStringEncodingEUC_JP: _bindgen_ty_59 = 2336;
pub const kCFStringEncodingEUC_CN: _bindgen_ty_59 = 2352;
pub const kCFStringEncodingEUC_TW: _bindgen_ty_59 = 2353;
pub const kCFStringEncodingEUC_KR: _bindgen_ty_59 = 2368;
pub const kCFStringEncodingShiftJIS: _bindgen_ty_59 = 2561;
pub const kCFStringEncodingKOI8_R: _bindgen_ty_59 = 2562;
pub const kCFStringEncodingBig5: _bindgen_ty_59 = 2563;
pub const kCFStringEncodingMacRomanLatin1: _bindgen_ty_59 = 2564;
pub const kCFStringEncodingHZ_GB_2312: _bindgen_ty_59 = 2565;
pub const kCFStringEncodingBig5_HKSCS_1999: _bindgen_ty_59 = 2566;
pub const kCFStringEncodingVISCII: _bindgen_ty_59 = 2567;
pub const kCFStringEncodingKOI8_U: _bindgen_ty_59 = 2568;
pub const kCFStringEncodingBig5_E: _bindgen_ty_59 = 2569;
pub const kCFStringEncodingNextStepJapanese: _bindgen_ty_59 = 2818;
pub const kCFStringEncodingEBCDIC_US: _bindgen_ty_59 = 3073;
pub const kCFStringEncodingEBCDIC_CP037: _bindgen_ty_59 = 3074;
pub const kCFStringEncodingUTF7: _bindgen_ty_59 = 67109120;
pub const kCFStringEncodingUTF7_IMAP: _bindgen_ty_59 = 2576;
pub const kCFStringEncodingShiftJIS_X0213_00: _bindgen_ty_59 = 1576;
pub type _bindgen_ty_59 = u32;
///@typedef CFTreeRetainCallBack
///Type of the callback function used to add a retain to the user-specified
///info parameter.  This callback may returns the value to use whenever the
///info parameter is retained, which is usually the value parameter passed
///to this callback, but may be a different value if a different value
///should be used.
///@param info A user-supplied info parameter provided in a CFTreeContext.
///@result The retained info parameter.
pub type CFTreeRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
>;
///@typedef CFTreeReleaseCallBack
///Type of the callback function used to remove a retain previously
///added to the user-specified info parameter.
///@param info A user-supplied info parameter provided in a CFTreeContext.
pub type CFTreeReleaseCallBack =
    ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>;
///@typedef CFTreeCopyDescriptionCallBack
///Type of the callback function used to provide a description of the
///user-specified info parameter.
///@param info A user-supplied info parameter provided in a CFTreeContext.
///@result A description of the info parameter.
pub type CFTreeCopyDescriptionCallBack =
    ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef>;
///@typedef CFTreeContext
///Structure containing user-specified data and callbacks for a CFTree.
///@field version The version number of the structure type being passed
///in as a parameter to the CFTree creation function.
///This structure is version 0.
///@field info A C pointer to a user-specified block of data.
///@field retain The callback used to add a retain for the info field.
///If this parameter is not a pointer to a function of the correct
///prototype, the behavior is undefined.  The value may be NULL.
///@field release The calllback used to remove a retain previously added
///for the info field.  If this parameter is not a pointer to a
///function of the correct prototype, the behavior is undefined.
///The value may be NULL.
///@field copyDescription The callback used to provide a description of
///the info field.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFTreeContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: CFTreeRetainCallBack,
    pub release: CFTreeReleaseCallBack,
    pub copyDescription: CFTreeCopyDescriptionCallBack,
}
#[test]
fn bindgen_test_layout_CFTreeContext() {
    assert_eq!(
        ::std::mem::size_of::<CFTreeContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFTreeContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFTreeContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFTreeContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFTreeContext>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFTreeContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFTreeContext>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFTreeContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFTreeContext>())).retain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFTreeContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFTreeContext>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFTreeContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFTreeContext>())).copyDescription as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFTreeContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
impl Default for CFTreeContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@typedef CFTreeApplierFunction
///Type of the callback function used by the apply functions of
///CFTree.
///@param value The current value from the CFTree
///@param context The user-defined context parameter give to the apply
///function.
pub type CFTreeApplierFunction = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFTree {
    _unused: [u8; 0],
}
///@typedef CFTreeRef
///This is the type of a reference to CFTrees.
pub type CFTreeRef = *mut __CFTree;
extern "C" {
    ///@function CFTreeGetTypeID
    ///Returns the type identifier of all CFTree instances.
    pub fn CFTreeGetTypeID() -> CFTypeID;
}
extern "C" {
    ///@function CFTreeCreate
    ///Creates a new mutable tree.
    ///@param allocator The CFAllocator which should be used to allocate
    ///memory for the tree and storage for its children.  This
    ///parameter may be NULL in which case the current default
    ///CFAllocator is used.  If this reference is not a valid
    ///CFAllocator, the behavior is undefined.
    ///@param context A C pointer to a CFTreeContext structure to be copied
    ///and used as the context of the new tree.  The info parameter
    ///will be retained by the tree if a retain function is provided.
    ///If this value is not a valid C pointer to a CFTreeContext
    ///structure-sized block of storage, the result is undefined.
    ///If the version number of the storage is not a valid CFTreeContext
    ///version number, the result is undefined.
    ///@result A reference to the new CFTree.
    pub fn CFTreeCreate(allocator: CFAllocatorRef, context: *const CFTreeContext) -> CFTreeRef;
}
extern "C" {
    ///@function CFTreeGetParent
    ///Returns the parent of the specified tree.
    ///@param tree The tree to be queried.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    ///@result The parent of the tree.
    pub fn CFTreeGetParent(tree: CFTreeRef) -> CFTreeRef;
}
extern "C" {
    ///@function CFTreeGetNextSibling
    ///Returns the sibling after the specified tree in the parent tree's list.
    ///@param tree The tree to be queried.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    ///@result The next sibling of the tree.
    pub fn CFTreeGetNextSibling(tree: CFTreeRef) -> CFTreeRef;
}
extern "C" {
    ///@function CFTreeGetFirstChild
    ///Returns the first child of the tree.
    ///@param tree The tree to be queried.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    ///@result The first child of the tree.
    pub fn CFTreeGetFirstChild(tree: CFTreeRef) -> CFTreeRef;
}
extern "C" {
    ///@function CFTreeGetContext
    ///Returns the context of the specified tree.
    ///@param tree The tree to be queried.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    ///@param context A C pointer to a CFTreeContext structure to be filled in with
    ///the context of the specified tree.  If this value is not a valid C
    ///pointer to a CFTreeContext structure-sized block of storage, the
    ///result is undefined.  If the version number of the storage is not
    ///a valid CFTreeContext version number, the result is undefined.
    pub fn CFTreeGetContext(tree: CFTreeRef, context: *mut CFTreeContext);
}
extern "C" {
    ///@function CFTreeGetChildCount
    ///Returns the number of children of the specified tree.
    ///@param tree The tree to be queried.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    ///@result The number of children.
    pub fn CFTreeGetChildCount(tree: CFTreeRef) -> CFIndex;
}
extern "C" {
    ///@function CFTreeGetChildAtIndex
    ///Returns the nth child of the specified tree.
    ///@param tree The tree to be queried.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    ///@param idx The index of the child tree to be returned.  If this parameter
    ///is less than zero or greater than the number of children of the
    ///tree, the result is undefined.
    ///@result A reference to the specified child tree.
    pub fn CFTreeGetChildAtIndex(tree: CFTreeRef, idx: CFIndex) -> CFTreeRef;
}
extern "C" {
    ///@function CFTreeGetChildren
    ///Fills the buffer with children from the tree.
    ///@param tree The tree to be queried.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    ///@param children A C array of pointer-sized values to be filled with
    ///children from the tree.  If this parameter is not a valid pointer to a
    ///C array of at least CFTreeGetChildCount() pointers, the behavior is undefined.
    pub fn CFTreeGetChildren(tree: CFTreeRef, children: *mut CFTreeRef);
}
extern "C" {
    ///@function CFTreeApplyFunctionToChildren
    ///Calls a function once for each child of the tree.  Note that the applier
    ///only operates one level deep, and does not operate on descendents further
    ///removed than the immediate children of the tree.
    ///@param tree The tree to be operated upon.  If this parameter is not a
    ///valid CFTree, the behavior is undefined.
    ///@param applier The callback function to call once for each child of
    ///the given tree.  If this parameter is not a pointer to a
    ///function of the correct prototype, the behavior is undefined.
    ///If there are values in the tree which the applier function does
    ///not expect or cannot properly apply to, the behavior is undefined.
    ///@param context A pointer-sized user-defined value, which is passed
    ///as the second parameter to the applier function, but is
    ///otherwise unused by this function.  If the context is not
    ///what is expected by the applier function, the behavior is
    ///undefined.
    pub fn CFTreeApplyFunctionToChildren(
        tree: CFTreeRef,
        applier: CFTreeApplierFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function CFTreeFindRoot
    ///Returns the root tree of which the specified tree is a descendent.
    ///@param tree The tree to be queried.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    ///@result A reference to the root of the tree.
    pub fn CFTreeFindRoot(tree: CFTreeRef) -> CFTreeRef;
}
extern "C" {
    ///@function CFTreeSetContext
    ///Replaces the context of a tree.  The tree releases its retain on the
    ///info of the previous context, and retains the info of the new context.
    ///@param tree The tree to be operated on.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    ///@param context A C pointer to a CFTreeContext structure to be copied
    ///and used as the context of the new tree.  The info parameter
    ///will be retained by the tree if a retain function is provided.
    ///If this value is not a valid C pointer to a CFTreeContext
    ///structure-sized block of storage, the result is undefined.
    ///If the version number of the storage is not a valid CFTreeContext
    ///version number, the result is undefined.
    pub fn CFTreeSetContext(tree: CFTreeRef, context: *const CFTreeContext);
}
extern "C" {
    ///@function CFTreePrependChild
    ///Adds the newChild to the specified tree as the first in its list of children.
    ///@param tree The tree to be operated on.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    ///@param newChild The child to be added.
    ///If this parameter is not a valid CFTree, the behavior is undefined.
    ///If this parameter is a tree which is already a child of any tree,
    ///the behavior is undefined.
    pub fn CFTreePrependChild(tree: CFTreeRef, newChild: CFTreeRef);
}
extern "C" {
    ///@function CFTreeAppendChild
    ///Adds the newChild to the specified tree as the last in its list of children.
    ///@param tree The tree to be operated on.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    ///@param newChild The child to be added.
    ///If this parameter is not a valid CFTree, the behavior is undefined.
    ///If this parameter is a tree which is already a child of any tree,
    ///the behavior is undefined.
    pub fn CFTreeAppendChild(tree: CFTreeRef, newChild: CFTreeRef);
}
extern "C" {
    ///@function CFTreeInsertSibling
    ///Inserts newSibling into the the parent tree's linked list of children after
    ///tree.  The newSibling will have the same parent as tree.
    ///@param tree The tree to insert newSibling after.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.  If the tree does not have a
    ///parent, the behavior is undefined.
    ///@param newSibling The sibling to be added.
    ///If this parameter is not a valid CFTree, the behavior is undefined.
    ///If this parameter is a tree which is already a child of any tree,
    ///the behavior is undefined.
    pub fn CFTreeInsertSibling(tree: CFTreeRef, newSibling: CFTreeRef);
}
extern "C" {
    ///@function CFTreeRemove
    ///Removes the tree from its parent.
    ///@param tree The tree to be removed.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    pub fn CFTreeRemove(tree: CFTreeRef);
}
extern "C" {
    ///@function CFTreeRemoveAllChildren
    ///Removes all the children of the tree.
    ///@param tree The tree to remove all children from.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    pub fn CFTreeRemoveAllChildren(tree: CFTreeRef);
}
extern "C" {
    ///@function CFTreeSortChildren
    ///Sorts the children of the specified tree using the specified comparator function.
    ///@param tree The tree to be operated on.  If this parameter is not a valid
    ///CFTree, the behavior is undefined.
    ///@param comparator The function with the comparator function type
    ///signature which is used in the sort operation to compare
    ///children of the tree with the given value. If this parameter
    ///is not a pointer to a function of the correct prototype, the
    ///the behavior is undefined. The children of the tree are sorted
    ///from least to greatest according to this function.
    ///@param context A pointer-sized user-defined value, which is passed
    ///as the third parameter to the comparator function, but is
    ///otherwise unused by this function. If the context is not
    ///what is expected by the comparator function, the behavior is
    ///undefined.
    pub fn CFTreeSortChildren(
        tree: CFTreeRef,
        comparator: CFComparatorFunction,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFURLCreateDataAndPropertiesFromResource(
        alloc: CFAllocatorRef,
        url: CFURLRef,
        resourceData: *mut CFDataRef,
        properties: *mut CFDictionaryRef,
        desiredProperties: CFArrayRef,
        errorCode: *mut SInt32,
    ) -> Boolean;
}
extern "C" {
    pub fn CFURLWriteDataAndPropertiesToResource(
        url: CFURLRef,
        dataToWrite: CFDataRef,
        propertiesToWrite: CFDictionaryRef,
        errorCode: *mut SInt32,
    ) -> Boolean;
}
extern "C" {
    pub fn CFURLDestroyResource(url: CFURLRef, errorCode: *mut SInt32) -> Boolean;
}
extern "C" {
    pub fn CFURLCreatePropertyFromResource(
        alloc: CFAllocatorRef,
        url: CFURLRef,
        property: CFStringRef,
        errorCode: *mut SInt32,
    ) -> CFTypeRef;
}
pub type CFURLError = CFIndex;
pub const kCFURLUnknownError: _bindgen_ty_60 = -10;
pub const kCFURLUnknownSchemeError: _bindgen_ty_60 = -11;
pub const kCFURLResourceNotFoundError: _bindgen_ty_60 = -12;
pub const kCFURLResourceAccessViolationError: _bindgen_ty_60 = -13;
pub const kCFURLRemoteHostUnavailableError: _bindgen_ty_60 = -14;
pub const kCFURLImproperArgumentsError: _bindgen_ty_60 = -15;
pub const kCFURLUnknownPropertyKeyError: _bindgen_ty_60 = -16;
pub const kCFURLPropertyKeyUnavailableError: _bindgen_ty_60 = -17;
pub const kCFURLTimeoutError: _bindgen_ty_60 = -18;
pub type _bindgen_ty_60 = i32;
extern "C" {
    pub static kCFURLFileExists: CFStringRef;
}
extern "C" {
    pub static kCFURLFileDirectoryContents: CFStringRef;
}
extern "C" {
    pub static kCFURLFileLength: CFStringRef;
}
extern "C" {
    pub static kCFURLFileLastModificationTime: CFStringRef;
}
extern "C" {
    pub static kCFURLFilePOSIXMode: CFStringRef;
}
extern "C" {
    pub static kCFURLFileOwnerID: CFStringRef;
}
extern "C" {
    pub static kCFURLHTTPStatusCode: CFStringRef;
}
extern "C" {
    pub static kCFURLHTTPStatusLine: CFStringRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFUUID {
    _unused: [u8; 0],
}
pub type CFUUIDRef = *const __CFUUID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CFUUIDBytes {
    pub byte0: UInt8,
    pub byte1: UInt8,
    pub byte2: UInt8,
    pub byte3: UInt8,
    pub byte4: UInt8,
    pub byte5: UInt8,
    pub byte6: UInt8,
    pub byte7: UInt8,
    pub byte8: UInt8,
    pub byte9: UInt8,
    pub byte10: UInt8,
    pub byte11: UInt8,
    pub byte12: UInt8,
    pub byte13: UInt8,
    pub byte14: UInt8,
    pub byte15: UInt8,
}
#[test]
fn bindgen_test_layout_CFUUIDBytes() {
    assert_eq!(
        ::std::mem::size_of::<CFUUIDBytes>(),
        16usize,
        concat!("Size of: ", stringify!(CFUUIDBytes))
    );
    assert_eq!(
        ::std::mem::align_of::<CFUUIDBytes>(),
        1usize,
        concat!("Alignment of ", stringify!(CFUUIDBytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte3 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte4 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte5 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte6 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte7 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte8 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte9 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte10 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte11 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte12 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte13 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte14 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFUUIDBytes>())).byte15 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(CFUUIDBytes),
            "::",
            stringify!(byte15)
        )
    );
}
extern "C" {
    pub fn CFUUIDGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFUUIDCreate(alloc: CFAllocatorRef) -> CFUUIDRef;
}
extern "C" {
    pub fn CFUUIDCreateWithBytes(
        alloc: CFAllocatorRef,
        byte0: UInt8,
        byte1: UInt8,
        byte2: UInt8,
        byte3: UInt8,
        byte4: UInt8,
        byte5: UInt8,
        byte6: UInt8,
        byte7: UInt8,
        byte8: UInt8,
        byte9: UInt8,
        byte10: UInt8,
        byte11: UInt8,
        byte12: UInt8,
        byte13: UInt8,
        byte14: UInt8,
        byte15: UInt8,
    ) -> CFUUIDRef;
}
extern "C" {
    pub fn CFUUIDCreateFromString(alloc: CFAllocatorRef, uuidStr: CFStringRef) -> CFUUIDRef;
}
extern "C" {
    pub fn CFUUIDCreateString(alloc: CFAllocatorRef, uuid: CFUUIDRef) -> CFStringRef;
}
extern "C" {
    pub fn CFUUIDGetConstantUUIDWithBytes(
        alloc: CFAllocatorRef,
        byte0: UInt8,
        byte1: UInt8,
        byte2: UInt8,
        byte3: UInt8,
        byte4: UInt8,
        byte5: UInt8,
        byte6: UInt8,
        byte7: UInt8,
        byte8: UInt8,
        byte9: UInt8,
        byte10: UInt8,
        byte11: UInt8,
        byte12: UInt8,
        byte13: UInt8,
        byte14: UInt8,
        byte15: UInt8,
    ) -> CFUUIDRef;
}
extern "C" {
    pub fn CFUUIDGetUUIDBytes(uuid: CFUUIDRef) -> CFUUIDBytes;
}
extern "C" {
    pub fn CFUUIDCreateFromUUIDBytes(alloc: CFAllocatorRef, bytes: CFUUIDBytes) -> CFUUIDRef;
}
extern "C" {
    pub fn CFCopyHomeDirectoryURL() -> CFURLRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFBundle {
    _unused: [u8; 0],
}
pub type CFBundleRef = *mut __CFBundle;
pub type CFPlugInRef = *mut __CFBundle;
extern "C" {
    pub static kCFBundleInfoDictionaryVersionKey: CFStringRef;
}
extern "C" {
    pub static kCFBundleExecutableKey: CFStringRef;
}
extern "C" {
    pub static kCFBundleIdentifierKey: CFStringRef;
}
extern "C" {
    pub static kCFBundleVersionKey: CFStringRef;
}
extern "C" {
    pub static kCFBundleDevelopmentRegionKey: CFStringRef;
}
extern "C" {
    pub static kCFBundleNameKey: CFStringRef;
}
extern "C" {
    pub static kCFBundleLocalizationsKey: CFStringRef;
}
extern "C" {
    pub fn CFBundleGetMainBundle() -> CFBundleRef;
}
extern "C" {
    pub fn CFBundleGetBundleWithIdentifier(bundleID: CFStringRef) -> CFBundleRef;
}
extern "C" {
    pub fn CFBundleGetAllBundles() -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFBundleCreate(allocator: CFAllocatorRef, bundleURL: CFURLRef) -> CFBundleRef;
}
extern "C" {
    pub fn CFBundleCreateBundlesFromDirectory(
        allocator: CFAllocatorRef,
        directoryURL: CFURLRef,
        bundleType: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyBundleURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleGetValueForInfoDictionaryKey(bundle: CFBundleRef, key: CFStringRef)
        -> CFTypeRef;
}
extern "C" {
    pub fn CFBundleGetInfoDictionary(bundle: CFBundleRef) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFBundleGetLocalInfoDictionary(bundle: CFBundleRef) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFBundleGetPackageInfo(
        bundle: CFBundleRef,
        packageType: *mut UInt32,
        packageCreator: *mut UInt32,
    );
}
extern "C" {
    pub fn CFBundleGetIdentifier(bundle: CFBundleRef) -> CFStringRef;
}
extern "C" {
    pub fn CFBundleGetVersionNumber(bundle: CFBundleRef) -> UInt32;
}
extern "C" {
    pub fn CFBundleGetDevelopmentRegion(bundle: CFBundleRef) -> CFStringRef;
}
extern "C" {
    pub fn CFBundleCopySupportFilesDirectoryURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyResourcesDirectoryURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyPrivateFrameworksURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopySharedFrameworksURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopySharedSupportURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyBuiltInPlugInsURL(bundle: CFBundleRef) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyInfoDictionaryInDirectory(bundleURL: CFURLRef) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFBundleGetPackageInfoInDirectory(
        url: CFURLRef,
        packageType: *mut UInt32,
        packageCreator: *mut UInt32,
    ) -> Boolean;
}
extern "C" {
    pub fn CFBundleCopyResourceURL(
        bundle: CFBundleRef,
        resourceName: CFStringRef,
        resourceType: CFStringRef,
        subDirName: CFStringRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyResourceURLsOfType(
        bundle: CFBundleRef,
        resourceType: CFStringRef,
        subDirName: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyLocalizedString(
        bundle: CFBundleRef,
        key: CFStringRef,
        value: CFStringRef,
        tableName: CFStringRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFBundleCopyResourceURLInDirectory(
        bundleURL: CFURLRef,
        resourceName: CFStringRef,
        resourceType: CFStringRef,
        subDirName: CFStringRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyResourceURLsOfTypeInDirectory(
        bundleURL: CFURLRef,
        resourceType: CFStringRef,
        subDirName: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyBundleLocalizations(bundle: CFBundleRef) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyPreferredLocalizationsFromArray(locArray: CFArrayRef) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyLocalizationsForPreferences(
        locArray: CFArrayRef,
        prefArray: CFArrayRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyResourceURLForLocalization(
        bundle: CFBundleRef,
        resourceName: CFStringRef,
        resourceType: CFStringRef,
        subDirName: CFStringRef,
        localizationName: CFStringRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleCopyResourceURLsOfTypeForLocalization(
        bundle: CFBundleRef,
        resourceType: CFStringRef,
        subDirName: CFStringRef,
        localizationName: CFStringRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyInfoDictionaryForURL(url: CFURLRef) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFBundleCopyLocalizationsForURL(url: CFURLRef) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyExecutableArchitecturesForURL(url: CFURLRef) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundleCopyExecutableURL(bundle: CFBundleRef) -> CFURLRef;
}
pub const kCFBundleExecutableArchitectureI386: _bindgen_ty_61 = 7;
pub const kCFBundleExecutableArchitecturePPC: _bindgen_ty_61 = 18;
pub const kCFBundleExecutableArchitectureX86_64: _bindgen_ty_61 = 16777223;
pub const kCFBundleExecutableArchitecturePPC64: _bindgen_ty_61 = 16777234;
pub type _bindgen_ty_61 = u32;
extern "C" {
    pub fn CFBundleCopyExecutableArchitectures(bundle: CFBundleRef) -> CFArrayRef;
}
extern "C" {
    pub fn CFBundlePreflightExecutable(bundle: CFBundleRef, error: *mut CFErrorRef) -> Boolean;
}
extern "C" {
    pub fn CFBundleLoadExecutableAndReturnError(
        bundle: CFBundleRef,
        error: *mut CFErrorRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFBundleLoadExecutable(bundle: CFBundleRef) -> Boolean;
}
extern "C" {
    pub fn CFBundleIsExecutableLoaded(bundle: CFBundleRef) -> Boolean;
}
extern "C" {
    pub fn CFBundleUnloadExecutable(bundle: CFBundleRef);
}
extern "C" {
    pub fn CFBundleGetFunctionPointerForName(
        bundle: CFBundleRef,
        functionName: CFStringRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFBundleGetFunctionPointersForNames(
        bundle: CFBundleRef,
        functionNames: CFArrayRef,
        ftbl: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFBundleGetDataPointerForName(
        bundle: CFBundleRef,
        symbolName: CFStringRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFBundleGetDataPointersForNames(
        bundle: CFBundleRef,
        symbolNames: CFArrayRef,
        stbl: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn CFBundleCopyAuxiliaryExecutableURL(
        bundle: CFBundleRef,
        executableName: CFStringRef,
    ) -> CFURLRef;
}
extern "C" {
    pub fn CFBundleGetPlugIn(bundle: CFBundleRef) -> CFPlugInRef;
}
pub type CFBundleRefNum = ::std::os::raw::c_int;
extern "C" {
    pub fn CFBundleOpenBundleResourceMap(bundle: CFBundleRef) -> CFBundleRefNum;
}
extern "C" {
    pub fn CFBundleOpenBundleResourceFiles(
        bundle: CFBundleRef,
        refNum: *mut CFBundleRefNum,
        localizedRefNum: *mut CFBundleRefNum,
    ) -> SInt32;
}
extern "C" {
    pub fn CFBundleCloseBundleResourceMap(bundle: CFBundleRef, refNum: CFBundleRefNum);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFMessagePort {
    _unused: [u8; 0],
}
pub type CFMessagePortRef = *mut __CFMessagePort;
pub const kCFMessagePortSuccess: _bindgen_ty_62 = 0;
pub const kCFMessagePortSendTimeout: _bindgen_ty_62 = -1;
pub const kCFMessagePortReceiveTimeout: _bindgen_ty_62 = -2;
pub const kCFMessagePortIsInvalid: _bindgen_ty_62 = -3;
pub const kCFMessagePortTransportError: _bindgen_ty_62 = -4;
pub const kCFMessagePortBecameInvalidError: _bindgen_ty_62 = -5;
pub type _bindgen_ty_62 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFMessagePortContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub release: ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFMessagePortContext() {
    assert_eq!(
        ::std::mem::size_of::<CFMessagePortContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFMessagePortContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFMessagePortContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFMessagePortContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFMessagePortContext>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMessagePortContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFMessagePortContext>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMessagePortContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFMessagePortContext>())).retain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMessagePortContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFMessagePortContext>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMessagePortContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFMessagePortContext>())).copyDescription as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMessagePortContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
impl Default for CFMessagePortContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CFMessagePortCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        local: CFMessagePortRef,
        msgid: SInt32,
        data: CFDataRef,
        info: *mut ::std::os::raw::c_void,
    ) -> CFDataRef,
>;
pub type CFMessagePortInvalidationCallBack = ::std::option::Option<
    unsafe extern "C" fn(ms: CFMessagePortRef, info: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn CFMessagePortGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFMessagePortCreateLocal(
        allocator: CFAllocatorRef,
        name: CFStringRef,
        callout: CFMessagePortCallBack,
        context: *mut CFMessagePortContext,
        shouldFreeInfo: *mut Boolean,
    ) -> CFMessagePortRef;
}
extern "C" {
    pub fn CFMessagePortCreateRemote(
        allocator: CFAllocatorRef,
        name: CFStringRef,
    ) -> CFMessagePortRef;
}
extern "C" {
    pub fn CFMessagePortIsRemote(ms: CFMessagePortRef) -> Boolean;
}
extern "C" {
    pub fn CFMessagePortGetName(ms: CFMessagePortRef) -> CFStringRef;
}
extern "C" {
    pub fn CFMessagePortSetName(ms: CFMessagePortRef, newName: CFStringRef) -> Boolean;
}
extern "C" {
    pub fn CFMessagePortGetContext(ms: CFMessagePortRef, context: *mut CFMessagePortContext);
}
extern "C" {
    pub fn CFMessagePortInvalidate(ms: CFMessagePortRef);
}
extern "C" {
    pub fn CFMessagePortIsValid(ms: CFMessagePortRef) -> Boolean;
}
extern "C" {
    pub fn CFMessagePortGetInvalidationCallBack(
        ms: CFMessagePortRef,
    ) -> CFMessagePortInvalidationCallBack;
}
extern "C" {
    pub fn CFMessagePortSetInvalidationCallBack(
        ms: CFMessagePortRef,
        callout: CFMessagePortInvalidationCallBack,
    );
}
extern "C" {
    pub fn CFMessagePortSendRequest(
        remote: CFMessagePortRef,
        msgid: SInt32,
        data: CFDataRef,
        sendTimeout: CFTimeInterval,
        rcvTimeout: CFTimeInterval,
        replyMode: CFStringRef,
        returnData: *mut CFDataRef,
    ) -> SInt32;
}
extern "C" {
    pub fn CFMessagePortCreateRunLoopSource(
        allocator: CFAllocatorRef,
        local: CFMessagePortRef,
        order: CFIndex,
    ) -> CFRunLoopSourceRef;
}
extern "C" {
    pub fn CFMessagePortSetDispatchQueue(ms: CFMessagePortRef, queue: dispatch_queue_t);
}
extern "C" {
    pub static kCFPlugInDynamicRegistrationKey: CFStringRef;
}
extern "C" {
    pub static kCFPlugInDynamicRegisterFunctionKey: CFStringRef;
}
extern "C" {
    pub static kCFPlugInUnloadFunctionKey: CFStringRef;
}
extern "C" {
    pub static kCFPlugInFactoriesKey: CFStringRef;
}
extern "C" {
    pub static kCFPlugInTypesKey: CFStringRef;
}
pub type CFPlugInDynamicRegisterFunction =
    ::std::option::Option<unsafe extern "C" fn(plugIn: CFPlugInRef)>;
pub type CFPlugInUnloadFunction = ::std::option::Option<unsafe extern "C" fn(plugIn: CFPlugInRef)>;
pub type CFPlugInFactoryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: CFAllocatorRef,
        typeUUID: CFUUIDRef,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn CFPlugInGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFPlugInCreate(allocator: CFAllocatorRef, plugInURL: CFURLRef) -> CFPlugInRef;
}
extern "C" {
    pub fn CFPlugInGetBundle(plugIn: CFPlugInRef) -> CFBundleRef;
}
extern "C" {
    pub fn CFPlugInSetLoadOnDemand(plugIn: CFPlugInRef, flag: Boolean);
}
extern "C" {
    pub fn CFPlugInIsLoadOnDemand(plugIn: CFPlugInRef) -> Boolean;
}
extern "C" {
    pub fn CFPlugInFindFactoriesForPlugInType(typeUUID: CFUUIDRef) -> CFArrayRef;
}
extern "C" {
    pub fn CFPlugInFindFactoriesForPlugInTypeInPlugIn(
        typeUUID: CFUUIDRef,
        plugIn: CFPlugInRef,
    ) -> CFArrayRef;
}
extern "C" {
    pub fn CFPlugInInstanceCreate(
        allocator: CFAllocatorRef,
        factoryUUID: CFUUIDRef,
        typeUUID: CFUUIDRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFPlugInRegisterFactoryFunction(
        factoryUUID: CFUUIDRef,
        func: CFPlugInFactoryFunction,
    ) -> Boolean;
}
extern "C" {
    pub fn CFPlugInRegisterFactoryFunctionByName(
        factoryUUID: CFUUIDRef,
        plugIn: CFPlugInRef,
        functionName: CFStringRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFPlugInUnregisterFactory(factoryUUID: CFUUIDRef) -> Boolean;
}
extern "C" {
    pub fn CFPlugInRegisterPlugInType(factoryUUID: CFUUIDRef, typeUUID: CFUUIDRef) -> Boolean;
}
extern "C" {
    pub fn CFPlugInUnregisterPlugInType(factoryUUID: CFUUIDRef, typeUUID: CFUUIDRef) -> Boolean;
}
extern "C" {
    pub fn CFPlugInAddInstanceForFactory(factoryID: CFUUIDRef);
}
extern "C" {
    pub fn CFPlugInRemoveInstanceForFactory(factoryID: CFUUIDRef);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFPlugInInstance {
    _unused: [u8; 0],
}
pub type CFPlugInInstanceRef = *mut __CFPlugInInstance;
pub type CFPlugInInstanceGetInterfaceFunction = ::std::option::Option<
    unsafe extern "C" fn(
        instance: CFPlugInInstanceRef,
        interfaceName: CFStringRef,
        ftbl: *mut *mut ::std::os::raw::c_void,
    ) -> Boolean,
>;
pub type CFPlugInInstanceDeallocateInstanceDataFunction =
    ::std::option::Option<unsafe extern "C" fn(instanceData: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn CFPlugInInstanceGetInterfaceFunctionTable(
        instance: CFPlugInInstanceRef,
        interfaceName: CFStringRef,
        ftbl: *mut *mut ::std::os::raw::c_void,
    ) -> Boolean;
}
extern "C" {
    pub fn CFPlugInInstanceGetFactoryName(instance: CFPlugInInstanceRef) -> CFStringRef;
}
extern "C" {
    pub fn CFPlugInInstanceGetInstanceData(
        instance: CFPlugInInstanceRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFPlugInInstanceGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFPlugInInstanceCreateWithInstanceDataSize(
        allocator: CFAllocatorRef,
        instanceDataSize: CFIndex,
        deallocateInstanceFunction: CFPlugInInstanceDeallocateInstanceDataFunction,
        factoryName: CFStringRef,
        getInterfaceFunction: CFPlugInInstanceGetInterfaceFunction,
    ) -> CFPlugInInstanceRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFMachPort {
    _unused: [u8; 0],
}
pub type CFMachPortRef = *mut __CFMachPort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFMachPortContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub release: ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFMachPortContext() {
    assert_eq!(
        ::std::mem::size_of::<CFMachPortContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFMachPortContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFMachPortContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFMachPortContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFMachPortContext>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMachPortContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFMachPortContext>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMachPortContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFMachPortContext>())).retain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMachPortContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFMachPortContext>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMachPortContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFMachPortContext>())).copyDescription as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFMachPortContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
impl Default for CFMachPortContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CFMachPortCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        port: CFMachPortRef,
        msg: *mut ::std::os::raw::c_void,
        size: CFIndex,
        info: *mut ::std::os::raw::c_void,
    ),
>;
pub type CFMachPortInvalidationCallBack = ::std::option::Option<
    unsafe extern "C" fn(port: CFMachPortRef, info: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn CFMachPortGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFMachPortCreate(
        allocator: CFAllocatorRef,
        callout: CFMachPortCallBack,
        context: *mut CFMachPortContext,
        shouldFreeInfo: *mut Boolean,
    ) -> CFMachPortRef;
}
extern "C" {
    pub fn CFMachPortCreateWithPort(
        allocator: CFAllocatorRef,
        portNum: mach_port_t,
        callout: CFMachPortCallBack,
        context: *mut CFMachPortContext,
        shouldFreeInfo: *mut Boolean,
    ) -> CFMachPortRef;
}
extern "C" {
    pub fn CFMachPortGetPort(port: CFMachPortRef) -> mach_port_t;
}
extern "C" {
    pub fn CFMachPortGetContext(port: CFMachPortRef, context: *mut CFMachPortContext);
}
extern "C" {
    pub fn CFMachPortInvalidate(port: CFMachPortRef);
}
extern "C" {
    pub fn CFMachPortIsValid(port: CFMachPortRef) -> Boolean;
}
extern "C" {
    pub fn CFMachPortGetInvalidationCallBack(port: CFMachPortRef)
        -> CFMachPortInvalidationCallBack;
}
extern "C" {
    pub fn CFMachPortSetInvalidationCallBack(
        port: CFMachPortRef,
        callout: CFMachPortInvalidationCallBack,
    );
}
extern "C" {
    pub fn CFMachPortCreateRunLoopSource(
        allocator: CFAllocatorRef,
        port: CFMachPortRef,
        order: CFIndex,
    ) -> CFRunLoopSourceRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFAttributedString {
    _unused: [u8; 0],
}
pub type CFAttributedStringRef = *const __CFAttributedString;
pub type CFMutableAttributedStringRef = *mut __CFAttributedString;
extern "C" {
    /// @function CFAttributedStringGetTypeID
    ///Returns the type identifier of all CFAttributedString instances.
    pub fn CFAttributedStringGetTypeID() -> CFTypeID;
}
extern "C" {
    /// @function CFAttributedStringCreate
    ///Creates an attributed string with the specified string and attributes (both copied).
    pub fn CFAttributedStringCreate(
        alloc: CFAllocatorRef,
        str: CFStringRef,
        attributes: CFDictionaryRef,
    ) -> CFAttributedStringRef;
}
extern "C" {
    /// @function CFAttributedStringCreateWithSubstring
    ///Creates a sub-attributed string from the specified range. It's a programming error for range to specify characters outside the bounds of aStr.
    pub fn CFAttributedStringCreateWithSubstring(
        alloc: CFAllocatorRef,
        aStr: CFAttributedStringRef,
        range: CFRange,
    ) -> CFAttributedStringRef;
}
extern "C" {
    /// @function CFAttributedStringCreateCopy
    ///Creates an immutable attributed string copy.
    pub fn CFAttributedStringCreateCopy(
        alloc: CFAllocatorRef,
        aStr: CFAttributedStringRef,
    ) -> CFAttributedStringRef;
}
extern "C" {
    /// @function CFAttributedStringGetString
    ///Returns the string for the attributed string. For performance reasons, this will often point at the backing store of the attributed string, and it might change if the attributed string is edited.  However, this is an implementation detail, and definitely not something that should be counted on.
    pub fn CFAttributedStringGetString(aStr: CFAttributedStringRef) -> CFStringRef;
}
extern "C" {
    /// @function CFAttributedStringGetLength
    ///Returns the length of the attributed string in characters; same as CFStringGetLength(CFAttributedStringGetString(aStr))
    pub fn CFAttributedStringGetLength(aStr: CFAttributedStringRef) -> CFIndex;
}
extern "C" {
    /// @function CFAttributedStringGetAttributes
    ///Returns the attributes at the specified location. If effectiveRange is not NULL, upon return *effectiveRange contains a range over which the exact same set of attributes apply. Note that for performance reasons, the returned effectiveRange is not necessarily the maximal range - for that, use CFAttributedStringGetAttributesAndLongestEffectiveRange().  It's a programming error for loc to specify a location outside the bounds of the attributed string.
    ///
    ///Note that the returned attribute dictionary might change in unpredictable ways from under the caller if the attributed string is edited after this call. If you wish to hang on to the dictionary long-term, you should make an actual copy of it rather than just retaining it.  Also, no assumptions should be made about the relationship of the actual CFDictionaryRef returned by this call and the dictionary originally used to set the attributes, other than the fact that the values stored in the dictionary will be identical (that is, ==) to those originally specified.
    pub fn CFAttributedStringGetAttributes(
        aStr: CFAttributedStringRef,
        loc: CFIndex,
        effectiveRange: *mut CFRange,
    ) -> CFDictionaryRef;
}
extern "C" {
    /// @function CFAttributedStringGetAttribute
    ///Returns the value of a single attribute at the specified location. If the specified attribute doesn't exist at the location, returns NULL. If effectiveRange is not NULL, upon return *effectiveRange contains a range over which the exact same attribute value applies. Note that for performance reasons, the returned effectiveRange is not necessarily the maximal range - for that, use CFAttributedStringGetAttributeAndLongestEffectiveRange(). It's a programming error for loc to specify a location outside the bounds of the attributed string.
    pub fn CFAttributedStringGetAttribute(
        aStr: CFAttributedStringRef,
        loc: CFIndex,
        attrName: CFStringRef,
        effectiveRange: *mut CFRange,
    ) -> CFTypeRef;
}
extern "C" {
    /// @function CFAttributedStringGetAttributesAndLongestEffectiveRange
    ///Returns the attributes at the specified location. If longestEffectiveRange is not NULL, upon return *longestEffectiveRange contains the maximal range within inRange over which the exact same set of attributes apply. The returned range is clipped to inRange. It's a programming error for loc or inRange to specify locations outside the bounds of the attributed string.
    pub fn CFAttributedStringGetAttributesAndLongestEffectiveRange(
        aStr: CFAttributedStringRef,
        loc: CFIndex,
        inRange: CFRange,
        longestEffectiveRange: *mut CFRange,
    ) -> CFDictionaryRef;
}
extern "C" {
    /// @function CFAttributedStringGetAttributeAndLongestEffectiveRange
    ///Returns the value of a single attribute at the specified location. If longestEffectiveRange is not NULL, upon return *longestEffectiveRange contains the maximal range within inRange over which the exact same attribute value applies. The returned range is clipped to inRange. It's a programming error for loc or inRange to specify locations outside the bounds of the attributed string.
    pub fn CFAttributedStringGetAttributeAndLongestEffectiveRange(
        aStr: CFAttributedStringRef,
        loc: CFIndex,
        attrName: CFStringRef,
        inRange: CFRange,
        longestEffectiveRange: *mut CFRange,
    ) -> CFTypeRef;
}
extern "C" {
    /// @function CFAttributedStringCreateMutableCopy
    ///Creates a mutable attributed string copy. maxLength, if not 0, is a hard bound on the length of the attributed string; exceeding this size limit during any editing operation is a programming error. If 0, there is no limit on the length.
    pub fn CFAttributedStringCreateMutableCopy(
        alloc: CFAllocatorRef,
        maxLength: CFIndex,
        aStr: CFAttributedStringRef,
    ) -> CFMutableAttributedStringRef;
}
extern "C" {
    /// @function CFAttributedStringCreateMutable
    ///Creates a mutable empty attributed string. maxLength, if not 0, is a hard bound on the length of the attributed string; exceeding this size limit during any editing operation is a programming error. If 0, there is no limit on the length.
    pub fn CFAttributedStringCreateMutable(
        alloc: CFAllocatorRef,
        maxLength: CFIndex,
    ) -> CFMutableAttributedStringRef;
}
extern "C" {
    /// @function CFAttributedStringReplaceString
    ///Modifies the string for the attributed string, much like CFStringReplace().  It's an error for range to specify characters outside the bounds of aStr.
    ///
    ///(Note: This function is a convenience on CFAttributedStringGetMutableString(); however, until CFAttributedStringGetMutableString() is implemented, it remains the only way to edit the string of the attributed string.)
    pub fn CFAttributedStringReplaceString(
        aStr: CFMutableAttributedStringRef,
        range: CFRange,
        replacement: CFStringRef,
    );
}
extern "C" {
    /// @function CFAttributedStringGetMutableString
    ///Gets the string for the attributed string as a mutable string, allowing editing the character contents of the string as if it were an CFMutableString. Attributes corresponding to the edited range are appropriately modified. If, as a result of the edit, new characters are introduced into the string, they inherit the attributes of the first replaced character from range. If no existing characters are replaced by the edit, the new characters inherit the attributes of the character preceding range if it has any, otherwise of the character following range. If the initial string is empty, the attributes for the new characters are also empty.
    ///
    ///(Note: This function is not yet implemented and will return NULL except for toll-free bridged instances.)
    pub fn CFAttributedStringGetMutableString(
        aStr: CFMutableAttributedStringRef,
    ) -> CFMutableStringRef;
}
extern "C" {
    /// @function CFAttributedStringSetAttributes
    ///Sets the value of multiple attributes over the specified range, which should be valid. If clearOtherAttributes is false, existing attributes (which aren't being replaced) are left alone; otherwise they are cleared. The dictionary should be setup for "usual" CF type usage --- CFString keys, and arbitrary CFType values. Note that after this call, further mutations to the replacement dictionary argument by the caller will not affect the contents of the attributed string.
    pub fn CFAttributedStringSetAttributes(
        aStr: CFMutableAttributedStringRef,
        range: CFRange,
        replacement: CFDictionaryRef,
        clearOtherAttributes: Boolean,
    );
}
extern "C" {
    /// @function CFAttributedStringSetAttribute
    ///Sets the value of a single attribute over the specified range, which should be valid. value should not be NULL.
    pub fn CFAttributedStringSetAttribute(
        aStr: CFMutableAttributedStringRef,
        range: CFRange,
        attrName: CFStringRef,
        value: CFTypeRef,
    );
}
extern "C" {
    /// @function CFAttributedStringRemoveAttribute
    ///Removes the value of a single attribute over the specified range, which should be valid. It's OK for the attribute not the exist over the specified range.
    pub fn CFAttributedStringRemoveAttribute(
        aStr: CFMutableAttributedStringRef,
        range: CFRange,
        attrName: CFStringRef,
    );
}
extern "C" {
    /// @function CFAttributedStringReplaceAttributedString
    ///Replaces the attributed substring over the specified range with the attributed string specified in replacement. range should be valid. To delete a range of the attributed string, call CFAttributedStringReplaceString() with empty string and specified range.
    pub fn CFAttributedStringReplaceAttributedString(
        aStr: CFMutableAttributedStringRef,
        range: CFRange,
        replacement: CFAttributedStringRef,
    );
}
extern "C" {
    /// @function CFAttributedStringBeginEditing
    ///In cases where attributed string might do a bunch of work to assure self-consistency, CFAttributedStringBeginEditing/CFAttributedStringEndEditing allow disabling that to allow deferring and coalescing any work. It's a good idea to call these around a set of related mutation calls which don't require the string to be in consistent state in between. These calls can be nested.
    pub fn CFAttributedStringBeginEditing(aStr: CFMutableAttributedStringRef);
}
extern "C" {
    /// @function CFAttributedStringEndEditing
    ///In cases where attributed string might do a bunch of work to assure self-consistency, CFAttributedStringBeginEditing/CFAttributedStringEndEditing allow disabling that to allow deferring and coalescing any work. It's a good idea to call these around a set of related mutation calls which don't require the string to be in consistent state in between. These calls can be nested.
    pub fn CFAttributedStringEndEditing(aStr: CFMutableAttributedStringRef);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFURLEnumerator {
    _unused: [u8; 0],
}
pub type CFURLEnumeratorRef = *const __CFURLEnumerator;
extern "C" {
    pub fn CFURLEnumeratorGetTypeID() -> CFTypeID;
}
pub type CFURLEnumeratorOptions = CFOptionFlags;
pub const kCFURLEnumeratorDefaultBehavior: _bindgen_ty_63 = 0;
pub const kCFURLEnumeratorDescendRecursively: _bindgen_ty_63 = 1;
pub const kCFURLEnumeratorSkipInvisibles: _bindgen_ty_63 = 2;
pub const kCFURLEnumeratorGenerateFileReferenceURLs: _bindgen_ty_63 = 4;
pub const kCFURLEnumeratorSkipPackageContents: _bindgen_ty_63 = 8;
pub const kCFURLEnumeratorIncludeDirectoriesPreOrder: _bindgen_ty_63 = 16;
pub const kCFURLEnumeratorIncludeDirectoriesPostOrder: _bindgen_ty_63 = 32;
pub type _bindgen_ty_63 = u32;
extern "C" {
    pub fn CFURLEnumeratorCreateForDirectoryURL(
        alloc: CFAllocatorRef,
        directoryURL: CFURLRef,
        option: CFURLEnumeratorOptions,
        propertyKeys: CFArrayRef,
    ) -> CFURLEnumeratorRef;
}
extern "C" {
    pub fn CFURLEnumeratorCreateForMountedVolumes(
        alloc: CFAllocatorRef,
        option: CFURLEnumeratorOptions,
        propertyKeys: CFArrayRef,
    ) -> CFURLEnumeratorRef;
}
pub type CFURLEnumeratorResult = CFIndex;
pub const kCFURLEnumeratorSuccess: _bindgen_ty_64 = 1;
pub const kCFURLEnumeratorEnd: _bindgen_ty_64 = 2;
pub const kCFURLEnumeratorError: _bindgen_ty_64 = 3;
pub const kCFURLEnumeratorDirectoryPostOrderSuccess: _bindgen_ty_64 = 4;
pub type _bindgen_ty_64 = u32;
extern "C" {
    pub fn CFURLEnumeratorGetNextURL(
        enumerator: CFURLEnumeratorRef,
        url: *mut CFURLRef,
        error: *mut CFErrorRef,
    ) -> CFURLEnumeratorResult;
}
extern "C" {
    pub fn CFURLEnumeratorSkipDescendents(enumerator: CFURLEnumeratorRef);
}
extern "C" {
    pub fn CFURLEnumeratorGetDescendentLevel(enumerator: CFURLEnumeratorRef) -> CFIndex;
}
extern "C" {
    pub fn CFURLEnumeratorGetSourceDidChange(enumerator: CFURLEnumeratorRef) -> Boolean;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct guid_t {
    pub g_guid: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_guid_t() {
    assert_eq!(
        ::std::mem::size_of::<guid_t>(),
        16usize,
        concat!("Size of: ", stringify!(guid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<guid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(guid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<guid_t>())).g_guid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(guid_t),
            "::",
            stringify!(g_guid)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ntsid_t {
    pub sid_kind: u_int8_t,
    pub sid_authcount: u_int8_t,
    pub sid_authority: [u_int8_t; 6usize],
    pub sid_authorities: [u_int32_t; 16usize],
}
#[test]
fn bindgen_test_layout_ntsid_t() {
    assert_eq!(
        ::std::mem::size_of::<ntsid_t>(),
        72usize,
        concat!("Size of: ", stringify!(ntsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ntsid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ntsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ntsid_t>())).sid_kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ntsid_t),
            "::",
            stringify!(sid_kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ntsid_t>())).sid_authcount as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ntsid_t),
            "::",
            stringify!(sid_authcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ntsid_t>())).sid_authority as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ntsid_t),
            "::",
            stringify!(sid_authority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ntsid_t>())).sid_authorities as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ntsid_t),
            "::",
            stringify!(sid_authorities)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kauth_identity_extlookup {
    pub el_seqno: u_int32_t,
    pub el_result: u_int32_t,
    pub el_flags: u_int32_t,
    pub el_info_pid: __darwin_pid_t,
    pub el_extend: u_int64_t,
    pub el_info_reserved_1: u_int32_t,
    pub el_uid: uid_t,
    pub el_uguid: guid_t,
    pub el_uguid_valid: u_int32_t,
    pub el_usid: ntsid_t,
    pub el_usid_valid: u_int32_t,
    pub el_gid: gid_t,
    pub el_gguid: guid_t,
    pub el_gguid_valid: u_int32_t,
    pub el_gsid: ntsid_t,
    pub el_gsid_valid: u_int32_t,
    pub el_member_valid: u_int32_t,
    pub el_sup_grp_cnt: u_int32_t,
    pub el_sup_groups: [gid_t; 16usize],
}
#[test]
fn bindgen_test_layout_kauth_identity_extlookup() {
    assert_eq!(
        ::std::mem::size_of::<kauth_identity_extlookup>(),
        304usize,
        concat!("Size of: ", stringify!(kauth_identity_extlookup))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_identity_extlookup>(),
        8usize,
        concat!("Alignment of ", stringify!(kauth_identity_extlookup))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_seqno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_seqno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_result as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_result)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_info_pid as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_info_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_extend as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_extend)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_info_reserved_1 as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_info_reserved_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_uid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_uguid as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_uguid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_uguid_valid as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_uguid_valid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_usid as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_usid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_usid_valid as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_usid_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_gid as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_gguid as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gguid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_gguid_valid as *const _ as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gguid_valid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_gsid as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gsid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_gsid_valid as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_gsid_valid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_member_valid as *const _
                as usize
        },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_member_valid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_sup_grp_cnt as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_sup_grp_cnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_identity_extlookup>())).el_sup_groups as *const _ as usize
        },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_identity_extlookup),
            "::",
            stringify!(el_sup_groups)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kauth_cache_sizes {
    pub kcs_group_size: u_int32_t,
    pub kcs_id_size: u_int32_t,
}
#[test]
fn bindgen_test_layout_kauth_cache_sizes() {
    assert_eq!(
        ::std::mem::size_of::<kauth_cache_sizes>(),
        8usize,
        concat!("Size of: ", stringify!(kauth_cache_sizes))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_cache_sizes>(),
        4usize,
        concat!("Alignment of ", stringify!(kauth_cache_sizes))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kauth_cache_sizes>())).kcs_group_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_cache_sizes),
            "::",
            stringify!(kcs_group_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kauth_cache_sizes>())).kcs_id_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_cache_sizes),
            "::",
            stringify!(kcs_id_size)
        )
    );
}
pub type kauth_ace_rights_t = u_int32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kauth_ace {
    pub ace_applicable: guid_t,
    pub ace_flags: u_int32_t,
    pub ace_rights: kauth_ace_rights_t,
}
#[test]
fn bindgen_test_layout_kauth_ace() {
    assert_eq!(
        ::std::mem::size_of::<kauth_ace>(),
        24usize,
        concat!("Size of: ", stringify!(kauth_ace))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_ace>(),
        4usize,
        concat!("Alignment of ", stringify!(kauth_ace))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kauth_ace>())).ace_applicable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_ace),
            "::",
            stringify!(ace_applicable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kauth_ace>())).ace_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_ace),
            "::",
            stringify!(ace_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kauth_ace>())).ace_rights as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_ace),
            "::",
            stringify!(ace_rights)
        )
    );
}
pub type kauth_ace_t = *mut kauth_ace;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kauth_acl {
    pub acl_entrycount: u_int32_t,
    pub acl_flags: u_int32_t,
    pub acl_ace: [kauth_ace; 1usize],
}
#[test]
fn bindgen_test_layout_kauth_acl() {
    assert_eq!(
        ::std::mem::size_of::<kauth_acl>(),
        32usize,
        concat!("Size of: ", stringify!(kauth_acl))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_acl>(),
        4usize,
        concat!("Alignment of ", stringify!(kauth_acl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kauth_acl>())).acl_entrycount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_acl),
            "::",
            stringify!(acl_entrycount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kauth_acl>())).acl_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_acl),
            "::",
            stringify!(acl_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kauth_acl>())).acl_ace as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_acl),
            "::",
            stringify!(acl_ace)
        )
    );
}
pub type kauth_acl_t = *mut kauth_acl;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kauth_filesec {
    pub fsec_magic: u_int32_t,
    pub fsec_owner: guid_t,
    pub fsec_group: guid_t,
    pub fsec_acl: kauth_acl,
}
#[test]
fn bindgen_test_layout_kauth_filesec() {
    assert_eq!(
        ::std::mem::size_of::<kauth_filesec>(),
        68usize,
        concat!("Size of: ", stringify!(kauth_filesec))
    );
    assert_eq!(
        ::std::mem::align_of::<kauth_filesec>(),
        4usize,
        concat!("Alignment of ", stringify!(kauth_filesec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kauth_filesec>())).fsec_magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_filesec),
            "::",
            stringify!(fsec_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kauth_filesec>())).fsec_owner as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_filesec),
            "::",
            stringify!(fsec_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kauth_filesec>())).fsec_group as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_filesec),
            "::",
            stringify!(fsec_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kauth_filesec>())).fsec_acl as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(kauth_filesec),
            "::",
            stringify!(fsec_acl)
        )
    );
}
pub type kauth_filesec_t = *mut kauth_filesec;
pub const acl_perm_t_ACL_READ_DATA: acl_perm_t = 2;
pub const acl_perm_t_ACL_LIST_DIRECTORY: acl_perm_t = 2;
pub const acl_perm_t_ACL_WRITE_DATA: acl_perm_t = 4;
pub const acl_perm_t_ACL_ADD_FILE: acl_perm_t = 4;
pub const acl_perm_t_ACL_EXECUTE: acl_perm_t = 8;
pub const acl_perm_t_ACL_SEARCH: acl_perm_t = 8;
pub const acl_perm_t_ACL_DELETE: acl_perm_t = 16;
pub const acl_perm_t_ACL_APPEND_DATA: acl_perm_t = 32;
pub const acl_perm_t_ACL_ADD_SUBDIRECTORY: acl_perm_t = 32;
pub const acl_perm_t_ACL_DELETE_CHILD: acl_perm_t = 64;
pub const acl_perm_t_ACL_READ_ATTRIBUTES: acl_perm_t = 128;
pub const acl_perm_t_ACL_WRITE_ATTRIBUTES: acl_perm_t = 256;
pub const acl_perm_t_ACL_READ_EXTATTRIBUTES: acl_perm_t = 512;
pub const acl_perm_t_ACL_WRITE_EXTATTRIBUTES: acl_perm_t = 1024;
pub const acl_perm_t_ACL_READ_SECURITY: acl_perm_t = 2048;
pub const acl_perm_t_ACL_WRITE_SECURITY: acl_perm_t = 4096;
pub const acl_perm_t_ACL_CHANGE_OWNER: acl_perm_t = 8192;
pub const acl_perm_t_ACL_SYNCHRONIZE: acl_perm_t = 1048576;
pub type acl_perm_t = u32;
pub const acl_tag_t_ACL_UNDEFINED_TAG: acl_tag_t = 0;
pub const acl_tag_t_ACL_EXTENDED_ALLOW: acl_tag_t = 1;
pub const acl_tag_t_ACL_EXTENDED_DENY: acl_tag_t = 2;
pub type acl_tag_t = u32;
pub const acl_type_t_ACL_TYPE_EXTENDED: acl_type_t = 256;
pub const acl_type_t_ACL_TYPE_ACCESS: acl_type_t = 0;
pub const acl_type_t_ACL_TYPE_DEFAULT: acl_type_t = 1;
pub const acl_type_t_ACL_TYPE_AFS: acl_type_t = 2;
pub const acl_type_t_ACL_TYPE_CODA: acl_type_t = 3;
pub const acl_type_t_ACL_TYPE_NTFS: acl_type_t = 4;
pub const acl_type_t_ACL_TYPE_NWFS: acl_type_t = 5;
pub type acl_type_t = u32;
pub const acl_entry_id_t_ACL_FIRST_ENTRY: acl_entry_id_t = 0;
pub const acl_entry_id_t_ACL_NEXT_ENTRY: acl_entry_id_t = -1;
pub const acl_entry_id_t_ACL_LAST_ENTRY: acl_entry_id_t = -2;
pub type acl_entry_id_t = i32;
pub const acl_flag_t_ACL_FLAG_DEFER_INHERIT: acl_flag_t = 1;
pub const acl_flag_t_ACL_FLAG_NO_INHERIT: acl_flag_t = 131072;
pub const acl_flag_t_ACL_ENTRY_INHERITED: acl_flag_t = 16;
pub const acl_flag_t_ACL_ENTRY_FILE_INHERIT: acl_flag_t = 32;
pub const acl_flag_t_ACL_ENTRY_DIRECTORY_INHERIT: acl_flag_t = 64;
pub const acl_flag_t_ACL_ENTRY_LIMIT_INHERIT: acl_flag_t = 128;
pub const acl_flag_t_ACL_ENTRY_ONLY_INHERIT: acl_flag_t = 256;
pub type acl_flag_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _acl_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _acl_permset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _acl_flagset {
    _unused: [u8; 0],
}
pub type acl_t = *mut _acl;
pub type acl_entry_t = *mut _acl_entry;
pub type acl_permset_t = *mut _acl_permset;
pub type acl_flagset_t = *mut _acl_flagset;
pub type acl_permset_mask_t = u_int64_t;
extern "C" {
    pub fn acl_dup(acl: acl_t) -> acl_t;
}
extern "C" {
    pub fn acl_free(obj_p: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_init(count: ::std::os::raw::c_int) -> acl_t;
}
extern "C" {
    pub fn acl_copy_entry(dest_d: acl_entry_t, src_d: acl_entry_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_create_entry(acl_p: *mut acl_t, entry_p: *mut acl_entry_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_create_entry_np(
        acl_p: *mut acl_t,
        entry_p: *mut acl_entry_t,
        entry_index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_delete_entry(acl: acl_t, entry_d: acl_entry_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_entry(
        acl: acl_t,
        entry_id: ::std::os::raw::c_int,
        entry_p: *mut acl_entry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_valid(acl: acl_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_valid_fd_np(
        fd: ::std::os::raw::c_int,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_valid_file_np(
        path: *const ::std::os::raw::c_char,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_valid_link_np(
        path: *const ::std::os::raw::c_char,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_add_perm(permset_d: acl_permset_t, perm: acl_perm_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_calc_mask(acl_p: *mut acl_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_clear_perms(permset_d: acl_permset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_delete_perm(permset_d: acl_permset_t, perm: acl_perm_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_perm_np(permset_d: acl_permset_t, perm: acl_perm_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_permset(
        entry_d: acl_entry_t,
        permset_p: *mut acl_permset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_permset(entry_d: acl_entry_t, permset_d: acl_permset_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_maximal_permset_mask_np(mask_p: *mut acl_permset_mask_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_permset_mask_np(
        entry_d: acl_entry_t,
        mask_p: *mut acl_permset_mask_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_permset_mask_np(
        entry_d: acl_entry_t,
        mask: acl_permset_mask_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_add_flag_np(flagset_d: acl_flagset_t, flag: acl_flag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_clear_flags_np(flagset_d: acl_flagset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_delete_flag_np(flagset_d: acl_flagset_t, flag: acl_flag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_flag_np(flagset_d: acl_flagset_t, flag: acl_flag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_flagset_np(
        obj_p: *mut ::std::os::raw::c_void,
        flagset_p: *mut acl_flagset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_flagset_np(
        obj_p: *mut ::std::os::raw::c_void,
        flagset_d: acl_flagset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_qualifier(entry_d: acl_entry_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn acl_get_tag_type(
        entry_d: acl_entry_t,
        tag_type_p: *mut acl_tag_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_qualifier(
        entry_d: acl_entry_t,
        tag_qualifier_p: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_tag_type(entry_d: acl_entry_t, tag_type: acl_tag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_delete_def_file(path_p: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_get_fd(fd: ::std::os::raw::c_int) -> acl_t;
}
extern "C" {
    pub fn acl_get_fd_np(fd: ::std::os::raw::c_int, type_: acl_type_t) -> acl_t;
}
extern "C" {
    pub fn acl_get_file(path_p: *const ::std::os::raw::c_char, type_: acl_type_t) -> acl_t;
}
extern "C" {
    pub fn acl_get_link_np(path_p: *const ::std::os::raw::c_char, type_: acl_type_t) -> acl_t;
}
extern "C" {
    pub fn acl_set_fd(fd: ::std::os::raw::c_int, acl: acl_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_fd_np(
        fd: ::std::os::raw::c_int,
        acl: acl_t,
        acl_type: acl_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_file(
        path_p: *const ::std::os::raw::c_char,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_set_link_np(
        path_p: *const ::std::os::raw::c_char,
        type_: acl_type_t,
        acl: acl_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_copy_ext(buf_p: *mut ::std::os::raw::c_void, acl: acl_t, size: isize) -> isize;
}
extern "C" {
    pub fn acl_copy_ext_native(
        buf_p: *mut ::std::os::raw::c_void,
        acl: acl_t,
        size: isize,
    ) -> isize;
}
extern "C" {
    pub fn acl_copy_int(buf_p: *const ::std::os::raw::c_void) -> acl_t;
}
extern "C" {
    pub fn acl_copy_int_native(buf_p: *const ::std::os::raw::c_void) -> acl_t;
}
extern "C" {
    pub fn acl_from_text(buf_p: *const ::std::os::raw::c_char) -> acl_t;
}
extern "C" {
    pub fn acl_size(acl: acl_t) -> isize;
}
extern "C" {
    pub fn acl_to_text(acl: acl_t, len_p: *mut isize) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFFileSecurity {
    _unused: [u8; 0],
}
pub type CFFileSecurityRef = *mut __CFFileSecurity;
extern "C" {
    pub fn CFFileSecurityGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFFileSecurityCreate(allocator: CFAllocatorRef) -> CFFileSecurityRef;
}
extern "C" {
    pub fn CFFileSecurityCreateCopy(
        allocator: CFAllocatorRef,
        fileSec: CFFileSecurityRef,
    ) -> CFFileSecurityRef;
}
extern "C" {
    pub fn CFFileSecurityCopyOwnerUUID(
        fileSec: CFFileSecurityRef,
        ownerUUID: *mut CFUUIDRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFFileSecuritySetOwnerUUID(fileSec: CFFileSecurityRef, ownerUUID: CFUUIDRef) -> Boolean;
}
extern "C" {
    pub fn CFFileSecurityCopyGroupUUID(
        fileSec: CFFileSecurityRef,
        groupUUID: *mut CFUUIDRef,
    ) -> Boolean;
}
extern "C" {
    pub fn CFFileSecuritySetGroupUUID(fileSec: CFFileSecurityRef, groupUUID: CFUUIDRef) -> Boolean;
}
extern "C" {
    pub fn CFFileSecurityCopyAccessControlList(
        fileSec: CFFileSecurityRef,
        accessControlList: *mut acl_t,
    ) -> Boolean;
}
extern "C" {
    pub fn CFFileSecuritySetAccessControlList(
        fileSec: CFFileSecurityRef,
        accessControlList: acl_t,
    ) -> Boolean;
}
extern "C" {
    pub fn CFFileSecurityGetOwner(fileSec: CFFileSecurityRef, owner: *mut uid_t) -> Boolean;
}
extern "C" {
    pub fn CFFileSecuritySetOwner(fileSec: CFFileSecurityRef, owner: uid_t) -> Boolean;
}
extern "C" {
    pub fn CFFileSecurityGetGroup(fileSec: CFFileSecurityRef, group: *mut gid_t) -> Boolean;
}
extern "C" {
    pub fn CFFileSecuritySetGroup(fileSec: CFFileSecurityRef, group: gid_t) -> Boolean;
}
extern "C" {
    pub fn CFFileSecurityGetMode(fileSec: CFFileSecurityRef, mode: *mut mode_t) -> Boolean;
}
extern "C" {
    pub fn CFFileSecuritySetMode(fileSec: CFFileSecurityRef, mode: mode_t) -> Boolean;
}
pub type CFFileSecurityClearOptions = CFOptionFlags;
pub const kCFFileSecurityClearOwner: _bindgen_ty_65 = 1;
pub const kCFFileSecurityClearGroup: _bindgen_ty_65 = 2;
pub const kCFFileSecurityClearMode: _bindgen_ty_65 = 4;
pub const kCFFileSecurityClearOwnerUUID: _bindgen_ty_65 = 8;
pub const kCFFileSecurityClearGroupUUID: _bindgen_ty_65 = 16;
pub const kCFFileSecurityClearAccessControlList: _bindgen_ty_65 = 32;
pub type _bindgen_ty_65 = u32;
extern "C" {
    pub fn CFFileSecurityClearProperties(
        fileSec: CFFileSecurityRef,
        clearPropertyMask: CFFileSecurityClearOptions,
    ) -> Boolean;
}
extern "C" {
    ///@function CFStringTokenizerCopyBestStringLanguage
    ///@abstract Guesses the language of a string and returns the BCP 47 string of the
    ///language.
    ///@param string The string whose language is to be guessed.
    ///@param range The range of characters in string whose language to be
    ///guessed. The specified range must not exceed the bounds of the string.
    ///@result A language represented in BCP 47 string. NULL is returned either if
    ///string is NULL, the location of range is negative, the length of range
    ///is 0, or the language of the string cannot be guessed.
    ///@discussion The result is not guaranteed to be accurate. Typically 200-400
    ///characters are required to reliably guess the language of a string.
    pub fn CFStringTokenizerCopyBestStringLanguage(
        string: CFStringRef,
        range: CFRange,
    ) -> CFStringRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFStringTokenizer {
    _unused: [u8; 0],
}
pub type CFStringTokenizerRef = *mut __CFStringTokenizer;
///Tokenization Unit
///Use one of tokenization unit options with CFStringTokenizerCreate to
///specify how the string should be tokenized.
pub const kCFStringTokenizerUnitWord: _bindgen_ty_66 = 0;
///Tokenization Unit
///Use one of tokenization unit options with CFStringTokenizerCreate to
///specify how the string should be tokenized.
pub const kCFStringTokenizerUnitSentence: _bindgen_ty_66 = 1;
///Tokenization Unit
///Use one of tokenization unit options with CFStringTokenizerCreate to
///specify how the string should be tokenized.
pub const kCFStringTokenizerUnitParagraph: _bindgen_ty_66 = 2;
///Tokenization Unit
///Use one of tokenization unit options with CFStringTokenizerCreate to
///specify how the string should be tokenized.
pub const kCFStringTokenizerUnitLineBreak: _bindgen_ty_66 = 3;
///Tokenization Unit
///Use one of tokenization unit options with CFStringTokenizerCreate to
///specify how the string should be tokenized.
pub const kCFStringTokenizerUnitWordBoundary: _bindgen_ty_66 = 4;
///Attribute Specifier
///Use attribute specifier to tell tokenizer to prepare the specified attribute
///when it tokenizes the given string. The attribute value can be retrieved by
///calling CFStringTokenizerCopyCurrentTokenAttribute with one of the attribute
///option.
pub const kCFStringTokenizerAttributeLatinTranscription: _bindgen_ty_66 = 65536;
///Attribute Specifier
///Use attribute specifier to tell tokenizer to prepare the specified attribute
///when it tokenizes the given string. The attribute value can be retrieved by
///calling CFStringTokenizerCopyCurrentTokenAttribute with one of the attribute
///option.
pub const kCFStringTokenizerAttributeLanguage: _bindgen_ty_66 = 131072;
pub type _bindgen_ty_66 = u32;
///Token type
///CFStringTokenizerGoToTokenAtIndex / CFStringTokenizerAdvanceToNextToken returns
///the type of current token.
pub type CFStringTokenizerTokenType = CFOptionFlags;
pub const kCFStringTokenizerTokenNone: _bindgen_ty_67 = 0;
pub const kCFStringTokenizerTokenNormal: _bindgen_ty_67 = 1;
///Compound token which may contain subtokens but with no derived subtokens.
///Its subtokens can be obtained by calling CFStringTokenizerGetCurrentSubTokens.
pub const kCFStringTokenizerTokenHasSubTokensMask: _bindgen_ty_67 = 2;
///Compound token which may contain derived subtokens.
///Its subtokens and derived subtokens can be obtained by calling
///CFStringTokenizerGetCurrentSubTokens.
pub const kCFStringTokenizerTokenHasDerivedSubTokensMask: _bindgen_ty_67 = 4;
///Compound token which may contain derived subtokens.
///Its subtokens and derived subtokens can be obtained by calling
///CFStringTokenizerGetCurrentSubTokens.
pub const kCFStringTokenizerTokenHasHasNumbersMask: _bindgen_ty_67 = 8;
///Compound token which may contain derived subtokens.
///Its subtokens and derived subtokens can be obtained by calling
///CFStringTokenizerGetCurrentSubTokens.
pub const kCFStringTokenizerTokenHasNonLettersMask: _bindgen_ty_67 = 16;
///Compound token which may contain derived subtokens.
///Its subtokens and derived subtokens can be obtained by calling
///CFStringTokenizerGetCurrentSubTokens.
pub const kCFStringTokenizerTokenIsCJWordMask: _bindgen_ty_67 = 32;
pub type _bindgen_ty_67 = u32;
extern "C" {
    ///@function CFStringTokenizerGetTypeID
    ///@abstract Get the type identifier.
    ///@result the type identifier of all CFStringTokenizer instances.
    pub fn CFStringTokenizerGetTypeID() -> CFTypeID;
}
extern "C" {
    ///@function CFStringTokenizerCreate
    ///@abstract Creates a tokenizer instance.
    ///@param alloc The CFAllocator which should be used to allocate memory for the
    ///tokenizer and its storage for values. This parameter may be NULL in which
    ///case the current default CFAllocator is used.
    ///@param string The string to tokenize.
    ///@param range The range of characters within the string to be tokenized. The
    ///specified range must not exceed the length of the string.
    ///@param options Use one of the Tokenization Unit options to specify how the
    ///string should be tokenized. Optionally specify one or more attribute
    ///specifiers to tell the tokenizer to prepare specified attributes when it
    ///tokenizes the string.
    ///@param locale The locale to specify language or region specific behavior. Pass
    ///NULL if you want tokenizer to identify the locale automatically.
    ///@result A reference to the new CFStringTokenizer.
    pub fn CFStringTokenizerCreate(
        alloc: CFAllocatorRef,
        string: CFStringRef,
        range: CFRange,
        options: CFOptionFlags,
        locale: CFLocaleRef,
    ) -> CFStringTokenizerRef;
}
extern "C" {
    ///@function CFStringTokenizerSetString
    ///@abstract Set the string to tokenize.
    ///@param tokenizer The reference to CFStringTokenizer returned by
    ///CFStringTokenizerCreate.
    ///@param string The string to tokenize.
    ///@param range The range of characters within the string to be tokenized. The
    ///specified range must not exceed the length of the string.
    pub fn CFStringTokenizerSetString(
        tokenizer: CFStringTokenizerRef,
        string: CFStringRef,
        range: CFRange,
    );
}
extern "C" {
    ///@function CFStringTokenizerGoToTokenAtIndex
    ///@abstract Random access to a token. Find a token that includes the character specified
    ///by character index, and set it as the current token.
    ///@param tokenizer The reference to CFStringTokenizer returned by
    ///CFStringTokenizerCreate.
    ///@param index The index of the Unicode character in the CFString.
    ///@result Type of the token if succeeded in finding a token and setting it as
    ///current token. kCFStringTokenizerTokenNone if failed in finding a token.
    ///@discussion The range and attribute of the token can be obtained by calling
    ///CFStringTokenizerGetCurrentTokenRange and CFStringTokenizerCopyCurrentTokenAttribute.
    ///If the token is a compound (with type kCFStringTokenizerTokenHasSubTokensMask or
    ///kCFStringTokenizerTokenHasDerivedSubTokensMask), its subtokens and
    ///(or) derived subtokens can be obtained by calling CFStringTokenizerGetCurrentSubTokens.
    pub fn CFStringTokenizerGoToTokenAtIndex(
        tokenizer: CFStringTokenizerRef,
        index: CFIndex,
    ) -> CFStringTokenizerTokenType;
}
extern "C" {
    ///@function CFStringTokenizerAdvanceToNextToken
    ///@abstract Token enumerator.
    ///@param tokenizer The reference to CFStringTokenizer returned by
    ///CFStringTokenizerCreate.
    ///@result Type of the token if succeeded in finding a token and setting it as
    ///current token. kCFStringTokenizerTokenNone if failed in finding a token.
    ///@discussion If there is no preceding call to CFStringTokenizerGoToTokenAtIndex
    ///or CFStringTokenizerAdvanceToNextToken, it finds the first token in the range
    ///specified to CFStringTokenizerCreate. If there is a current token after successful
    ///call to CFStringTokenizerGoToTokenAtIndex or CFStringTokenizerAdvanceToNextToken,
    ///it proceeds to the next token. If succeeded in finding a token, set it as current
    ///token and return its token type. Otherwise invalidate current token and return
    ///kCFStringTokenizerTokenNone.
    ///The range and attribute of the token can be obtained by calling
    ///CFStringTokenizerGetCurrentTokenRange and
    ///CFStringTokenizerCopyCurrentTokenAttribute. If the token is a compound
    ///(with type kCFStringTokenizerTokenHasSubTokensMask or
    ///kCFStringTokenizerTokenHasDerivedSubTokensMask), its subtokens and
    ///(or) derived subtokens can be obtained by calling CFStringTokenizerGetCurrentSubTokens.
    pub fn CFStringTokenizerAdvanceToNextToken(
        tokenizer: CFStringTokenizerRef,
    ) -> CFStringTokenizerTokenType;
}
extern "C" {
    ///@function CFStringTokenizerGetCurrentTokenRange
    ///@abstract Returns the range of current token.
    ///@param tokenizer The reference to CFStringTokenizer returned by
    ///CFStringTokenizerCreate.
    ///@result Range of current token, or {kCFNotFound,0} if there is no current token.
    pub fn CFStringTokenizerGetCurrentTokenRange(tokenizer: CFStringTokenizerRef) -> CFRange;
}
extern "C" {
    ///@function CFStringTokenizerCopyCurrentTokenAttribute
    ///@abstract Copies the specified attribute of current token.
    ///@param tokenizer The reference to CFStringTokenizer returned by
    ///CFStringTokenizerCreate.
    ///@param attribute Specify a token attribute you want to obtain. The value is
    ///one of kCFStringTokenizerAttributeLatinTranscription or
    ///kCFStringTokenizerAttributeLanguage.
    ///@result Token attribute, or NULL if current token does not have the specified
    ///attribute or if there is no current token.
    pub fn CFStringTokenizerCopyCurrentTokenAttribute(
        tokenizer: CFStringTokenizerRef,
        attribute: CFOptionFlags,
    ) -> CFTypeRef;
}
extern "C" {
    ///@function CFStringTokenizerGetCurrentSubTokens
    ///@abstract Retrieves the subtokens or derived subtokens contained in the compound token.
    ///@param tokenizer The reference to CFStringTokenizer returned by CFStringTokenizerCreate.
    ///@param ranges An array of CFRange to fill in with the ranges of subtokens. The filled in
    ///ranges are relative to the string specified to CFStringTokenizerCreate. This parameter
    ///can be NULL.
    ///@param maxRangeLength The maximum number of ranges to return.
    ///@param derivedSubTokens An array of CFMutableArray to which the derived subtokens are to
    ///be added. This parameter can be NULL.
    ///@result number of subtokens.
    ///@discussion If token type is kCFStringTokenizerTokenNone, the ranges array and
    ///derivedSubTokens array are untouched and the return value is 0.
    ///If token type is kCFStringTokenizerTokenNormal, the ranges array has one item
    ///filled in with the entire range of the token (if maxRangeLength >= 1) and a string
    ///taken from the entire token range is added to the derivedSubTokens array and the
    ///return value is 1.
    ///If token type is kCFStringTokenizerTokenHasSubTokensMask or
    ///kCFStringTokenizerTokenHasDerivedSubTokensMask, the ranges array is filled
    ///in with as many items as there are subtokens (up to a limit of maxRangeLength).
    ///The derivedSubTokens array will have sub tokens added even when the sub token is a
    ///substring of the token. If token type is kCFStringTokenizerTokenHasSubTokensMask,
    ///the ordinary non-derived subtokens are added to the derivedSubTokens array.
    pub fn CFStringTokenizerGetCurrentSubTokens(
        tokenizer: CFStringTokenizerRef,
        ranges: *mut CFRange,
        maxRangeLength: CFIndex,
        derivedSubTokens: CFMutableArrayRef,
    ) -> CFIndex;
}
pub type CFFileDescriptorNativeDescriptor = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFFileDescriptor {
    _unused: [u8; 0],
}
pub type CFFileDescriptorRef = *mut __CFFileDescriptor;
pub const kCFFileDescriptorReadCallBack: _bindgen_ty_68 = 1;
pub const kCFFileDescriptorWriteCallBack: _bindgen_ty_68 = 2;
pub type _bindgen_ty_68 = u32;
pub type CFFileDescriptorCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        f: CFFileDescriptorRef,
        callBackTypes: CFOptionFlags,
        info: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFFileDescriptorContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: ::std::option::Option<
        unsafe extern "C" fn(info: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
    pub release: ::std::option::Option<unsafe extern "C" fn(info: *mut ::std::os::raw::c_void)>,
    pub copyDescription: ::std::option::Option<
        unsafe extern "C" fn(info: *mut ::std::os::raw::c_void) -> CFStringRef,
    >,
}
#[test]
fn bindgen_test_layout_CFFileDescriptorContext() {
    assert_eq!(
        ::std::mem::size_of::<CFFileDescriptorContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFFileDescriptorContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFFileDescriptorContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFFileDescriptorContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFFileDescriptorContext>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFFileDescriptorContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFFileDescriptorContext>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFFileDescriptorContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFFileDescriptorContext>())).retain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFFileDescriptorContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFFileDescriptorContext>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFFileDescriptorContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFFileDescriptorContext>())).copyDescription as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFFileDescriptorContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
impl Default for CFFileDescriptorContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn CFFileDescriptorGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFFileDescriptorCreate(
        allocator: CFAllocatorRef,
        fd: CFFileDescriptorNativeDescriptor,
        closeOnInvalidate: Boolean,
        callout: CFFileDescriptorCallBack,
        context: *const CFFileDescriptorContext,
    ) -> CFFileDescriptorRef;
}
extern "C" {
    pub fn CFFileDescriptorGetNativeDescriptor(
        f: CFFileDescriptorRef,
    ) -> CFFileDescriptorNativeDescriptor;
}
extern "C" {
    pub fn CFFileDescriptorGetContext(
        f: CFFileDescriptorRef,
        context: *mut CFFileDescriptorContext,
    );
}
extern "C" {
    pub fn CFFileDescriptorEnableCallBacks(f: CFFileDescriptorRef, callBackTypes: CFOptionFlags);
}
extern "C" {
    pub fn CFFileDescriptorDisableCallBacks(f: CFFileDescriptorRef, callBackTypes: CFOptionFlags);
}
extern "C" {
    pub fn CFFileDescriptorInvalidate(f: CFFileDescriptorRef);
}
extern "C" {
    pub fn CFFileDescriptorIsValid(f: CFFileDescriptorRef) -> Boolean;
}
extern "C" {
    pub fn CFFileDescriptorCreateRunLoopSource(
        allocator: CFAllocatorRef,
        f: CFFileDescriptorRef,
        order: CFIndex,
    ) -> CFRunLoopSourceRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFUserNotification {
    _unused: [u8; 0],
}
pub type CFUserNotificationRef = *mut __CFUserNotification;
pub type CFUserNotificationCallBack = ::std::option::Option<
    unsafe extern "C" fn(userNotification: CFUserNotificationRef, responseFlags: CFOptionFlags),
>;
extern "C" {
    pub fn CFUserNotificationGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFUserNotificationCreate(
        allocator: CFAllocatorRef,
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        error: *mut SInt32,
        dictionary: CFDictionaryRef,
    ) -> CFUserNotificationRef;
}
extern "C" {
    pub fn CFUserNotificationReceiveResponse(
        userNotification: CFUserNotificationRef,
        timeout: CFTimeInterval,
        responseFlags: *mut CFOptionFlags,
    ) -> SInt32;
}
extern "C" {
    pub fn CFUserNotificationGetResponseValue(
        userNotification: CFUserNotificationRef,
        key: CFStringRef,
        idx: CFIndex,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFUserNotificationGetResponseDictionary(
        userNotification: CFUserNotificationRef,
    ) -> CFDictionaryRef;
}
extern "C" {
    pub fn CFUserNotificationUpdate(
        userNotification: CFUserNotificationRef,
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        dictionary: CFDictionaryRef,
    ) -> SInt32;
}
extern "C" {
    pub fn CFUserNotificationCancel(userNotification: CFUserNotificationRef) -> SInt32;
}
extern "C" {
    pub fn CFUserNotificationCreateRunLoopSource(
        allocator: CFAllocatorRef,
        userNotification: CFUserNotificationRef,
        callout: CFUserNotificationCallBack,
        order: CFIndex,
    ) -> CFRunLoopSourceRef;
}
extern "C" {
    pub fn CFUserNotificationDisplayNotice(
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        iconURL: CFURLRef,
        soundURL: CFURLRef,
        localizationURL: CFURLRef,
        alertHeader: CFStringRef,
        alertMessage: CFStringRef,
        defaultButtonTitle: CFStringRef,
    ) -> SInt32;
}
extern "C" {
    pub fn CFUserNotificationDisplayAlert(
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        iconURL: CFURLRef,
        soundURL: CFURLRef,
        localizationURL: CFURLRef,
        alertHeader: CFStringRef,
        alertMessage: CFStringRef,
        defaultButtonTitle: CFStringRef,
        alternateButtonTitle: CFStringRef,
        otherButtonTitle: CFStringRef,
        responseFlags: *mut CFOptionFlags,
    ) -> SInt32;
}
pub const kCFUserNotificationStopAlertLevel: _bindgen_ty_69 = 0;
pub const kCFUserNotificationNoteAlertLevel: _bindgen_ty_69 = 1;
pub const kCFUserNotificationCautionAlertLevel: _bindgen_ty_69 = 2;
pub const kCFUserNotificationPlainAlertLevel: _bindgen_ty_69 = 3;
pub type _bindgen_ty_69 = u32;
pub const kCFUserNotificationDefaultResponse: _bindgen_ty_70 = 0;
pub const kCFUserNotificationAlternateResponse: _bindgen_ty_70 = 1;
pub const kCFUserNotificationOtherResponse: _bindgen_ty_70 = 2;
pub const kCFUserNotificationCancelResponse: _bindgen_ty_70 = 3;
pub type _bindgen_ty_70 = u32;
pub const kCFUserNotificationNoDefaultButtonFlag: _bindgen_ty_71 = 32;
pub const kCFUserNotificationUseRadioButtonsFlag: _bindgen_ty_71 = 64;
pub type _bindgen_ty_71 = u32;
extern "C" {
    pub static kCFUserNotificationIconURLKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationSoundURLKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationLocalizationURLKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationAlertHeaderKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationAlertMessageKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationDefaultButtonTitleKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationAlternateButtonTitleKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationOtherButtonTitleKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationProgressIndicatorValueKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationPopUpTitlesKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationTextFieldTitlesKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationCheckBoxTitlesKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationTextFieldValuesKey: CFStringRef;
}
extern "C" {
    pub static kCFUserNotificationPopUpSelectionKey: CFStringRef;
}
pub const kCFXMLNodeCurrentVersion: _bindgen_ty_72 = 1;
pub type _bindgen_ty_72 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFXMLNode {
    _unused: [u8; 0],
}
pub type CFXMLNodeRef = *const __CFXMLNode;
pub type CFXMLTreeRef = CFTreeRef;
pub type CFXMLNodeTypeCode = CFIndex;
pub const kCFXMLNodeTypeDocument: _bindgen_ty_73 = 1;
pub const kCFXMLNodeTypeElement: _bindgen_ty_73 = 2;
pub const kCFXMLNodeTypeAttribute: _bindgen_ty_73 = 3;
pub const kCFXMLNodeTypeProcessingInstruction: _bindgen_ty_73 = 4;
pub const kCFXMLNodeTypeComment: _bindgen_ty_73 = 5;
pub const kCFXMLNodeTypeText: _bindgen_ty_73 = 6;
pub const kCFXMLNodeTypeCDATASection: _bindgen_ty_73 = 7;
pub const kCFXMLNodeTypeDocumentFragment: _bindgen_ty_73 = 8;
pub const kCFXMLNodeTypeEntity: _bindgen_ty_73 = 9;
pub const kCFXMLNodeTypeEntityReference: _bindgen_ty_73 = 10;
pub const kCFXMLNodeTypeDocumentType: _bindgen_ty_73 = 11;
pub const kCFXMLNodeTypeWhitespace: _bindgen_ty_73 = 12;
pub const kCFXMLNodeTypeNotation: _bindgen_ty_73 = 13;
pub const kCFXMLNodeTypeElementTypeDeclaration: _bindgen_ty_73 = 14;
pub const kCFXMLNodeTypeAttributeListDeclaration: _bindgen_ty_73 = 15;
pub type _bindgen_ty_73 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLElementInfo {
    pub attributes: CFDictionaryRef,
    pub attributeOrder: CFArrayRef,
    pub isEmpty: Boolean,
    pub _reserved: [::std::os::raw::c_char; 3usize],
}
#[test]
fn bindgen_test_layout_CFXMLElementInfo() {
    assert_eq!(
        ::std::mem::size_of::<CFXMLElementInfo>(),
        24usize,
        concat!("Size of: ", stringify!(CFXMLElementInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLElementInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLElementInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLElementInfo>())).attributes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLElementInfo),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLElementInfo>())).attributeOrder as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLElementInfo),
            "::",
            stringify!(attributeOrder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLElementInfo>())).isEmpty as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLElementInfo),
            "::",
            stringify!(isEmpty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLElementInfo>()))._reserved as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLElementInfo),
            "::",
            stringify!(_reserved)
        )
    );
}
impl Default for CFXMLElementInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLProcessingInstructionInfo {
    pub dataString: CFStringRef,
}
#[test]
fn bindgen_test_layout_CFXMLProcessingInstructionInfo() {
    assert_eq!(
        ::std::mem::size_of::<CFXMLProcessingInstructionInfo>(),
        8usize,
        concat!("Size of: ", stringify!(CFXMLProcessingInstructionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLProcessingInstructionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLProcessingInstructionInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLProcessingInstructionInfo>())).dataString as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLProcessingInstructionInfo),
            "::",
            stringify!(dataString)
        )
    );
}
impl Default for CFXMLProcessingInstructionInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLDocumentInfo {
    pub sourceURL: CFURLRef,
    pub encoding: CFStringEncoding,
}
#[test]
fn bindgen_test_layout_CFXMLDocumentInfo() {
    assert_eq!(
        ::std::mem::size_of::<CFXMLDocumentInfo>(),
        16usize,
        concat!("Size of: ", stringify!(CFXMLDocumentInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLDocumentInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLDocumentInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLDocumentInfo>())).sourceURL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLDocumentInfo),
            "::",
            stringify!(sourceURL)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLDocumentInfo>())).encoding as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLDocumentInfo),
            "::",
            stringify!(encoding)
        )
    );
}
impl Default for CFXMLDocumentInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLExternalID {
    pub systemID: CFURLRef,
    pub publicID: CFStringRef,
}
#[test]
fn bindgen_test_layout_CFXMLExternalID() {
    assert_eq!(
        ::std::mem::size_of::<CFXMLExternalID>(),
        16usize,
        concat!("Size of: ", stringify!(CFXMLExternalID))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLExternalID>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLExternalID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLExternalID>())).systemID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLExternalID),
            "::",
            stringify!(systemID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLExternalID>())).publicID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLExternalID),
            "::",
            stringify!(publicID)
        )
    );
}
impl Default for CFXMLExternalID {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLDocumentTypeInfo {
    pub externalID: CFXMLExternalID,
}
#[test]
fn bindgen_test_layout_CFXMLDocumentTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<CFXMLDocumentTypeInfo>(),
        16usize,
        concat!("Size of: ", stringify!(CFXMLDocumentTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLDocumentTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLDocumentTypeInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLDocumentTypeInfo>())).externalID as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLDocumentTypeInfo),
            "::",
            stringify!(externalID)
        )
    );
}
impl Default for CFXMLDocumentTypeInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLNotationInfo {
    pub externalID: CFXMLExternalID,
}
#[test]
fn bindgen_test_layout_CFXMLNotationInfo() {
    assert_eq!(
        ::std::mem::size_of::<CFXMLNotationInfo>(),
        16usize,
        concat!("Size of: ", stringify!(CFXMLNotationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLNotationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLNotationInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLNotationInfo>())).externalID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLNotationInfo),
            "::",
            stringify!(externalID)
        )
    );
}
impl Default for CFXMLNotationInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLElementTypeDeclarationInfo {
    pub contentDescription: CFStringRef,
}
#[test]
fn bindgen_test_layout_CFXMLElementTypeDeclarationInfo() {
    assert_eq!(
        ::std::mem::size_of::<CFXMLElementTypeDeclarationInfo>(),
        8usize,
        concat!("Size of: ", stringify!(CFXMLElementTypeDeclarationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLElementTypeDeclarationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLElementTypeDeclarationInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLElementTypeDeclarationInfo>())).contentDescription
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLElementTypeDeclarationInfo),
            "::",
            stringify!(contentDescription)
        )
    );
}
impl Default for CFXMLElementTypeDeclarationInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLAttributeDeclarationInfo {
    pub attributeName: CFStringRef,
    pub typeString: CFStringRef,
    pub defaultString: CFStringRef,
}
#[test]
fn bindgen_test_layout_CFXMLAttributeDeclarationInfo() {
    assert_eq!(
        ::std::mem::size_of::<CFXMLAttributeDeclarationInfo>(),
        24usize,
        concat!("Size of: ", stringify!(CFXMLAttributeDeclarationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLAttributeDeclarationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLAttributeDeclarationInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLAttributeDeclarationInfo>())).attributeName as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLAttributeDeclarationInfo),
            "::",
            stringify!(attributeName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLAttributeDeclarationInfo>())).typeString as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLAttributeDeclarationInfo),
            "::",
            stringify!(typeString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLAttributeDeclarationInfo>())).defaultString as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLAttributeDeclarationInfo),
            "::",
            stringify!(defaultString)
        )
    );
}
impl Default for CFXMLAttributeDeclarationInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLAttributeListDeclarationInfo {
    pub numberOfAttributes: CFIndex,
    pub attributes: *mut CFXMLAttributeDeclarationInfo,
}
#[test]
fn bindgen_test_layout_CFXMLAttributeListDeclarationInfo() {
    assert_eq!(
        ::std::mem::size_of::<CFXMLAttributeListDeclarationInfo>(),
        16usize,
        concat!("Size of: ", stringify!(CFXMLAttributeListDeclarationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLAttributeListDeclarationInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CFXMLAttributeListDeclarationInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLAttributeListDeclarationInfo>())).numberOfAttributes
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLAttributeListDeclarationInfo),
            "::",
            stringify!(numberOfAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLAttributeListDeclarationInfo>())).attributes as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLAttributeListDeclarationInfo),
            "::",
            stringify!(attributes)
        )
    );
}
impl Default for CFXMLAttributeListDeclarationInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CFXMLEntityTypeCode = CFIndex;
pub const kCFXMLEntityTypeParameter: _bindgen_ty_74 = 0;
pub const kCFXMLEntityTypeParsedInternal: _bindgen_ty_74 = 1;
pub const kCFXMLEntityTypeParsedExternal: _bindgen_ty_74 = 2;
pub const kCFXMLEntityTypeUnparsed: _bindgen_ty_74 = 3;
pub const kCFXMLEntityTypeCharacter: _bindgen_ty_74 = 4;
pub type _bindgen_ty_74 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLEntityInfo {
    pub entityType: CFXMLEntityTypeCode,
    pub replacementText: CFStringRef,
    pub entityID: CFXMLExternalID,
    pub notationName: CFStringRef,
}
#[test]
fn bindgen_test_layout_CFXMLEntityInfo() {
    assert_eq!(
        ::std::mem::size_of::<CFXMLEntityInfo>(),
        40usize,
        concat!("Size of: ", stringify!(CFXMLEntityInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLEntityInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLEntityInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLEntityInfo>())).entityType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLEntityInfo),
            "::",
            stringify!(entityType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLEntityInfo>())).replacementText as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLEntityInfo),
            "::",
            stringify!(replacementText)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLEntityInfo>())).entityID as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLEntityInfo),
            "::",
            stringify!(entityID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLEntityInfo>())).notationName as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLEntityInfo),
            "::",
            stringify!(notationName)
        )
    );
}
impl Default for CFXMLEntityInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CFXMLEntityReferenceInfo {
    pub entityType: CFXMLEntityTypeCode,
}
#[test]
fn bindgen_test_layout_CFXMLEntityReferenceInfo() {
    assert_eq!(
        ::std::mem::size_of::<CFXMLEntityReferenceInfo>(),
        8usize,
        concat!("Size of: ", stringify!(CFXMLEntityReferenceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLEntityReferenceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLEntityReferenceInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLEntityReferenceInfo>())).entityType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLEntityReferenceInfo),
            "::",
            stringify!(entityType)
        )
    );
}
extern "C" {
    pub fn CFXMLNodeGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFXMLNodeCreate(
        alloc: CFAllocatorRef,
        xmlType: CFXMLNodeTypeCode,
        dataString: CFStringRef,
        additionalInfoPtr: *const ::std::os::raw::c_void,
        version: CFIndex,
    ) -> CFXMLNodeRef;
}
extern "C" {
    pub fn CFXMLNodeCreateCopy(alloc: CFAllocatorRef, origNode: CFXMLNodeRef) -> CFXMLNodeRef;
}
extern "C" {
    pub fn CFXMLNodeGetTypeCode(node: CFXMLNodeRef) -> CFXMLNodeTypeCode;
}
extern "C" {
    pub fn CFXMLNodeGetString(node: CFXMLNodeRef) -> CFStringRef;
}
extern "C" {
    pub fn CFXMLNodeGetInfoPtr(node: CFXMLNodeRef) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFXMLNodeGetVersion(node: CFXMLNodeRef) -> CFIndex;
}
extern "C" {
    pub fn CFXMLTreeCreateWithNode(allocator: CFAllocatorRef, node: CFXMLNodeRef) -> CFXMLTreeRef;
}
extern "C" {
    pub fn CFXMLTreeGetNode(xmlTree: CFXMLTreeRef) -> CFXMLNodeRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFXMLParser {
    _unused: [u8; 0],
}
pub type CFXMLParserRef = *mut __CFXMLParser;
pub type CFXMLParserOptions = CFOptionFlags;
pub const kCFXMLParserValidateDocument: _bindgen_ty_75 = 1;
pub const kCFXMLParserSkipMetaData: _bindgen_ty_75 = 2;
pub const kCFXMLParserReplacePhysicalEntities: _bindgen_ty_75 = 4;
pub const kCFXMLParserSkipWhitespace: _bindgen_ty_75 = 8;
pub const kCFXMLParserResolveExternalEntities: _bindgen_ty_75 = 16;
pub const kCFXMLParserAddImpliedAttributes: _bindgen_ty_75 = 32;
pub const kCFXMLParserAllOptions: _bindgen_ty_75 = 16777215;
pub const kCFXMLParserNoOptions: _bindgen_ty_75 = 0;
pub type _bindgen_ty_75 = u32;
pub type CFXMLParserStatusCode = CFIndex;
pub const kCFXMLStatusParseNotBegun: _bindgen_ty_76 = -2;
pub const kCFXMLStatusParseInProgress: _bindgen_ty_76 = -1;
pub const kCFXMLStatusParseSuccessful: _bindgen_ty_76 = 0;
pub const kCFXMLErrorUnexpectedEOF: _bindgen_ty_76 = 1;
pub const kCFXMLErrorUnknownEncoding: _bindgen_ty_76 = 2;
pub const kCFXMLErrorEncodingConversionFailure: _bindgen_ty_76 = 3;
pub const kCFXMLErrorMalformedProcessingInstruction: _bindgen_ty_76 = 4;
pub const kCFXMLErrorMalformedDTD: _bindgen_ty_76 = 5;
pub const kCFXMLErrorMalformedName: _bindgen_ty_76 = 6;
pub const kCFXMLErrorMalformedCDSect: _bindgen_ty_76 = 7;
pub const kCFXMLErrorMalformedCloseTag: _bindgen_ty_76 = 8;
pub const kCFXMLErrorMalformedStartTag: _bindgen_ty_76 = 9;
pub const kCFXMLErrorMalformedDocument: _bindgen_ty_76 = 10;
pub const kCFXMLErrorElementlessDocument: _bindgen_ty_76 = 11;
pub const kCFXMLErrorMalformedComment: _bindgen_ty_76 = 12;
pub const kCFXMLErrorMalformedCharacterReference: _bindgen_ty_76 = 13;
pub const kCFXMLErrorMalformedParsedCharacterData: _bindgen_ty_76 = 14;
pub const kCFXMLErrorNoData: _bindgen_ty_76 = 15;
pub type _bindgen_ty_76 = i32;
pub type CFXMLParserCreateXMLStructureCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        parser: CFXMLParserRef,
        nodeDesc: CFXMLNodeRef,
        info: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type CFXMLParserAddChildCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        parser: CFXMLParserRef,
        parent: *mut ::std::os::raw::c_void,
        child: *mut ::std::os::raw::c_void,
        info: *mut ::std::os::raw::c_void,
    ),
>;
pub type CFXMLParserEndXMLStructureCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        parser: CFXMLParserRef,
        xmlType: *mut ::std::os::raw::c_void,
        info: *mut ::std::os::raw::c_void,
    ),
>;
pub type CFXMLParserResolveExternalEntityCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        parser: CFXMLParserRef,
        extID: *mut CFXMLExternalID,
        info: *mut ::std::os::raw::c_void,
    ) -> CFDataRef,
>;
pub type CFXMLParserHandleErrorCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        parser: CFXMLParserRef,
        error: CFXMLParserStatusCode,
        info: *mut ::std::os::raw::c_void,
    ) -> Boolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLParserCallBacks {
    pub version: CFIndex,
    pub createXMLStructure: CFXMLParserCreateXMLStructureCallBack,
    pub addChild: CFXMLParserAddChildCallBack,
    pub endXMLStructure: CFXMLParserEndXMLStructureCallBack,
    pub resolveExternalEntity: CFXMLParserResolveExternalEntityCallBack,
    pub handleError: CFXMLParserHandleErrorCallBack,
}
#[test]
fn bindgen_test_layout_CFXMLParserCallBacks() {
    assert_eq!(
        ::std::mem::size_of::<CFXMLParserCallBacks>(),
        48usize,
        concat!("Size of: ", stringify!(CFXMLParserCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLParserCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLParserCallBacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLParserCallBacks>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserCallBacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLParserCallBacks>())).createXMLStructure as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserCallBacks),
            "::",
            stringify!(createXMLStructure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLParserCallBacks>())).addChild as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserCallBacks),
            "::",
            stringify!(addChild)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLParserCallBacks>())).endXMLStructure as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserCallBacks),
            "::",
            stringify!(endXMLStructure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLParserCallBacks>())).resolveExternalEntity as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserCallBacks),
            "::",
            stringify!(resolveExternalEntity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLParserCallBacks>())).handleError as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserCallBacks),
            "::",
            stringify!(handleError)
        )
    );
}
impl Default for CFXMLParserCallBacks {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CFXMLParserRetainCallBack = ::std::option::Option<
    unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
>;
pub type CFXMLParserReleaseCallBack =
    ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void)>;
pub type CFXMLParserCopyDescriptionCallBack =
    ::std::option::Option<unsafe extern "C" fn(info: *const ::std::os::raw::c_void) -> CFStringRef>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFXMLParserContext {
    pub version: CFIndex,
    pub info: *mut ::std::os::raw::c_void,
    pub retain: CFXMLParserRetainCallBack,
    pub release: CFXMLParserReleaseCallBack,
    pub copyDescription: CFXMLParserCopyDescriptionCallBack,
}
#[test]
fn bindgen_test_layout_CFXMLParserContext() {
    assert_eq!(
        ::std::mem::size_of::<CFXMLParserContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFXMLParserContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CFXMLParserContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFXMLParserContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLParserContext>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLParserContext>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLParserContext>())).retain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFXMLParserContext>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CFXMLParserContext>())).copyDescription as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFXMLParserContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
impl Default for CFXMLParserContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn CFXMLParserGetTypeID() -> CFTypeID;
}
extern "C" {
    pub fn CFXMLParserCreate(
        allocator: CFAllocatorRef,
        xmlData: CFDataRef,
        dataSource: CFURLRef,
        parseOptions: CFOptionFlags,
        versionOfNodes: CFIndex,
        callBacks: *mut CFXMLParserCallBacks,
        context: *mut CFXMLParserContext,
    ) -> CFXMLParserRef;
}
extern "C" {
    pub fn CFXMLParserCreateWithDataFromURL(
        allocator: CFAllocatorRef,
        dataSource: CFURLRef,
        parseOptions: CFOptionFlags,
        versionOfNodes: CFIndex,
        callBacks: *mut CFXMLParserCallBacks,
        context: *mut CFXMLParserContext,
    ) -> CFXMLParserRef;
}
extern "C" {
    pub fn CFXMLParserGetContext(parser: CFXMLParserRef, context: *mut CFXMLParserContext);
}
extern "C" {
    pub fn CFXMLParserGetCallBacks(parser: CFXMLParserRef, callBacks: *mut CFXMLParserCallBacks);
}
extern "C" {
    pub fn CFXMLParserGetSourceURL(parser: CFXMLParserRef) -> CFURLRef;
}
extern "C" {
    pub fn CFXMLParserGetLocation(parser: CFXMLParserRef) -> CFIndex;
}
extern "C" {
    pub fn CFXMLParserGetLineNumber(parser: CFXMLParserRef) -> CFIndex;
}
extern "C" {
    pub fn CFXMLParserGetDocument(parser: CFXMLParserRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CFXMLParserGetStatusCode(parser: CFXMLParserRef) -> CFXMLParserStatusCode;
}
extern "C" {
    pub fn CFXMLParserCopyErrorDescription(parser: CFXMLParserRef) -> CFStringRef;
}
extern "C" {
    pub fn CFXMLParserAbort(
        parser: CFXMLParserRef,
        errorCode: CFXMLParserStatusCode,
        errorDescription: CFStringRef,
    );
}
extern "C" {
    pub fn CFXMLParserParse(parser: CFXMLParserRef) -> Boolean;
}
extern "C" {
    pub fn CFXMLTreeCreateFromData(
        allocator: CFAllocatorRef,
        xmlData: CFDataRef,
        dataSource: CFURLRef,
        parseOptions: CFOptionFlags,
        versionOfNodes: CFIndex,
    ) -> CFXMLTreeRef;
}
extern "C" {
    pub fn CFXMLTreeCreateFromDataWithError(
        allocator: CFAllocatorRef,
        xmlData: CFDataRef,
        dataSource: CFURLRef,
        parseOptions: CFOptionFlags,
        versionOfNodes: CFIndex,
        errorDict: *mut CFDictionaryRef,
    ) -> CFXMLTreeRef;
}
extern "C" {
    pub fn CFXMLTreeCreateWithDataFromURL(
        allocator: CFAllocatorRef,
        dataSource: CFURLRef,
        parseOptions: CFOptionFlags,
        versionOfNodes: CFIndex,
    ) -> CFXMLTreeRef;
}
extern "C" {
    pub fn CFXMLTreeCreateXMLData(allocator: CFAllocatorRef, xmlTree: CFXMLTreeRef) -> CFDataRef;
}
extern "C" {
    pub fn CFXMLCreateStringByEscapingEntities(
        allocator: CFAllocatorRef,
        string: CFStringRef,
        entitiesDictionary: CFDictionaryRef,
    ) -> CFStringRef;
}
extern "C" {
    pub fn CFXMLCreateStringByUnescapingEntities(
        allocator: CFAllocatorRef,
        string: CFStringRef,
        entitiesDictionary: CFDictionaryRef,
    ) -> CFStringRef;
}
extern "C" {
    pub static kCFXMLTreeErrorDescription: CFStringRef;
}
extern "C" {
    pub static kCFXMLTreeErrorLineNumber: CFStringRef;
}
extern "C" {
    pub static kCFXMLTreeErrorLocation: CFStringRef;
}
extern "C" {
    pub static kCFXMLTreeErrorStatusCode: CFStringRef;
}
///@constant	kAudioComponentFlag_Unsearchable
///
///When this bit in AudioComponentDescription's componentFlags is set, AudioComponentFindNext
///will only return this component when performing a specific, non-wildcard search for the
///component, i.e. with non-zero values of componentType, componentSubType, and
///componentManufacturer. This can be useful when privately registering a component.
///
///@constant	kAudioComponentFlag_SandboxSafe
///
///An AudioComponent sets this bit in its componentFlags to indicate to the system that the
///AudioComponent is safe to open in a sandboxed process.
///
///@constant	kAudioComponentFlag_IsV3AudioUnit
///
///The system sets this flag automatically when registering components which implement a version 3
///Audio Unit.
///
///@constant	kAudioComponentFlag_RequiresAsyncInstantiation
///
///The system sets this flag automatically when registering components which require asynchronous
///instantiation via AudioComponentInstantiate (v3 audio units with views).
///
///@constant	kAudioComponentFlag_CanLoadInProcess
///
///The system sets this flag automatically when registering components which can be loaded into
///the current process. This is always true for V2 audio units; it depends on the packaging
///in the case of a V3 audio unit.
pub type AudioComponentFlags = UInt32;
pub const kAudioComponentFlag_Unsearchable: _bindgen_ty_77 = 1;
pub const kAudioComponentFlag_SandboxSafe: _bindgen_ty_77 = 2;
pub const kAudioComponentFlag_IsV3AudioUnit: _bindgen_ty_77 = 4;
pub const kAudioComponentFlag_RequiresAsyncInstantiation: _bindgen_ty_77 = 8;
pub const kAudioComponentFlag_CanLoadInProcess: _bindgen_ty_77 = 16;
pub type _bindgen_ty_77 = u32;
/// @enum       AudioComponentInstantiationOptions
///@brief      Options controlling component instantiation.
///@discussion
///Most component instances are loaded into the calling process.
///
///A version 3 audio unit, however, can be loaded into a separate extension service process,
///and this is the default behavior for these components. To be able to load one in-process
///requires that the developer package the audio unit in a bundle separate from the application
///extension, since an extension's main binary cannot be dynamically loaded into another
///process.
///
///An OS X host may request in-process loading of such audio units using
///kAudioComponentInstantiation_LoadInProcess.
///
///kAudioComponentFlag_IsV3AudioUnit specifies whether an audio unit is implemented using API
///version 3.
///
///These options are just requests to the implementation. It may fail and fall back to the
///default.
///@constant kAudioComponentInstantiation_LoadOutOfProcess
///Attempt to load the component into a separate extension process.
///@constant kAudioComponentInstantiation_LoadInProcess
///Attempt to load the component into the current process. Only available on OS X.
pub type AudioComponentInstantiationOptions = UInt32;
pub const kAudioComponentInstantiation_LoadOutOfProcess: _bindgen_ty_78 = 1;
pub const kAudioComponentInstantiation_LoadInProcess: _bindgen_ty_78 = 2;
pub type _bindgen_ty_78 = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioComponentDescription {
    pub componentType: OSType,
    pub componentSubType: OSType,
    pub componentManufacturer: OSType,
    pub componentFlags: UInt32,
    pub componentFlagsMask: UInt32,
}
#[test]
fn bindgen_test_layout_AudioComponentDescription() {
    assert_eq!(
        ::std::mem::size_of::<AudioComponentDescription>(),
        20usize,
        concat!("Size of: ", stringify!(AudioComponentDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioComponentDescription>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioComponentDescription))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioComponentDescription>())).componentType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioComponentDescription),
            "::",
            stringify!(componentType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioComponentDescription>())).componentSubType as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioComponentDescription),
            "::",
            stringify!(componentSubType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioComponentDescription>())).componentManufacturer as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioComponentDescription),
            "::",
            stringify!(componentManufacturer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioComponentDescription>())).componentFlags as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioComponentDescription),
            "::",
            stringify!(componentFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioComponentDescription>())).componentFlagsMask as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioComponentDescription),
            "::",
            stringify!(componentFlagsMask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueAudioComponent {
    _unused: [u8; 0],
}
///@typedef        AudioComponent
///@abstract       The type used to represent a class of particular audio components
///@discussion     An audio component is usually found through a search and is then uniquely
///identified by the triple of an audio component's type, subtype and
///manufacturer.
///
///It can have properties associated with it (such as a name, a version).
///
///It is then used as a factory (like a class in an object-oriented programming
///language) from which to create instances. The instances are used to do the
///actual work.
///
///For example: the AudioComponentDescription 'aufx'/'dely'/'appl' describes the
///delay audio unit effect from Apple, Inc. You can find this component by
///searching explicitly for the audio component that matches this pattern (this is
///an unique identifier - there is only one match to this triple ID). Then once
///found, instances of the Apple delay effect audio unit can be created from its
///audio component and used to apply that effect to an audio signal. A single
///component can create any number of component instances.
pub type AudioComponent = *mut OpaqueAudioComponent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ComponentInstanceRecord {
    _unused: [u8; 0],
}
///@typedef        AudioComponentInstance
///@abstract       The type used to represent an instance of a particular audio component
///@discussion     An audio component instance is created from its factory/producer audio
///component. It is the body of code that does the work.
///
///A special note: While on the desktop this is typedef'd to a
///ComponentInstanceRecord *, you should not assume that this will always be
///compatible and usable with Component Manager calls.
pub type AudioComponentInstance = *mut ComponentInstanceRecord;
///@typedef        AudioComponentMethod
///@abstract       The broad prototype for an audio plugin method
///@discussion     Every audio plugin will implement a collection of methods that match a particular
///selector. For example, the AudioUnitInitialize API call is implemented by a
///plugin implementing the kAudioUnitInitializeSelect selector. Any function implementing
///an audio plugin selector conforms to the basic pattern where the first argument
///is a pointer to the plugin instance structure, has 0 or more specific arguments,
///and returns an OSStatus.
pub type AudioComponentMethod = ::std::option::Option<
    unsafe extern "C" fn(self_: *mut ::std::os::raw::c_void, ...) -> OSStatus,
>;
///@struct         AudioComponentPlugInInterface
///@discussion     A structure used to represent an audio plugin's routines
///@field          Open
///the function used to open (or create) an audio plugin instance
///@field          Close
///the function used to close (or dispose) an audio plugin instance
///@field          Lookup
///this is used to return a function pointer for a given selector,
///or NULL if that selector is not implemented
///@field          reserved
///must be NULL
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioComponentPlugInInterface {
    pub Open: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut ::std::os::raw::c_void,
            mInstance: AudioComponentInstance,
        ) -> OSStatus,
    >,
    pub Close:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut ::std::os::raw::c_void) -> OSStatus>,
    pub Lookup:
        ::std::option::Option<unsafe extern "C" fn(selector: SInt16) -> AudioComponentMethod>,
    pub reserved: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AudioComponentPlugInInterface() {
    assert_eq!(
        ::std::mem::size_of::<AudioComponentPlugInInterface>(),
        32usize,
        concat!("Size of: ", stringify!(AudioComponentPlugInInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioComponentPlugInInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioComponentPlugInInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioComponentPlugInInterface>())).Open as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioComponentPlugInInterface),
            "::",
            stringify!(Open)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioComponentPlugInInterface>())).Close as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioComponentPlugInInterface),
            "::",
            stringify!(Close)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioComponentPlugInInterface>())).Lookup as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioComponentPlugInInterface),
            "::",
            stringify!(Lookup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioComponentPlugInInterface>())).reserved as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioComponentPlugInInterface),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for AudioComponentPlugInInterface {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@typedef        AudioComponentFactoryFunction
///@abstract       A function that creates AudioComponentInstances.
///@discussion
///Authors of AudioComponents may register them from bundles as described
///above in the discussion of this header file, or dynamically within a single
///process, using AudioComponentRegister.
///
///@param          inDesc
///The AudioComponentDescription specifying the component to be instantiated.
///@result         A pointer to a AudioComponentPlugInInterface structure.
pub type AudioComponentFactoryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        inDesc: *const AudioComponentDescription,
    ) -> *mut AudioComponentPlugInInterface,
>;
extern "C" {
    ///@function       AudioComponentFindNext
    ///@abstract       Finds an audio component.
    ///@discussion     This function is used to find an audio component that is the closest match
    ///to the provided values. Note that the list of available components may change
    ///dynamically in situations involving inter-app audio on iOS, or version 3
    ///audio unit extensions. See kAudioComponentRegistrationsChangedNotification.
    ///
    ///@param          inComponent
    ///If NULL, then the search starts from the beginning until an audio
    ///component is found that matches the description provided by inDesc.
    ///If non-NULL, then the search starts (continues) from the previously
    ///found audio component specified by inComponent, and will return the next
    ///found audio component.
    ///@param          inDesc
    ///The type, subtype and manufacturer fields are used to specify the audio
    ///component to search for. A value of 0 (zero) for any of these fields is
    ///a wildcard, so the first match found is returned.
    ///@result         An audio component that matches the search parameters, or NULL if none found.
    pub fn AudioComponentFindNext(
        inComponent: AudioComponent,
        inDesc: *const AudioComponentDescription,
    ) -> AudioComponent;
}
extern "C" {
    ///@function       AudioComponentCount
    ///@abstract       Counts audio components.
    ///@discussion     Returns the number of AudioComponents that match the specified
    ///AudioComponentDescription.
    ///@param          inDesc
    ///The type, subtype and manufacturer fields are used to specify the audio
    ///components to count A value of 0 (zero) for any of these fields is a
    ///wildcard, so will match any value for this field
    ///@result         a UInt32. 0 (zero) means no audio components were found that matched the
    ///search parameters.
    pub fn AudioComponentCount(inDesc: *const AudioComponentDescription) -> UInt32;
}
extern "C" {
    ///@function       AudioComponentCopyName
    ///@abstract       Retrieves the name of an audio component.
    ///@discussion     the name of an audio component
    ///@param          inComponent
    ///the audio component (must not be NULL)
    ///@param          outName
    ///a CFString that is the name of the audio component. This string should
    ///be released by the caller.
    ///@result         an OSStatus result code.
    pub fn AudioComponentCopyName(
        inComponent: AudioComponent,
        outName: *mut CFStringRef,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioComponentGetDescription
    ///@abstract       Retrieve an audio component's description.
    ///@discussion     This will return the fully specified audio component description for the
    ///provided audio component.
    ///@param          inComponent
    ///the audio component (must not be NULL)
    ///@param          outDesc
    ///the audio component description for the specified audio component
    ///@result         an OSStatus result code.
    pub fn AudioComponentGetDescription(
        inComponent: AudioComponent,
        outDesc: *mut AudioComponentDescription,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioComponentGetVersion
    ///@abstract       Retrieve an audio component's version.
    ///@discussion
    ///@param          inComponent
    ///the audio component (must not be NULL)
    ///@param          outVersion
    ///the audio component's version in the form of 0xMMMMmmDD (Major, Minor, Dot)
    ///@result         an OSStatus result code.
    pub fn AudioComponentGetVersion(
        inComponent: AudioComponent,
        outVersion: *mut UInt32,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioComponentInstanceNew
    ///@abstract       Creates an audio component instance.
    ///@discussion     This function creates an instance of a given audio component. The audio
    ///component instance is the object that does all of the work, whereas the
    ///audio component is the way an application finds and then creates this object
    ///to do this work. For example, an audio unit is a type of audio component
    ///instance, so to use an audio unit, one finds its audio component, and then
    ///creates a new instance of that component. This instance is then used to
    ///perform the audio tasks for which it was designed (process, mix, synthesise,
    ///etc.).
    ///@param          inComponent
    ///the audio component (must not be NULL)
    ///@param          outInstance
    ///the audio component instance
    ///@result         an OSStatus result code.
    pub fn AudioComponentInstanceNew(
        inComponent: AudioComponent,
        outInstance: *mut AudioComponentInstance,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioComponentInstantiate
    ///@abstract       Creates an audio component instance, asynchronously.
    ///@discussion     This is an asynchronous version of AudioComponentInstanceNew(). It must be
    ///used to instantiate any component with kAudioComponentFlag_RequiresAsyncInstantiation
    ///set in its component flags. It may be used for other components as well.
    ///
    ///Note: Do not block the main thread while waiting for the completion handler
    ///to be called; this can deadlock.
    ///@param          inComponent
    ///the audio component
    ///@param          inOptions
    ///see AudioComponentInstantiationOptions
    ///@param          inCompletionHandler
    ///called in an arbitrary thread context when instantiation is complete.
    pub fn AudioComponentInstantiate(
        inComponent: AudioComponent,
        inOptions: AudioComponentInstantiationOptions,
        inCompletionHandler: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    ///@function       AudioComponentInstanceDispose
    ///@abstract       Disposes of an audio component instance.
    ///@discussion     This function will dispose the audio component instance that was created
    ///with the New call. It will deallocate any resources that the instance was using.
    ///@param          inInstance
    ///the audio component instance to dispose (must not be NULL)
    ///@result         an OSStatus result code.
    pub fn AudioComponentInstanceDispose(inInstance: AudioComponentInstance) -> OSStatus;
}
extern "C" {
    ///@function       AudioComponentInstanceGetComponent
    ///@abstract       Retrieve the audio component from its instance
    ///@discussion     Allows the application at any time to retrieve the audio component that is
    ///the factory object of a given instance (i.e., the audio component that was
    ///used to create the instance in the first place). This allows the application
    ///to retrieve general information about a particular audio component (its
    ///name, version, etc) when one just has an audio component instance to work
    ///with
    ///@param          inInstance
    ///the audio component instance (must not be NULL, and instance must be valid - that is, not disposed)
    ///@result         a valid audio component or NULL if no component was found.
    pub fn AudioComponentInstanceGetComponent(inInstance: AudioComponentInstance)
        -> AudioComponent;
}
extern "C" {
    ///@function       AudioComponentInstanceCanDo
    ///@discussion     Determines if an audio component instance implements a particular component
    ///API call as signified by the specified selector identifier token.
    ///@param          inInstance
    ///the audio component instance
    ///@param          inSelectorID
    ///a number to signify the audio component API (component selector) as appropriate for the instance's component type.
    ///@result         a boolean
    pub fn AudioComponentInstanceCanDo(
        inInstance: AudioComponentInstance,
        inSelectorID: SInt16,
    ) -> Boolean;
}
extern "C" {
    ///@function       AudioComponentRegister
    ///@abstract       Dynamically registers an AudioComponent within the current process
    ///@discussion
    ///AudioComponents are registered either when found in appropriate bundles in the filesystem,
    ///or via this call. AudioComponents registered via this call are available only within
    ///the current process.
    ///
    ///@param          inDesc
    ///The AudioComponentDescription that describes the AudioComponent. Note that
    ///the registrar needs to be sure to set the flag kAudioComponentFlag_SandboxSafe
    ///in the componentFlags field of the AudioComponentDescription to indicate that
    ///the AudioComponent can be loaded directly into a sandboxed process.
    ///@param          inName
    ///the AudioComponent's name
    ///@param          inVersion
    ///the AudioComponent's version
    ///@param          inFactory
    ///an AudioComponentFactoryFunction which will create instances of your
    ///AudioComponent
    ///@result         an AudioComponent object
    pub fn AudioComponentRegister(
        inDesc: *const AudioComponentDescription,
        inName: CFStringRef,
        inVersion: UInt32,
        inFactory: AudioComponentFactoryFunction,
    ) -> AudioComponent;
}
extern "C" {
    ///@function       AudioComponentCopyConfigurationInfo
    ///@abstract       Fetches the basic configuration info about a given AudioComponent
    ///@discussion     Currently, only AudioUnits can supply this information.
    ///@param          inComponent
    ///The AudioComponent whose info is being fetched.
    ///@param          outConfigurationInfo
    ///On exit, this is CFDictionaryRef that contains information describing the
    ///capabilities of the AudioComponent. The specific information depends on the
    ///type of AudioComponent. The keys for the dictionary are defined in
    ///AudioUnitProperties.h (or other headers as appropriate for the component type).
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioComponentCopyConfigurationInfo(
        inComponent: AudioComponent,
        outConfigurationInfo: *mut CFDictionaryRef,
    ) -> OSStatus;
}
///@enum		 AudioComponentValidationResult
///@abstract	 Constants for describing the result of validating an AudioComponent
///@constant	 kAudioComponentValidationResult_Passed
///The AudioComponent passed validation.
///@constant	 kAudioComponentValidationResult_Failed
///The AudioComponent failed validation.
///@constant	 kAudioComponentValidationResult_TimedOut
///The validation operation timed out before completing.
///@constant	 kAudioComponentValidationResult_UnauthorizedError_Open
///The AudioComponent failed validation during open operation as it is not authorized.
///@constant	 kAudioComponentValidationResult_UnauthorizedError_Init
///The AudioComponent failed validation during initialization as it is not authorized.
pub type AudioComponentValidationResult = UInt32;
pub const kAudioComponentValidationResult_Unknown: _bindgen_ty_79 = 0;
pub const kAudioComponentValidationResult_Passed: _bindgen_ty_79 = 1;
pub const kAudioComponentValidationResult_Failed: _bindgen_ty_79 = 2;
pub const kAudioComponentValidationResult_TimedOut: _bindgen_ty_79 = 3;
pub const kAudioComponentValidationResult_UnauthorizedError_Open: _bindgen_ty_79 = 4;
pub const kAudioComponentValidationResult_UnauthorizedError_Init: _bindgen_ty_79 = 5;
pub type _bindgen_ty_79 = u32;
extern "C" {
    ///@function		AudioComponentValidate
    ///@abstract		Tests a specified AudioComponent for API and behavioral conformance.
    ///@discussion	Currently, only AudioUnits can can be validated.
    ///@param			inComponent
    ///The AudioComponent to validate.
    ///@param			inValidationParameters
    ///A CFDictionaryRef that contains parameters for the validation operation.
    ///Passing NULL for this argument tells the system to use the default
    ///parameters.
    ///@param			outValidationResult
    ///On exit, this is an AudioComponentValidationResult.
    ///@result			an OSStatus result code.
    pub fn AudioComponentValidate(
        inComponent: AudioComponent,
        inValidationParameters: CFDictionaryRef,
        outValidationResult: *mut AudioComponentValidationResult,
    ) -> OSStatus;
}
///@typedef			AudioUnit
///@discussion			An audio unit is of type AudioComponentInstance as defined in
///AudioComponent.h
pub type AudioUnit = AudioComponentInstance;
pub const kAudioUnitType_Output: _bindgen_ty_80 = 1635086197;
pub const kAudioUnitType_MusicDevice: _bindgen_ty_80 = 1635085685;
pub const kAudioUnitType_MusicEffect: _bindgen_ty_80 = 1635085670;
pub const kAudioUnitType_FormatConverter: _bindgen_ty_80 = 1635083875;
pub const kAudioUnitType_Effect: _bindgen_ty_80 = 1635083896;
pub const kAudioUnitType_Mixer: _bindgen_ty_80 = 1635085688;
pub const kAudioUnitType_Panner: _bindgen_ty_80 = 1635086446;
pub const kAudioUnitType_Generator: _bindgen_ty_80 = 1635084142;
pub const kAudioUnitType_OfflineEffect: _bindgen_ty_80 = 1635086188;
pub const kAudioUnitType_MIDIProcessor: _bindgen_ty_80 = 1635085673;
pub type _bindgen_ty_80 = u32;
pub const kAudioUnitManufacturer_Apple: _bindgen_ty_81 = 1634758764;
pub type _bindgen_ty_81 = u32;
pub const kAudioUnitSubType_GenericOutput: _bindgen_ty_82 = 1734700658;
pub const kAudioUnitSubType_VoiceProcessingIO: _bindgen_ty_82 = 1987078511;
pub type _bindgen_ty_82 = u32;
pub const kAudioUnitSubType_HALOutput: _bindgen_ty_83 = 1634230636;
pub const kAudioUnitSubType_DefaultOutput: _bindgen_ty_83 = 1684366880;
pub const kAudioUnitSubType_SystemOutput: _bindgen_ty_83 = 1937339168;
pub type _bindgen_ty_83 = u32;
pub const kAudioUnitSubType_DLSSynth: _bindgen_ty_84 = 1684828960;
pub const kAudioUnitSubType_Sampler: _bindgen_ty_84 = 1935764848;
pub const kAudioUnitSubType_MIDISynth: _bindgen_ty_84 = 1836284270;
pub type _bindgen_ty_84 = u32;
pub const kAudioUnitSubType_AUConverter: _bindgen_ty_85 = 1668247158;
pub const kAudioUnitSubType_Varispeed: _bindgen_ty_85 = 1986097769;
pub const kAudioUnitSubType_DeferredRenderer: _bindgen_ty_85 = 1684366962;
pub const kAudioUnitSubType_Splitter: _bindgen_ty_85 = 1936747636;
pub const kAudioUnitSubType_MultiSplitter: _bindgen_ty_85 = 1836281964;
pub const kAudioUnitSubType_Merger: _bindgen_ty_85 = 1835364967;
pub const kAudioUnitSubType_NewTimePitch: _bindgen_ty_85 = 1853191280;
pub const kAudioUnitSubType_AUiPodTimeOther: _bindgen_ty_85 = 1768977519;
pub const kAudioUnitSubType_RoundTripAAC: _bindgen_ty_85 = 1918984547;
pub type _bindgen_ty_85 = u32;
pub const kAudioUnitSubType_TimePitch: _bindgen_ty_86 = 1953329268;
pub type _bindgen_ty_86 = u32;
pub const kAudioUnitSubType_PeakLimiter: _bindgen_ty_87 = 1819112562;
pub const kAudioUnitSubType_DynamicsProcessor: _bindgen_ty_87 = 1684237680;
pub const kAudioUnitSubType_LowPassFilter: _bindgen_ty_87 = 1819304307;
pub const kAudioUnitSubType_HighPassFilter: _bindgen_ty_87 = 1752195443;
pub const kAudioUnitSubType_BandPassFilter: _bindgen_ty_87 = 1651532147;
pub const kAudioUnitSubType_HighShelfFilter: _bindgen_ty_87 = 1752393830;
pub const kAudioUnitSubType_LowShelfFilter: _bindgen_ty_87 = 1819502694;
pub const kAudioUnitSubType_ParametricEQ: _bindgen_ty_87 = 1886217585;
pub const kAudioUnitSubType_Distortion: _bindgen_ty_87 = 1684632436;
pub const kAudioUnitSubType_Delay: _bindgen_ty_87 = 1684368505;
pub const kAudioUnitSubType_SampleDelay: _bindgen_ty_87 = 1935961209;
pub const kAudioUnitSubType_NBandEQ: _bindgen_ty_87 = 1851942257;
pub type _bindgen_ty_87 = u32;
pub const kAudioUnitSubType_GraphicEQ: _bindgen_ty_88 = 1735550321;
pub const kAudioUnitSubType_MultiBandCompressor: _bindgen_ty_88 = 1835232624;
pub const kAudioUnitSubType_MatrixReverb: _bindgen_ty_88 = 1836213622;
pub const kAudioUnitSubType_Pitch: _bindgen_ty_88 = 1953329268;
pub const kAudioUnitSubType_AUFilter: _bindgen_ty_88 = 1718185076;
pub const kAudioUnitSubType_NetSend: _bindgen_ty_88 = 1853058660;
pub const kAudioUnitSubType_RogerBeep: _bindgen_ty_88 = 1919903602;
pub type _bindgen_ty_88 = u32;
pub const kAudioUnitSubType_MultiChannelMixer: _bindgen_ty_89 = 1835232632;
pub const kAudioUnitSubType_MatrixMixer: _bindgen_ty_89 = 1836608888;
pub const kAudioUnitSubType_SpatialMixer: _bindgen_ty_89 = 862217581;
pub type _bindgen_ty_89 = u32;
pub const kAudioUnitSubType_StereoMixer: _bindgen_ty_90 = 1936554098;
pub const kAudioUnitSubType_3DMixer: _bindgen_ty_90 = 862219640;
pub type _bindgen_ty_90 = u32;
pub const kAudioUnitSubType_SphericalHeadPanner: _bindgen_ty_91 = 1936746610;
pub const kAudioUnitSubType_VectorPanner: _bindgen_ty_91 = 1986158963;
pub const kAudioUnitSubType_SoundFieldPanner: _bindgen_ty_91 = 1634558569;
pub const kAudioUnitSubType_HRTFPanner: _bindgen_ty_91 = 1752331366;
pub type _bindgen_ty_91 = u32;
pub const kAudioUnitSubType_NetReceive: _bindgen_ty_92 = 1852990326;
pub const kAudioUnitSubType_ScheduledSoundPlayer: _bindgen_ty_92 = 1936945260;
pub const kAudioUnitSubType_AudioFilePlayer: _bindgen_ty_92 = 1634103404;
pub type _bindgen_ty_92 = u32;
///@enum			AudioUnitRenderActionFlags
///@discussion		These flags can be set in a callback from an audio unit during an audio unit
///render operation from either the RenderNotify Proc or the render input
///callback.
///
///@constant		kAudioUnitRenderAction_PreRender
///Called on a render notification Proc - which is called either before or after
///the render operation of the audio unit. If this flag is set, the proc is being
///called before the render operation is performed.
///
///@constant		kAudioUnitRenderAction_PostRender
///Called on a render notification Proc - which is called either before or after
///the render operation of the audio unit. If this flag is set, the proc is being
///called after the render operation is completed.
///
///@constant		kAudioUnitRenderAction_OutputIsSilence
///This flag can be set in a render input callback (or in the audio unit's render
///operation itself) and is used to indicate that the render buffer contains only
///silence. It can then be used by the caller as a hint to whether the buffer
///needs to be processed or not.
///
///@constant		kAudioOfflineUnitRenderAction_Preflight
///This is used with offline audio units (of type 'auol'). It is used when an
///offline unit is being preflighted, which is performed prior to the actual
///offline rendering actions are performed. It is used for those cases where the
///offline process needs it (for example, with an offline unit that normalises an
///audio file, it needs to see all of the audio data first before it can perform
///its normalisation)
///
///@constant		kAudioOfflineUnitRenderAction_Render
///Once an offline unit has been successfully preflighted, it is then put into
///its render mode. So this flag is set to indicate to the audio unit that it is
///now in that state and that it should perform its processing on the input data.
///
///@constant		kAudioOfflineUnitRenderAction_Complete
///This flag is set when an offline unit has completed either its preflight or
///performed render operations
///
///@constant		kAudioUnitRenderAction_PostRenderError
///If this flag is set on the post-render call an error was returned by the
///AUs render operation. In this case, the error can be retrieved through the
///lastRenderError property and the audio data in ioData handed to the post-render
///notification will be invalid.
///@constant		kAudioUnitRenderAction_DoNotCheckRenderArgs
///If this flag is set, then checks that are done on the arguments provided to render
///are not performed. This can be useful to use to save computation time in
///situations where you are sure you are providing the correct arguments
///and structures to the various render calls
pub type AudioUnitRenderActionFlags = UInt32;
pub const kAudioUnitRenderAction_PreRender: _bindgen_ty_93 = 4;
pub const kAudioUnitRenderAction_PostRender: _bindgen_ty_93 = 8;
pub const kAudioUnitRenderAction_OutputIsSilence: _bindgen_ty_93 = 16;
pub const kAudioOfflineUnitRenderAction_Preflight: _bindgen_ty_93 = 32;
pub const kAudioOfflineUnitRenderAction_Render: _bindgen_ty_93 = 64;
pub const kAudioOfflineUnitRenderAction_Complete: _bindgen_ty_93 = 128;
pub const kAudioUnitRenderAction_PostRenderError: _bindgen_ty_93 = 256;
pub const kAudioUnitRenderAction_DoNotCheckRenderArgs: _bindgen_ty_93 = 512;
pub type _bindgen_ty_93 = u32;
pub const kAudioUnitErr_InvalidProperty: _bindgen_ty_94 = -10879;
pub const kAudioUnitErr_InvalidParameter: _bindgen_ty_94 = -10878;
pub const kAudioUnitErr_InvalidElement: _bindgen_ty_94 = -10877;
pub const kAudioUnitErr_NoConnection: _bindgen_ty_94 = -10876;
pub const kAudioUnitErr_FailedInitialization: _bindgen_ty_94 = -10875;
pub const kAudioUnitErr_TooManyFramesToProcess: _bindgen_ty_94 = -10874;
pub const kAudioUnitErr_InvalidFile: _bindgen_ty_94 = -10871;
pub const kAudioUnitErr_UnknownFileType: _bindgen_ty_94 = -10870;
pub const kAudioUnitErr_FileNotSpecified: _bindgen_ty_94 = -10869;
pub const kAudioUnitErr_FormatNotSupported: _bindgen_ty_94 = -10868;
pub const kAudioUnitErr_Uninitialized: _bindgen_ty_94 = -10867;
pub const kAudioUnitErr_InvalidScope: _bindgen_ty_94 = -10866;
pub const kAudioUnitErr_PropertyNotWritable: _bindgen_ty_94 = -10865;
pub const kAudioUnitErr_CannotDoInCurrentContext: _bindgen_ty_94 = -10863;
pub const kAudioUnitErr_InvalidPropertyValue: _bindgen_ty_94 = -10851;
pub const kAudioUnitErr_PropertyNotInUse: _bindgen_ty_94 = -10850;
pub const kAudioUnitErr_Initialized: _bindgen_ty_94 = -10849;
pub const kAudioUnitErr_InvalidOfflineRender: _bindgen_ty_94 = -10848;
pub const kAudioUnitErr_Unauthorized: _bindgen_ty_94 = -10847;
pub const kAudioUnitErr_MIDIOutputBufferFull: _bindgen_ty_94 = -66753;
pub const kAudioComponentErr_InstanceTimedOut: _bindgen_ty_94 = -66754;
pub const kAudioComponentErr_InstanceInvalidated: _bindgen_ty_94 = -66749;
pub const kAudioUnitErr_RenderTimeout: _bindgen_ty_94 = -66745;
pub const kAudioUnitErr_ExtensionNotFound: _bindgen_ty_94 = -66744;
pub const kAudioUnitErr_InvalidParameterValue: _bindgen_ty_94 = -66743;
pub type _bindgen_ty_94 = i32;
///@typedef			AudioUnitPropertyID
///@discussion			Type used for audio unit properties.
///Properties are used to describe the state of an audio unit (for instance,
///the input or output audio format)
pub type AudioUnitPropertyID = UInt32;
///@typedef			AudioUnitScope
///@discussion			Type used for audio unit scopes. Apple reserves the 0 < 1024 range for
///audio unit scope identifiers.
///Scopes are used to delineate a major attribute of an audio unit
///(for instance, global, input, output)
pub type AudioUnitScope = UInt32;
///@typedef			AudioUnitElement
///@discussion			Type used for audio unit elements.
///Scopes can have one or more member, and a member of a scope is
///addressed / described by its element
///For instance, input bus 1 is input scope, element 1
pub type AudioUnitElement = UInt32;
///@typedef			AudioUnitParameterID
///@discussion			Type used for audio unit parameters.
///Parameters are typically used to control and set render state
///(for instance, filter cut-off frequency)
pub type AudioUnitParameterID = UInt32;
///@typedef			AudioUnitParameterValue
///@discussion			Type used for audio unit parameter values.
///The value of a given parameter is specified using this type
///(typically a Float32)
pub type AudioUnitParameterValue = Float32;
///@enum			AUParameterEventType
///@discussion		The type of a parameter event (see AudioUnitScheduleParameter)
///
///@constant		kParameterEvent_Immediate
///The parameter event describes an immediate change to the parameter value to
///the new value
///@constant		kParameterEvent_Ramped
///The parameter event describes a change to the parameter value that should
///be applied over the specified period of time
pub type AUParameterEventType = UInt32;
pub const kParameterEvent_Immediate: _bindgen_ty_95 = 1;
pub const kParameterEvent_Ramped: _bindgen_ty_95 = 2;
pub type _bindgen_ty_95 = u32;
///@struct			AudioUnitParameterEvent
///@discussion		A parameter event describes a change to a parameter's value, where the type of
///the event describes how that change is to be applied (see AUParameterEventType).
///A parameter is uniquely defined through the triplet of scope, element and
///parameterID.
///
///See AudioUnitScheduleParameters
///
///@field			scope
///The scope for the parameter
///@field			element
///The element for the parameter
///@field			parameter
///The parameterID for the parameter
///
///@field			eventType
///The event type. This field further defines how the union described by
///eventValues is to be interpreted.
///
///@field			eventValues
///If the parameter event type is _Immediate, then the immediate struct of this
///union should be used.
///If the parameter event type is _Ramped, then the ramp struct of this union
///should be used.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AudioUnitParameterEvent {
    pub scope: AudioUnitScope,
    pub element: AudioUnitElement,
    pub parameter: AudioUnitParameterID,
    pub eventType: AUParameterEventType,
    pub eventValues: AudioUnitParameterEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AudioUnitParameterEvent__bindgen_ty_1 {
    pub ramp: AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1,
    pub immediate: AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1 {
    pub startBufferOffset: SInt32,
    pub durationInFrames: UInt32,
    pub startValue: AudioUnitParameterValue,
    pub endValue: AudioUnitParameterValue,
}
#[test]
fn bindgen_test_layout_AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1>()))
                .startBufferOffset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(startBufferOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1>()))
                .durationInFrames as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(durationInFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1>()))
                .startValue as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(startValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1>())).endValue
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(endValue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_2 {
    pub bufferOffset: UInt32,
    pub value: AudioUnitParameterValue,
}
#[test]
fn bindgen_test_layout_AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_2>()))
                .bufferOffset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(bufferOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_2>())).value
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_AudioUnitParameterEvent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitParameterEvent__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitParameterEvent__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterEvent__bindgen_ty_1>())).ramp as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1),
            "::",
            stringify!(ramp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterEvent__bindgen_ty_1>())).immediate as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterEvent__bindgen_ty_1),
            "::",
            stringify!(immediate)
        )
    );
}
impl Default for AudioUnitParameterEvent__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_AudioUnitParameterEvent() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitParameterEvent>(),
        32usize,
        concat!("Size of: ", stringify!(AudioUnitParameterEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitParameterEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioUnitParameterEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameterEvent>())).scope as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterEvent),
            "::",
            stringify!(scope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameterEvent>())).element as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterEvent),
            "::",
            stringify!(element)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterEvent>())).parameter as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterEvent),
            "::",
            stringify!(parameter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterEvent>())).eventType as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterEvent),
            "::",
            stringify!(eventType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterEvent>())).eventValues as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterEvent),
            "::",
            stringify!(eventValues)
        )
    );
}
impl Default for AudioUnitParameterEvent {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@struct			AudioUnitParameter
///@discussion		An audio unit parameter is defined by the triplet of audio unit scope, element
///and parameterID. This struct is used with the functions in AudioUnitUtilities.h
///to deal with audio unit parameters, but is included in this header file for
///completeness.
///
///@field			mAudioUnit
///The audio unit instance to which the specified parameter applies.
///@field			mParameterID
///The parameterID for the parameter
///@field			mScope
///The scope for the parameter
///@field			mElement
///The element for the parameter
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioUnitParameter {
    pub mAudioUnit: AudioUnit,
    pub mParameterID: AudioUnitParameterID,
    pub mScope: AudioUnitScope,
    pub mElement: AudioUnitElement,
}
#[test]
fn bindgen_test_layout_AudioUnitParameter() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitParameter>(),
        24usize,
        concat!("Size of: ", stringify!(AudioUnitParameter))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitParameter>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioUnitParameter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameter>())).mAudioUnit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameter),
            "::",
            stringify!(mAudioUnit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameter>())).mParameterID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameter),
            "::",
            stringify!(mParameterID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameter>())).mScope as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameter),
            "::",
            stringify!(mScope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameter>())).mElement as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameter),
            "::",
            stringify!(mElement)
        )
    );
}
impl Default for AudioUnitParameter {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@struct			AudioUnitProperty
///@discussion		An audio unit property is defined by the triplet of audio unit scope, element
///and propertyID. This struct is used with the functions in AudioUnitUtilities.h
///to deal with audio unit properties, but is included in this header file for
///completeness.
///
///@field			mAudioUnit
///The audio unit instance which the specified property applies too
///@field			mPropertyID
///The propertyID for the property
///@field			mScope
///The scope for the property
///@field			mElement
///The element for the property
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioUnitProperty {
    pub mAudioUnit: AudioUnit,
    pub mPropertyID: AudioUnitPropertyID,
    pub mScope: AudioUnitScope,
    pub mElement: AudioUnitElement,
}
#[test]
fn bindgen_test_layout_AudioUnitProperty() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitProperty>(),
        24usize,
        concat!("Size of: ", stringify!(AudioUnitProperty))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitProperty>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioUnitProperty))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitProperty>())).mAudioUnit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitProperty),
            "::",
            stringify!(mAudioUnit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitProperty>())).mPropertyID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitProperty),
            "::",
            stringify!(mPropertyID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitProperty>())).mScope as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitProperty),
            "::",
            stringify!(mScope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitProperty>())).mElement as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitProperty),
            "::",
            stringify!(mElement)
        )
    );
}
impl Default for AudioUnitProperty {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@typedef		AURenderCallback
///@discussion		This is the prototype for a function callback Proc that is used both with the
///AudioUnit render notification API and the render input callback. See
///kAudioUnitProperty_SetRenderCallback property or AudioUnitAddRenderNotify.
///This callback is part of the process of a call to AudioUnitRender. As a
///notification it is called either before or after the audio unit's render
///operations. As a render input callback, it is called to provide input data for
///the particular input bus the callback is attached too.
///
///@param			inRefCon
///The client data that is provided either with the AURenderCallbackStruct or as
///specified with the Add API call
///@param			ioActionFlags
///Flags used to describe more about the context of this call (pre or post in the
///notify case for instance)
///@param			inTimeStamp
///The times stamp associated with this call of audio unit render
///@param			inBusNumber
///The bus number associated with this call of audio unit render
///@param			inNumberFrames
///The number of sample frames that will be represented in the audio data in the
///provided ioData parameter
///@param			ioData
///The AudioBufferList that will be used to contain the rendered or provided
///audio data. These buffers will be aligned to 16 byte boundaries (which is
///normally what malloc will return). Can be null in the notification that
///input is available.
pub type AURenderCallback = ::std::option::Option<
    unsafe extern "C" fn(
        inRefCon: *mut ::std::os::raw::c_void,
        ioActionFlags: *mut AudioUnitRenderActionFlags,
        inTimeStamp: *const AudioTimeStamp,
        inBusNumber: UInt32,
        inNumberFrames: UInt32,
        ioData: *mut AudioBufferList,
    ) -> OSStatus,
>;
///@typedef		AudioUnitPropertyListenerProc
///@discussion		This is the prototype for a function callback Proc that is registered with an
///audio unit to notify the caller of any changes to a value of an audio unit
///property. See AudioUnitAddPropertyListener
///
///@param			inRefCon
///The client data that is provided with the add property listener registration
///@param			inUnit
///The audio unit upon which the specified property value has changed
///@param			inID
///The property whose value has changed
///@param			inScope
///The scope of the property whose value has changed
///@param			inElement
///The element ID on the scope of the property whose value has changed
pub type AudioUnitPropertyListenerProc = ::std::option::Option<
    unsafe extern "C" fn(
        inRefCon: *mut ::std::os::raw::c_void,
        inUnit: AudioUnit,
        inID: AudioUnitPropertyID,
        inScope: AudioUnitScope,
        inElement: AudioUnitElement,
    ),
>;
///@typedef		AUInputSamplesInOutputCallback
///@discussion		This is the prototype for a function callback Proc that is registered with an
///audio unit to notify the caller of for the user of a varispeed or AUTimePitch
///audio unit where it is not clear what input sample is represented in the
///rendered output samples.
///
///@param			inRefCon
///The client data that is provided with the add property listener registration
///@param			inOutputTimeStamp
///The time stamp that corresponds to the first sample of audio data produced in
///AudioUnitRender (its output data)
///@param			inInputSample
///The sample number of the input that is represented in the first sample of that
///output time stamp
///@param			inNumberInputSamples
///The number of input samples that are represented in an output buffer
pub type AUInputSamplesInOutputCallback = ::std::option::Option<
    unsafe extern "C" fn(
        inRefCon: *mut ::std::os::raw::c_void,
        inOutputTimeStamp: *const AudioTimeStamp,
        inInputSample: Float64,
        inNumberInputSamples: Float64,
    ),
>;
extern "C" {
    pub static kAudioComponentRegistrationsChangedNotification: CFStringRef;
}
extern "C" {
    pub static kAudioComponentInstanceInvalidationNotification: CFStringRef;
}
extern "C" {
    ///@function		AudioUnitInitialize
    ///@abstract		initialize an audio unit
    ///@discussion		Upon success, the audio unit has been successfully initialized. This means
    ///that the formats for input and output are valid and can be supported and it
    ///has based its allocations on the max number of frames that it is able to
    ///render at any given time. Once initialized, it is in a state where it can be
    ///asked to render.
    ///
    ///In common practice, major state of an audio unit (such as its I/O formats,
    ///memory allocations) cannot be changed while an audio unit is initialized.
    ///
    ///@param			inUnit
    ///The audio unit to initialize
    ///@result			noErr, or an error representing the reasons why the audio unit was not able
    ///to be initialized successfully
    pub fn AudioUnitInitialize(inUnit: AudioUnit) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitUninitialize
    ///@abstract		uninitialize an audio unit
    ///@discussion		Once an audio unit has been initialized, to change its state in response to
    ///some kind of environmental change, the audio unit should be uninitialized.
    ///This will have the effect of the audio unit de-allocating its resources.
    ///The caller can then reconfigure the audio unit to match the new environment
    ///(for instance, the sample rate to process audio is different than it was) and
    ///then re-initialize the audio unit when those changes have been applied.
    ///
    ///@param			inUnit
    ///The audio unit to uninitialize
    ///@result			noErr, or an error representing the reasons why the audio unit was not able
    ///to be initialized successfully. Typically this call won't return an error
    ///unless the audio unit in question is no longer valid.
    pub fn AudioUnitUninitialize(inUnit: AudioUnit) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitGetPropertyInfo
    ///@abstract		retrieves information about a specified property
    ///@discussion		The API can be used to retrieve both the size of the property, and whether it
    ///is writable or not. In order to get a general answer on the capability of an
    ///audio unit, this function should be called before the audio unit
    ///is initialized (as some properties are writable when the audio unit is
    ///initialized, and others not)
    ///
    ///@param			inUnit
    ///the audio unit
    ///@param			inID
    ///the property identifier
    ///@param			inScope
    ///the scope of the property
    ///@param			inElement
    ///the element of the scope
    ///@param			outDataSize
    ///if not null, then will retrieve the maximum size for the property. if null,
    ///then it is ignored
    ///@param			outWritable
    ///if not null, then will retrieve whether the property can be written or not.
    ///if null, then it is ignored
    ///
    ///@result			noErr, or various audio unit errors related to properties
    pub fn AudioUnitGetPropertyInfo(
        inUnit: AudioUnit,
        inID: AudioUnitPropertyID,
        inScope: AudioUnitScope,
        inElement: AudioUnitElement,
        outDataSize: *mut UInt32,
        outWritable: *mut Boolean,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitGetProperty
    ///@abstract		retrieves the value of a specified property
    ///@discussion		The API can is used to retrieve the value of the property. Property values for
    ///audio units are always passed by reference
    ///
    ///@param			inUnit
    ///the audio unit
    ///@param			inID
    ///the property identifier
    ///@param			inScope
    ///the scope of the property
    ///@param			inElement
    ///the element of the scope
    ///@param			outData
    ///used to retrieve the value of the property. It should point to memory at least
    ///as large as the value described by ioDataSize
    ///@param			ioDataSize
    ///on input contains the size of the data pointed to by outData, on output, the
    ///size of the data that was returned.
    ///
    ///@result			noErr, or various audio unit errors related to properties
    pub fn AudioUnitGetProperty(
        inUnit: AudioUnit,
        inID: AudioUnitPropertyID,
        inScope: AudioUnitScope,
        inElement: AudioUnitElement,
        outData: *mut ::std::os::raw::c_void,
        ioDataSize: *mut UInt32,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitSetProperty
    ///@abstract		sets the value of a specified property
    ///@discussion		The API can is used to set the value of the property. Property values for
    ///audio units are always passed by reference
    ///
    ///@param			inUnit
    ///the audio unit
    ///@param			inID
    ///the property identifier
    ///@param			inScope
    ///the scope of the property
    ///@param			inElement
    ///the element of the scope
    ///@param			inData
    ///if not null, then is the new value for the property that will be set. If null,
    ///then inDataSize should be zero, and the call is then used to remove a
    ///previously set value for a property. This removal is only valid for
    ///some properties, as most properties will always have a default value if not
    ///set.
    ///@param			inDataSize
    ///the size of the data being provided in inData
    ///
    ///@result			noErr, or various audio unit errors related to properties
    pub fn AudioUnitSetProperty(
        inUnit: AudioUnit,
        inID: AudioUnitPropertyID,
        inScope: AudioUnitScope,
        inElement: AudioUnitElement,
        inData: *const ::std::os::raw::c_void,
        inDataSize: UInt32,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitAddPropertyListener
    ///@abstract		registration call to receive notifications for when a property changes
    ///@discussion		When an audio unit property value changes, a notification callback can be
    ///called by the audio unit to  inform interested parties that this event has
    ///occurred. The notification is defined by the tuple of inProc and
    ///inProcUserData as paired to the specified property ID, so the previously
    ///defined AudioUnitRemovePropertyListener is deprecated because it didn't allow
    ///for the provision of the inProcUserData to remove a given listener (so,
    ///you should use AudioUnitRemovePropertyListenerWithUserData).
    ///
    ///@param			inUnit
    ///the audio unit
    ///@param			inID
    ///the property identifier
    ///@param			inProc
    ///the procedure to call when the property changes (on any scope or element)
    ///@param			inProcUserData
    ///the user data to provide with the callback
    ///
    ///@result			noErr, or various audio unit errors related to properties
    pub fn AudioUnitAddPropertyListener(
        inUnit: AudioUnit,
        inID: AudioUnitPropertyID,
        inProc: AudioUnitPropertyListenerProc,
        inProcUserData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitRemovePropertyListenerWithUserData
    ///@abstract		remove a previously registered property listener
    ///@discussion		Removes a previously registered property listener as specified by the inProc
    ///and inProcUser data as paired to the property identifier
    ///
    ///@param			inUnit
    ///the audio unit
    ///@param			inID
    ///the property identifier
    ///@param			inProc
    ///the procedure previously registered
    ///@param			inProcUserData
    ///the user data paired with the provided inProc
    ///
    ///@result			noErr, or various audio unit errors related to properties
    pub fn AudioUnitRemovePropertyListenerWithUserData(
        inUnit: AudioUnit,
        inID: AudioUnitPropertyID,
        inProc: AudioUnitPropertyListenerProc,
        inProcUserData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitAddRenderNotify
    ///@abstract		a notification callback to call when an audio unit is asked to render
    ///@discussion		allows an application to register a callback with an audio unit for whenever
    ///the audio unit is asked to render. The callback is called both before the
    ///audio unit performs its render operations (the render flag's pre-render bit
    ///is set) and after the audio unit has completed its render operations (the
    ///render flag's post-render bit is set). On post-render, the audio buffer list
    ///(ioData) will contain valid audio data that was rendered by the audio unit.
    ///
    ///The inProc and inProcUserData are treated as a tuple entity, so when wanting
    ///to remove one, both the inProc and its inProcUserData must be specified
    ///
    ///@param			inUnit
    ///the audio unit
    ///@param			inProc
    ///an AURenderCallback proc
    ///@param			inProcUserData
    ///the user data that will be provided with the proc when it is called
    ///
    ///@result			noErr, or an audio unit error code
    pub fn AudioUnitAddRenderNotify(
        inUnit: AudioUnit,
        inProc: AURenderCallback,
        inProcUserData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitRemoveRenderNotify
    ///@abstract		remove a previously registered render notification proc
    ///
    ///@param			inUnit
    ///the audio unit
    ///@param			inProc
    ///an AURenderCallback proc
    ///@param			inProcUserData
    ///the user data that was provided with the proc when it was previously
    ///registered
    ///
    ///@result			noErr, or an audio unit error code
    pub fn AudioUnitRemoveRenderNotify(
        inUnit: AudioUnit,
        inProc: AURenderCallback,
        inProcUserData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitGetParameter
    ///@abstract		Get the value of a parameter
    ///@discussion		Get the value of a parameter as specified by its ID, scope and element.
    ///
    ///@param			inUnit
    ///the audio unit
    ///@param			inID
    ///the parameter ID
    ///@param			inScope
    ///the scope for the parameter
    ///@param			inElement
    ///the element on the scope for the parameter
    ///@param			outValue
    ///Must be non-null, and upon success will contain the current value for the
    ///specified parameter
    ///
    ///@result			noErr, or an audio unit error code (such as InvalidParameter)
    pub fn AudioUnitGetParameter(
        inUnit: AudioUnit,
        inID: AudioUnitParameterID,
        inScope: AudioUnitScope,
        inElement: AudioUnitElement,
        outValue: *mut AudioUnitParameterValue,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitSetParameter
    ///@abstract		Set the value of a parameter
    ///@discussion		Set the value of a parameter as specified by its ID, scope and element.
    ///Parameter IDs are consistent across all of the elements in a scope - so for a
    ///mixer, the "input volume" parameter can be applied on any input, and the
    ///particular input is specified by the elementID.
    ///
    ///@param			inUnit
    ///the audio unit
    ///@param			inID
    ///the parameter ID
    ///@param			inScope
    ///the scope for the parameter
    ///@param			inElement
    ///the element on the scope for the parameter
    ///@param			inValue
    ///the new value for the parameter.
    ///@param			inBufferOffsetInFrames
    ///generally should be set to zero - see AudioUnitScheduleParameters
    ///
    ///@result			noErr, or an audio unit error code (such as InvalidParameter)
    pub fn AudioUnitSetParameter(
        inUnit: AudioUnit,
        inID: AudioUnitParameterID,
        inScope: AudioUnitScope,
        inElement: AudioUnitElement,
        inValue: AudioUnitParameterValue,
        inBufferOffsetInFrames: UInt32,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitScheduleParameters
    ///@abstract		Schedule changes to the value of a parameter
    ///@discussion		This API is used to schedule intra-buffer changes to the value of a parameter
    ///(immediate) or to ramp a parameter from a start value to an end value for a
    ///specified number of samples (ramp)
    ///
    ///The API allows for the scheduling of multiple parameter events with the one
    ///call. All of the parameter events must apply to the current (and only apply to
    ///the current) audio unit render call, so the events are scheduled as a part of
    ///the pre-render notification callback.
    ///
    ///When scheduling an immediate parameter event, the new value at the specified
    ///sample buffer offset is provided
    ///
    ///When scheduling a ramped parameter, the ramp is scheduled each audio unit
    ///render for the duration of the ramp. Each schedule of the the new audio unit
    ///render specifies the progress of the ramp.
    ///
    ///Parameters that can have events scheduled to them will indicate this through
    ///their parameter info struct
    ///
    ///@param			inUnit
    ///the audio unit
    ///@param			inParameterEvent
    ///a pointer to an array of parameter event structs
    ///@param			inNumParamEvents
    ///the number of parameter event structs pointed to by inParameterEvent
    ///
    ///@result			noErr, or an audio unit error code (such as InvalidParameter)
    pub fn AudioUnitScheduleParameters(
        inUnit: AudioUnit,
        inParameterEvent: *const AudioUnitParameterEvent,
        inNumParamEvents: UInt32,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitRender
    ///@abstract		the render operation where ioData will contain the results of the audio unit's
    ///render operations
    ///@discussion		an audio unit will render the amount of audio data described by
    ///inNumberOfFrames and the results of that render will be contained within
    ///ioData. The caller should provide audio time stamps where at least the sample
    ///time is valid and it is incrementing sequentially from its previous call
    ///(so, the next time stamp will be the current time stamp + inNumberFrames)
    ///If the sample time is not incrementing sequentially, the audio unit will infer
    ///that there is some discontinuity with the timeline it is rendering for
    ///
    ///The caller must provide a valid ioData AudioBufferList that matches the
    ///expected topology for the current audio format for the given bus. The buffer
    ///list can be of two variants:
    ///(1) If the mData pointers are non-null then the audio unit will render its
    ///output into those buffers. These buffers should be aligned to 16 byte
    ///boundaries (which is normally what malloc will return).
    ///(2) If the mData pointers are null, then the audio unit can provide pointers
    ///to its own buffers. In this case the audio unit is required to keep those
    ///buffers valid for the duration of the calling thread's I/O cycle
    ///
    ///@param			inUnit
    ///the audio unit
    ///@param			ioActionFlags
    ///any appropriate action flags for the render operation
    ///@param			inTimeStamp
    ///the time stamp that applies to this particular render operation. when
    ///rendering for multiple output buses the time stamp will generally be the same
    ///for each output bus, so the audio unit is able to determine without doubt that
    ///this the same render operation
    ///@param			inOutputBusNumber
    ///the output bus to render for
    ///@param			inNumberFrames
    ///the number of sample frames to render
    ///@param			ioData
    ///the audio buffer list that the audio unit is to render into.
    ///
    ///@result			noErr, or an audio unit render error
    pub fn AudioUnitRender(
        inUnit: AudioUnit,
        ioActionFlags: *mut AudioUnitRenderActionFlags,
        inTimeStamp: *const AudioTimeStamp,
        inOutputBusNumber: UInt32,
        inNumberFrames: UInt32,
        ioData: *mut AudioBufferList,
    ) -> OSStatus;
}
extern "C" {
    pub fn AudioUnitProcess(
        inUnit: AudioUnit,
        ioActionFlags: *mut AudioUnitRenderActionFlags,
        inTimeStamp: *const AudioTimeStamp,
        inNumberFrames: UInt32,
        ioData: *mut AudioBufferList,
    ) -> OSStatus;
}
extern "C" {
    pub fn AudioUnitProcessMultiple(
        inUnit: AudioUnit,
        ioActionFlags: *mut AudioUnitRenderActionFlags,
        inTimeStamp: *const AudioTimeStamp,
        inNumberFrames: UInt32,
        inNumberInputBufferLists: UInt32,
        inInputBufferLists: *mut *const AudioBufferList,
        inNumberOutputBufferLists: UInt32,
        ioOutputBufferLists: *mut *mut AudioBufferList,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitReset
    ///@abstract		reset an audio unit's render state
    ///@discussion		This call will clear any render state of an audio unit. For instance, with a
    ///delay or reverb type of audio unit reset will clear any of the delay lines
    ///maintained within the audio unit. Typically, this call is made when an
    ///audio unit was previously rendering, and was taken out of the render chain
    ///(say, the track it is in was muted) and is being added back in (unmuted).
    ///The host should reset the audio unit before adding it back so that it doesn't
    ///produce audio from its delay lines that is no longer valid.
    ///
    ///The call should only clear memory, it should NOT allocate or free memory
    ///resources (this is done in the Initialize calls).
    ///
    ///@param			inUnit
    ///the audio unit
    ///@param			inScope
    ///the scope - typically this is set to GlobalScope
    ///@param			inElement
    ///the element - typically this is set to 0
    ///
    ///@result			noErr, or an audio unit error
    pub fn AudioUnitReset(
        inUnit: AudioUnit,
        inScope: AudioUnitScope,
        inElement: AudioUnitElement,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitExtensionSetComponentList
    ///@abstract		Allows the implementor of an audio unit extension to dynamically modify the
    ///list of component registrations for the extension.
    ///@param			extensionIdentifier
    ///The bundle ID of the audio unit extension.
    ///@param			audioComponentInfo
    ///An array of dictionaries, one for each component, in the same format as
    ///described in AudioComponent.h for the Info.plist key "AudioComponents".
    ///@result         An OSStatus result code.
    ///@discussion
    ///Note that the bundle ID of the process calling this API must prefix (or match)
    ///the provided extension identifier.
    pub fn AudioUnitExtensionSetComponentList(
        extensionIdentifier: CFStringRef,
        audioComponentInfo: CFArrayRef,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioUnitExtensionCopyComponentList
    ///@abstract		Returns the component registrations for a given audio unit extension.
    ///@param			extensionIdentifier
    ///The bundle ID of the audio unit extension.
    ///@result			An array of dictionaries, one for each component, in the same format as
    ///described in AudioComponent.h for the Info.plist key "AudioComponents".
    ///The caller should release this value when done with it.
    pub fn AudioUnitExtensionCopyComponentList(extensionIdentifier: CFStringRef) -> CFArrayRef;
}
pub const kAudioUnitRange: _bindgen_ty_96 = 0;
pub const kAudioUnitInitializeSelect: _bindgen_ty_96 = 1;
pub const kAudioUnitUninitializeSelect: _bindgen_ty_96 = 2;
pub const kAudioUnitGetPropertyInfoSelect: _bindgen_ty_96 = 3;
pub const kAudioUnitGetPropertySelect: _bindgen_ty_96 = 4;
pub const kAudioUnitSetPropertySelect: _bindgen_ty_96 = 5;
pub const kAudioUnitAddPropertyListenerSelect: _bindgen_ty_96 = 10;
pub const kAudioUnitRemovePropertyListenerSelect: _bindgen_ty_96 = 11;
pub const kAudioUnitRemovePropertyListenerWithUserDataSelect: _bindgen_ty_96 = 18;
pub const kAudioUnitAddRenderNotifySelect: _bindgen_ty_96 = 15;
pub const kAudioUnitRemoveRenderNotifySelect: _bindgen_ty_96 = 16;
pub const kAudioUnitGetParameterSelect: _bindgen_ty_96 = 6;
pub const kAudioUnitSetParameterSelect: _bindgen_ty_96 = 7;
pub const kAudioUnitScheduleParametersSelect: _bindgen_ty_96 = 17;
pub const kAudioUnitRenderSelect: _bindgen_ty_96 = 14;
pub const kAudioUnitResetSelect: _bindgen_ty_96 = 9;
pub const kAudioUnitComplexRenderSelect: _bindgen_ty_96 = 19;
pub const kAudioUnitProcessSelect: _bindgen_ty_96 = 20;
pub const kAudioUnitProcessMultipleSelect: _bindgen_ty_96 = 21;
///@enum			AudioUnitRange
///@discussion		the range of selectors that are used to dispatch through to the various audio
///unit API
///
///@constant		kAudioUnitRange
///@constant		kAudioUnitInitializeSelect
///@constant		kAudioUnitUninitializeSelect
///@constant		kAudioUnitGetPropertyInfoSelect
///@constant		kAudioUnitGetPropertySelect
///@constant		kAudioUnitSetPropertySelect
///@constant		kAudioUnitAddPropertyListenerSelect
///@constant		kAudioUnitRemovePropertyListenerSelect
///@constant		kAudioUnitRemovePropertyListenerWithUserDataSelect
///@constant		kAudioUnitAddRenderNotifySelect
///@constant		kAudioUnitRemoveRenderNotifySelect
///@constant		kAudioUnitGetParameterSelect
///@constant		kAudioUnitSetParameterSelect
///@constant		kAudioUnitScheduleParametersSelect
///@constant		kAudioUnitRenderSelect
///@constant		kAudioUnitResetSelect
///@constant		kAudioUnitComplexRenderSelect
///@constant		kAudioUnitProcessSelect
///@constant		kAudioUnitProcessMultipleSelect
pub type _bindgen_ty_96 = u32;
pub type AudioUnitInitializeProc =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut ::std::os::raw::c_void) -> OSStatus>;
pub type AudioUnitUninitializeProc =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut ::std::os::raw::c_void) -> OSStatus>;
pub type AudioUnitGetPropertyInfoProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        prop: AudioUnitPropertyID,
        scope: AudioUnitScope,
        elem: AudioUnitElement,
        outDataSize: *mut UInt32,
        outWritable: *mut Boolean,
    ) -> OSStatus,
>;
pub type AudioUnitGetPropertyProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        inID: AudioUnitPropertyID,
        inScope: AudioUnitScope,
        inElement: AudioUnitElement,
        outData: *mut ::std::os::raw::c_void,
        ioDataSize: *mut UInt32,
    ) -> OSStatus,
>;
pub type AudioUnitSetPropertyProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        inID: AudioUnitPropertyID,
        inScope: AudioUnitScope,
        inElement: AudioUnitElement,
        inData: *const ::std::os::raw::c_void,
        inDataSize: UInt32,
    ) -> OSStatus,
>;
pub type AudioUnitAddPropertyListenerProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        prop: AudioUnitPropertyID,
        proc_: AudioUnitPropertyListenerProc,
        userData: *mut ::std::os::raw::c_void,
    ) -> OSStatus,
>;
pub type AudioUnitRemovePropertyListenerProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        prop: AudioUnitPropertyID,
        proc_: AudioUnitPropertyListenerProc,
    ) -> OSStatus,
>;
pub type AudioUnitRemovePropertyListenerWithUserDataProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        prop: AudioUnitPropertyID,
        proc_: AudioUnitPropertyListenerProc,
        userData: *mut ::std::os::raw::c_void,
    ) -> OSStatus,
>;
pub type AudioUnitAddRenderNotifyProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        proc_: AURenderCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OSStatus,
>;
pub type AudioUnitRemoveRenderNotifyProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        proc_: AURenderCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> OSStatus,
>;
pub type AudioUnitScheduleParametersProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        events: *const AudioUnitParameterEvent,
        numEvents: UInt32,
    ) -> OSStatus,
>;
pub type AudioUnitResetProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        inScope: AudioUnitScope,
        inElement: AudioUnitElement,
    ) -> OSStatus,
>;
pub type AudioUnitComplexRenderProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        ioActionFlags: *mut AudioUnitRenderActionFlags,
        inTimeStamp: *const AudioTimeStamp,
        inOutputBusNumber: UInt32,
        inNumberOfPackets: UInt32,
        outNumberOfPackets: *mut UInt32,
        outPacketDescriptions: *mut AudioStreamPacketDescription,
        ioData: *mut AudioBufferList,
        outMetadata: *mut ::std::os::raw::c_void,
        outMetadataByteSize: *mut UInt32,
    ) -> OSStatus,
>;
pub type AudioUnitProcessProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        ioActionFlags: *mut AudioUnitRenderActionFlags,
        inTimeStamp: *const AudioTimeStamp,
        inNumberFrames: UInt32,
        ioData: *mut AudioBufferList,
    ) -> OSStatus,
>;
pub type AudioUnitProcessMultipleProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        ioActionFlags: *mut AudioUnitRenderActionFlags,
        inTimeStamp: *const AudioTimeStamp,
        inNumberFrames: UInt32,
        inNumberInputBufferLists: UInt32,
        inInputBufferLists: *mut *const AudioBufferList,
        inNumberOutputBufferLists: UInt32,
        ioOutputBufferLists: *mut *mut AudioBufferList,
    ) -> OSStatus,
>;
///@typedef		AudioUnitGetParameterProc
///@discussion		This proc can be exported through the FastDispatch property or is used as the prototype for
///an audio component dispatch for this selector.
///
///The arguments are the same as are provided to the corresponding API call
///
///@param			inComponentStorage
///For a component manager component, this is the component instance storage
///pointer
///@param			inID
///@param			inScope
///@param			inElement
///@param			outValue
pub type AudioUnitGetParameterProc = ::std::option::Option<
    unsafe extern "C" fn(
        inComponentStorage: *mut ::std::os::raw::c_void,
        inID: AudioUnitParameterID,
        inScope: AudioUnitScope,
        inElement: AudioUnitElement,
        outValue: *mut AudioUnitParameterValue,
    ) -> OSStatus,
>;
///@typedef		AudioUnitSetParameterProc
///@discussion		This proc can be exported through the FastDispatch property or is used as the prototype for
///an audio component dispatch for this selector.
///
///The arguments are the same as are provided to the corresponding API call
///
///@param			inComponentStorage
///For a component manager component, this is the component instance storage
///pointer
///@param			inID
///@param			inScope
///@param			inElement
///@param			inValue
///@param			inBufferOffsetInFrames
pub type AudioUnitSetParameterProc = ::std::option::Option<
    unsafe extern "C" fn(
        inComponentStorage: *mut ::std::os::raw::c_void,
        inID: AudioUnitParameterID,
        inScope: AudioUnitScope,
        inElement: AudioUnitElement,
        inValue: AudioUnitParameterValue,
        inBufferOffsetInFrames: UInt32,
    ) -> OSStatus,
>;
///@typedef		AudioUnitRenderProc
///@discussion		This proc can be exported through the FastDispatch property or is used as the prototype for
///an audio component dispatch for this selector.
///
///The arguments are the same as are provided to the corresponding API call
///
///@param			inComponentStorage
///For a component manager component, this is the component instance storage
///pointer
///@param			ioActionFlags
///@param			inTimeStamp
///@param			inOutputBusNumber
///@param			inNumberFrames
///@param			ioData
pub type AudioUnitRenderProc = ::std::option::Option<
    unsafe extern "C" fn(
        inComponentStorage: *mut ::std::os::raw::c_void,
        ioActionFlags: *mut AudioUnitRenderActionFlags,
        inTimeStamp: *const AudioTimeStamp,
        inOutputBusNumber: UInt32,
        inNumberFrames: UInt32,
        ioData: *mut AudioBufferList,
    ) -> OSStatus,
>;
pub const kAudioUnitErr_IllegalInstrument: _bindgen_ty_97 = -10873;
pub const kAudioUnitErr_InstrumentTypeNotFound: _bindgen_ty_97 = -10872;
pub type _bindgen_ty_97 = i32;
extern "C" {
    pub fn AudioOutputUnitStart(ci: AudioUnit) -> OSStatus;
}
extern "C" {
    pub fn AudioOutputUnitStop(ci: AudioUnit) -> OSStatus;
}
pub const kAudioOutputUnitRange: _bindgen_ty_98 = 512;
pub const kAudioOutputUnitStartSelect: _bindgen_ty_98 = 513;
pub const kAudioOutputUnitStopSelect: _bindgen_ty_98 = 514;
pub type _bindgen_ty_98 = u32;

pub type AudioOutputUnitStartProc =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut ::std::os::raw::c_void) -> OSStatus>;

pub type AudioOutputUnitStopProc =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut ::std::os::raw::c_void) -> OSStatus>;
pub const kAudioUnitScope_Global: _bindgen_ty_99 = 0;
pub const kAudioUnitScope_Input: _bindgen_ty_99 = 1;
pub const kAudioUnitScope_Output: _bindgen_ty_99 = 2;
pub const kAudioUnitScope_Group: _bindgen_ty_99 = 3;
pub const kAudioUnitScope_Part: _bindgen_ty_99 = 4;
pub const kAudioUnitScope_Note: _bindgen_ty_99 = 5;
pub const kAudioUnitScope_Layer: _bindgen_ty_99 = 6;
pub const kAudioUnitScope_LayerItem: _bindgen_ty_99 = 7;
pub type _bindgen_ty_99 = u32;
pub const kAudioUnitProperty_ClassInfo: _bindgen_ty_100 = 0;
pub const kAudioUnitProperty_MakeConnection: _bindgen_ty_100 = 1;
pub const kAudioUnitProperty_SampleRate: _bindgen_ty_100 = 2;
pub const kAudioUnitProperty_ParameterList: _bindgen_ty_100 = 3;
pub const kAudioUnitProperty_ParameterInfo: _bindgen_ty_100 = 4;
pub const kAudioUnitProperty_CPULoad: _bindgen_ty_100 = 6;
pub const kAudioUnitProperty_StreamFormat: _bindgen_ty_100 = 8;
pub const kAudioUnitProperty_ElementCount: _bindgen_ty_100 = 11;
pub const kAudioUnitProperty_Latency: _bindgen_ty_100 = 12;
pub const kAudioUnitProperty_SupportedNumChannels: _bindgen_ty_100 = 13;
pub const kAudioUnitProperty_MaximumFramesPerSlice: _bindgen_ty_100 = 14;
pub const kAudioUnitProperty_ParameterValueStrings: _bindgen_ty_100 = 16;
pub const kAudioUnitProperty_AudioChannelLayout: _bindgen_ty_100 = 19;
pub const kAudioUnitProperty_TailTime: _bindgen_ty_100 = 20;
pub const kAudioUnitProperty_BypassEffect: _bindgen_ty_100 = 21;
pub const kAudioUnitProperty_LastRenderError: _bindgen_ty_100 = 22;
pub const kAudioUnitProperty_SetRenderCallback: _bindgen_ty_100 = 23;
pub const kAudioUnitProperty_FactoryPresets: _bindgen_ty_100 = 24;
pub const kAudioUnitProperty_RenderQuality: _bindgen_ty_100 = 26;
pub const kAudioUnitProperty_HostCallbacks: _bindgen_ty_100 = 27;
pub const kAudioUnitProperty_InPlaceProcessing: _bindgen_ty_100 = 29;
pub const kAudioUnitProperty_ElementName: _bindgen_ty_100 = 30;
pub const kAudioUnitProperty_SupportedChannelLayoutTags: _bindgen_ty_100 = 32;
pub const kAudioUnitProperty_PresentPreset: _bindgen_ty_100 = 36;
pub const kAudioUnitProperty_DependentParameters: _bindgen_ty_100 = 45;
pub const kAudioUnitProperty_InputSamplesInOutput: _bindgen_ty_100 = 49;
pub const kAudioUnitProperty_ShouldAllocateBuffer: _bindgen_ty_100 = 51;
pub const kAudioUnitProperty_FrequencyResponse: _bindgen_ty_100 = 52;
pub const kAudioUnitProperty_ParameterHistoryInfo: _bindgen_ty_100 = 53;
pub const kAudioUnitProperty_NickName: _bindgen_ty_100 = 54;
pub const kAudioUnitProperty_OfflineRender: _bindgen_ty_100 = 37;
pub const kAudioUnitProperty_ParameterIDName: _bindgen_ty_100 = 34;
pub const kAudioUnitProperty_ParameterStringFromValue: _bindgen_ty_100 = 33;
pub const kAudioUnitProperty_ParameterClumpName: _bindgen_ty_100 = 35;
pub const kAudioUnitProperty_ParameterValueFromString: _bindgen_ty_100 = 38;
pub const kAudioUnitProperty_ContextName: _bindgen_ty_100 = 25;
pub const kAudioUnitProperty_PresentationLatency: _bindgen_ty_100 = 40;
pub const kAudioUnitProperty_ClassInfoFromDocument: _bindgen_ty_100 = 50;
pub const kAudioUnitProperty_RequestViewController: _bindgen_ty_100 = 56;
pub const kAudioUnitProperty_ParametersForOverview: _bindgen_ty_100 = 57;
pub const kAudioUnitProperty_SupportsMPE: _bindgen_ty_100 = 58;
pub const kAudioUnitProperty_FastDispatch: _bindgen_ty_100 = 5;
pub const kAudioUnitProperty_SetExternalBuffer: _bindgen_ty_100 = 15;
pub const kAudioUnitProperty_GetUIComponentList: _bindgen_ty_100 = 18;
pub const kAudioUnitProperty_CocoaUI: _bindgen_ty_100 = 31;
pub const kAudioUnitProperty_IconLocation: _bindgen_ty_100 = 39;
pub const kAudioUnitProperty_AUHostIdentifier: _bindgen_ty_100 = 46;
pub const kAudioUnitProperty_MIDIOutputCallbackInfo: _bindgen_ty_100 = 47;
pub const kAudioUnitProperty_MIDIOutputCallback: _bindgen_ty_100 = 48;
pub type _bindgen_ty_100 = u32;
///@struct         AudioUnitConnection
///@abstract       This structure contains the information needed to make a connection between a source
///and destination audio unit.
///@discussion		The structure is set on the destination audio unit's input element
///@field          sourceAudioUnit
///The audio unit that is the source for the connection
///@field          sourceOutputNumber
///The source audio unit's output element to be used in the connection
///@field          destInputNumber
///The destination audio unit's input element to be used in the connection
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioUnitConnection {
    pub sourceAudioUnit: AudioUnit,
    pub sourceOutputNumber: UInt32,
    pub destInputNumber: UInt32,
}
#[test]
fn bindgen_test_layout_AudioUnitConnection() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitConnection>(),
        16usize,
        concat!("Size of: ", stringify!(AudioUnitConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioUnitConnection))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitConnection>())).sourceAudioUnit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitConnection),
            "::",
            stringify!(sourceAudioUnit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitConnection>())).sourceOutputNumber as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitConnection),
            "::",
            stringify!(sourceOutputNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitConnection>())).destInputNumber as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitConnection),
            "::",
            stringify!(destInputNumber)
        )
    );
}
impl Default for AudioUnitConnection {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@struct			AUChannelInfo
///@abstract		Define an audio unit's channel handling capabilities
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AUChannelInfo {
    pub inChannels: SInt16,
    pub outChannels: SInt16,
}
#[test]
fn bindgen_test_layout_AUChannelInfo() {
    assert_eq!(
        ::std::mem::size_of::<AUChannelInfo>(),
        4usize,
        concat!("Size of: ", stringify!(AUChannelInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AUChannelInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(AUChannelInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUChannelInfo>())).inChannels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUChannelInfo),
            "::",
            stringify!(inChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUChannelInfo>())).outChannels as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AUChannelInfo),
            "::",
            stringify!(outChannels)
        )
    );
}
///@struct			AudioUnitExternalBuffer
///@abstract		Allow a host to tell an audio unit to use the provided memory for its input callback
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioUnitExternalBuffer {
    pub buffer: *mut Byte,
    pub size: UInt32,
}
#[test]
fn bindgen_test_layout_AudioUnitExternalBuffer() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitExternalBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(AudioUnitExternalBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitExternalBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioUnitExternalBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitExternalBuffer>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitExternalBuffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitExternalBuffer>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitExternalBuffer),
            "::",
            stringify!(size)
        )
    );
}
impl Default for AudioUnitExternalBuffer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@struct			AURenderCallbackStruct
///@abstract		Used by a host when registering a callback with the audio unit to provide input
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AURenderCallbackStruct {
    pub inputProc: AURenderCallback,
    pub inputProcRefCon: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AURenderCallbackStruct() {
    assert_eq!(
        ::std::mem::size_of::<AURenderCallbackStruct>(),
        16usize,
        concat!("Size of: ", stringify!(AURenderCallbackStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<AURenderCallbackStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(AURenderCallbackStruct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AURenderCallbackStruct>())).inputProc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AURenderCallbackStruct),
            "::",
            stringify!(inputProc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AURenderCallbackStruct>())).inputProcRefCon as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AURenderCallbackStruct),
            "::",
            stringify!(inputProcRefCon)
        )
    );
}
impl Default for AURenderCallbackStruct {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@struct			AUPreset
///@abstract		Used to publish and set factory presets on an audio unit
///@field			presetNumber
///If < 0, then preset is a user preset
///If >= 0, then this field is used to select the factory preset
///@field			presetName
///If a factory preset, the name of the specified factory preset
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUPreset {
    pub presetNumber: SInt32,
    pub presetName: CFStringRef,
}
#[test]
fn bindgen_test_layout_AUPreset() {
    assert_eq!(
        ::std::mem::size_of::<AUPreset>(),
        16usize,
        concat!("Size of: ", stringify!(AUPreset))
    );
    assert_eq!(
        ::std::mem::align_of::<AUPreset>(),
        8usize,
        concat!("Alignment of ", stringify!(AUPreset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUPreset>())).presetNumber as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUPreset),
            "::",
            stringify!(presetNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUPreset>())).presetName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AUPreset),
            "::",
            stringify!(presetName)
        )
    );
}
impl Default for AUPreset {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const kRenderQuality_Max: _bindgen_ty_101 = 127;
pub const kRenderQuality_High: _bindgen_ty_101 = 96;
pub const kRenderQuality_Medium: _bindgen_ty_101 = 64;
pub const kRenderQuality_Low: _bindgen_ty_101 = 32;
pub const kRenderQuality_Min: _bindgen_ty_101 = 0;
///@enum			RenderQuality
///@abstract		Used to get/set a render quality setting on an audio unit
///@discussion		Typically, this property is used to trade-off between CPU usage, latency
///and the quality of the audio unit's processing/output.
pub type _bindgen_ty_101 = u32;
pub const kNumberOfResponseFrequencies: _bindgen_ty_102 = 1024;
///@enum			kNumberOfResponseFrequencies
///@abstract		The maximum number of frequency response bins for kAudioUnitProperty_FrequencyResponse.
///@discussion		An array of AudioUnitFrequencyResponseBin are passed in to kAudioUnitProperty_FrequencyResponse
///with the mFrequency field filled in. The array is returned with the mMagnitude fields filled in.
///If fewer than kNumberOfResponseFrequencies are needed, then the first unused bin should be marked with
///a negative frequency.
pub type _bindgen_ty_102 = u32;
///@struct			AudioUnitFrequencyResponseBin
///@abstract		Structure used to get the magnitude of the frequency response at a particular frequency via kAudioUnitProperty_FrequencyResponse.
///@discussion		An array of AudioUnitFrequencyResponseBin are passed in to kAudioUnitProperty_FrequencyResponse
///with the mFrequency field filled in. The array is returned with the mMagnitude fields filled in.
///If fewer than kNumberOfResponseFrequencies are needed, then the first unused bin should be marked with
///a negative frequency.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioUnitFrequencyResponseBin {
    pub mFrequency: Float64,
    pub mMagnitude: Float64,
}
#[test]
fn bindgen_test_layout_AudioUnitFrequencyResponseBin() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitFrequencyResponseBin>(),
        16usize,
        concat!("Size of: ", stringify!(AudioUnitFrequencyResponseBin))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitFrequencyResponseBin>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioUnitFrequencyResponseBin))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitFrequencyResponseBin>())).mFrequency as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitFrequencyResponseBin),
            "::",
            stringify!(mFrequency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitFrequencyResponseBin>())).mMagnitude as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitFrequencyResponseBin),
            "::",
            stringify!(mMagnitude)
        )
    );
}
///@typedef		HostCallback_GetBeatAndTempo
///@abstract		Retrieve information about the current beat and/or tempo
///@discussion
///If the host app has set this callback, then the audio unit can use this to get the current
///beat and tempo as they relate to the first sample in the render buffer. The audio unit can
///call this callback only from within the audio unit render call (otherwise the host is unable
///to provide information accurately to the audio unit as the information obtained is relate to
///the current AudioUnitRender call). If the host cannot provide the requested information, it
///will return kAudioUnitErr_CannotDoInCurrentContext.
///
///The AudioUnit can provide NULL for any of the requested parameters (except for
///inHostUserData) if it is not interested in that particular piece of information
///
///@param			inHostUserData			Must be provided by the audio unit when it makes this call. It is the client data provided by the host when it set the HostCallbacks property
///@param			outCurrentBeat			The current beat, where 0 is the first beat. Tempo is defined as the number of whole-number (integer) beat values (as indicated by the outCurrentBeat field) per minute.
///@param			outCurrentTempo			The current tempo
pub type HostCallback_GetBeatAndTempo = ::std::option::Option<
    unsafe extern "C" fn(
        inHostUserData: *mut ::std::os::raw::c_void,
        outCurrentBeat: *mut Float64,
        outCurrentTempo: *mut Float64,
    ) -> OSStatus,
>;
///@typedef		HostCallback_GetMusicalTimeLocation
///@abstract		Retrieve information about the musical time state of the host
///@discussion
///If the host app has set this callback, then the audio unit can use this to obtain
///information about the state of musical time in the host. The audio unit can call this
///callback only from within the audio unit render call (otherwise the host is unable to
///provide information accurately to the audio unit as the information obtained is relate to
///the current AudioUnitRender call). If the host cannot provide the requested information, it
///will return kAudioUnitErr_CannotDoInCurrentContext.
///
///The AudioUnit can provide NULL for any of the requested parameters (except for
///inHostUserData) if it is not interested in that particular piece of information
///
///@param			inHostUserData					Must be provided by the audio unit when it makes this call. It is the client data provided by the host when it set the HostCallbacks property
///@param			outDeltaSampleOffsetToNextBeat	The number of samples until the next whole beat from the start sample of the current rendering buffer
///@param			outTimeSig_Numerator			The Numerator of the current time signature
///@param			outTimeSig_Denominator			The Denominator of the current time signature (4 is a quarter note, etc)
///@param			outCurrentMeasureDownBeat		The beat that corresponds to the downbeat (first beat) of the current measure that is being rendered
pub type HostCallback_GetMusicalTimeLocation = ::std::option::Option<
    unsafe extern "C" fn(
        inHostUserData: *mut ::std::os::raw::c_void,
        outDeltaSampleOffsetToNextBeat: *mut UInt32,
        outTimeSig_Numerator: *mut Float32,
        outTimeSig_Denominator: *mut UInt32,
        outCurrentMeasureDownBeat: *mut Float64,
    ) -> OSStatus,
>;
///@typedef		HostCallback_GetTransportState
///@abstract		Retrieve information about the time line's (or transport) state of the host.
///@discussion
///If the host app has set this callback, then the audio unit can use this to obtain
///information about the transport state of the host's time line. The audio unit can call this
///callback only from within the audio unit render call (otherwise the host is unable to
///provide information accurately to the audio unit as the information obtained is relate to
///the current AudioUnitRender call. If the host cannot provide the requested information, it
///will return kAudioUnitErr_CannotDoInCurrentContext.
///
///The AudioUnit can provide NULL for any of the requested parameters (except for
///inHostUserData) if it is not interested in that particular piece of information
///
///@param			inHostUserData					Must be provided by the audio unit when it makes this call. It is the client data provided by the host when it set the HostCallbacks property
///@param			outIsPlaying					Returns true if the host's transport is currently playing, false if stopped
///@param			outTransportStateChanged		Returns true if there was a change to the state of, or discontinuities in, the host's transport (generally since the callback was last called). Can indicate such state changes as start/top, time moves (jump from one time line to another).
///@param			outCurrentSampleInTimeLine		Returns the current sample count in the time line of the host's transport time.
///@param			outIsCycling					Returns true if the host's transport is currently cycling or looping
///@param			outCycleStartBeat				If cycling is true, the start beat of the cycle or loop point in the host's transport
///@param			outCycleEndBeat					If cycling is true, the end beat of the cycle or loop point in the host's transport
pub type HostCallback_GetTransportState = ::std::option::Option<
    unsafe extern "C" fn(
        inHostUserData: *mut ::std::os::raw::c_void,
        outIsPlaying: *mut Boolean,
        outTransportStateChanged: *mut Boolean,
        outCurrentSampleInTimeLine: *mut Float64,
        outIsCycling: *mut Boolean,
        outCycleStartBeat: *mut Float64,
        outCycleEndBeat: *mut Float64,
    ) -> OSStatus,
>;
///@typedef		HostCallback_GetTransportState2
///@abstract		Retrieve information about the time line's (or transport) state of the host.
///@discussion
///If the host app has set this callback, then the audio unit can use this to obtain
///information about the transport state of the host's time line. The audio unit can call this
///callback only from within the audio unit render call (otherwise the host is unable to
///provide information accurately to the audio unit as the information obtained is relate to
///the current AudioUnitRender call. If the host cannot provide the requested information, it
///will return kAudioUnitErr_CannotDoInCurrentContext.
///
///The AudioUnit can provide NULL for any of the requested parameters (except for
///inHostUserData) if it is not interested in that particular piece of information
///
///@param			inHostUserData					Must be provided by the audio unit when it makes this call. It is the client data provided by the host when it set the HostCallbacks property
///@param			outIsPlaying					Returns true if the host's transport is currently playing, false if stopped
///@param			outIsRecording					Returns true if the host is currently record-enabled, otherwise false.
///@param			outTransportStateChanged		Returns true if there was a change to the state of, or discontinuities in, the host's transport (generally since the callback was last called). Can indicate such state changes as start/top, time moves (jump from one time line to another).
///@param			outCurrentSampleInTimeLine		Returns the current sample count in the time line of the host's transport time.
///@param			outIsCycling					Returns true if the host's transport is currently cycling or looping
///@param			outCycleStartBeat				If cycling is true, the start beat of the cycle or loop point in the host's transport
///@param			outCycleEndBeat					If cycling is true, the end beat of the cycle or loop point in the host's transport
pub type HostCallback_GetTransportState2 = ::std::option::Option<
    unsafe extern "C" fn(
        inHostUserData: *mut ::std::os::raw::c_void,
        outIsPlaying: *mut Boolean,
        outIsRecording: *mut Boolean,
        outTransportStateChanged: *mut Boolean,
        outCurrentSampleInTimeLine: *mut Float64,
        outIsCycling: *mut Boolean,
        outCycleStartBeat: *mut Float64,
        outCycleEndBeat: *mut Float64,
    ) -> OSStatus,
>;
///@struct			HostCallbackInfo
///@abstract		Contains the various callbacks for an audio unit to call
///@discussion
///Any callback can be NULL.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HostCallbackInfo {
    pub hostUserData: *mut ::std::os::raw::c_void,
    pub beatAndTempoProc: HostCallback_GetBeatAndTempo,
    pub musicalTimeLocationProc: HostCallback_GetMusicalTimeLocation,
    pub transportStateProc: HostCallback_GetTransportState,
    pub transportStateProc2: HostCallback_GetTransportState2,
}
#[test]
fn bindgen_test_layout_HostCallbackInfo() {
    assert_eq!(
        ::std::mem::size_of::<HostCallbackInfo>(),
        40usize,
        concat!("Size of: ", stringify!(HostCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<HostCallbackInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(HostCallbackInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HostCallbackInfo>())).hostUserData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HostCallbackInfo),
            "::",
            stringify!(hostUserData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HostCallbackInfo>())).beatAndTempoProc as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HostCallbackInfo),
            "::",
            stringify!(beatAndTempoProc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HostCallbackInfo>())).musicalTimeLocationProc as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HostCallbackInfo),
            "::",
            stringify!(musicalTimeLocationProc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HostCallbackInfo>())).transportStateProc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HostCallbackInfo),
            "::",
            stringify!(transportStateProc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HostCallbackInfo>())).transportStateProc2 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HostCallbackInfo),
            "::",
            stringify!(transportStateProc2)
        )
    );
}
impl Default for HostCallbackInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@struct			AUDependentParameter
///@abstract		Used to represent a dependent parameter that can change as a result of its parent meta-parameter
///changing
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AUDependentParameter {
    pub mScope: AudioUnitScope,
    pub mParameterID: AudioUnitParameterID,
}
#[test]
fn bindgen_test_layout_AUDependentParameter() {
    assert_eq!(
        ::std::mem::size_of::<AUDependentParameter>(),
        8usize,
        concat!("Size of: ", stringify!(AUDependentParameter))
    );
    assert_eq!(
        ::std::mem::align_of::<AUDependentParameter>(),
        4usize,
        concat!("Alignment of ", stringify!(AUDependentParameter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUDependentParameter>())).mScope as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUDependentParameter),
            "::",
            stringify!(mScope)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUDependentParameter>())).mParameterID as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AUDependentParameter),
            "::",
            stringify!(mParameterID)
        )
    );
}
///@struct			AudioUnitCocoaViewInfo
///@abstract		The location and class name of one or more view factory objects an Audio Unit publishes
///@field			mCocoaAUViewBundleLocation
///Contains the location of the bundle which the host app can then use to locate the bundle
///@field			mCocoaAUViewClass
///Contains the names of the classes that implements the required protocol (AUCocoaUIBase). This class is a view factory that creates the NSView object that is the AudioUnit view.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioUnitCocoaViewInfo {
    pub mCocoaAUViewBundleLocation: CFURLRef,
    pub mCocoaAUViewClass: [CFStringRef; 1usize],
}
#[test]
fn bindgen_test_layout_AudioUnitCocoaViewInfo() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitCocoaViewInfo>(),
        16usize,
        concat!("Size of: ", stringify!(AudioUnitCocoaViewInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitCocoaViewInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioUnitCocoaViewInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitCocoaViewInfo>())).mCocoaAUViewBundleLocation
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitCocoaViewInfo),
            "::",
            stringify!(mCocoaAUViewBundleLocation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitCocoaViewInfo>())).mCocoaAUViewClass as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitCocoaViewInfo),
            "::",
            stringify!(mCocoaAUViewClass)
        )
    );
}
impl Default for AudioUnitCocoaViewInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@struct			AUHostVersionIdentifier
///@abstract		Used to describe the name and version of the audio unit's host
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUHostVersionIdentifier {
    pub hostName: CFStringRef,
    pub hostVersion: UInt32,
}
#[test]
fn bindgen_test_layout_AUHostVersionIdentifier() {
    assert_eq!(
        ::std::mem::size_of::<AUHostVersionIdentifier>(),
        16usize,
        concat!("Size of: ", stringify!(AUHostVersionIdentifier))
    );
    assert_eq!(
        ::std::mem::align_of::<AUHostVersionIdentifier>(),
        8usize,
        concat!("Alignment of ", stringify!(AUHostVersionIdentifier))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUHostVersionIdentifier>())).hostName as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUHostVersionIdentifier),
            "::",
            stringify!(hostName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUHostVersionIdentifier>())).hostVersion as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AUHostVersionIdentifier),
            "::",
            stringify!(hostVersion)
        )
    );
}
impl Default for AUHostVersionIdentifier {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@struct			MIDIPacketList
///@abstract		Forward declaration of MIDIPacketList found in <CoreMIDI/MIDIServices.h>
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MIDIPacketList {
    _unused: [u8; 0],
}
pub type AUMIDIOutputCallback = ::std::option::Option<
    unsafe extern "C" fn(
        userData: *mut ::std::os::raw::c_void,
        timeStamp: *const AudioTimeStamp,
        midiOutNum: UInt32,
        pktlist: *const MIDIPacketList,
    ) -> OSStatus,
>;
///@struct			AUMIDIOutputCallbackStruct
///@abstract		Set by host application to provide the callback and user data for an audio
///unit that provides MIDI output
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUMIDIOutputCallbackStruct {
    pub midiOutputCallback: AUMIDIOutputCallback,
    pub userData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AUMIDIOutputCallbackStruct() {
    assert_eq!(
        ::std::mem::size_of::<AUMIDIOutputCallbackStruct>(),
        16usize,
        concat!("Size of: ", stringify!(AUMIDIOutputCallbackStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<AUMIDIOutputCallbackStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(AUMIDIOutputCallbackStruct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUMIDIOutputCallbackStruct>())).midiOutputCallback as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUMIDIOutputCallbackStruct),
            "::",
            stringify!(midiOutputCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUMIDIOutputCallbackStruct>())).userData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AUMIDIOutputCallbackStruct),
            "::",
            stringify!(userData)
        )
    );
}
impl Default for AUMIDIOutputCallbackStruct {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@struct			AUInputSamplesInOutputCallbackStruct
///@abstract		Used by a host when registering a callback with an audio unit, to provide
///input-to-output samples mapping
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUInputSamplesInOutputCallbackStruct {
    pub inputToOutputCallback: AUInputSamplesInOutputCallback,
    pub userData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AUInputSamplesInOutputCallbackStruct() {
    assert_eq!(
        ::std::mem::size_of::<AUInputSamplesInOutputCallbackStruct>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(AUInputSamplesInOutputCallbackStruct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AUInputSamplesInOutputCallbackStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AUInputSamplesInOutputCallbackStruct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUInputSamplesInOutputCallbackStruct>())).inputToOutputCallback
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUInputSamplesInOutputCallbackStruct),
            "::",
            stringify!(inputToOutputCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUInputSamplesInOutputCallbackStruct>())).userData as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AUInputSamplesInOutputCallbackStruct),
            "::",
            stringify!(userData)
        )
    );
}
impl Default for AUInputSamplesInOutputCallbackStruct {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@struct			AudioUnitParameterHistoryInfo
///@abstract		This structure contains the suggested update rate and history duration for parameters which have the kAudioUnitParameterFlag_PlotHistory flag set.
///The structure is filled out by getting kAudioUnitProperty_ParameterHistoryInfo.
///@field			updatesPerSecond
///This is the number of times per second that it is suggested that the host get the value of this parameter.
///@field			historyDurationInSeconds
///This is the duration in seconds of history that should be plotted.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioUnitParameterHistoryInfo {
    pub updatesPerSecond: Float32,
    pub historyDurationInSeconds: Float32,
}
#[test]
fn bindgen_test_layout_AudioUnitParameterHistoryInfo() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitParameterHistoryInfo>(),
        8usize,
        concat!("Size of: ", stringify!(AudioUnitParameterHistoryInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitParameterHistoryInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioUnitParameterHistoryInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterHistoryInfo>())).updatesPerSecond as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterHistoryInfo),
            "::",
            stringify!(updatesPerSecond)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterHistoryInfo>())).historyDurationInSeconds
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterHistoryInfo),
            "::",
            stringify!(historyDurationInSeconds)
        )
    );
}
///@enum			AudioUnitParameterUnit
///@constant		kAudioUnitParameterUnit_Generic
///untyped value generally between 0.0 and 1.0
///@constant		kAudioUnitParameterUnit_Indexed
///takes an integer value (good for menu selections)
///@constant		kAudioUnitParameterUnit_Boolean
///0.0 means FALSE, non-zero means TRUE
///@constant		kAudioUnitParameterUnit_Percent
///usually from 0 -> 100, sometimes -50 -> +50
///@constant		kAudioUnitParameterUnit_Seconds
///absolute or relative time
///@constant		kAudioUnitParameterUnit_SampleFrames
///one sample frame equals (1.0/sampleRate) seconds
///@constant		kAudioUnitParameterUnit_Phase
///-180 to 180 degrees
///@constant		kAudioUnitParameterUnit_Rate
///rate multiplier, for playback speed, etc. (e.g. 2.0 == twice as fast)
///@constant		kAudioUnitParameterUnit_Hertz
///absolute frequency/pitch in cycles/second
///@constant		kAudioUnitParameterUnit_Cents
///unit of relative pitch
///@constant		kAudioUnitParameterUnit_RelativeSemiTones
///useful for coarse detuning
///@constant		kAudioUnitParameterUnit_MIDINoteNumber
///absolute pitch as defined in the MIDI spec (exact freq may depend on tuning table)
///@constant		kAudioUnitParameterUnit_MIDIController
///a generic MIDI controller value from 0 -> 127
///@constant		kAudioUnitParameterUnit_Decibels
///logarithmic relative gain
///@constant		kAudioUnitParameterUnit_LinearGain
///linear relative gain
///@constant		kAudioUnitParameterUnit_Degrees
///-180 to 180 degrees, similar to phase but more general (good for 3D coord system)
///@constant		kAudioUnitParameterUnit_EqualPowerCrossfade
///0 -> 100, crossfade mix two sources according to sqrt(x) and sqrt(1.0 - x)
///@constant		kAudioUnitParameterUnit_MixerFaderCurve1
///0.0 -> 1.0, pow(x, 3.0) -> linear gain to simulate a reasonable mixer channel fader response
///@constant		kAudioUnitParameterUnit_Pan
///standard left to right mixer pan
///@constant		kAudioUnitParameterUnit_Meters
///distance measured in meters
///@constant		kAudioUnitParameterUnit_AbsoluteCents
///absolute frequency measurement :
///if f is freq in hertz then absoluteCents = 1200 * log2(f / 440) + 6900
///@constant		kAudioUnitParameterUnit_Octaves
///octaves in relative pitch where a value of 1 is equal to 1200 cents
///@constant		kAudioUnitParameterUnit_BPM
///beats per minute, ie tempo
///@constant		kAudioUnitParameterUnit_Beats
///time relative to tempo, i.e., 1.0 at 120 BPM would equal 1/2 a second
///@constant		kAudioUnitParameterUnit_Milliseconds
///parameter is expressed in milliseconds
///@constant		kAudioUnitParameterUnit_Ratio
///for compression, expansion ratio, etc.
///@constant		kAudioUnitParameterUnit_CustomUnit
///this is the parameter unit type for parameters that present a custom unit name
pub type AudioUnitParameterUnit = UInt32;
pub const kAudioUnitParameterUnit_Generic: _bindgen_ty_103 = 0;
pub const kAudioUnitParameterUnit_Indexed: _bindgen_ty_103 = 1;
pub const kAudioUnitParameterUnit_Boolean: _bindgen_ty_103 = 2;
pub const kAudioUnitParameterUnit_Percent: _bindgen_ty_103 = 3;
pub const kAudioUnitParameterUnit_Seconds: _bindgen_ty_103 = 4;
pub const kAudioUnitParameterUnit_SampleFrames: _bindgen_ty_103 = 5;
pub const kAudioUnitParameterUnit_Phase: _bindgen_ty_103 = 6;
pub const kAudioUnitParameterUnit_Rate: _bindgen_ty_103 = 7;
pub const kAudioUnitParameterUnit_Hertz: _bindgen_ty_103 = 8;
pub const kAudioUnitParameterUnit_Cents: _bindgen_ty_103 = 9;
pub const kAudioUnitParameterUnit_RelativeSemiTones: _bindgen_ty_103 = 10;
pub const kAudioUnitParameterUnit_MIDINoteNumber: _bindgen_ty_103 = 11;
pub const kAudioUnitParameterUnit_MIDIController: _bindgen_ty_103 = 12;
pub const kAudioUnitParameterUnit_Decibels: _bindgen_ty_103 = 13;
pub const kAudioUnitParameterUnit_LinearGain: _bindgen_ty_103 = 14;
pub const kAudioUnitParameterUnit_Degrees: _bindgen_ty_103 = 15;
pub const kAudioUnitParameterUnit_EqualPowerCrossfade: _bindgen_ty_103 = 16;
pub const kAudioUnitParameterUnit_MixerFaderCurve1: _bindgen_ty_103 = 17;
pub const kAudioUnitParameterUnit_Pan: _bindgen_ty_103 = 18;
pub const kAudioUnitParameterUnit_Meters: _bindgen_ty_103 = 19;
pub const kAudioUnitParameterUnit_AbsoluteCents: _bindgen_ty_103 = 20;
pub const kAudioUnitParameterUnit_Octaves: _bindgen_ty_103 = 21;
pub const kAudioUnitParameterUnit_BPM: _bindgen_ty_103 = 22;
pub const kAudioUnitParameterUnit_Beats: _bindgen_ty_103 = 23;
pub const kAudioUnitParameterUnit_Milliseconds: _bindgen_ty_103 = 24;
pub const kAudioUnitParameterUnit_Ratio: _bindgen_ty_103 = 25;
pub const kAudioUnitParameterUnit_CustomUnit: _bindgen_ty_103 = 26;
pub type _bindgen_ty_103 = u32;
///@enum			AudioUnitParameterOptions
///@discussion		Bit positions 18, 17, and 16 are set aside for display scales. Bit 19 is reserved.
///@constant		kAudioUnitParameterFlag_CFNameRelease
///@constant		kAudioUnitParameterFlag_PlotHistory
///@constant		kAudioUnitParameterFlag_MeterReadOnly
///@constant		kAudioUnitParameterFlag_DisplayMask
///@constant		kAudioUnitParameterFlag_DisplaySquareRoot
///@constant		kAudioUnitParameterFlag_DisplaySquared
///@constant		kAudioUnitParameterFlag_DisplayCubed
///@constant		kAudioUnitParameterFlag_DisplayCubeRoot
///@constant		kAudioUnitParameterFlag_DisplayExponential
///@constant		kAudioUnitParameterFlag_HasClump
///@constant		kAudioUnitParameterFlag_ValuesHaveStrings
///@constant		kAudioUnitParameterFlag_DisplayLogarithmic
///@constant		kAudioUnitParameterFlag_IsHighResolution
///@constant		kAudioUnitParameterFlag_NonRealTime
///@constant		kAudioUnitParameterFlag_CanRamp
///@constant		kAudioUnitParameterFlag_ExpertMode
///@constant		kAudioUnitParameterFlag_HasCFNameString
///@constant		kAudioUnitParameterFlag_IsGlobalMeta
///@constant		kAudioUnitParameterFlag_IsElementMeta
///@constant		kAudioUnitParameterFlag_IsReadable
///@constant		kAudioUnitParameterFlag_IsWritable
pub type AudioUnitParameterOptions = UInt32;
pub const kAudioUnitParameterFlag_CFNameRelease: _bindgen_ty_104 = 16;
pub const kAudioUnitParameterFlag_OmitFromPresets: _bindgen_ty_104 = 8192;
pub const kAudioUnitParameterFlag_PlotHistory: _bindgen_ty_104 = 16384;
pub const kAudioUnitParameterFlag_MeterReadOnly: _bindgen_ty_104 = 32768;
pub const kAudioUnitParameterFlag_DisplayMask: _bindgen_ty_104 = 4653056;
pub const kAudioUnitParameterFlag_DisplaySquareRoot: _bindgen_ty_104 = 65536;
pub const kAudioUnitParameterFlag_DisplaySquared: _bindgen_ty_104 = 131072;
pub const kAudioUnitParameterFlag_DisplayCubed: _bindgen_ty_104 = 196608;
pub const kAudioUnitParameterFlag_DisplayCubeRoot: _bindgen_ty_104 = 262144;
pub const kAudioUnitParameterFlag_DisplayExponential: _bindgen_ty_104 = 327680;
pub const kAudioUnitParameterFlag_HasClump: _bindgen_ty_104 = 1048576;
pub const kAudioUnitParameterFlag_ValuesHaveStrings: _bindgen_ty_104 = 2097152;
pub const kAudioUnitParameterFlag_DisplayLogarithmic: _bindgen_ty_104 = 4194304;
pub const kAudioUnitParameterFlag_IsHighResolution: _bindgen_ty_104 = 8388608;
pub const kAudioUnitParameterFlag_NonRealTime: _bindgen_ty_104 = 16777216;
pub const kAudioUnitParameterFlag_CanRamp: _bindgen_ty_104 = 33554432;
pub const kAudioUnitParameterFlag_ExpertMode: _bindgen_ty_104 = 67108864;
pub const kAudioUnitParameterFlag_HasCFNameString: _bindgen_ty_104 = 134217728;
pub const kAudioUnitParameterFlag_IsGlobalMeta: _bindgen_ty_104 = 268435456;
pub const kAudioUnitParameterFlag_IsElementMeta: _bindgen_ty_104 = 536870912;
pub const kAudioUnitParameterFlag_IsReadable: _bindgen_ty_104 = 1073741824;
pub const kAudioUnitParameterFlag_IsWritable: _bindgen_ty_104 = 2147483648;
pub type _bindgen_ty_104 = u32;
///@struct			AudioUnitParameterInfo
///@field			name
///UNUSED - set to zero - UTF8 encoded C string (originally).
///@field			unitName
///only valid if kAudioUnitParameterUnit_CustomUnit is set. If kAudioUnitParameterUnit_CustomUnit
///is set, this field must contain a valid CFString.
///@field			clumpID
///only valid if kAudioUnitParameterFlag_HasClump
///@field			cfNameString
///only valid if kAudioUnitParameterFlag_HasCFNameString
///@field			unit
///if the "unit" field contains a value not in the enum above, then assume
///kAudioUnitParameterUnit_Generic
///@field			minValue
///@field			maxValue
///@field			defaultValue
///@field			flags
///Due to some vagaries about the ways in which Parameter's CFNames have been described, it was
///necessary to add a flag: kAudioUnitParameterFlag_CFNameRelease
///In normal usage a parameter name is essentially a static object, but sometimes an audio unit will
///generate parameter names dynamically.. As these are expected to be CFStrings, in that case
///the host should release those names when it is finished with them, but there was no way
///to communicate this distinction in behavior.
///Thus, if an audio unit will (or could) generate a name dynamically, it should set this flag in
///the parameter's info. The host should check for this flag, and if present, release the parameter
///name when it is finished with it.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AudioUnitParameterInfo {
    pub name: [::std::os::raw::c_char; 52usize],
    pub unitName: CFStringRef,
    pub clumpID: UInt32,
    pub cfNameString: CFStringRef,
    pub unit: AudioUnitParameterUnit,
    pub minValue: AudioUnitParameterValue,
    pub maxValue: AudioUnitParameterValue,
    pub defaultValue: AudioUnitParameterValue,
    pub flags: AudioUnitParameterOptions,
}
#[test]
fn bindgen_test_layout_AudioUnitParameterInfo() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitParameterInfo>(),
        104usize,
        concat!("Size of: ", stringify!(AudioUnitParameterInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitParameterInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioUnitParameterInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameterInfo>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameterInfo>())).unitName as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterInfo),
            "::",
            stringify!(unitName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameterInfo>())).clumpID as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterInfo),
            "::",
            stringify!(clumpID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterInfo>())).cfNameString as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterInfo),
            "::",
            stringify!(cfNameString)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameterInfo>())).unit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterInfo),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameterInfo>())).minValue as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterInfo),
            "::",
            stringify!(minValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameterInfo>())).maxValue as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterInfo),
            "::",
            stringify!(maxValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterInfo>())).defaultValue as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterInfo),
            "::",
            stringify!(defaultValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameterInfo>())).flags as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterInfo),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for AudioUnitParameterInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const kAudioUnitClumpID_System: _bindgen_ty_105 = 0;
///@enum			Audio Unit Clump ID
///@discussion		Audio unit developers should not use a clump ID of 0. This value is reserved for system use.
pub type _bindgen_ty_105 = u32;
pub const kAudioUnitParameterName_Full: _bindgen_ty_106 = -1;
///@enum			Audio Unit Parameter Full Name
///@discussion		Used with the AudioUnitParameterIDName.inDesiredLength field to indicate the full name
///of the requested parameter.
pub type _bindgen_ty_106 = i32;
///@struct			AudioUnitParameterIDName
///@abstract		Used to provide shorter names for a specified parameter
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioUnitParameterNameInfo {
    pub inID: AudioUnitParameterID,
    pub inDesiredLength: SInt32,
    pub outName: CFStringRef,
}
#[test]
fn bindgen_test_layout_AudioUnitParameterNameInfo() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitParameterNameInfo>(),
        16usize,
        concat!("Size of: ", stringify!(AudioUnitParameterNameInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitParameterNameInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioUnitParameterNameInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitParameterNameInfo>())).inID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterNameInfo),
            "::",
            stringify!(inID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterNameInfo>())).inDesiredLength as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterNameInfo),
            "::",
            stringify!(inDesiredLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterNameInfo>())).outName as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterNameInfo),
            "::",
            stringify!(outName)
        )
    );
}
impl Default for AudioUnitParameterNameInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type AudioUnitParameterIDName = AudioUnitParameterNameInfo;
///@struct			AudioUnitParameterStringFromValue
///@abstract		Provide a string representation of a parameter's value
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioUnitParameterStringFromValue {
    pub inParamID: AudioUnitParameterID,
    pub inValue: *const AudioUnitParameterValue,
    pub outString: CFStringRef,
}
#[test]
fn bindgen_test_layout_AudioUnitParameterStringFromValue() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitParameterStringFromValue>(),
        24usize,
        concat!("Size of: ", stringify!(AudioUnitParameterStringFromValue))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitParameterStringFromValue>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AudioUnitParameterStringFromValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterStringFromValue>())).inParamID as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterStringFromValue),
            "::",
            stringify!(inParamID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterStringFromValue>())).inValue as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterStringFromValue),
            "::",
            stringify!(inValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterStringFromValue>())).outString as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterStringFromValue),
            "::",
            stringify!(outString)
        )
    );
}
impl Default for AudioUnitParameterStringFromValue {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///@struct			AudioUnitParameterValueFromString
///@abstract		Provide the parameter's value for a given string representation of it
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioUnitParameterValueFromString {
    pub inParamID: AudioUnitParameterID,
    pub inString: CFStringRef,
    pub outValue: AudioUnitParameterValue,
}
#[test]
fn bindgen_test_layout_AudioUnitParameterValueFromString() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitParameterValueFromString>(),
        24usize,
        concat!("Size of: ", stringify!(AudioUnitParameterValueFromString))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitParameterValueFromString>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AudioUnitParameterValueFromString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterValueFromString>())).inParamID as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterValueFromString),
            "::",
            stringify!(inParamID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterValueFromString>())).inString as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterValueFromString),
            "::",
            stringify!(inString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterValueFromString>())).outValue as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterValueFromString),
            "::",
            stringify!(outValue)
        )
    );
}
impl Default for AudioUnitParameterValueFromString {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const kAudioOutputUnitProperty_IsRunning: _bindgen_ty_107 = 2001;
pub type _bindgen_ty_107 = u32;
pub const kAudioUnitProperty_AllParameterMIDIMappings: _bindgen_ty_108 = 41;
pub const kAudioUnitProperty_AddParameterMIDIMapping: _bindgen_ty_108 = 42;
pub const kAudioUnitProperty_RemoveParameterMIDIMapping: _bindgen_ty_108 = 43;
pub const kAudioUnitProperty_HotMapParameterMIDIMapping: _bindgen_ty_108 = 44;
pub type _bindgen_ty_108 = u32;
///@enum			ParameterMIDIMappings
///@abstract		General defined values to customize the behavior of parameter-to-MIDI mappings
///
///@constant		kAUParameterMIDIMapping_AnyChannelFlag
///@discussion			If this flag is set and the value of the mStatus field is a MIDI channel message, then
///the MIDI channel number in the status byte is ignored; the mapping is from the specified
///MIDI message on any channel.
///
///@constant		kAUParameterMIDIMapping_AnyNoteFlag
///@discussion			If this flag is set and the value of the mStatus field is a Note On, Note Off, or
///Polyphonic Pressure message, the message's note number is ignored. The mapping is from
///any note number.
///
///@constant		kAUParameterMIDIMapping_SubRange
///@discussion			Set this flag if the MIDI control should map only to a sub-range of the parameter's value.
///Then specify that range in the mSubRangeMin and mSubRangeMax member fields.
///
///@constant		kAUParameterMIDIMapping_Toggle
///@discussion			Intended for Boolean typed parameters. When this property is set, it means that the
///parameter's value should be toggled when the mapped MIDI message is received. For example,
///if the parameter's value is currently TRUE, when the mapped MIDI message is received
///the value changes to FALSE.
///
///@constant		kAUParameterMIDIMapping_Bipolar
///@discussion			This property is useful when mapping a parameter to a MIDI Controller. When set, it
///indicates that the parameter can assume only two values: on or off. For this reason, a
///parameter associated with this property is typically Boolean. For example, if this
///property is set for a parameter mapped to a sustain pedal MIDI controller, controller
///values from 0 to 64 result in the parameter switched to its "off" state; controller
///values from 65 to 127 result in the parameter switched to its "on" state.
///
///This property works in connection with the kAUParameterMIDIMapping_Bipolar_On property.
///The value of the kAUParameterMIDIMapping_Bipolar_On property
///
///@constant		kAUParameterMIDIMapping_Bipolar_On
///@discussion			Determines whether the  "on" state of a parameter is mapped to the "on" or "off" state
///of the associated MIDI controller. Only valid  if the  kAUParameterMIDIMapping_Bipolar
///property is set.
pub type AUParameterMIDIMappingFlags = UInt32;
pub const kAUParameterMIDIMapping_AnyChannelFlag: _bindgen_ty_109 = 1;
pub const kAUParameterMIDIMapping_AnyNoteFlag: _bindgen_ty_109 = 2;
pub const kAUParameterMIDIMapping_SubRange: _bindgen_ty_109 = 4;
pub const kAUParameterMIDIMapping_Toggle: _bindgen_ty_109 = 8;
pub const kAUParameterMIDIMapping_Bipolar: _bindgen_ty_109 = 16;
pub const kAUParameterMIDIMapping_Bipolar_On: _bindgen_ty_109 = 32;
pub type _bindgen_ty_109 = u32;
///@struct			AUParameterMIDIMapping
///@abstract		Represents a mapping between a MIDI message and an audio unit's parameter.
///@discussion		The reserved fields in this structure are for future use. In the current implementation,
///they help align the structure to 64 bit size. Do not use the names of these fields in a
///host application. They are subject to change.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AUParameterMIDIMapping {
    pub mScope: AudioUnitScope,
    pub mElement: AudioUnitElement,
    pub mParameterID: AudioUnitParameterID,
    pub mFlags: AUParameterMIDIMappingFlags,
    pub mSubRangeMin: AudioUnitParameterValue,
    pub mSubRangeMax: AudioUnitParameterValue,
    pub mStatus: UInt8,
    pub mData1: UInt8,
    pub reserved1: UInt8,
    pub reserved2: UInt8,
    pub reserved3: UInt32,
}
#[test]
fn bindgen_test_layout_AUParameterMIDIMapping() {
    assert_eq!(
        ::std::mem::size_of::<AUParameterMIDIMapping>(),
        32usize,
        concat!("Size of: ", stringify!(AUParameterMIDIMapping))
    );
    assert_eq!(
        ::std::mem::align_of::<AUParameterMIDIMapping>(),
        4usize,
        concat!("Alignment of ", stringify!(AUParameterMIDIMapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUParameterMIDIMapping>())).mScope as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUParameterMIDIMapping),
            "::",
            stringify!(mScope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUParameterMIDIMapping>())).mElement as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AUParameterMIDIMapping),
            "::",
            stringify!(mElement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUParameterMIDIMapping>())).mParameterID as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AUParameterMIDIMapping),
            "::",
            stringify!(mParameterID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUParameterMIDIMapping>())).mFlags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AUParameterMIDIMapping),
            "::",
            stringify!(mFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUParameterMIDIMapping>())).mSubRangeMin as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AUParameterMIDIMapping),
            "::",
            stringify!(mSubRangeMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUParameterMIDIMapping>())).mSubRangeMax as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AUParameterMIDIMapping),
            "::",
            stringify!(mSubRangeMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUParameterMIDIMapping>())).mStatus as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AUParameterMIDIMapping),
            "::",
            stringify!(mStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUParameterMIDIMapping>())).mData1 as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(AUParameterMIDIMapping),
            "::",
            stringify!(mData1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUParameterMIDIMapping>())).reserved1 as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(AUParameterMIDIMapping),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUParameterMIDIMapping>())).reserved2 as *const _ as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(AUParameterMIDIMapping),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUParameterMIDIMapping>())).reserved3 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AUParameterMIDIMapping),
            "::",
            stringify!(reserved3)
        )
    );
}
pub const kMusicDeviceProperty_MIDIXMLNames: _bindgen_ty_110 = 1006;
pub const kMusicDeviceProperty_PartGroup: _bindgen_ty_110 = 1010;
pub const kMusicDeviceProperty_DualSchedulingMode: _bindgen_ty_110 = 1013;
pub const kMusicDeviceProperty_SupportsStartStopNote: _bindgen_ty_110 = 1014;
pub type _bindgen_ty_110 = u32;
pub const kMusicDeviceSampleFrameMask_SampleOffset: _bindgen_ty_111 = 16777215;
pub const kMusicDeviceSampleFrameMask_IsScheduled: _bindgen_ty_111 = 16777216;
///@enum			DualSchedulingMode
pub type _bindgen_ty_111 = u32;
pub const kAudioUnitOfflineProperty_InputSize: _bindgen_ty_112 = 3020;
pub const kAudioUnitOfflineProperty_OutputSize: _bindgen_ty_112 = 3021;
pub const kAudioUnitOfflineProperty_StartOffset: _bindgen_ty_112 = 3022;
pub const kAudioUnitOfflineProperty_PreflightRequirements: _bindgen_ty_112 = 3023;
pub const kAudioUnitOfflineProperty_PreflightName: _bindgen_ty_112 = 3024;
pub type _bindgen_ty_112 = u32;
pub const kOfflinePreflight_NotRequired: _bindgen_ty_113 = 0;
pub const kOfflinePreflight_Optional: _bindgen_ty_113 = 1;
pub const kOfflinePreflight_Required: _bindgen_ty_113 = 2;
///@enum		Offline Preflight Flags
///@abstract	Used to indicate an Offline Unit's preflight requirements
///@constant	kOfflinePreflight_NotRequired
///@discussion		Offline unit does not require preflight
///@constant	kOfflinePreflight_Optional
///@discussion		Offline unit will generally behave better if it is preflighted, but it is not
///required to be preflighted.
///@constant	kOfflinePreflight_Required
///@discussion		Offline unit requires preflighting or it cannot do its work
pub type _bindgen_ty_113 = u32;
pub const kAudioUnitProperty_DistanceAttenuationData: _bindgen_ty_114 = 3600;
pub type _bindgen_ty_114 = u32;
///@struct			AUDistanceAttenuationData
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AUDistanceAttenuationData {
    pub inNumberOfPairs: UInt32,
    pub pairs: [AUDistanceAttenuationData__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AUDistanceAttenuationData__bindgen_ty_1 {
    pub inDistance: Float32,
    pub outGain: Float32,
}
#[test]
fn bindgen_test_layout_AUDistanceAttenuationData__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<AUDistanceAttenuationData__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(AUDistanceAttenuationData__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AUDistanceAttenuationData__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AUDistanceAttenuationData__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUDistanceAttenuationData__bindgen_ty_1>())).inDistance
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUDistanceAttenuationData__bindgen_ty_1),
            "::",
            stringify!(inDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUDistanceAttenuationData__bindgen_ty_1>())).outGain as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AUDistanceAttenuationData__bindgen_ty_1),
            "::",
            stringify!(outGain)
        )
    );
}
#[test]
fn bindgen_test_layout_AUDistanceAttenuationData() {
    assert_eq!(
        ::std::mem::size_of::<AUDistanceAttenuationData>(),
        12usize,
        concat!("Size of: ", stringify!(AUDistanceAttenuationData))
    );
    assert_eq!(
        ::std::mem::align_of::<AUDistanceAttenuationData>(),
        4usize,
        concat!("Alignment of ", stringify!(AUDistanceAttenuationData))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUDistanceAttenuationData>())).inNumberOfPairs as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUDistanceAttenuationData),
            "::",
            stringify!(inNumberOfPairs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUDistanceAttenuationData>())).pairs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AUDistanceAttenuationData),
            "::",
            stringify!(pairs)
        )
    );
}
pub const kAudioUnitMigrateProperty_FromPlugin: _bindgen_ty_115 = 4000;
pub const kAudioUnitMigrateProperty_OldAutomation: _bindgen_ty_115 = 4001;
pub type _bindgen_ty_115 = u32;
pub const kOtherPluginFormat_Undefined: _bindgen_ty_116 = 0;
pub const kOtherPluginFormat_kMAS: _bindgen_ty_116 = 1;
pub const kOtherPluginFormat_kVST: _bindgen_ty_116 = 2;
pub const kOtherPluginFormat_AU: _bindgen_ty_116 = 3;
pub type _bindgen_ty_116 = u32;
///@struct			AudioUnitOtherPluginDesc
///@discussion
///
///@field			format
///@discussion			One of the OtherPluginFormat values
///
///@field			plugin
///@discussion			struct AudioClassDescription {
///OSType mType;
///OSType mSubType;
///OSType mManufacturer;
///};
///is defined in <CoreAudio/CoreAudioTypes.h>
///
///mType specifies a generic, plug-in format defined descriptor
///mSubType is usually left to the manufacturer to use at their discretion
///mManufacturer is a registered code to identify all plugins from the same manufacturer
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioUnitOtherPluginDesc {
    pub format: UInt32,
    pub plugin: AudioClassDescription,
}
#[test]
fn bindgen_test_layout_AudioUnitOtherPluginDesc() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitOtherPluginDesc>(),
        16usize,
        concat!("Size of: ", stringify!(AudioUnitOtherPluginDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitOtherPluginDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioUnitOtherPluginDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitOtherPluginDesc>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitOtherPluginDesc),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioUnitOtherPluginDesc>())).plugin as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitOtherPluginDesc),
            "::",
            stringify!(plugin)
        )
    );
}
///@struct			AudioUnitParameterValueTranslation
///@abstract		Used to translate another plug-in's parameter values to  audio unit parameter
///values
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioUnitParameterValueTranslation {
    pub otherDesc: AudioUnitOtherPluginDesc,
    pub otherParamID: UInt32,
    pub otherValue: Float32,
    pub auParamID: AudioUnitParameterID,
    pub auValue: AudioUnitParameterValue,
}
#[test]
fn bindgen_test_layout_AudioUnitParameterValueTranslation() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitParameterValueTranslation>(),
        32usize,
        concat!("Size of: ", stringify!(AudioUnitParameterValueTranslation))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitParameterValueTranslation>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AudioUnitParameterValueTranslation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterValueTranslation>())).otherDesc as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterValueTranslation),
            "::",
            stringify!(otherDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterValueTranslation>())).otherParamID as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterValueTranslation),
            "::",
            stringify!(otherParamID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterValueTranslation>())).otherValue as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterValueTranslation),
            "::",
            stringify!(otherValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterValueTranslation>())).auParamID as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterValueTranslation),
            "::",
            stringify!(auParamID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterValueTranslation>())).auValue as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterValueTranslation),
            "::",
            stringify!(auValue)
        )
    );
}
///@struct			AudioUnitPresetMAS_SettingData
///@discussion		AU-MAS specific structs for the data contained in the "masdata" key of an audio
///unit preset dictionary
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioUnitPresetMAS_SettingData {
    pub isStockSetting: UInt32,
    pub settingID: UInt32,
    pub dataLen: UInt32,
    pub data: [UInt8; 1usize],
}
#[test]
fn bindgen_test_layout_AudioUnitPresetMAS_SettingData() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitPresetMAS_SettingData>(),
        16usize,
        concat!("Size of: ", stringify!(AudioUnitPresetMAS_SettingData))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitPresetMAS_SettingData>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioUnitPresetMAS_SettingData))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitPresetMAS_SettingData>())).isStockSetting as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitPresetMAS_SettingData),
            "::",
            stringify!(isStockSetting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitPresetMAS_SettingData>())).settingID as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitPresetMAS_SettingData),
            "::",
            stringify!(settingID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitPresetMAS_SettingData>())).dataLen as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitPresetMAS_SettingData),
            "::",
            stringify!(dataLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitPresetMAS_SettingData>())).data as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitPresetMAS_SettingData),
            "::",
            stringify!(data)
        )
    );
}
///@struct			AudioUnitPresetMAS_Settings
///@discussion		See MAS documentation
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioUnitPresetMAS_Settings {
    pub manufacturerID: UInt32,
    pub effectID: UInt32,
    pub variantID: UInt32,
    pub settingsVersion: UInt32,
    pub numberOfSettings: UInt32,
    pub settings: [AudioUnitPresetMAS_SettingData; 1usize],
}
#[test]
fn bindgen_test_layout_AudioUnitPresetMAS_Settings() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitPresetMAS_Settings>(),
        36usize,
        concat!("Size of: ", stringify!(AudioUnitPresetMAS_Settings))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitPresetMAS_Settings>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioUnitPresetMAS_Settings))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitPresetMAS_Settings>())).manufacturerID as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitPresetMAS_Settings),
            "::",
            stringify!(manufacturerID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitPresetMAS_Settings>())).effectID as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitPresetMAS_Settings),
            "::",
            stringify!(effectID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitPresetMAS_Settings>())).variantID as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitPresetMAS_Settings),
            "::",
            stringify!(variantID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitPresetMAS_Settings>())).settingsVersion as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitPresetMAS_Settings),
            "::",
            stringify!(settingsVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitPresetMAS_Settings>())).numberOfSettings as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitPresetMAS_Settings),
            "::",
            stringify!(numberOfSettings)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitPresetMAS_Settings>())).settings as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitPresetMAS_Settings),
            "::",
            stringify!(settings)
        )
    );
}
pub const kAudioUnitProperty_SampleRateConverterComplexity: _bindgen_ty_117 = 3014;
pub type _bindgen_ty_117 = u32;
pub const kAudioUnitSampleRateConverterComplexity_Linear: _bindgen_ty_118 = 1818848869;
pub const kAudioUnitSampleRateConverterComplexity_Normal: _bindgen_ty_118 = 1852797549;
pub const kAudioUnitSampleRateConverterComplexity_Mastering: _bindgen_ty_118 = 1650553971;
pub type _bindgen_ty_118 = u32;
pub const kAudioOutputUnitProperty_CurrentDevice: _bindgen_ty_119 = 2000;
pub const kAudioOutputUnitProperty_ChannelMap: _bindgen_ty_119 = 2002;
pub const kAudioOutputUnitProperty_EnableIO: _bindgen_ty_119 = 2003;
pub const kAudioOutputUnitProperty_StartTime: _bindgen_ty_119 = 2004;
pub const kAudioOutputUnitProperty_SetInputCallback: _bindgen_ty_119 = 2005;
pub const kAudioOutputUnitProperty_HasIO: _bindgen_ty_119 = 2006;
pub const kAudioOutputUnitProperty_StartTimestampsAtZero: _bindgen_ty_119 = 2007;
pub type _bindgen_ty_119 = u32;
///@struct			AudioOutputUnitStartAtTimeParams
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioOutputUnitStartAtTimeParams {
    pub mTimestamp: AudioTimeStamp,
    pub mFlags: UInt32,
}
#[test]
fn bindgen_test_layout_AudioOutputUnitStartAtTimeParams() {
    assert_eq!(
        ::std::mem::size_of::<AudioOutputUnitStartAtTimeParams>(),
        72usize,
        concat!("Size of: ", stringify!(AudioOutputUnitStartAtTimeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioOutputUnitStartAtTimeParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AudioOutputUnitStartAtTimeParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioOutputUnitStartAtTimeParams>())).mTimestamp as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioOutputUnitStartAtTimeParams),
            "::",
            stringify!(mTimestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioOutputUnitStartAtTimeParams>())).mFlags as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioOutputUnitStartAtTimeParams),
            "::",
            stringify!(mFlags)
        )
    );
}
pub const kAUVoiceIOProperty_BypassVoiceProcessing: _bindgen_ty_120 = 2100;
pub const kAUVoiceIOProperty_VoiceProcessingEnableAGC: _bindgen_ty_120 = 2101;
pub const kAUVoiceIOProperty_MuteOutput: _bindgen_ty_120 = 2104;
pub type _bindgen_ty_120 = u32;
pub const kAUVoiceIOProperty_VoiceProcessingQuality: _bindgen_ty_121 = 2103;
pub type _bindgen_ty_121 = u32;
pub const kAUNBandEQProperty_NumberOfBands: _bindgen_ty_122 = 2200;
pub const kAUNBandEQProperty_MaxNumberOfBands: _bindgen_ty_122 = 2201;
pub const kAUNBandEQProperty_BiquadCoefficients: _bindgen_ty_122 = 2203;
pub type _bindgen_ty_122 = u32;
pub const kAUVoiceIOErr_UnexpectedNumberOfInputChannels: _bindgen_ty_123 = -66784;
pub type _bindgen_ty_123 = i32;
pub const kAudioUnitProperty_MeteringMode: _bindgen_ty_124 = 3007;
pub const kAudioUnitProperty_MatrixLevels: _bindgen_ty_124 = 3006;
pub const kAudioUnitProperty_MatrixDimensions: _bindgen_ty_124 = 3009;
pub const kAudioUnitProperty_MeterClipping: _bindgen_ty_124 = 3011;
pub const kAudioUnitProperty_InputAnchorTimeStamp: _bindgen_ty_124 = 3016;
pub type _bindgen_ty_124 = u32;
///@struct			AudioUnitMeterClipping
///
///@field			peakValueSinceLastCall;
///@discussion			The maximum value seen on the channel since the last time the property was retrieved.
///@field			sawInfinity;
///@discussion			TRUE if there was an infinite value on this channel.
///@field			sawNotANumber
///@discussion			TRUE if there was a floating point Not-A-Number value on this channel.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioUnitMeterClipping {
    pub peakValueSinceLastCall: Float32,
    pub sawInfinity: Boolean,
    pub sawNotANumber: Boolean,
}
#[test]
fn bindgen_test_layout_AudioUnitMeterClipping() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitMeterClipping>(),
        8usize,
        concat!("Size of: ", stringify!(AudioUnitMeterClipping))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitMeterClipping>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioUnitMeterClipping))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitMeterClipping>())).peakValueSinceLastCall as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitMeterClipping),
            "::",
            stringify!(peakValueSinceLastCall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitMeterClipping>())).sawInfinity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitMeterClipping),
            "::",
            stringify!(sawInfinity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitMeterClipping>())).sawNotANumber as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitMeterClipping),
            "::",
            stringify!(sawNotANumber)
        )
    );
}
pub const kAudioUnitProperty_ReverbRoomType: _bindgen_ty_125 = 10;
pub const kAudioUnitProperty_UsesInternalReverb: _bindgen_ty_125 = 1005;
pub const kAudioUnitProperty_SpatializationAlgorithm: _bindgen_ty_125 = 3000;
pub const kAudioUnitProperty_SpatialMixerDistanceParams: _bindgen_ty_125 = 3010;
pub const kAudioUnitProperty_SpatialMixerAttenuationCurve: _bindgen_ty_125 = 3013;
pub const kAudioUnitProperty_SpatialMixerRenderingFlags: _bindgen_ty_125 = 3003;
pub type _bindgen_ty_125 = u32;
///@enum 	Spatialization Algorithms
pub type AUSpatializationAlgorithm = UInt32;
pub const kSpatializationAlgorithm_EqualPowerPanning: _bindgen_ty_126 = 0;
pub const kSpatializationAlgorithm_SphericalHead: _bindgen_ty_126 = 1;
pub const kSpatializationAlgorithm_HRTF: _bindgen_ty_126 = 2;
pub const kSpatializationAlgorithm_SoundField: _bindgen_ty_126 = 3;
pub const kSpatializationAlgorithm_VectorBasedPanning: _bindgen_ty_126 = 4;
pub const kSpatializationAlgorithm_StereoPassThrough: _bindgen_ty_126 = 5;
pub const kSpatializationAlgorithm_HRTFHQ: _bindgen_ty_126 = 6;
pub type _bindgen_ty_126 = u32;
///@enum	Reverb Room Types
///@discussion Used to specify room type (as identified by a factory preset number) on Apple audio
///units that use internal reverb.
pub type AUReverbRoomType = UInt32;
pub const kReverbRoomType_SmallRoom: _bindgen_ty_127 = 0;
pub const kReverbRoomType_MediumRoom: _bindgen_ty_127 = 1;
pub const kReverbRoomType_LargeRoom: _bindgen_ty_127 = 2;
pub const kReverbRoomType_MediumHall: _bindgen_ty_127 = 3;
pub const kReverbRoomType_LargeHall: _bindgen_ty_127 = 4;
pub const kReverbRoomType_Plate: _bindgen_ty_127 = 5;
pub const kReverbRoomType_MediumChamber: _bindgen_ty_127 = 6;
pub const kReverbRoomType_LargeChamber: _bindgen_ty_127 = 7;
pub const kReverbRoomType_Cathedral: _bindgen_ty_127 = 8;
pub const kReverbRoomType_LargeRoom2: _bindgen_ty_127 = 9;
pub const kReverbRoomType_MediumHall2: _bindgen_ty_127 = 10;
pub const kReverbRoomType_MediumHall3: _bindgen_ty_127 = 11;
pub const kReverbRoomType_LargeHall2: _bindgen_ty_127 = 12;
pub type _bindgen_ty_127 = u32;
///@enum AUSpatialMixer Attenuation Curves
pub type AUSpatialMixerAttenuationCurve = UInt32;
pub const kSpatialMixerAttenuationCurve_Power: _bindgen_ty_128 = 0;
pub const kSpatialMixerAttenuationCurve_Exponential: _bindgen_ty_128 = 1;
pub const kSpatialMixerAttenuationCurve_Inverse: _bindgen_ty_128 = 2;
pub const kSpatialMixerAttenuationCurve_Linear: _bindgen_ty_128 = 3;
pub type _bindgen_ty_128 = u32;
///@struct			MixerDistanceParams
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MixerDistanceParams {
    pub mReferenceDistance: Float32,
    pub mMaxDistance: Float32,
    pub mMaxAttenuation: Float32,
}
#[test]
fn bindgen_test_layout_MixerDistanceParams() {
    assert_eq!(
        ::std::mem::size_of::<MixerDistanceParams>(),
        12usize,
        concat!("Size of: ", stringify!(MixerDistanceParams))
    );
    assert_eq!(
        ::std::mem::align_of::<MixerDistanceParams>(),
        4usize,
        concat!("Alignment of ", stringify!(MixerDistanceParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MixerDistanceParams>())).mReferenceDistance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MixerDistanceParams),
            "::",
            stringify!(mReferenceDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MixerDistanceParams>())).mMaxDistance as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MixerDistanceParams),
            "::",
            stringify!(mMaxDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MixerDistanceParams>())).mMaxAttenuation as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MixerDistanceParams),
            "::",
            stringify!(mMaxAttenuation)
        )
    );
}
///@enum	AUSpatial Mixer Rendering Flags
pub type AUSpatialMixerRenderingFlags = UInt32;
pub const kSpatialMixerRenderingFlags_InterAuralDelay: _bindgen_ty_129 = 1;
pub const kSpatialMixerRenderingFlags_DistanceAttenuation: _bindgen_ty_129 = 4;
pub type _bindgen_ty_129 = u32;
pub const kAudioUnitProperty_3DMixerDistanceParams: _bindgen_ty_130 = 3010;
pub const kAudioUnitProperty_3DMixerAttenuationCurve: _bindgen_ty_130 = 3013;
pub const kAudioUnitProperty_DopplerShift: _bindgen_ty_130 = 3002;
pub const kAudioUnitProperty_3DMixerRenderingFlags: _bindgen_ty_130 = 3003;
pub const kAudioUnitProperty_3DMixerDistanceAtten: _bindgen_ty_130 = 3004;
pub const kAudioUnitProperty_ReverbPreset: _bindgen_ty_130 = 3012;
pub type _bindgen_ty_130 = u32;
///@enum	3D Mixer Rendering Flags
pub type AU3DMixerRenderingFlags = UInt32;
pub const k3DMixerRenderingFlags_InterAuralDelay: _bindgen_ty_131 = 1;
pub const k3DMixerRenderingFlags_DopplerShift: _bindgen_ty_131 = 2;
pub const k3DMixerRenderingFlags_DistanceAttenuation: _bindgen_ty_131 = 4;
pub const k3DMixerRenderingFlags_DistanceFilter: _bindgen_ty_131 = 8;
pub const k3DMixerRenderingFlags_DistanceDiffusion: _bindgen_ty_131 = 16;
pub const k3DMixerRenderingFlags_LinearDistanceAttenuation: _bindgen_ty_131 = 32;
pub const k3DMixerRenderingFlags_ConstantReverbBlend: _bindgen_ty_131 = 64;
pub type _bindgen_ty_131 = u32;
///@enum 3D Mixer Attenuation Curves
pub type AU3DMixerAttenuationCurve = UInt32;
pub const k3DMixerAttenuationCurve_Power: _bindgen_ty_132 = 0;
pub const k3DMixerAttenuationCurve_Exponential: _bindgen_ty_132 = 1;
pub const k3DMixerAttenuationCurve_Inverse: _bindgen_ty_132 = 2;
pub const k3DMixerAttenuationCurve_Linear: _bindgen_ty_132 = 3;
pub type _bindgen_ty_132 = u32;
pub const kAudioUnitProperty_ScheduleAudioSlice: _bindgen_ty_133 = 3300;
pub const kAudioUnitProperty_ScheduleStartTimeStamp: _bindgen_ty_133 = 3301;
pub const kAudioUnitProperty_CurrentPlayTime: _bindgen_ty_133 = 3302;
pub type _bindgen_ty_133 = u32;
///@enum           ScheduledAudioSlice
///@abstract           bits in ScheduledAudioSlice.mFlags
///
///@constant       kScheduledAudioSliceFlag_Complete
///@abstract           Set if the unit is done with this slice
///@constant       kScheduledAudioSliceFlag_BeganToRender
///@abstract           Set if any portion of the buffer has been played
///@constant       kScheduledAudioSliceFlag_BeganToRenderLate
///@abstract           Set if any portion of the buffer was not played because it was scheduled late
///@constant       kScheduledAudioSliceFlag_Loop
///@abstract           specifies that the buffer should loop indefinitely
///@constant       kScheduledAudioSliceFlag_Interrupt
///@abstract           specifies that the buffer should interrupt any previously scheduled buffer
///(by default, buffers following a playing buffer are not played until the
///playing buffer has completed).
///@constant       kScheduledAudioSliceFlag_InterruptAtLoop
///@abstract           specifies that the buffer should interrupt any previously scheduled buffer,
///but only at a loop point in that buffer.
pub type AUScheduledAudioSliceFlags = UInt32;
pub const kScheduledAudioSliceFlag_Complete: _bindgen_ty_134 = 1;
pub const kScheduledAudioSliceFlag_BeganToRender: _bindgen_ty_134 = 2;
pub const kScheduledAudioSliceFlag_BeganToRenderLate: _bindgen_ty_134 = 4;
pub const kScheduledAudioSliceFlag_Loop: _bindgen_ty_134 = 8;
pub const kScheduledAudioSliceFlag_Interrupt: _bindgen_ty_134 = 16;
pub const kScheduledAudioSliceFlag_InterruptAtLoop: _bindgen_ty_134 = 32;
pub type _bindgen_ty_134 = u32;
///@typedef			ScheduledAudioSliceCompletionProc
pub type ScheduledAudioSliceCompletionProc = ::std::option::Option<
    unsafe extern "C" fn(
        userData: *mut ::std::os::raw::c_void,
        bufferList: *mut ScheduledAudioSlice,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScheduledAudioSlice {
    pub mTimeStamp: AudioTimeStamp,
    pub mCompletionProc: ScheduledAudioSliceCompletionProc,
    pub mCompletionProcUserData: *mut ::std::os::raw::c_void,
    pub mFlags: AUScheduledAudioSliceFlags,
    pub mReserved: UInt32,
    pub mReserved2: *mut ::std::os::raw::c_void,
    pub mNumberFrames: UInt32,
    pub mBufferList: *mut AudioBufferList,
}
#[test]
fn bindgen_test_layout_ScheduledAudioSlice() {
    assert_eq!(
        ::std::mem::size_of::<ScheduledAudioSlice>(),
        112usize,
        concat!("Size of: ", stringify!(ScheduledAudioSlice))
    );
    assert_eq!(
        ::std::mem::align_of::<ScheduledAudioSlice>(),
        8usize,
        concat!("Alignment of ", stringify!(ScheduledAudioSlice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScheduledAudioSlice>())).mTimeStamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioSlice),
            "::",
            stringify!(mTimeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ScheduledAudioSlice>())).mCompletionProc as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioSlice),
            "::",
            stringify!(mCompletionProc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ScheduledAudioSlice>())).mCompletionProcUserData as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioSlice),
            "::",
            stringify!(mCompletionProcUserData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScheduledAudioSlice>())).mFlags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioSlice),
            "::",
            stringify!(mFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScheduledAudioSlice>())).mReserved as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioSlice),
            "::",
            stringify!(mReserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScheduledAudioSlice>())).mReserved2 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioSlice),
            "::",
            stringify!(mReserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ScheduledAudioSlice>())).mNumberFrames as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioSlice),
            "::",
            stringify!(mNumberFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScheduledAudioSlice>())).mBufferList as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioSlice),
            "::",
            stringify!(mBufferList)
        )
    );
}
impl Default for ScheduledAudioSlice {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const kAudioUnitProperty_ScheduledFileIDs: _bindgen_ty_135 = 3310;
pub const kAudioUnitProperty_ScheduledFileRegion: _bindgen_ty_135 = 3311;
pub const kAudioUnitProperty_ScheduledFilePrime: _bindgen_ty_135 = 3312;
pub const kAudioUnitProperty_ScheduledFileBufferSizeFrames: _bindgen_ty_135 = 3313;
pub const kAudioUnitProperty_ScheduledFileNumberBuffers: _bindgen_ty_135 = 3314;
pub type _bindgen_ty_135 = u32;
///@typedef		ScheduledAudioFileRegionCompletionProc
pub type ScheduledAudioFileRegionCompletionProc = ::std::option::Option<
    unsafe extern "C" fn(
        userData: *mut ::std::os::raw::c_void,
        fileRegion: *mut ScheduledAudioFileRegion,
        result: OSStatus,
    ),
>;
///@struct			ScheduledAudioFileRegion
///@field			mTimeStamp
///@field			mCompletionProc
///may be NULL
///@field			mCompletionProcUserData
///@field			mAudioFile
///must be a valid and open AudioFileID
///defined in AudioToolbox/AudioFile.h: typedef	struct OpaqueAudioFileID	*AudioFileID;
///@field			mLoopCount
///0 = don't loop
///@field			mStartFrame
///offset into file
///@field			mFramesToPlay
///number of frames to play
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScheduledAudioFileRegion {
    pub mTimeStamp: AudioTimeStamp,
    pub mCompletionProc: ScheduledAudioFileRegionCompletionProc,
    pub mCompletionProcUserData: *mut ::std::os::raw::c_void,
    pub mAudioFile: *mut OpaqueAudioFileID,
    pub mLoopCount: UInt32,
    pub mStartFrame: SInt64,
    pub mFramesToPlay: UInt32,
}
#[test]
fn bindgen_test_layout_ScheduledAudioFileRegion() {
    assert_eq!(
        ::std::mem::size_of::<ScheduledAudioFileRegion>(),
        112usize,
        concat!("Size of: ", stringify!(ScheduledAudioFileRegion))
    );
    assert_eq!(
        ::std::mem::align_of::<ScheduledAudioFileRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(ScheduledAudioFileRegion))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ScheduledAudioFileRegion>())).mTimeStamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioFileRegion),
            "::",
            stringify!(mTimeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ScheduledAudioFileRegion>())).mCompletionProc as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioFileRegion),
            "::",
            stringify!(mCompletionProc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ScheduledAudioFileRegion>())).mCompletionProcUserData as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioFileRegion),
            "::",
            stringify!(mCompletionProcUserData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ScheduledAudioFileRegion>())).mAudioFile as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioFileRegion),
            "::",
            stringify!(mAudioFile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ScheduledAudioFileRegion>())).mLoopCount as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioFileRegion),
            "::",
            stringify!(mLoopCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ScheduledAudioFileRegion>())).mStartFrame as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioFileRegion),
            "::",
            stringify!(mStartFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ScheduledAudioFileRegion>())).mFramesToPlay as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ScheduledAudioFileRegion),
            "::",
            stringify!(mFramesToPlay)
        )
    );
}
impl Default for ScheduledAudioFileRegion {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const kMusicDeviceProperty_UsesInternalReverb: _bindgen_ty_136 = 1005;
pub const kMusicDeviceProperty_SoundBankData: _bindgen_ty_136 = 1008;
pub const kMusicDeviceProperty_StreamFromDisk: _bindgen_ty_136 = 1011;
pub const kMusicDeviceProperty_SoundBankFSRef: _bindgen_ty_136 = 1012;
pub type _bindgen_ty_136 = u32;
pub const kMusicDeviceProperty_InstrumentName: _bindgen_ty_137 = 1001;
pub const kMusicDeviceProperty_InstrumentNumber: _bindgen_ty_137 = 1004;
pub type _bindgen_ty_137 = u32;
pub const kMusicDeviceProperty_InstrumentCount: _bindgen_ty_138 = 1000;
pub const kMusicDeviceProperty_BankName: _bindgen_ty_138 = 1007;
pub const kMusicDeviceProperty_SoundBankURL: _bindgen_ty_138 = 1100;
pub type _bindgen_ty_138 = u32;
pub const kAUMIDISynthProperty_EnablePreload: _bindgen_ty_139 = 4119;
pub type _bindgen_ty_139 = u32;
pub const kAUSamplerProperty_LoadInstrument: _bindgen_ty_140 = 4102;
pub const kAUSamplerProperty_LoadAudioFiles: _bindgen_ty_140 = 4101;
pub type _bindgen_ty_140 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUSamplerInstrumentData {
    pub fileURL: CFURLRef,
    pub instrumentType: UInt8,
    pub bankMSB: UInt8,
    pub bankLSB: UInt8,
    pub presetID: UInt8,
}
#[test]
fn bindgen_test_layout_AUSamplerInstrumentData() {
    assert_eq!(
        ::std::mem::size_of::<AUSamplerInstrumentData>(),
        16usize,
        concat!("Size of: ", stringify!(AUSamplerInstrumentData))
    );
    assert_eq!(
        ::std::mem::align_of::<AUSamplerInstrumentData>(),
        8usize,
        concat!("Alignment of ", stringify!(AUSamplerInstrumentData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUSamplerInstrumentData>())).fileURL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUSamplerInstrumentData),
            "::",
            stringify!(fileURL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUSamplerInstrumentData>())).instrumentType as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AUSamplerInstrumentData),
            "::",
            stringify!(instrumentType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUSamplerInstrumentData>())).bankMSB as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(AUSamplerInstrumentData),
            "::",
            stringify!(bankMSB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUSamplerInstrumentData>())).bankLSB as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(AUSamplerInstrumentData),
            "::",
            stringify!(bankLSB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUSamplerInstrumentData>())).presetID as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(AUSamplerInstrumentData),
            "::",
            stringify!(presetID)
        )
    );
}
impl Default for AUSamplerInstrumentData {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const kInstrumentType_DLSPreset: _bindgen_ty_141 = 1;
pub const kInstrumentType_SF2Preset: _bindgen_ty_141 = 1;
pub const kInstrumentType_AUPreset: _bindgen_ty_141 = 2;
pub const kInstrumentType_Audiofile: _bindgen_ty_141 = 3;
pub const kInstrumentType_EXS24: _bindgen_ty_141 = 4;
pub type _bindgen_ty_141 = u32;
pub const kAUSampler_DefaultPercussionBankMSB: _bindgen_ty_142 = 120;
pub const kAUSampler_DefaultMelodicBankMSB: _bindgen_ty_142 = 121;
pub const kAUSampler_DefaultBankLSB: _bindgen_ty_142 = 0;
pub type _bindgen_ty_142 = u32;
pub const kAudioUnitProperty_DeferredRendererPullSize: _bindgen_ty_143 = 3320;
pub const kAudioUnitProperty_DeferredRendererExtraLatency: _bindgen_ty_143 = 3321;
pub const kAudioUnitProperty_DeferredRendererWaitFrames: _bindgen_ty_143 = 3322;
pub type _bindgen_ty_143 = u32;
pub const kAUNetReceiveProperty_Hostname: _bindgen_ty_144 = 3511;
pub const kAUNetReceiveProperty_Password: _bindgen_ty_144 = 3512;
pub type _bindgen_ty_144 = u32;
pub const kAUNetSendProperty_PortNum: _bindgen_ty_145 = 3513;
pub const kAUNetSendProperty_TransmissionFormat: _bindgen_ty_145 = 3514;
pub const kAUNetSendProperty_TransmissionFormatIndex: _bindgen_ty_145 = 3515;
pub const kAUNetSendProperty_ServiceName: _bindgen_ty_145 = 3516;
pub const kAUNetSendProperty_Disconnect: _bindgen_ty_145 = 3517;
pub const kAUNetSendProperty_Password: _bindgen_ty_145 = 3518;
pub type _bindgen_ty_145 = u32;
pub const kAUNetSendPresetFormat_PCMFloat32: _bindgen_ty_146 = 0;
pub const kAUNetSendPresetFormat_PCMInt24: _bindgen_ty_146 = 1;
pub const kAUNetSendPresetFormat_PCMInt16: _bindgen_ty_146 = 2;
pub const kAUNetSendPresetFormat_Lossless24: _bindgen_ty_146 = 3;
pub const kAUNetSendPresetFormat_Lossless16: _bindgen_ty_146 = 4;
pub const kAUNetSendPresetFormat_ULaw: _bindgen_ty_146 = 5;
pub const kAUNetSendPresetFormat_IMA4: _bindgen_ty_146 = 6;
pub const kAUNetSendPresetFormat_AAC_128kbpspc: _bindgen_ty_146 = 7;
pub const kAUNetSendPresetFormat_AAC_96kbpspc: _bindgen_ty_146 = 8;
pub const kAUNetSendPresetFormat_AAC_80kbpspc: _bindgen_ty_146 = 9;
pub const kAUNetSendPresetFormat_AAC_64kbpspc: _bindgen_ty_146 = 10;
pub const kAUNetSendPresetFormat_AAC_48kbpspc: _bindgen_ty_146 = 11;
pub const kAUNetSendPresetFormat_AAC_40kbpspc: _bindgen_ty_146 = 12;
pub const kAUNetSendPresetFormat_AAC_32kbpspc: _bindgen_ty_146 = 13;
pub const kAUNetSendPresetFormat_AAC_LD_64kbpspc: _bindgen_ty_146 = 14;
pub const kAUNetSendPresetFormat_AAC_LD_48kbpspc: _bindgen_ty_146 = 15;
pub const kAUNetSendPresetFormat_AAC_LD_40kbpspc: _bindgen_ty_146 = 16;
pub const kAUNetSendPresetFormat_AAC_LD_32kbpspc: _bindgen_ty_146 = 17;
pub const kAUNetSendNumPresetFormats: _bindgen_ty_146 = 18;
pub type _bindgen_ty_146 = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AUNumVersion {
    pub nonRelRev: UInt8,
    pub stage: UInt8,
    pub minorAndBugRev: UInt8,
    pub majorRev: UInt8,
}
#[test]
fn bindgen_test_layout_AUNumVersion() {
    assert_eq!(
        ::std::mem::size_of::<AUNumVersion>(),
        4usize,
        concat!("Size of: ", stringify!(AUNumVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<AUNumVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(AUNumVersion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUNumVersion>())).nonRelRev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUNumVersion),
            "::",
            stringify!(nonRelRev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUNumVersion>())).stage as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(AUNumVersion),
            "::",
            stringify!(stage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUNumVersion>())).minorAndBugRev as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AUNumVersion),
            "::",
            stringify!(minorAndBugRev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUNumVersion>())).majorRev as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(AUNumVersion),
            "::",
            stringify!(majorRev)
        )
    );
}
///@struct			AUHostIdentifier
///@abstract		Used to describe the name and version of the audio unit's host
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUHostIdentifier {
    pub hostName: CFStringRef,
    pub hostVersion: AUNumVersion,
}
#[test]
fn bindgen_test_layout_AUHostIdentifier() {
    assert_eq!(
        ::std::mem::size_of::<AUHostIdentifier>(),
        16usize,
        concat!("Size of: ", stringify!(AUHostIdentifier))
    );
    assert_eq!(
        ::std::mem::align_of::<AUHostIdentifier>(),
        8usize,
        concat!("Alignment of ", stringify!(AUHostIdentifier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUHostIdentifier>())).hostName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUHostIdentifier),
            "::",
            stringify!(hostName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUHostIdentifier>())).hostVersion as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AUHostIdentifier),
            "::",
            stringify!(hostVersion)
        )
    );
}
impl Default for AUHostIdentifier {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const kAudioUnitParameterFlag_Global: _bindgen_ty_147 = 1;
pub const kAudioUnitParameterFlag_Input: _bindgen_ty_147 = 2;
pub const kAudioUnitParameterFlag_Output: _bindgen_ty_147 = 4;
pub const kAudioUnitParameterFlag_Group: _bindgen_ty_147 = 8;
pub type _bindgen_ty_147 = u32;
pub const kAudioUnitParameterFlag_HasName: _bindgen_ty_148 = 2097152;
pub type _bindgen_ty_148 = u32;
pub const kAudioUnitProperty_SRCAlgorithm: _bindgen_ty_149 = 9;
pub const kAudioUnitProperty_MIDIControlMapping: _bindgen_ty_149 = 17;
pub const kAudioUnitProperty_CurrentPreset: _bindgen_ty_149 = 28;
pub const kAudioUnitProperty_ParameterValueName: _bindgen_ty_149 = 33;
pub const kAudioUnitProperty_BusCount: _bindgen_ty_149 = 11;
pub const kAudioOfflineUnitProperty_InputSize: _bindgen_ty_149 = 3020;
pub const kAudioOfflineUnitProperty_OutputSize: _bindgen_ty_149 = 3021;
pub type _bindgen_ty_149 = u32;
pub const kAudioUnitSRCAlgorithm_Polyphase: _bindgen_ty_150 = 1886350457;
pub const kAudioUnitSRCAlgorithm_MediumQuality: _bindgen_ty_150 = 1668510307;
pub type _bindgen_ty_150 = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioUnitMIDIControlMapping {
    pub midiNRPN: UInt16,
    pub midiControl: UInt8,
    pub scope: UInt8,
    pub element: AudioUnitElement,
    pub parameter: AudioUnitParameterID,
}
#[test]
fn bindgen_test_layout_AudioUnitMIDIControlMapping() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitMIDIControlMapping>(),
        12usize,
        concat!("Size of: ", stringify!(AudioUnitMIDIControlMapping))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitMIDIControlMapping>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioUnitMIDIControlMapping))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitMIDIControlMapping>())).midiNRPN as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitMIDIControlMapping),
            "::",
            stringify!(midiNRPN)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitMIDIControlMapping>())).midiControl as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitMIDIControlMapping),
            "::",
            stringify!(midiControl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitMIDIControlMapping>())).scope as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitMIDIControlMapping),
            "::",
            stringify!(scope)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitMIDIControlMapping>())).element as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitMIDIControlMapping),
            "::",
            stringify!(element)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitMIDIControlMapping>())).parameter as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitMIDIControlMapping),
            "::",
            stringify!(parameter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioUnitParameterValueName {
    pub inParamID: AudioUnitParameterID,
    pub inValue: *const Float32,
    pub outName: CFStringRef,
}
#[test]
fn bindgen_test_layout_AudioUnitParameterValueName() {
    assert_eq!(
        ::std::mem::size_of::<AudioUnitParameterValueName>(),
        24usize,
        concat!("Size of: ", stringify!(AudioUnitParameterValueName))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioUnitParameterValueName>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioUnitParameterValueName))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterValueName>())).inParamID as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterValueName),
            "::",
            stringify!(inParamID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterValueName>())).inValue as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterValueName),
            "::",
            stringify!(inValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioUnitParameterValueName>())).outName as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioUnitParameterValueName),
            "::",
            stringify!(outName)
        )
    );
}
impl Default for AudioUnitParameterValueName {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const kMusicDeviceProperty_GroupOutputBus: _bindgen_ty_151 = 1002;
pub const kMusicDeviceProperty_SoundBankFSSpec: _bindgen_ty_151 = 1003;
pub const kAudioUnitProperty_PannerMode: _bindgen_ty_151 = 3008;
pub type _bindgen_ty_151 = u32;
pub const kAudioUnitProperty_SpeakerConfiguration: _bindgen_ty_152 = 3001;
pub type _bindgen_ty_152 = u32;
pub const kSpeakerConfiguration_HeadPhones: _bindgen_ty_153 = 0;
pub const kSpeakerConfiguration_Stereo: _bindgen_ty_153 = 1;
pub const kSpeakerConfiguration_Quad: _bindgen_ty_153 = 2;
pub const kSpeakerConfiguration_5_0: _bindgen_ty_153 = 3;
pub const kSpeakerConfiguration_5_1: _bindgen_ty_153 = 3;
pub type _bindgen_ty_153 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUSamplerBankPresetData {
    pub bankURL: CFURLRef,
    pub bankMSB: UInt8,
    pub bankLSB: UInt8,
    pub presetID: UInt8,
    pub reserved: UInt8,
}
#[test]
fn bindgen_test_layout_AUSamplerBankPresetData() {
    assert_eq!(
        ::std::mem::size_of::<AUSamplerBankPresetData>(),
        16usize,
        concat!("Size of: ", stringify!(AUSamplerBankPresetData))
    );
    assert_eq!(
        ::std::mem::align_of::<AUSamplerBankPresetData>(),
        8usize,
        concat!("Alignment of ", stringify!(AUSamplerBankPresetData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUSamplerBankPresetData>())).bankURL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUSamplerBankPresetData),
            "::",
            stringify!(bankURL)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUSamplerBankPresetData>())).bankMSB as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AUSamplerBankPresetData),
            "::",
            stringify!(bankMSB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AUSamplerBankPresetData>())).bankLSB as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(AUSamplerBankPresetData),
            "::",
            stringify!(bankLSB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUSamplerBankPresetData>())).presetID as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(AUSamplerBankPresetData),
            "::",
            stringify!(presetID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AUSamplerBankPresetData>())).reserved as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(AUSamplerBankPresetData),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for AUSamplerBankPresetData {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const kAUSamplerProperty_LoadPresetFromBank: _bindgen_ty_154 = 4100;
pub const kAUSamplerProperty_BankAndPreset: _bindgen_ty_154 = 4100;
pub type _bindgen_ty_154 = u32;
pub const kAUGroupParameterID_Volume: _bindgen_ty_155 = 7;
pub const kAUGroupParameterID_Sustain: _bindgen_ty_155 = 64;
pub const kAUGroupParameterID_Sostenuto: _bindgen_ty_155 = 66;
pub const kAUGroupParameterID_AllNotesOff: _bindgen_ty_155 = 123;
pub const kAUGroupParameterID_ModWheel: _bindgen_ty_155 = 1;
pub const kAUGroupParameterID_PitchBend: _bindgen_ty_155 = 224;
pub const kAUGroupParameterID_AllSoundOff: _bindgen_ty_155 = 120;
pub const kAUGroupParameterID_ResetAllControllers: _bindgen_ty_155 = 121;
pub const kAUGroupParameterID_Pan: _bindgen_ty_155 = 10;
pub const kAUGroupParameterID_Foot: _bindgen_ty_155 = 4;
pub const kAUGroupParameterID_ChannelPressure: _bindgen_ty_155 = 208;
pub const kAUGroupParameterID_KeyPressure: _bindgen_ty_155 = 160;
pub const kAUGroupParameterID_Expression: _bindgen_ty_155 = 11;
pub const kAUGroupParameterID_DataEntry: _bindgen_ty_155 = 6;
pub const kAUGroupParameterID_Volume_LSB: _bindgen_ty_155 = 39;
pub const kAUGroupParameterID_ModWheel_LSB: _bindgen_ty_155 = 33;
pub const kAUGroupParameterID_Pan_LSB: _bindgen_ty_155 = 42;
pub const kAUGroupParameterID_Foot_LSB: _bindgen_ty_155 = 36;
pub const kAUGroupParameterID_Expression_LSB: _bindgen_ty_155 = 43;
pub const kAUGroupParameterID_DataEntry_LSB: _bindgen_ty_155 = 38;
pub const kAUGroupParameterID_KeyPressure_FirstKey: _bindgen_ty_155 = 256;
pub const kAUGroupParameterID_KeyPressure_LastKey: _bindgen_ty_155 = 383;
pub type _bindgen_ty_155 = u32;
pub const kPannerParam_Gain: _bindgen_ty_156 = 0;
pub const kPannerParam_Azimuth: _bindgen_ty_156 = 1;
pub const kPannerParam_Elevation: _bindgen_ty_156 = 2;
pub const kPannerParam_Distance: _bindgen_ty_156 = 3;
pub const kPannerParam_CoordScale: _bindgen_ty_156 = 4;
pub const kPannerParam_RefDistance: _bindgen_ty_156 = 5;
pub type _bindgen_ty_156 = u32;
pub const kSpatialMixerParam_Azimuth: _bindgen_ty_157 = 0;
pub const kSpatialMixerParam_Elevation: _bindgen_ty_157 = 1;
pub const kSpatialMixerParam_Distance: _bindgen_ty_157 = 2;
pub const kSpatialMixerParam_Gain: _bindgen_ty_157 = 3;
pub const kSpatialMixerParam_PlaybackRate: _bindgen_ty_157 = 4;
pub const kSpatialMixerParam_Enable: _bindgen_ty_157 = 5;
pub const kSpatialMixerParam_MinGain: _bindgen_ty_157 = 6;
pub const kSpatialMixerParam_MaxGain: _bindgen_ty_157 = 7;
pub const kSpatialMixerParam_ReverbBlend: _bindgen_ty_157 = 8;
pub const kSpatialMixerParam_GlobalReverbGain: _bindgen_ty_157 = 9;
pub const kSpatialMixerParam_OcclusionAttenuation: _bindgen_ty_157 = 10;
pub const kSpatialMixerParam_ObstructionAttenuation: _bindgen_ty_157 = 11;
pub type _bindgen_ty_157 = u32;
pub const kReverbParam_FilterFrequency: _bindgen_ty_158 = 14;
pub const kReverbParam_FilterBandwidth: _bindgen_ty_158 = 15;
pub const kReverbParam_FilterGain: _bindgen_ty_158 = 16;
pub const kReverbParam_FilterType: _bindgen_ty_158 = 17;
pub const kReverbParam_FilterEnable: _bindgen_ty_158 = 18;
pub type _bindgen_ty_158 = u32;
pub const k3DMixerParam_Azimuth: _bindgen_ty_159 = 0;
pub const k3DMixerParam_Elevation: _bindgen_ty_159 = 1;
pub const k3DMixerParam_Distance: _bindgen_ty_159 = 2;
pub const k3DMixerParam_Gain: _bindgen_ty_159 = 3;
pub const k3DMixerParam_PlaybackRate: _bindgen_ty_159 = 4;
pub const k3DMixerParam_ReverbBlend: _bindgen_ty_159 = 5;
pub const k3DMixerParam_GlobalReverbGain: _bindgen_ty_159 = 6;
pub const k3DMixerParam_OcclusionAttenuation: _bindgen_ty_159 = 7;
pub const k3DMixerParam_ObstructionAttenuation: _bindgen_ty_159 = 8;
pub const k3DMixerParam_MinGain: _bindgen_ty_159 = 9;
pub const k3DMixerParam_MaxGain: _bindgen_ty_159 = 10;
pub const k3DMixerParam_PreAveragePower: _bindgen_ty_159 = 1000;
pub const k3DMixerParam_PrePeakHoldLevel: _bindgen_ty_159 = 2000;
pub const k3DMixerParam_PostAveragePower: _bindgen_ty_159 = 3000;
pub const k3DMixerParam_PostPeakHoldLevel: _bindgen_ty_159 = 4000;
pub type _bindgen_ty_159 = u32;
pub const kMultiChannelMixerParam_Volume: _bindgen_ty_160 = 0;
pub const kMultiChannelMixerParam_Enable: _bindgen_ty_160 = 1;
pub const kMultiChannelMixerParam_Pan: _bindgen_ty_160 = 2;
pub const kMultiChannelMixerParam_PreAveragePower: _bindgen_ty_160 = 1000;
pub const kMultiChannelMixerParam_PrePeakHoldLevel: _bindgen_ty_160 = 2000;
pub const kMultiChannelMixerParam_PostAveragePower: _bindgen_ty_160 = 3000;
pub const kMultiChannelMixerParam_PostPeakHoldLevel: _bindgen_ty_160 = 4000;
pub type _bindgen_ty_160 = u32;
pub const kMatrixMixerParam_Volume: _bindgen_ty_161 = 0;
pub const kMatrixMixerParam_Enable: _bindgen_ty_161 = 1;
pub const kMatrixMixerParam_PreAveragePower: _bindgen_ty_161 = 1000;
pub const kMatrixMixerParam_PrePeakHoldLevel: _bindgen_ty_161 = 2000;
pub const kMatrixMixerParam_PostAveragePower: _bindgen_ty_161 = 3000;
pub const kMatrixMixerParam_PostPeakHoldLevel: _bindgen_ty_161 = 4000;
pub const kMatrixMixerParam_PreAveragePowerLinear: _bindgen_ty_161 = 5000;
pub const kMatrixMixerParam_PrePeakHoldLevelLinear: _bindgen_ty_161 = 6000;
pub const kMatrixMixerParam_PostAveragePowerLinear: _bindgen_ty_161 = 7000;
pub const kMatrixMixerParam_PostPeakHoldLevelLinear: _bindgen_ty_161 = 8000;
pub type _bindgen_ty_161 = u32;
pub const kHALOutputParam_Volume: _bindgen_ty_162 = 14;
pub type _bindgen_ty_162 = u32;
pub const kTimePitchParam_Rate: _bindgen_ty_163 = 0;
pub const kTimePitchParam_Pitch: _bindgen_ty_163 = 1;
pub const kTimePitchParam_EffectBlend: _bindgen_ty_163 = 2;
pub type _bindgen_ty_163 = u32;
pub const kNewTimePitchParam_Rate: _bindgen_ty_164 = 0;
pub const kNewTimePitchParam_Pitch: _bindgen_ty_164 = 1;
pub const kNewTimePitchParam_Overlap: _bindgen_ty_164 = 4;
pub const kNewTimePitchParam_EnablePeakLocking: _bindgen_ty_164 = 6;
pub type _bindgen_ty_164 = u32;
pub const kAUSamplerParam_Gain: _bindgen_ty_165 = 900;
pub const kAUSamplerParam_CoarseTuning: _bindgen_ty_165 = 901;
pub const kAUSamplerParam_FineTuning: _bindgen_ty_165 = 902;
pub const kAUSamplerParam_Pan: _bindgen_ty_165 = 903;
pub type _bindgen_ty_165 = u32;
pub const kBandpassParam_CenterFrequency: _bindgen_ty_166 = 0;
pub const kBandpassParam_Bandwidth: _bindgen_ty_166 = 1;
pub type _bindgen_ty_166 = u32;
pub const kHipassParam_CutoffFrequency: _bindgen_ty_167 = 0;
pub const kHipassParam_Resonance: _bindgen_ty_167 = 1;
pub type _bindgen_ty_167 = u32;
pub const kLowPassParam_CutoffFrequency: _bindgen_ty_168 = 0;
pub const kLowPassParam_Resonance: _bindgen_ty_168 = 1;
pub type _bindgen_ty_168 = u32;
pub const kHighShelfParam_CutOffFrequency: _bindgen_ty_169 = 0;
pub const kHighShelfParam_Gain: _bindgen_ty_169 = 1;
pub type _bindgen_ty_169 = u32;
pub const kAULowShelfParam_CutoffFrequency: _bindgen_ty_170 = 0;
pub const kAULowShelfParam_Gain: _bindgen_ty_170 = 1;
pub type _bindgen_ty_170 = u32;
pub const kParametricEQParam_CenterFreq: _bindgen_ty_171 = 0;
pub const kParametricEQParam_Q: _bindgen_ty_171 = 1;
pub const kParametricEQParam_Gain: _bindgen_ty_171 = 2;
pub type _bindgen_ty_171 = u32;
pub const kLimiterParam_AttackTime: _bindgen_ty_172 = 0;
pub const kLimiterParam_DecayTime: _bindgen_ty_172 = 1;
pub const kLimiterParam_PreGain: _bindgen_ty_172 = 2;
pub type _bindgen_ty_172 = u32;
pub const kDynamicsProcessorParam_Threshold: _bindgen_ty_173 = 0;
pub const kDynamicsProcessorParam_HeadRoom: _bindgen_ty_173 = 1;
pub const kDynamicsProcessorParam_ExpansionRatio: _bindgen_ty_173 = 2;
pub const kDynamicsProcessorParam_ExpansionThreshold: _bindgen_ty_173 = 3;
pub const kDynamicsProcessorParam_AttackTime: _bindgen_ty_173 = 4;
pub const kDynamicsProcessorParam_ReleaseTime: _bindgen_ty_173 = 5;
pub const kDynamicsProcessorParam_MasterGain: _bindgen_ty_173 = 6;
pub const kDynamicsProcessorParam_CompressionAmount: _bindgen_ty_173 = 1000;
pub const kDynamicsProcessorParam_InputAmplitude: _bindgen_ty_173 = 2000;
pub const kDynamicsProcessorParam_OutputAmplitude: _bindgen_ty_173 = 3000;
pub type _bindgen_ty_173 = u32;
pub const kVarispeedParam_PlaybackRate: _bindgen_ty_174 = 0;
pub const kVarispeedParam_PlaybackCents: _bindgen_ty_174 = 1;
pub type _bindgen_ty_174 = u32;
pub const kDistortionParam_Delay: _bindgen_ty_175 = 0;
pub const kDistortionParam_Decay: _bindgen_ty_175 = 1;
pub const kDistortionParam_DelayMix: _bindgen_ty_175 = 2;
pub const kDistortionParam_Decimation: _bindgen_ty_175 = 3;
pub const kDistortionParam_Rounding: _bindgen_ty_175 = 4;
pub const kDistortionParam_DecimationMix: _bindgen_ty_175 = 5;
pub const kDistortionParam_LinearTerm: _bindgen_ty_175 = 6;
pub const kDistortionParam_SquaredTerm: _bindgen_ty_175 = 7;
pub const kDistortionParam_CubicTerm: _bindgen_ty_175 = 8;
pub const kDistortionParam_PolynomialMix: _bindgen_ty_175 = 9;
pub const kDistortionParam_RingModFreq1: _bindgen_ty_175 = 10;
pub const kDistortionParam_RingModFreq2: _bindgen_ty_175 = 11;
pub const kDistortionParam_RingModBalance: _bindgen_ty_175 = 12;
pub const kDistortionParam_RingModMix: _bindgen_ty_175 = 13;
pub const kDistortionParam_SoftClipGain: _bindgen_ty_175 = 14;
pub const kDistortionParam_FinalMix: _bindgen_ty_175 = 15;
pub type _bindgen_ty_175 = u32;
pub const kDelayParam_WetDryMix: _bindgen_ty_176 = 0;
pub const kDelayParam_DelayTime: _bindgen_ty_176 = 1;
pub const kDelayParam_Feedback: _bindgen_ty_176 = 2;
pub const kDelayParam_LopassCutoff: _bindgen_ty_176 = 3;
pub type _bindgen_ty_176 = u32;
pub const kAUNBandEQParam_GlobalGain: _bindgen_ty_177 = 0;
pub const kAUNBandEQParam_BypassBand: _bindgen_ty_177 = 1000;
pub const kAUNBandEQParam_FilterType: _bindgen_ty_177 = 2000;
pub const kAUNBandEQParam_Frequency: _bindgen_ty_177 = 3000;
pub const kAUNBandEQParam_Gain: _bindgen_ty_177 = 4000;
pub const kAUNBandEQParam_Bandwidth: _bindgen_ty_177 = 5000;
pub type _bindgen_ty_177 = u32;
pub const kAUNBandEQFilterType_Parametric: _bindgen_ty_178 = 0;
pub const kAUNBandEQFilterType_2ndOrderButterworthLowPass: _bindgen_ty_178 = 1;
pub const kAUNBandEQFilterType_2ndOrderButterworthHighPass: _bindgen_ty_178 = 2;
pub const kAUNBandEQFilterType_ResonantLowPass: _bindgen_ty_178 = 3;
pub const kAUNBandEQFilterType_ResonantHighPass: _bindgen_ty_178 = 4;
pub const kAUNBandEQFilterType_BandPass: _bindgen_ty_178 = 5;
pub const kAUNBandEQFilterType_BandStop: _bindgen_ty_178 = 6;
pub const kAUNBandEQFilterType_LowShelf: _bindgen_ty_178 = 7;
pub const kAUNBandEQFilterType_HighShelf: _bindgen_ty_178 = 8;
pub const kAUNBandEQFilterType_ResonantLowShelf: _bindgen_ty_178 = 9;
pub const kAUNBandEQFilterType_ResonantHighShelf: _bindgen_ty_178 = 10;
pub const kNumAUNBandEQFilterTypes: _bindgen_ty_178 = 11;
pub type _bindgen_ty_178 = u32;
pub const kRoundTripAACParam_Format: _bindgen_ty_179 = 0;
pub const kRoundTripAACParam_EncodingStrategy: _bindgen_ty_179 = 1;
pub const kRoundTripAACParam_RateOrQuality: _bindgen_ty_179 = 2;
pub const kRoundTripAACParam_BitRate: _bindgen_ty_179 = 1;
pub const kRoundTripAACParam_Quality: _bindgen_ty_179 = 2;
pub const kRoundTripAACParam_CompressedFormatSampleRate: _bindgen_ty_179 = 3;
pub type _bindgen_ty_179 = u32;
pub const kGraphicEQParam_NumberOfBands: _bindgen_ty_180 = 10000;
pub type _bindgen_ty_180 = u32;
pub const kReverbParam_DryWetMix: _bindgen_ty_181 = 0;
pub const kReverbParam_SmallLargeMix: _bindgen_ty_181 = 1;
pub const kReverbParam_SmallSize: _bindgen_ty_181 = 2;
pub const kReverbParam_LargeSize: _bindgen_ty_181 = 3;
pub const kReverbParam_PreDelay: _bindgen_ty_181 = 4;
pub const kReverbParam_LargeDelay: _bindgen_ty_181 = 5;
pub const kReverbParam_SmallDensity: _bindgen_ty_181 = 6;
pub const kReverbParam_LargeDensity: _bindgen_ty_181 = 7;
pub const kReverbParam_LargeDelayRange: _bindgen_ty_181 = 8;
pub const kReverbParam_SmallBrightness: _bindgen_ty_181 = 9;
pub const kReverbParam_LargeBrightness: _bindgen_ty_181 = 10;
pub const kReverbParam_SmallDelayRange: _bindgen_ty_181 = 11;
pub const kReverbParam_ModulationRate: _bindgen_ty_181 = 12;
pub const kReverbParam_ModulationDepth: _bindgen_ty_181 = 13;
pub type _bindgen_ty_181 = u32;
pub const kMultibandCompressorParam_Pregain: _bindgen_ty_182 = 0;
pub const kMultibandCompressorParam_Postgain: _bindgen_ty_182 = 1;
pub const kMultibandCompressorParam_Crossover1: _bindgen_ty_182 = 2;
pub const kMultibandCompressorParam_Crossover2: _bindgen_ty_182 = 3;
pub const kMultibandCompressorParam_Crossover3: _bindgen_ty_182 = 4;
pub const kMultibandCompressorParam_Threshold1: _bindgen_ty_182 = 5;
pub const kMultibandCompressorParam_Threshold2: _bindgen_ty_182 = 6;
pub const kMultibandCompressorParam_Threshold3: _bindgen_ty_182 = 7;
pub const kMultibandCompressorParam_Threshold4: _bindgen_ty_182 = 8;
pub const kMultibandCompressorParam_Headroom1: _bindgen_ty_182 = 9;
pub const kMultibandCompressorParam_Headroom2: _bindgen_ty_182 = 10;
pub const kMultibandCompressorParam_Headroom3: _bindgen_ty_182 = 11;
pub const kMultibandCompressorParam_Headroom4: _bindgen_ty_182 = 12;
pub const kMultibandCompressorParam_AttackTime: _bindgen_ty_182 = 13;
pub const kMultibandCompressorParam_ReleaseTime: _bindgen_ty_182 = 14;
pub const kMultibandCompressorParam_EQ1: _bindgen_ty_182 = 15;
pub const kMultibandCompressorParam_EQ2: _bindgen_ty_182 = 16;
pub const kMultibandCompressorParam_EQ3: _bindgen_ty_182 = 17;
pub const kMultibandCompressorParam_EQ4: _bindgen_ty_182 = 18;
pub const kMultibandCompressorParam_CompressionAmount1: _bindgen_ty_182 = 1000;
pub const kMultibandCompressorParam_CompressionAmount2: _bindgen_ty_182 = 2000;
pub const kMultibandCompressorParam_CompressionAmount3: _bindgen_ty_182 = 3000;
pub const kMultibandCompressorParam_CompressionAmount4: _bindgen_ty_182 = 4000;
pub const kMultibandCompressorParam_InputAmplitude1: _bindgen_ty_182 = 5000;
pub const kMultibandCompressorParam_InputAmplitude2: _bindgen_ty_182 = 6000;
pub const kMultibandCompressorParam_InputAmplitude3: _bindgen_ty_182 = 7000;
pub const kMultibandCompressorParam_InputAmplitude4: _bindgen_ty_182 = 8000;
pub const kMultibandCompressorParam_OutputAmplitude1: _bindgen_ty_182 = 9000;
pub const kMultibandCompressorParam_OutputAmplitude2: _bindgen_ty_182 = 10000;
pub const kMultibandCompressorParam_OutputAmplitude3: _bindgen_ty_182 = 11000;
pub const kMultibandCompressorParam_OutputAmplitude4: _bindgen_ty_182 = 12000;
pub type _bindgen_ty_182 = u32;
pub const kMultibandFilter_LowFilterType: _bindgen_ty_183 = 0;
pub const kMultibandFilter_LowFrequency: _bindgen_ty_183 = 1;
pub const kMultibandFilter_LowGain: _bindgen_ty_183 = 2;
pub const kMultibandFilter_CenterFreq1: _bindgen_ty_183 = 3;
pub const kMultibandFilter_CenterGain1: _bindgen_ty_183 = 4;
pub const kMultibandFilter_Bandwidth1: _bindgen_ty_183 = 5;
pub const kMultibandFilter_CenterFreq2: _bindgen_ty_183 = 6;
pub const kMultibandFilter_CenterGain2: _bindgen_ty_183 = 7;
pub const kMultibandFilter_Bandwidth2: _bindgen_ty_183 = 8;
pub const kMultibandFilter_CenterFreq3: _bindgen_ty_183 = 9;
pub const kMultibandFilter_CenterGain3: _bindgen_ty_183 = 10;
pub const kMultibandFilter_Bandwidth3: _bindgen_ty_183 = 11;
pub const kMultibandFilter_HighFilterType: _bindgen_ty_183 = 12;
pub const kMultibandFilter_HighFrequency: _bindgen_ty_183 = 13;
pub const kMultibandFilter_HighGain: _bindgen_ty_183 = 14;
pub type _bindgen_ty_183 = u32;
pub const kRogerBeepParam_InGateThreshold: _bindgen_ty_184 = 0;
pub const kRogerBeepParam_InGateThresholdTime: _bindgen_ty_184 = 1;
pub const kRogerBeepParam_OutGateThreshold: _bindgen_ty_184 = 2;
pub const kRogerBeepParam_OutGateThresholdTime: _bindgen_ty_184 = 3;
pub const kRogerBeepParam_Sensitivity: _bindgen_ty_184 = 4;
pub const kRogerBeepParam_RogerType: _bindgen_ty_184 = 5;
pub const kRogerBeepParam_RogerGain: _bindgen_ty_184 = 6;
pub type _bindgen_ty_184 = u32;
pub const kStereoMixerParam_Volume: _bindgen_ty_185 = 0;
pub const kStereoMixerParam_Pan: _bindgen_ty_185 = 1;
pub const kStereoMixerParam_PreAveragePower: _bindgen_ty_185 = 1000;
pub const kStereoMixerParam_PrePeakHoldLevel: _bindgen_ty_185 = 2000;
pub const kStereoMixerParam_PostAveragePower: _bindgen_ty_185 = 3000;
pub const kStereoMixerParam_PostPeakHoldLevel: _bindgen_ty_185 = 4000;
pub type _bindgen_ty_185 = u32;
pub const kAUNetReceiveParam_Status: _bindgen_ty_186 = 0;
pub const kAUNetReceiveParam_NumParameters: _bindgen_ty_186 = 1;
pub type _bindgen_ty_186 = u32;
pub const kAUNetSendParam_Status: _bindgen_ty_187 = 0;
pub const kAUNetSendParam_NumParameters: _bindgen_ty_187 = 1;
pub type _bindgen_ty_187 = u32;
pub const kAUNetStatus_NotConnected: _bindgen_ty_188 = 0;
pub const kAUNetStatus_Connected: _bindgen_ty_188 = 1;
pub const kAUNetStatus_Overflow: _bindgen_ty_188 = 2;
pub const kAUNetStatus_Underflow: _bindgen_ty_188 = 3;
pub const kAUNetStatus_Connecting: _bindgen_ty_188 = 4;
pub const kAUNetStatus_Listening: _bindgen_ty_188 = 5;
pub type _bindgen_ty_188 = u32;
pub const kMusicDeviceParam_Tuning: _bindgen_ty_189 = 0;
pub const kMusicDeviceParam_Volume: _bindgen_ty_189 = 1;
pub const kMusicDeviceParam_ReverbVolume: _bindgen_ty_189 = 2;
pub type _bindgen_ty_189 = u32;
pub const kRandomParam_BoundA: _bindgen_ty_190 = 0;
pub const kRandomParam_BoundB: _bindgen_ty_190 = 1;
pub const kRandomParam_Curve: _bindgen_ty_190 = 2;
pub type _bindgen_ty_190 = u32;
pub const kReverb2Param_DryWetMix: _bindgen_ty_191 = 0;
pub const kReverb2Param_Gain: _bindgen_ty_191 = 1;
pub const kReverb2Param_MinDelayTime: _bindgen_ty_191 = 2;
pub const kReverb2Param_MaxDelayTime: _bindgen_ty_191 = 3;
pub const kReverb2Param_DecayTimeAt0Hz: _bindgen_ty_191 = 4;
pub const kReverb2Param_DecayTimeAtNyquist: _bindgen_ty_191 = 5;
pub const kReverb2Param_RandomizeReflections: _bindgen_ty_191 = 6;
pub type _bindgen_ty_191 = u32;
///@typedef MusicDeviceInstrumentID
///@abstract type for instrument identifiers
pub type MusicDeviceInstrumentID = UInt32;
///@typedef MusicDeviceStdNoteParams
///@abstract convenience struct for specifying a note and velocity
///
///@discussion This struct is the common usage for MusicDeviceStartNote, as most synths that implement this functionality
///will only allow for the specification of a note number and velocity when starting a new note.
///
///@param			argCount
///Should be set to 2
///@param			mPitch
///The pitch of the new note, typically specified using a MIDI note number (and a fractional pitch) within the
///range of 0 < 128. So 60 is middle C, 60.5 is middle C + 50 cents.
///@param			mVelocity
///The velocity of the new note - this can be a fractional value - specified as MIDI (within the range of 0 < 128)
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MusicDeviceStdNoteParams {
    pub argCount: UInt32,
    pub mPitch: Float32,
    pub mVelocity: Float32,
}
#[test]
fn bindgen_test_layout_MusicDeviceStdNoteParams() {
    assert_eq!(
        ::std::mem::size_of::<MusicDeviceStdNoteParams>(),
        12usize,
        concat!("Size of: ", stringify!(MusicDeviceStdNoteParams))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicDeviceStdNoteParams>(),
        4usize,
        concat!("Alignment of ", stringify!(MusicDeviceStdNoteParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MusicDeviceStdNoteParams>())).argCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicDeviceStdNoteParams),
            "::",
            stringify!(argCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MusicDeviceStdNoteParams>())).mPitch as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicDeviceStdNoteParams),
            "::",
            stringify!(mPitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MusicDeviceStdNoteParams>())).mVelocity as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicDeviceStdNoteParams),
            "::",
            stringify!(mVelocity)
        )
    );
}
///@typedef NoteParamsControlValue
///@abstract used to describe a control and value
///
///@discussion This struct is used to describe a parameterID (a control in MIDI terminology, though it is not limited to
///MIDI CC specifications) and the value of this parameter.
///
///@param			mID
///The parameter ID
///@param			mValue
///The value of that parameter
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NoteParamsControlValue {
    pub mID: AudioUnitParameterID,
    pub mValue: AudioUnitParameterValue,
}
#[test]
fn bindgen_test_layout_NoteParamsControlValue() {
    assert_eq!(
        ::std::mem::size_of::<NoteParamsControlValue>(),
        8usize,
        concat!("Size of: ", stringify!(NoteParamsControlValue))
    );
    assert_eq!(
        ::std::mem::align_of::<NoteParamsControlValue>(),
        4usize,
        concat!("Alignment of ", stringify!(NoteParamsControlValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NoteParamsControlValue>())).mID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NoteParamsControlValue),
            "::",
            stringify!(mID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NoteParamsControlValue>())).mValue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NoteParamsControlValue),
            "::",
            stringify!(mValue)
        )
    );
}
///@typedef MusicDeviceNoteParams
///@abstract Used to hold the value of the inParams parameter for the MusicDeviceStartNote function.
///
///@discussion The generic version of this structure describes an arg count (which is the number of mControls values
///+ 1 for mPitch and 1 for mVelocity). So, argCount should at least be two. See MusicDeviceStdNoteParams
///for the common use case, as many audio unit instruments will not respond to control values provided
///in the start note function
///
///@param			argCount
///The number of controls + 2 (for mPitch and mVelocity)
///@param			mPitch
///The pitch of the new note, typically specified using a MIDI note number (and a fractional pitch) within the
///range of 0 < 128. So 60 is middle C, 60.5 is middle C + 50 cents.
///@param			mVelocity
///The velocity of the new note - this can be a fractional value - specified as MIDI (within the range of 0 < 128)
///@param			mControls
///A variable length array with the number of elements: argCount - 2.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MusicDeviceNoteParams {
    pub argCount: UInt32,
    pub mPitch: Float32,
    pub mVelocity: Float32,
    pub mControls: [NoteParamsControlValue; 1usize],
}
#[test]
fn bindgen_test_layout_MusicDeviceNoteParams() {
    assert_eq!(
        ::std::mem::size_of::<MusicDeviceNoteParams>(),
        20usize,
        concat!("Size of: ", stringify!(MusicDeviceNoteParams))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicDeviceNoteParams>(),
        4usize,
        concat!("Alignment of ", stringify!(MusicDeviceNoteParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MusicDeviceNoteParams>())).argCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicDeviceNoteParams),
            "::",
            stringify!(argCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MusicDeviceNoteParams>())).mPitch as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicDeviceNoteParams),
            "::",
            stringify!(mPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MusicDeviceNoteParams>())).mVelocity as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicDeviceNoteParams),
            "::",
            stringify!(mVelocity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MusicDeviceNoteParams>())).mControls as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicDeviceNoteParams),
            "::",
            stringify!(mControls)
        )
    );
}
pub const kMusicNoteEvent_UseGroupInstrument: _bindgen_ty_192 = 4294967295;
pub const kMusicNoteEvent_Unused: _bindgen_ty_192 = 4294967295;
///@enum	MusicNoteEvent
///@discussion This is used to signify that the patch used to start a note (its sound) is defined by the current
///selection for the group ID; this is the normal usage in MIDI as any notes started on a given channel
///(group ID) use the sound (patch) defined for that channel. See MusicDeviceStartNote
///
///@constant	kMusicNoteEvent_UseGroupInstrument
///Use the patch (instrument number) assigned to the new notes group ID
///@constant	kMusicNoteEvent_Unused
///The instrument ID is not specified
pub type _bindgen_ty_192 = u32;
///@typedef		MusicDeviceGroupID
///@discussion The type used to specify which group (channel number in MIDI) is used with a given command (new note,
///control or parameter value change)
pub type MusicDeviceGroupID = UInt32;
///@typedef		NoteInstanceID
///@discussion The type used to hold an unique identifier returned by MusicDeviceStartNote that is used to then address
///that note (typically to turn the note off). An ID must be used for notes, because notes can be specified
///by fractional pitches, and so using the MIDI note number is not sufficient to identify the note to turn
///it off (or to apply polyphonic after touch).
pub type NoteInstanceID = UInt32;
///@typedef		MusicDeviceComponent
///@discussion	The unique type of a MusicDevice audio unit (which is an AudioComponentInstance)
pub type MusicDeviceComponent = AudioComponentInstance;
extern "C" {
    ///@function	MusicDeviceMIDIEvent
    ///@abstract	Used to sent MIDI channel messages to an audio unit
    ///
    ///@discussion	This is the API used to send MIDI channel messages to an audio unit. The status and data parameters
    ///are used exactly as described by the MIDI specification, including the combination of channel and
    ///command in the status byte.
    ///
    ///@param			inUnit
    ///The audio unit
    ///@param			inStatus
    ///The MIDI status byte
    ///@param			inData1
    ///The first MIDI data byte (value is in the range 0 < 128)
    ///@param			inData2
    ///The second MIDI data byte (value is in the range 0 < 128). If the MIDI status byte only has one
    ///data byte, this should be set to zero.
    ///@param			inOffsetSampleFrame
    ///If you are scheduling the MIDI Event from the audio unit's render thread, then you can supply a
    ///sample offset that the audio unit may apply when applying that event in its next audio unit render.
    ///This allows you to schedule to the sample, the time when a MIDI command is applied and is particularly
    ///important when starting new notes. If you are not scheduling in the audio unit's render thread,
    ///then you should set this value to 0
    ///
    ///@result			noErr, or an audio unit error code
    pub fn MusicDeviceMIDIEvent(
        inUnit: MusicDeviceComponent,
        inStatus: UInt32,
        inData1: UInt32,
        inData2: UInt32,
        inOffsetSampleFrame: UInt32,
    ) -> OSStatus;
}
extern "C" {
    ///@function	MusicDeviceSysEx
    ///@abstract	used to send any non-channel MIDI event to an audio unit
    ///
    ///@discussion	This is used to send any non-channel MIDI event to an audio unit. In practise this is a System Exclusive
    ///(SysEx) MIDI message
    ///
    ///@param			inUnit
    ///The audio unit
    ///@param			inData
    ///The complete MIDI SysEx message including the F0 and F7 start and termination bytes
    ///@param			inLength
    ///The size, in bytes, of the data
    ///
    ///@result			noErr, or an audio unit error code
    pub fn MusicDeviceSysEx(
        inUnit: MusicDeviceComponent,
        inData: *const UInt8,
        inLength: UInt32,
    ) -> OSStatus;
}
extern "C" {
    ///@function	MusicDeviceStartNote
    ///@abstract	used to start a note
    ///
    ///@discussion	This function is used to start a note.  The caller must provide a NoteInstanceID to receive a
    ///token that is then used to stop the note. The MusicDeviceStopNote call should be used to stop
    ///notes started with this API. The token can also be used to address individual notes on the
    ///kAudioUnitScope_Note if the audio unit supports it. The instrumentID is no longer used and the
    ///kMusicNoteEvent_Unused constant should be specified (this takes the current patch for the
    ///specifed group as the sound to use for the note).
    ///
    ///The Audio unit must provide an unique ID for the note instance ID. This ID must be non-zero and not
    ///0xFFFFFFFF (any other UInt32 value is valid).
    ///
    ///Not all Music Device audio units implement the semantics of this API (though it is strongly recommended
    ///that they do). A host application shoudl query the kMusicDeviceProperty_SupportsStartStopNote to
    ///check that this is supported.
    ///
    ///@param			inUnit
    ///The audio unit
    ///@param			inInstrument
    ///The instrumentID is no longer used and the kMusicNoteEvent_Unused constant should be specified (this takes
    ///the current patch for the specifed group as the sound to use for the note)
    ///@param			inGroupID
    ///The group ID that this note will be attached too. As with MIDI, all notes sounding on a groupID can be
    ///controlled through the various parameters (such as pitch bend, etc) that can be specified on the Group
    ///Scope
    ///@param			outNoteInstanceID
    ///A pointer to receive the token that is used to identify the note. This parameter must be specified
    ///@param			inOffsetSampleFrame
    ///If you are scheduling the MIDI Event from the audio unit's render thread, then you can supply a sample offset
    ///that the audio unit may apply when starting the note in its next audio unit render. This allows you to
    ///schedule to the sample and is particularly important when starting new notes. If you are not scheduling
    ///in the audio unit's render thread, then you should set this value to 0
    ///@param			inParams
    ///The parameters to be used when starting the note - pitch and velocity must be specified
    ///
    ///@result			noErr, or an audio unit error code
    pub fn MusicDeviceStartNote(
        inUnit: MusicDeviceComponent,
        inInstrument: MusicDeviceInstrumentID,
        inGroupID: MusicDeviceGroupID,
        outNoteInstanceID: *mut NoteInstanceID,
        inOffsetSampleFrame: UInt32,
        inParams: *const MusicDeviceNoteParams,
    ) -> OSStatus;
}
extern "C" {
    ///@function	MusicDeviceStopNote
    ///@abstract	used to stop notes started with the MusicDeviceStartNote call
    ///
    ///@discussion	This call is used to stop notes that have been started with the MusicDeviceStartNote call; both the group ID
    ///that the note was started on and the noteInstanceID should be specified.
    ///
    ///@param			inUnit
    ///The audio unit
    ///@param			inGroupID
    ///the group ID
    ///@param			inNoteInstanceID
    ///the note instance ID
    ///@param			inOffsetSampleFrame
    ///the sample offset within the next buffer rendered that the note should be turned off at
    ///
    ///@result			noErr, or an audio unit error code
    pub fn MusicDeviceStopNote(
        inUnit: MusicDeviceComponent,
        inGroupID: MusicDeviceGroupID,
        inNoteInstanceID: NoteInstanceID,
        inOffsetSampleFrame: UInt32,
    ) -> OSStatus;
}
pub const kMusicDeviceRange: _bindgen_ty_193 = 256;
pub const kMusicDeviceMIDIEventSelect: _bindgen_ty_193 = 257;
pub const kMusicDeviceSysExSelect: _bindgen_ty_193 = 258;
pub const kMusicDevicePrepareInstrumentSelect: _bindgen_ty_193 = 259;
pub const kMusicDeviceReleaseInstrumentSelect: _bindgen_ty_193 = 260;
pub const kMusicDeviceStartNoteSelect: _bindgen_ty_193 = 261;
pub const kMusicDeviceStopNoteSelect: _bindgen_ty_193 = 262;
///@enum	Music Device range
///@constant	kMusicDeviceRange
///delineates the start of the selector ranges for music devices
///
///@constant	kMusicDeviceMIDIEventSelect
///@constant	kMusicDeviceSysExSelect
///@constant	kMusicDevicePrepareInstrumentSelect
///@constant	kMusicDeviceReleaseInstrumentSelect
///@constant	kMusicDeviceStartNoteSelect
///@constant	kMusicDeviceStopNoteSelect
pub type _bindgen_ty_193 = u32;
///@typedef		MusicDeviceMIDIEventProc
///@discussion		This proc can be exported through the FastDispatch property or is used as the prototype for
///an audio component dispatch for this selector.
///
///The arguments are the same as are provided to the corresponding API call
///
///@param			self
///For a component manager component, this is the component instance storage pointer
///@param			inStatus
///@param			inData1
///@param			inData2
///@param			inOffsetSampleFrame
///
///@result			noErr, or an audio unit error code
pub type MusicDeviceMIDIEventProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        inStatus: UInt32,
        inData1: UInt32,
        inData2: UInt32,
        inOffsetSampleFrame: UInt32,
    ) -> OSStatus,
>;
///@typedef		MusicDeviceSysExProc
///@discussion		This proc can be exported through the FastDispatch property or is used as the prototype for
///an audio component dispatch for this selector.
///
///The arguments are the same as are provided to the corresponding API call
///
///@param			self
///For a component manager component, this is the component instance storage pointer
///@param			inData
///@param			inLength
///
///@result			noErr, or an audio unit error code
pub type MusicDeviceSysExProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        inData: *const UInt8,
        inLength: UInt32,
    ) -> OSStatus,
>;
///@typedef		MusicDeviceStartNoteProc
///@discussion		This proc can be exported through the FastDispatch property or is used as the prototype for
///an audio component dispatch for this selector.
///
///The arguments are the same as are provided to the corresponding API call
///
///@param			self
///For a component manager component, this is the component instance storage pointer
///@param			inInstrument
///@param			inGroupID
///@param			outNoteInstanceID
///@param			inOffsetSampleFrame
///@param			inParams
///
///@result			noErr, or an audio unit error code
pub type MusicDeviceStartNoteProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        inInstrument: MusicDeviceInstrumentID,
        inGroupID: MusicDeviceGroupID,
        outNoteInstanceID: *mut NoteInstanceID,
        inOffsetSampleFrame: UInt32,
        inParams: *const MusicDeviceNoteParams,
    ) -> OSStatus,
>;
///@typedef		MusicDeviceStopNoteProc
///@discussion		This proc can be exported through the FastDispatch property or is used as the prototype for
///an audio component dispatch for this selector.
///
///The arguments are the same as are provided to the corresponding API call
///
///@param			self
///For a component manager component, this is the component instance storage pointer
///@param			inGroupID
///@param			inNoteInstanceID
///@param			inOffsetSampleFrame
///
///@result			noErr, or an audio unit error code
pub type MusicDeviceStopNoteProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        inGroupID: MusicDeviceGroupID,
        inNoteInstanceID: NoteInstanceID,
        inOffsetSampleFrame: UInt32,
    ) -> OSStatus,
>;
extern "C" {
    pub fn MusicDevicePrepareInstrument(
        inUnit: MusicDeviceComponent,
        inInstrument: MusicDeviceInstrumentID,
    ) -> OSStatus;
}
extern "C" {
    pub fn MusicDeviceReleaseInstrument(
        inUnit: MusicDeviceComponent,
        inInstrument: MusicDeviceInstrumentID,
    ) -> OSStatus;
}
pub type AudioCodec = AudioComponentInstance;
pub type AudioCodecPropertyID = UInt32;
///@struct AudioCodecMagicCookieInfo
///
///@abstract Structure holding the <em>magic cookie</em> information.
///
///@discussion Passed as input to AudioCodecGetProperty for kAudioCodecPropertyFormatList.
///The first four + sizeof(void *) bytes of the buffer pointed at by outPropertyData
///will contain this struct.
///
///@field mMagicCookieSize
///The size of the magic cookie
///@field mMagicCookie
///Generic const pointer to magic cookie
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioCodecMagicCookieInfo {
    pub mMagicCookieSize: UInt32,
    pub mMagicCookie: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_AudioCodecMagicCookieInfo() {
    assert_eq!(
        ::std::mem::size_of::<AudioCodecMagicCookieInfo>(),
        16usize,
        concat!("Size of: ", stringify!(AudioCodecMagicCookieInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioCodecMagicCookieInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioCodecMagicCookieInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioCodecMagicCookieInfo>())).mMagicCookieSize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioCodecMagicCookieInfo),
            "::",
            stringify!(mMagicCookieSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioCodecMagicCookieInfo>())).mMagicCookie as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioCodecMagicCookieInfo),
            "::",
            stringify!(mMagicCookie)
        )
    );
}
impl Default for AudioCodecMagicCookieInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const kAudioDecoderComponentType: _bindgen_ty_194 = 1633969507;
pub const kAudioEncoderComponentType: _bindgen_ty_194 = 1634037347;
pub const kAudioUnityCodecComponentType: _bindgen_ty_194 = 1633903715;
pub type _bindgen_ty_194 = u32;
pub const kAudioCodecPropertySupportedInputFormats: _bindgen_ty_195 = 1768320291;
pub const kAudioCodecPropertySupportedOutputFormats: _bindgen_ty_195 = 1868983587;
pub const kAudioCodecPropertyAvailableInputSampleRates: _bindgen_ty_195 = 1634300786;
pub const kAudioCodecPropertyAvailableOutputSampleRates: _bindgen_ty_195 = 1634694002;
pub const kAudioCodecPropertyAvailableBitRateRange: _bindgen_ty_195 = 1633841780;
pub const kAudioCodecPropertyMinimumNumberInputPackets: _bindgen_ty_195 = 1835952496;
pub const kAudioCodecPropertyMinimumNumberOutputPackets: _bindgen_ty_195 = 1835954032;
pub const kAudioCodecPropertyAvailableNumberChannels: _bindgen_ty_195 = 1668116067;
pub const kAudioCodecPropertyDoesSampleRateConversion: _bindgen_ty_195 = 1819112035;
pub const kAudioCodecPropertyAvailableInputChannelLayoutTags: _bindgen_ty_195 = 1634296684;
pub const kAudioCodecPropertyAvailableOutputChannelLayoutTags: _bindgen_ty_195 = 1634689900;
pub const kAudioCodecPropertyInputFormatsForOutputFormat: _bindgen_ty_195 = 1768305775;
pub const kAudioCodecPropertyOutputFormatsForInputFormat: _bindgen_ty_195 = 1868969065;
pub const kAudioCodecPropertyFormatInfo: _bindgen_ty_195 = 1633904233;
pub type _bindgen_ty_195 = u32;
pub const kAudioCodecPropertyInputBufferSize: _bindgen_ty_196 = 1952609638;
pub const kAudioCodecPropertyPacketFrameSize: _bindgen_ty_196 = 1885432678;
pub const kAudioCodecPropertyHasVariablePacketByteSizes: _bindgen_ty_196 = 1987078975;
pub const kAudioCodecPropertyMaximumPacketByteSize: _bindgen_ty_196 = 1885432674;
pub const kAudioCodecPropertyPacketSizeLimitForVBR: _bindgen_ty_196 = 1885432684;
pub const kAudioCodecPropertyCurrentInputFormat: _bindgen_ty_196 = 1768320372;
pub const kAudioCodecPropertyCurrentOutputFormat: _bindgen_ty_196 = 1868983668;
pub const kAudioCodecPropertyMagicCookie: _bindgen_ty_196 = 1802857321;
pub const kAudioCodecPropertyUsedInputBufferSize: _bindgen_ty_196 = 1969386854;
pub const kAudioCodecPropertyIsInitialized: _bindgen_ty_196 = 1768843636;
pub const kAudioCodecPropertyCurrentTargetBitRate: _bindgen_ty_196 = 1651663220;
pub const kAudioCodecPropertyCurrentInputSampleRate: _bindgen_ty_196 = 1667855218;
pub const kAudioCodecPropertyCurrentOutputSampleRate: _bindgen_ty_196 = 1668248434;
pub const kAudioCodecPropertyQualitySetting: _bindgen_ty_196 = 1936876401;
pub const kAudioCodecPropertyApplicableBitRateRange: _bindgen_ty_196 = 1651668065;
pub const kAudioCodecPropertyRecommendedBitRateRange: _bindgen_ty_196 = 1651668082;
pub const kAudioCodecPropertyApplicableInputSampleRates: _bindgen_ty_196 = 1769173601;
pub const kAudioCodecPropertyApplicableOutputSampleRates: _bindgen_ty_196 = 1869836897;
pub const kAudioCodecPropertyPaddedZeros: _bindgen_ty_196 = 1885430832;
pub const kAudioCodecPropertyPrimeMethod: _bindgen_ty_196 = 1886547309;
pub const kAudioCodecPropertyPrimeInfo: _bindgen_ty_196 = 1886546285;
pub const kAudioCodecPropertyCurrentInputChannelLayout: _bindgen_ty_196 = 1768123424;
pub const kAudioCodecPropertyCurrentOutputChannelLayout: _bindgen_ty_196 = 1868786720;
pub const kAudioCodecPropertySettings: _bindgen_ty_196 = 1633907488;
pub const kAudioCodecPropertyFormatList: _bindgen_ty_196 = 1633904236;
pub const kAudioCodecPropertyBitRateControlMode: _bindgen_ty_196 = 1633903206;
pub const kAudioCodecPropertySoundQualityForVBR: _bindgen_ty_196 = 1986163313;
pub const kAudioCodecPropertyDelayMode: _bindgen_ty_196 = 1684893540;
pub const kAudioCodecPropertyAdjustLocalQuality: _bindgen_ty_196 = 1584488812;
pub const kAudioCodecPropertyProgramTargetLevel: _bindgen_ty_196 = 1886418028;
pub const kAudioCodecPropertyDynamicRangeControlMode: _bindgen_ty_196 = 1835299427;
pub const kAudioCodecPropertyProgramTargetLevelConstant: _bindgen_ty_196 = 1886678115;
pub type _bindgen_ty_196 = u32;
pub const kAudioCodecQuality_Max: _bindgen_ty_197 = 127;
pub const kAudioCodecQuality_High: _bindgen_ty_197 = 96;
pub const kAudioCodecQuality_Medium: _bindgen_ty_197 = 64;
pub const kAudioCodecQuality_Low: _bindgen_ty_197 = 32;
pub const kAudioCodecQuality_Min: _bindgen_ty_197 = 0;
pub type _bindgen_ty_197 = u32;
pub const kAudioCodecPrimeMethod_Pre: _bindgen_ty_198 = 0;
pub const kAudioCodecPrimeMethod_Normal: _bindgen_ty_198 = 1;
pub const kAudioCodecPrimeMethod_None: _bindgen_ty_198 = 2;
pub type _bindgen_ty_198 = u32;
pub const kAudioCodecBitRateControlMode_Constant: _bindgen_ty_199 = 0;
pub const kAudioCodecBitRateControlMode_LongTermAverage: _bindgen_ty_199 = 1;
pub const kAudioCodecBitRateControlMode_VariableConstrained: _bindgen_ty_199 = 2;
pub const kAudioCodecBitRateControlMode_Variable: _bindgen_ty_199 = 3;
pub type _bindgen_ty_199 = u32;
pub const kAudioCodecDelayMode_Compatibility: _bindgen_ty_200 = 0;
pub const kAudioCodecDelayMode_Minimum: _bindgen_ty_200 = 1;
pub const kAudioCodecDelayMode_Optimal: _bindgen_ty_200 = 2;
pub type _bindgen_ty_200 = u32;
pub const kProgramTargetLevel_None: _bindgen_ty_201 = 0;
pub const kProgramTargetLevel_Minus31dB: _bindgen_ty_201 = 1;
pub const kProgramTargetLevel_Minus23dB: _bindgen_ty_201 = 2;
pub const kProgramTargetLevel_Minus20dB: _bindgen_ty_201 = 3;
pub type _bindgen_ty_201 = u32;
pub const kDynamicRangeControlMode_None: _bindgen_ty_202 = 0;
pub const kDynamicRangeControlMode_Light: _bindgen_ty_202 = 1;
pub const kDynamicRangeControlMode_Heavy: _bindgen_ty_202 = 2;
pub type _bindgen_ty_202 = u32;
///@struct			AudioCodecPrimeInfo
///
///@discussion		Specifies the number of leading and trailing empty frames
///which have to be inserted.
///
///@field			leadingFrames
///An unsigned integer specifying the number of leading empty frames
///@field			trailingFrames
///An unsigned integer specifying the number of trailing empty frames
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioCodecPrimeInfo {
    pub leadingFrames: UInt32,
    pub trailingFrames: UInt32,
}
#[test]
fn bindgen_test_layout_AudioCodecPrimeInfo() {
    assert_eq!(
        ::std::mem::size_of::<AudioCodecPrimeInfo>(),
        8usize,
        concat!("Size of: ", stringify!(AudioCodecPrimeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioCodecPrimeInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioCodecPrimeInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioCodecPrimeInfo>())).leadingFrames as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioCodecPrimeInfo),
            "::",
            stringify!(leadingFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioCodecPrimeInfo>())).trailingFrames as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioCodecPrimeInfo),
            "::",
            stringify!(trailingFrames)
        )
    );
}
///@enum			AudioSettingsFlags
///
///@discussion		Constants to be used with kAudioSettings_Hint
///in the kAudioCodecPropertySettings property dictionary.
///Indicates any special characteristics of each parameter within the dictionary,
///
///@constant		kAudioSettingsFlags_ExpertParameter
///If set, then the parameter is an expert parameter.
///@constant		kAudioSettingsFlags_InvisibleParameter
///If set, then the parameter should not be displayed.
///@constant		kAudioSettingsFlags_MetaParameter
///If set, then changing this parameter may affect the values of other parameters.
///If not set, then this parameter can be set without affecting the values of other parameters.
///@constant		kAudioSettingsFlags_UserInterfaceParameter
///If set, then this is only a user interface element and not reflected in the codec's bit stream.
pub type AudioSettingsFlags = UInt32;
pub const kAudioSettingsFlags_ExpertParameter: _bindgen_ty_203 = 1;
pub const kAudioSettingsFlags_InvisibleParameter: _bindgen_ty_203 = 2;
pub const kAudioSettingsFlags_MetaParameter: _bindgen_ty_203 = 4;
pub const kAudioSettingsFlags_UserInterfaceParameter: _bindgen_ty_203 = 8;
pub type _bindgen_ty_203 = u32;
pub const kAudioCodecProduceOutputPacketFailure: _bindgen_ty_204 = 1;
pub const kAudioCodecProduceOutputPacketSuccess: _bindgen_ty_204 = 2;
pub const kAudioCodecProduceOutputPacketSuccessHasMore: _bindgen_ty_204 = 3;
pub const kAudioCodecProduceOutputPacketNeedsMoreInputData: _bindgen_ty_204 = 4;
pub const kAudioCodecProduceOutputPacketAtEOF: _bindgen_ty_204 = 5;
pub type _bindgen_ty_204 = u32;
pub const kAudioCodecGetPropertyInfoSelect: _bindgen_ty_205 = 1;
pub const kAudioCodecGetPropertySelect: _bindgen_ty_205 = 2;
pub const kAudioCodecSetPropertySelect: _bindgen_ty_205 = 3;
pub const kAudioCodecInitializeSelect: _bindgen_ty_205 = 4;
pub const kAudioCodecUninitializeSelect: _bindgen_ty_205 = 5;
pub const kAudioCodecAppendInputDataSelect: _bindgen_ty_205 = 6;
pub const kAudioCodecProduceOutputDataSelect: _bindgen_ty_205 = 7;
pub const kAudioCodecResetSelect: _bindgen_ty_205 = 8;
pub const kAudioCodecAppendInputBufferListSelect: _bindgen_ty_205 = 9;
pub const kAudioCodecProduceOutputBufferListSelect: _bindgen_ty_205 = 10;
pub type _bindgen_ty_205 = u32;
pub const kAudioCodecNoError: _bindgen_ty_206 = 0;
pub const kAudioCodecUnspecifiedError: _bindgen_ty_206 = 2003329396;
pub const kAudioCodecUnknownPropertyError: _bindgen_ty_206 = 2003332927;
pub const kAudioCodecBadPropertySizeError: _bindgen_ty_206 = 561211770;
pub const kAudioCodecIllegalOperationError: _bindgen_ty_206 = 1852797029;
pub const kAudioCodecUnsupportedFormatError: _bindgen_ty_206 = 560226676;
pub const kAudioCodecStateError: _bindgen_ty_206 = 561214580;
pub const kAudioCodecNotEnoughBufferSpaceError: _bindgen_ty_206 = 560100710;
pub const kAudioCodecBadDataError: _bindgen_ty_206 = 1650549857;
pub type _bindgen_ty_206 = u32;
extern "C" {
    ///@function		AudioCodecGetPropertyInfo
    ///
    ///@discussion		Retrieve information about the given property. The outSize argument
    ///will return the size in bytes of the current value of the property.
    ///The outWritable argument will return whether or not the property
    ///in question can be changed.
    ///
    ///@param			inCodec
    ///An AudioCodec instance
    ///@param			inPropertyID
    ///Property ID whose value should be read
    ///@param			outSize
    ///Size in bytes of the property
    ///@param			outWritable
    ///Flag indicating wether the underlying property can be modified or not
    ///
    ///@result			The OSStatus value
    pub fn AudioCodecGetPropertyInfo(
        inCodec: AudioCodec,
        inPropertyID: AudioCodecPropertyID,
        outSize: *mut UInt32,
        outWritable: *mut Boolean,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioCodecGetProperty
    ///
    ///@discussion		Retrieve the indicated property data. On input, ioDataSize has the size
    ///of the data pointed to by outPropertyData. On output, ioDataSize will contain
    ///the amount written.
    ///
    ///@param			inCodec
    ///An AudioCodec instance
    ///@param			inPropertyID
    ///Property ID whose value should be read
    ///@param			ioPropertyDataSize
    ///Size in bytes of the property data
    ///@param			outPropertyData
    ///Pointer to the property data buffer
    ///
    ///@result			The OSStatus value
    pub fn AudioCodecGetProperty(
        inCodec: AudioCodec,
        inPropertyID: AudioCodecPropertyID,
        ioPropertyDataSize: *mut UInt32,
        outPropertyData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioCodecSetProperty
    ///
    ///@discussion		Set the indicated property data.
    ///
    ///@param			inCodec
    ///An AudioCodec instance
    ///@param			inPropertyID
    ///Property ID whose value should be changed
    ///@param			inPropertyDataSize
    ///Size in bytes of the property data
    ///@param			inPropertyData
    ///Pointer to the property data buffer
    ///
    ///@result			The OSStatus value
    pub fn AudioCodecSetProperty(
        inCodec: AudioCodec,
        inPropertyID: AudioCodecPropertyID,
        inPropertyDataSize: UInt32,
        inPropertyData: *const ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioCodecInitialize
    ///
    ///@discussion		This call will allocate any buffers needed and otherwise set the codec
    ///up to perform the indicated translation. If an argument is NULL, any
    ///previously set properties will be used for preparing the codec for work.
    ///Note that this routine will also validate the format information as useable.
    ///
    ///@param			inCodec
    ///An AudioCodec instance
    ///@param			inInputFormat
    ///Pointer to an input format structure
    ///@param			inOutputFormat
    ///Pointer to an output format structure
    ///@param			inMagicCookie
    ///Pointer to the magic cookie
    ///@param			inMagicCookieByteSize
    ///Size in bytes of the magic cookie
    ///
    ///@result			The OSStatus value
    pub fn AudioCodecInitialize(
        inCodec: AudioCodec,
        inInputFormat: *const AudioStreamBasicDescription,
        inOutputFormat: *const AudioStreamBasicDescription,
        inMagicCookie: *const ::std::os::raw::c_void,
        inMagicCookieByteSize: UInt32,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioCodecUninitialize
    ///
    ///@discussion		This call will move the codec from the initialized state back to the
    ///uninitialized state. The codec will release any resources it allocated
    ///or claimed in AudioCodecInitialize.
    ///
    ///@param			inCodec
    ///An AudioCodec instance
    ///
    ///@result			The OSStatus value
    pub fn AudioCodecUninitialize(inCodec: AudioCodec) -> OSStatus;
}
extern "C" {
    ///@function		AudioCodecAppendInputData
    ///
    ///@discussion		Append as much of the given data in inInputData to the codec's input buffer as possible
    ///and return in ioInputDataByteSize the amount of data used.
    ///
    ///The inPacketDescription argument is an array of AudioStreamPacketDescription
    ///structs that describes the packet layout. The number of elements in this array
    ///is indicated on input by ioNumberPackets. On return, this number indicates the number
    ///of packets consumed.
    ///
    ///Note also in this case that it is an error to supply less than a full packet
    ///of data at a time.
    ///
    ///@param			inCodec
    ///An AudioCodec instance
    ///@param			inInputData
    ///A const pointer to the input data
    ///@param			ioInputDataByteSize
    ///The size in bytes of the input data in inInputData on input,
    ///the number of bytes consumed on output
    ///@param			ioNumberPackets
    ///The number of packets
    ///@param			inPacketDescription
    ///The packet description pointer
    ///
    ///@result			The OSStatus value
    pub fn AudioCodecAppendInputData(
        inCodec: AudioCodec,
        inInputData: *const ::std::os::raw::c_void,
        ioInputDataByteSize: *mut UInt32,
        ioNumberPackets: *mut UInt32,
        inPacketDescription: *const AudioStreamPacketDescription,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioCodecProduceOutputPackets
    ///
    ///@discussion		Produce as many output packets as requested and the amount of input data
    ///allows for. The outStatus argument returns information about the codec's
    ///status to allow for proper data management. See the constants above for
    ///the possible values that can be returned.
    ///
    ///The outPacketDescription argument is an array of AudioStreamPacketDescription
    ///structs that describes the packet layout returned in outOutputData. This
    ///argument is optional. Pass NULL if this information is not to be returned.
    ///Note that this information is only provided when the output format isn't
    ///linear PCM.
    ///
    ///Note that decoders will always only produce linear PCM data in multiples of
    ///the number frames in a packet of the encoded format (as returned by
    ///kAudioCodecPropertyPacketFrameSize). Encoders will consume this many frames
    ///of linear PCM data to produce a packet of their format.
    ///
    ///@param			inCodec
    ///The AudioCodec instance
    ///@param			outOutputData
    ///Pointer to the output data buffer
    ///@param			ioOutputDataByteSize
    ///A pointer to the size
    ///@param			ioNumberPackets
    ///number of input/output packets
    ///@result			The OSStatus value
    pub fn AudioCodecProduceOutputPackets(
        inCodec: AudioCodec,
        outOutputData: *mut ::std::os::raw::c_void,
        ioOutputDataByteSize: *mut UInt32,
        ioNumberPackets: *mut UInt32,
        outPacketDescription: *mut AudioStreamPacketDescription,
        outStatus: *mut UInt32,
    ) -> OSStatus;
}
extern "C" {
    pub fn AudioCodecAppendInputBufferList(
        inCodec: AudioCodec,
        inBufferList: *const AudioBufferList,
        ioNumberPackets: *mut UInt32,
        inPacketDescription: *const AudioStreamPacketDescription,
        outBytesConsumed: *mut UInt32,
    ) -> OSStatus;
}
extern "C" {
    pub fn AudioCodecProduceOutputBufferList(
        inCodec: AudioCodec,
        ioBufferList: *mut AudioBufferList,
        ioNumberPackets: *mut UInt32,
        outPacketDescription: *mut AudioStreamPacketDescription,
        outStatus: *mut UInt32,
    ) -> OSStatus;
}
extern "C" {
    ///@function		AudioCodecReset
    ///
    ///@discussion		Flushes all the data in the codec and clears the input buffer. Note that
    ///the formats, and magic cookie will be retained so they won't need to be
    ///set up again to decode the same data.
    ///
    ///@param			inCodec The audio codec descriptor
    ///
    ///@result			the OSStatus value
    pub fn AudioCodecReset(inCodec: AudioCodec) -> OSStatus;
}
pub type AudioCodecGetPropertyInfoProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        inPropertyID: AudioCodecPropertyID,
        outSize: *mut UInt32,
        outWritable: *mut Boolean,
    ) -> OSStatus,
>;
pub type AudioCodecGetPropertyProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        inPropertyID: AudioCodecPropertyID,
        ioPropertyDataSize: *mut UInt32,
        outPropertyData: *mut ::std::os::raw::c_void,
    ) -> OSStatus,
>;
pub type AudioCodecSetPropertyProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        inPropertyID: AudioCodecPropertyID,
        inPropertyDataSize: UInt32,
        inPropertyData: *const ::std::os::raw::c_void,
    ) -> OSStatus,
>;
pub type AudioCodecInitializeProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        inInputFormat: *const AudioStreamBasicDescription,
        inOutputFormat: *const AudioStreamBasicDescription,
        inMagicCookie: *const ::std::os::raw::c_void,
        inMagicCookieByteSize: UInt32,
    ) -> OSStatus,
>;
pub type AudioCodecUninitializeProc =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut ::std::os::raw::c_void) -> OSStatus>;
pub type AudioCodecAppendInputDataProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        inInputData: *const ::std::os::raw::c_void,
        ioInputDataByteSize: *mut UInt32,
        ioNumberPackets: *mut UInt32,
        inPacketDescription: *const AudioStreamPacketDescription,
    ) -> OSStatus,
>;
pub type AudioCodecProduceOutputPacketsProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        outOutputData: *mut ::std::os::raw::c_void,
        ioOutputDataByteSize: *mut UInt32,
        ioNumberPackets: *mut UInt32,
        outPacketDescription: *mut AudioStreamPacketDescription,
        outStatus: *mut UInt32,
    ) -> OSStatus,
>;
pub type AudioCodecResetProc =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut ::std::os::raw::c_void) -> OSStatus>;
pub type AudioCodecAppendInputBufferListProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        ioBufferList: *const AudioBufferList,
        inNumberPackets: *mut UInt32,
        inPacketDescription: *const AudioStreamPacketDescription,
        outBytesConsumed: *mut UInt32,
    ) -> OSStatus,
>;
pub type AudioCodecProduceOutputBufferListProc = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut ::std::os::raw::c_void,
        ioBufferList: *mut AudioBufferList,
        ioNumberPackets: *mut UInt32,
        outPacketDescription: *mut AudioStreamPacketDescription,
        outStatus: *mut UInt32,
    ) -> OSStatus,
>;
pub const kAudioCodecPropertyMinimumDelayMode: _bindgen_ty_207 = 1835296108;
pub type _bindgen_ty_207 = u32;
pub const kAudioCodecPropertyNameCFString: _bindgen_ty_208 = 1819173229;
pub const kAudioCodecPropertyManufacturerCFString: _bindgen_ty_208 = 1819107691;
pub const kAudioCodecPropertyFormatCFString: _bindgen_ty_208 = 1818652530;
pub type _bindgen_ty_208 = u32;
pub const kAudioCodecPropertyRequiresPacketDescription: _bindgen_ty_209 = 1885432676;
pub const kAudioCodecPropertyAvailableBitRates: _bindgen_ty_209 = 1651668003;
pub const kAudioCodecExtendFrequencies: _bindgen_ty_209 = 1633903974;
pub const kAudioCodecUseRecommendedSampleRate: _bindgen_ty_209 = 1970434930;
pub const kAudioCodecOutputPrecedence: _bindgen_ty_209 = 1869639794;
pub const kAudioCodecBitRateFormat: _bindgen_ty_209 = 1633903206;
pub const kAudioCodecDoesSampleRateConversion: _bindgen_ty_209 = 1819112035;
pub const kAudioCodecInputFormatsForOutputFormat: _bindgen_ty_209 = 1768305775;
pub const kAudioCodecOutputFormatsForInputFormat: _bindgen_ty_209 = 1868969065;
pub const kAudioCodecPropertyInputChannelLayout: _bindgen_ty_209 = 1768123424;
pub const kAudioCodecPropertyOutputChannelLayout: _bindgen_ty_209 = 1868786720;
pub const kAudioCodecPropertyAvailableInputChannelLayouts: _bindgen_ty_209 = 1634296684;
pub const kAudioCodecPropertyAvailableOutputChannelLayouts: _bindgen_ty_209 = 1634689900;
pub const kAudioCodecPropertyZeroFramesPadded: _bindgen_ty_209 = 1885430832;
pub type _bindgen_ty_209 = u32;
pub const kAudioCodecBitRateFormat_CBR: _bindgen_ty_210 = 0;
pub const kAudioCodecBitRateFormat_ABR: _bindgen_ty_210 = 1;
pub const kAudioCodecBitRateFormat_VBR: _bindgen_ty_210 = 2;
pub type _bindgen_ty_210 = u32;
pub const kAudioCodecOutputPrecedenceNone: _bindgen_ty_211 = 0;
pub const kAudioCodecOutputPrecedenceBitRate: _bindgen_ty_211 = 1;
pub const kAudioCodecOutputPrecedenceSampleRate: _bindgen_ty_211 = 2;
pub type _bindgen_ty_211 = u32;
///@typedef	MagicCookieInfo
///
///@deprecated	in version 10.5
///
///@discussion	renamed to AudioCodecMagicCookieInfo
pub type MagicCookieInfo = AudioCodecMagicCookieInfo;
pub const kHintBasic: _bindgen_ty_212 = 0;
pub const kHintAdvanced: _bindgen_ty_212 = 1;
pub const kHintHidden: _bindgen_ty_212 = 2;
pub type _bindgen_ty_212 = u32;
///@typedef        AudioObjectID
///@abstract       A UInt32 that provides a handle on a specific AudioObject.
pub type AudioObjectID = UInt32;
///@typedef        AudioClassID
///@abstract       AudioClassIDs are used to identify the class of an AudioObject.
pub type AudioClassID = UInt32;
///@typedef        AudioObjectPropertySelector
///@abstract       An AudioObjectPropertySelector is a four char code that identifies, along with
///the AudioObjectPropertyScope and AudioObjectPropertyElement, a specific piece of
///information about an AudioObject.
///@discussion     The property selector specifies the general classification of the property such
///as volume, stream format, latency, etc. Note that each class has a different set
///of selectors. A subclass inherits its super class's set of selectors, although
///it may not implement them all.
pub type AudioObjectPropertySelector = UInt32;
///@typedef        AudioObjectPropertyScope
///@abstract       An AudioObjectPropertyScope is a four char code that identifies, along with the
///AudioObjectPropertySelector and AudioObjectPropertyElement, a specific piece of
///information about an AudioObject.
///@discussion     The scope specifies the section of the object in which to look for the property,
///such as input, output, global, etc. Note that each class has a different set of
///scopes. A subclass inherits its superclass's set of scopes.
pub type AudioObjectPropertyScope = UInt32;
///@typedef        AudioObjectPropertyElement
///@abstract       An AudioObjectPropertyElement is an integer that identifies, along with the
///AudioObjectPropertySelector and AudioObjectPropertyScope, a specific piece of
///information about an AudioObject.
///@discussion     The element selects one of possibly many items in the section of the object in
///which to look for the property. Elements are number sequentially where 0
///represents the master element. Elements are particular to an instance of a
///class, meaning that two instances can have different numbers of elements in the
///same scope. There is no inheritance of elements.
pub type AudioObjectPropertyElement = UInt32;
///@struct         AudioObjectPropertyAddress
///@abstract       An AudioObjectPropertyAddress collects the three parts that identify a specific
///property together in a struct for easy transmission.
///@field          mSelector
///The AudioObjectPropertySelector for the property.
///@field          mScope
///The AudioObjectPropertyScope for the property.
///@field          mElement
///The AudioObjectPropertyElement for the property.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioObjectPropertyAddress {
    pub mSelector: AudioObjectPropertySelector,
    pub mScope: AudioObjectPropertyScope,
    pub mElement: AudioObjectPropertyElement,
}
#[test]
fn bindgen_test_layout_AudioObjectPropertyAddress() {
    assert_eq!(
        ::std::mem::size_of::<AudioObjectPropertyAddress>(),
        12usize,
        concat!("Size of: ", stringify!(AudioObjectPropertyAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioObjectPropertyAddress>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioObjectPropertyAddress))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioObjectPropertyAddress>())).mSelector as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioObjectPropertyAddress),
            "::",
            stringify!(mSelector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioObjectPropertyAddress>())).mScope as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioObjectPropertyAddress),
            "::",
            stringify!(mScope)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioObjectPropertyAddress>())).mElement as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioObjectPropertyAddress),
            "::",
            stringify!(mElement)
        )
    );
}
pub const kAudioHardwareNoError: _bindgen_ty_213 = 0;
pub const kAudioHardwareNotRunningError: _bindgen_ty_213 = 1937010544;
pub const kAudioHardwareUnspecifiedError: _bindgen_ty_213 = 2003329396;
pub const kAudioHardwareUnknownPropertyError: _bindgen_ty_213 = 2003332927;
pub const kAudioHardwareBadPropertySizeError: _bindgen_ty_213 = 561211770;
pub const kAudioHardwareIllegalOperationError: _bindgen_ty_213 = 1852797029;
pub const kAudioHardwareBadObjectError: _bindgen_ty_213 = 560947818;
pub const kAudioHardwareBadDeviceError: _bindgen_ty_213 = 560227702;
pub const kAudioHardwareBadStreamError: _bindgen_ty_213 = 561214578;
pub const kAudioHardwareUnsupportedOperationError: _bindgen_ty_213 = 1970171760;
pub const kAudioDeviceUnsupportedFormatError: _bindgen_ty_213 = 560226676;
pub const kAudioDevicePermissionsError: _bindgen_ty_213 = 560492391;
pub type _bindgen_ty_213 = u32;
pub const kAudioObjectUnknown: _bindgen_ty_214 = 0;
pub type _bindgen_ty_214 = u32;
pub const kAudioObjectPropertyScopeGlobal: _bindgen_ty_215 = 1735159650;
pub const kAudioObjectPropertyScopeInput: _bindgen_ty_215 = 1768845428;
pub const kAudioObjectPropertyScopeOutput: _bindgen_ty_215 = 1869968496;
pub const kAudioObjectPropertyScopePlayThrough: _bindgen_ty_215 = 1886679669;
pub const kAudioObjectPropertyElementMaster: _bindgen_ty_215 = 0;
pub type _bindgen_ty_215 = u32;
pub const kAudioObjectPropertySelectorWildcard: _bindgen_ty_216 = 707406378;
pub type _bindgen_ty_216 = u32;
pub const kAudioObjectPropertyScopeWildcard: _bindgen_ty_217 = 707406378;
pub type _bindgen_ty_217 = u32;
pub const kAudioObjectPropertyElementWildcard: _bindgen_ty_218 = 4294967295;
pub type _bindgen_ty_218 = u32;
pub const kAudioObjectClassIDWildcard: _bindgen_ty_219 = 707406378;
pub type _bindgen_ty_219 = u32;
pub const kAudioObjectClassID: _bindgen_ty_220 = 1634689642;
pub type _bindgen_ty_220 = u32;
pub const kAudioObjectPropertyBaseClass: _bindgen_ty_221 = 1650682995;
pub const kAudioObjectPropertyClass: _bindgen_ty_221 = 1668047219;
pub const kAudioObjectPropertyOwner: _bindgen_ty_221 = 1937007734;
pub const kAudioObjectPropertyName: _bindgen_ty_221 = 1819173229;
pub const kAudioObjectPropertyModelName: _bindgen_ty_221 = 1819111268;
pub const kAudioObjectPropertyManufacturer: _bindgen_ty_221 = 1819107691;
pub const kAudioObjectPropertyElementName: _bindgen_ty_221 = 1818454126;
pub const kAudioObjectPropertyElementCategoryName: _bindgen_ty_221 = 1818452846;
pub const kAudioObjectPropertyElementNumberName: _bindgen_ty_221 = 1818455662;
pub const kAudioObjectPropertyOwnedObjects: _bindgen_ty_221 = 1870098020;
pub const kAudioObjectPropertyIdentify: _bindgen_ty_221 = 1768187246;
pub const kAudioObjectPropertySerialNumber: _bindgen_ty_221 = 1936618861;
pub const kAudioObjectPropertyFirmwareVersion: _bindgen_ty_221 = 1719105134;
pub type _bindgen_ty_221 = u32;
pub const kAudioPlugInClassID: _bindgen_ty_222 = 1634757735;
pub type _bindgen_ty_222 = u32;
pub const kAudioPlugInPropertyBundleID: _bindgen_ty_223 = 1885956452;
pub const kAudioPlugInPropertyDeviceList: _bindgen_ty_223 = 1684370979;
pub const kAudioPlugInPropertyTranslateUIDToDevice: _bindgen_ty_223 = 1969841252;
pub const kAudioPlugInPropertyBoxList: _bindgen_ty_223 = 1651472419;
pub const kAudioPlugInPropertyTranslateUIDToBox: _bindgen_ty_223 = 1969841250;
pub const kAudioPlugInPropertyClockDeviceList: _bindgen_ty_223 = 1668049699;
pub const kAudioPlugInPropertyTranslateUIDToClockDevice: _bindgen_ty_223 = 1969841251;
pub type _bindgen_ty_223 = u32;
pub const kAudioTransportManagerClassID: _bindgen_ty_224 = 1953656941;
pub type _bindgen_ty_224 = u32;
pub const kAudioTransportManagerPropertyEndPointList: _bindgen_ty_225 = 1701733411;
pub const kAudioTransportManagerPropertyTranslateUIDToEndPoint: _bindgen_ty_225 = 1969841253;
pub const kAudioTransportManagerPropertyTransportType: _bindgen_ty_225 = 1953653102;
pub type _bindgen_ty_225 = u32;
pub const kAudioBoxClassID: _bindgen_ty_226 = 1633841016;
pub type _bindgen_ty_226 = u32;
pub const kAudioBoxPropertyBoxUID: _bindgen_ty_227 = 1651861860;
pub const kAudioBoxPropertyTransportType: _bindgen_ty_227 = 1953653102;
pub const kAudioBoxPropertyHasAudio: _bindgen_ty_227 = 1651007861;
pub const kAudioBoxPropertyHasVideo: _bindgen_ty_227 = 1651013225;
pub const kAudioBoxPropertyHasMIDI: _bindgen_ty_227 = 1651010921;
pub const kAudioBoxPropertyIsProtected: _bindgen_ty_227 = 1651536495;
pub const kAudioBoxPropertyAcquired: _bindgen_ty_227 = 1652060014;
pub const kAudioBoxPropertyAcquisitionFailed: _bindgen_ty_227 = 1652060006;
pub const kAudioBoxPropertyDeviceList: _bindgen_ty_227 = 1650751011;
pub const kAudioBoxPropertyClockDeviceList: _bindgen_ty_227 = 1650682915;
pub type _bindgen_ty_227 = u32;
pub const kAudioDeviceClassID: _bindgen_ty_228 = 1633969526;
pub type _bindgen_ty_228 = u32;
pub const kAudioDeviceTransportTypeUnknown: _bindgen_ty_229 = 0;
pub const kAudioDeviceTransportTypeBuiltIn: _bindgen_ty_229 = 1651274862;
pub const kAudioDeviceTransportTypeAggregate: _bindgen_ty_229 = 1735554416;
pub const kAudioDeviceTransportTypeVirtual: _bindgen_ty_229 = 1986622068;
pub const kAudioDeviceTransportTypePCI: _bindgen_ty_229 = 1885563168;
pub const kAudioDeviceTransportTypeUSB: _bindgen_ty_229 = 1970496032;
pub const kAudioDeviceTransportTypeFireWire: _bindgen_ty_229 = 825440564;
pub const kAudioDeviceTransportTypeBluetooth: _bindgen_ty_229 = 1651275109;
pub const kAudioDeviceTransportTypeBluetoothLE: _bindgen_ty_229 = 1651271009;
pub const kAudioDeviceTransportTypeHDMI: _bindgen_ty_229 = 1751412073;
pub const kAudioDeviceTransportTypeDisplayPort: _bindgen_ty_229 = 1685090932;
pub const kAudioDeviceTransportTypeAirPlay: _bindgen_ty_229 = 1634300528;
pub const kAudioDeviceTransportTypeAVB: _bindgen_ty_229 = 1700886114;
pub const kAudioDeviceTransportTypeThunderbolt: _bindgen_ty_229 = 1953002862;
pub type _bindgen_ty_229 = u32;
pub const kAudioDevicePropertyConfigurationApplication: _bindgen_ty_230 = 1667330160;
pub const kAudioDevicePropertyDeviceUID: _bindgen_ty_230 = 1969841184;
pub const kAudioDevicePropertyModelUID: _bindgen_ty_230 = 1836411236;
pub const kAudioDevicePropertyTransportType: _bindgen_ty_230 = 1953653102;
pub const kAudioDevicePropertyRelatedDevices: _bindgen_ty_230 = 1634429294;
pub const kAudioDevicePropertyClockDomain: _bindgen_ty_230 = 1668049764;
pub const kAudioDevicePropertyDeviceIsAlive: _bindgen_ty_230 = 1818850926;
pub const kAudioDevicePropertyDeviceIsRunning: _bindgen_ty_230 = 1735354734;
pub const kAudioDevicePropertyDeviceCanBeDefaultDevice: _bindgen_ty_230 = 1684434036;
pub const kAudioDevicePropertyDeviceCanBeDefaultSystemDevice: _bindgen_ty_230 = 1936092276;
pub const kAudioDevicePropertyLatency: _bindgen_ty_230 = 1819569763;
pub const kAudioDevicePropertyStreams: _bindgen_ty_230 = 1937009955;
pub const kAudioObjectPropertyControlList: _bindgen_ty_230 = 1668575852;
pub const kAudioDevicePropertySafetyOffset: _bindgen_ty_230 = 1935763060;
pub const kAudioDevicePropertyNominalSampleRate: _bindgen_ty_230 = 1853059700;
pub const kAudioDevicePropertyAvailableNominalSampleRates: _bindgen_ty_230 = 1853059619;
pub const kAudioDevicePropertyIcon: _bindgen_ty_230 = 1768124270;
pub const kAudioDevicePropertyIsHidden: _bindgen_ty_230 = 1751737454;
pub const kAudioDevicePropertyPreferredChannelsForStereo: _bindgen_ty_230 = 1684236338;
pub const kAudioDevicePropertyPreferredChannelLayout: _bindgen_ty_230 = 1936879204;
pub type _bindgen_ty_230 = u32;
pub const kAudioClockDeviceClassID: _bindgen_ty_231 = 1633905771;
pub type _bindgen_ty_231 = u32;
pub const kAudioClockDevicePropertyDeviceUID: _bindgen_ty_232 = 1668639076;
pub const kAudioClockDevicePropertyTransportType: _bindgen_ty_232 = 1953653102;
pub const kAudioClockDevicePropertyClockDomain: _bindgen_ty_232 = 1668049764;
pub const kAudioClockDevicePropertyDeviceIsAlive: _bindgen_ty_232 = 1818850926;
pub const kAudioClockDevicePropertyDeviceIsRunning: _bindgen_ty_232 = 1735354734;
pub const kAudioClockDevicePropertyLatency: _bindgen_ty_232 = 1819569763;
pub const kAudioClockDevicePropertyControlList: _bindgen_ty_232 = 1668575852;
pub const kAudioClockDevicePropertyNominalSampleRate: _bindgen_ty_232 = 1853059700;
pub const kAudioClockDevicePropertyAvailableNominalSampleRates: _bindgen_ty_232 = 1853059619;
pub type _bindgen_ty_232 = u32;
pub const kAudioEndPointDeviceClassID: _bindgen_ty_233 = 1701078390;
pub type _bindgen_ty_233 = u32;
pub const kAudioEndPointDevicePropertyComposition: _bindgen_ty_234 = 1633906541;
pub const kAudioEndPointDevicePropertyEndPointList: _bindgen_ty_234 = 1634169456;
pub const kAudioEndPointDevicePropertyIsPrivate: _bindgen_ty_234 = 1886546294;
pub type _bindgen_ty_234 = u32;
pub const kAudioEndPointClassID: _bindgen_ty_235 = 1701733488;
pub type _bindgen_ty_235 = u32;
///@struct         AudioStreamRangedDescription
///@abstract       This structure allows a specific sample rate range to be associated with an
///AudioStreamBasicDescription that specifies its sample rate as
///kAudioStreamAnyRate.
///@discussion     Note that this structure is only used to describe the the available formats
///for a stream. It is not used for the current format.
///@field          mFormat
///The AudioStreamBasicDescription that describes the format of the stream.
///Note that the mSampleRate field of the structure will be the same as the
///the values in mSampleRateRange when only a single sample rate is supported.
///It will be kAudioStreamAnyRate when there is a range with more elements.
///@field          mSampleRateRange
///The AudioValueRange that describes the minimum and maximum sample rate for
///the stream. If the mSampleRate field of mFormat is kAudioStreamAnyRate the
///format supports the range of sample rates described by this structure.
///Otherwise, the minimum will be the same as the maximum which will be the
///same as the mSampleRate field of mFormat.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AudioStreamRangedDescription {
    pub mFormat: AudioStreamBasicDescription,
    pub mSampleRateRange: AudioValueRange,
}
#[test]
fn bindgen_test_layout_AudioStreamRangedDescription() {
    assert_eq!(
        ::std::mem::size_of::<AudioStreamRangedDescription>(),
        56usize,
        concat!("Size of: ", stringify!(AudioStreamRangedDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioStreamRangedDescription>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioStreamRangedDescription))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamRangedDescription>())).mFormat as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamRangedDescription),
            "::",
            stringify!(mFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioStreamRangedDescription>())).mSampleRateRange as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStreamRangedDescription),
            "::",
            stringify!(mSampleRateRange)
        )
    );
}
pub const kAudioStreamClassID: _bindgen_ty_236 = 1634956402;
pub type _bindgen_ty_236 = u32;
pub const kAudioStreamTerminalTypeUnknown: _bindgen_ty_237 = 0;
pub const kAudioStreamTerminalTypeLine: _bindgen_ty_237 = 1818848869;
pub const kAudioStreamTerminalTypeDigitalAudioInterface: _bindgen_ty_237 = 1936745574;
pub const kAudioStreamTerminalTypeSpeaker: _bindgen_ty_237 = 1936747378;
pub const kAudioStreamTerminalTypeHeadphones: _bindgen_ty_237 = 1751412840;
pub const kAudioStreamTerminalTypeLFESpeaker: _bindgen_ty_237 = 1818649971;
pub const kAudioStreamTerminalTypeReceiverSpeaker: _bindgen_ty_237 = 1920168043;
pub const kAudioStreamTerminalTypeMicrophone: _bindgen_ty_237 = 1835623282;
pub const kAudioStreamTerminalTypeHeadsetMicrophone: _bindgen_ty_237 = 1752000867;
pub const kAudioStreamTerminalTypeReceiverMicrophone: _bindgen_ty_237 = 1919773027;
pub const kAudioStreamTerminalTypeTTY: _bindgen_ty_237 = 1953790303;
pub const kAudioStreamTerminalTypeHDMI: _bindgen_ty_237 = 1751412073;
pub const kAudioStreamTerminalTypeDisplayPort: _bindgen_ty_237 = 1685090932;
pub type _bindgen_ty_237 = u32;
pub const kAudioStreamPropertyIsActive: _bindgen_ty_238 = 1935762292;
pub const kAudioStreamPropertyDirection: _bindgen_ty_238 = 1935960434;
pub const kAudioStreamPropertyTerminalType: _bindgen_ty_238 = 1952805485;
pub const kAudioStreamPropertyStartingChannel: _bindgen_ty_238 = 1935894638;
pub const kAudioStreamPropertyLatency: _bindgen_ty_238 = 1819569763;
pub const kAudioStreamPropertyVirtualFormat: _bindgen_ty_238 = 1936092532;
pub const kAudioStreamPropertyAvailableVirtualFormats: _bindgen_ty_238 = 1936092513;
pub const kAudioStreamPropertyPhysicalFormat: _bindgen_ty_238 = 1885762592;
pub const kAudioStreamPropertyAvailablePhysicalFormats: _bindgen_ty_238 = 1885762657;
pub type _bindgen_ty_238 = u32;
pub const kAudioControlClassID: _bindgen_ty_239 = 1633907820;
pub type _bindgen_ty_239 = u32;
pub const kAudioControlPropertyScope: _bindgen_ty_240 = 1668506480;
pub const kAudioControlPropertyElement: _bindgen_ty_240 = 1667591277;
pub type _bindgen_ty_240 = u32;
pub const kAudioSliderControlClassID: _bindgen_ty_241 = 1936483442;
pub type _bindgen_ty_241 = u32;
pub const kAudioSliderControlPropertyValue: _bindgen_ty_242 = 1935962742;
pub const kAudioSliderControlPropertyRange: _bindgen_ty_242 = 1935962738;
pub type _bindgen_ty_242 = u32;
pub const kAudioLevelControlClassID: _bindgen_ty_243 = 1818588780;
pub const kAudioVolumeControlClassID: _bindgen_ty_243 = 1986817381;
pub const kAudioLFEVolumeControlClassID: _bindgen_ty_243 = 1937072758;
pub type _bindgen_ty_243 = u32;
pub const kAudioLevelControlPropertyScalarValue: _bindgen_ty_244 = 1818456950;
pub const kAudioLevelControlPropertyDecibelValue: _bindgen_ty_244 = 1818453110;
pub const kAudioLevelControlPropertyDecibelRange: _bindgen_ty_244 = 1818453106;
pub const kAudioLevelControlPropertyConvertScalarToDecibels: _bindgen_ty_244 = 1818456932;
pub const kAudioLevelControlPropertyConvertDecibelsToScalar: _bindgen_ty_244 = 1818453107;
pub type _bindgen_ty_244 = u32;
pub const kAudioBooleanControlClassID: _bindgen_ty_245 = 1953458028;
pub const kAudioMuteControlClassID: _bindgen_ty_245 = 1836414053;
pub const kAudioSoloControlClassID: _bindgen_ty_245 = 1936682095;
pub const kAudioJackControlClassID: _bindgen_ty_245 = 1784767339;
pub const kAudioLFEMuteControlClassID: _bindgen_ty_245 = 1937072749;
pub const kAudioPhantomPowerControlClassID: _bindgen_ty_245 = 1885888878;
pub const kAudioPhaseInvertControlClassID: _bindgen_ty_245 = 1885893481;
pub const kAudioClipLightControlClassID: _bindgen_ty_245 = 1668049264;
pub const kAudioTalkbackControlClassID: _bindgen_ty_245 = 1952541794;
pub const kAudioListenbackControlClassID: _bindgen_ty_245 = 1819504226;
pub type _bindgen_ty_245 = u32;
pub const kAudioBooleanControlPropertyValue: _bindgen_ty_246 = 1650685548;
pub type _bindgen_ty_246 = u32;
pub const kAudioSelectorControlClassID: _bindgen_ty_247 = 1936483188;
pub const kAudioDataSourceControlClassID: _bindgen_ty_247 = 1685287523;
pub const kAudioDataDestinationControlClassID: _bindgen_ty_247 = 1684370292;
pub const kAudioClockSourceControlClassID: _bindgen_ty_247 = 1668047723;
pub const kAudioLineLevelControlClassID: _bindgen_ty_247 = 1852601964;
pub const kAudioHighPassFilterControlClassID: _bindgen_ty_247 = 1751740518;
pub type _bindgen_ty_247 = u32;
pub const kAudioSelectorControlPropertyCurrentItem: _bindgen_ty_248 = 1935893353;
pub const kAudioSelectorControlPropertyAvailableItems: _bindgen_ty_248 = 1935892841;
pub const kAudioSelectorControlPropertyItemName: _bindgen_ty_248 = 1935894894;
pub const kAudioSelectorControlPropertyItemKind: _bindgen_ty_248 = 1668049771;
pub type _bindgen_ty_248 = u32;
pub const kAudioSelectorControlItemKindSpacer: _bindgen_ty_249 = 1936745330;
pub type _bindgen_ty_249 = u32;
pub const kAudioClockSourceItemKindInternal: _bindgen_ty_250 = 1768846368;
pub type _bindgen_ty_250 = u32;
pub const kAudioStereoPanControlClassID: _bindgen_ty_251 = 1936744814;
pub type _bindgen_ty_251 = u32;
pub const kAudioStereoPanControlPropertyValue: _bindgen_ty_252 = 1936745334;
pub const kAudioStereoPanControlPropertyPanningChannels: _bindgen_ty_252 = 1936745315;
pub type _bindgen_ty_252 = u32;
pub const kAudioObjectSystemObject: _bindgen_ty_253 = 1;
pub type _bindgen_ty_253 = u32;
///@typedef        AudioObjectPropertyListenerProc
///@abstract       Clients register an AudioObjectPropertyListenerProc with an AudioObject in order
///to receive notifications when the properties of the object change.
///@discussion     Listeners will be called when possibly many properties have changed.
///Consequently, the implementation of a listener must go through the array of
///addresses to see what exactly has changed. Note that the array of addresses will
///always have at least one address in it for which the listener is signed up to
///receive notifications about but may contain addresses for properties for which
///the listener is not signed up to receive notifications.
///@param          inObjectID
///The AudioObject whose properties have changed.
///@param          inNumberAddresses
///The number of elements in the inAddresses array.
///@param          inAddresses
///An array of AudioObjectPropertyAddresses indicating which properties
///changed.
///@param          inClientData
///A pointer to client data established when the listener proc was registered
///with the AudioObject.
///@result         The return value is currently unused and should always be 0.
pub type AudioObjectPropertyListenerProc = ::std::option::Option<
    unsafe extern "C" fn(
        inObjectID: AudioObjectID,
        inNumberAddresses: UInt32,
        inAddresses: *const AudioObjectPropertyAddress,
        inClientData: *mut ::std::os::raw::c_void,
    ) -> OSStatus,
>;
///@typedef        AudioObjectPropertyListenerBlock
///@abstract       Clients register an AudioObjectPropertyListenerBlock with an AudioObject in
///order to receive notifications when the properties of the object change.
///@discussion     Listeners will be called when possibly many properties have changed.
///Consequently, the implementation of a listener must go through the array of
///addresses to see what exactly has changed. Note that the array of addresses will
///always have at least one address in it for which the listener is signed up to
///receive notifications about but may contain addresses for properties for which
///the listener is not signed up to receive notifications.
///@param          inNumberAddresses
///The number of elements in the inAddresses array.
///@param          inAddresses
///An array of AudioObjectPropertyAddresses indicating which properties
///changed.
pub type AudioObjectPropertyListenerBlock = *mut ::std::os::raw::c_void;
pub const kAudioObjectPropertyCreator: _bindgen_ty_254 = 1869638759;
pub const kAudioObjectPropertyListenerAdded: _bindgen_ty_254 = 1818850145;
pub const kAudioObjectPropertyListenerRemoved: _bindgen_ty_254 = 1818850162;
pub type _bindgen_ty_254 = u32;
extern "C" {
    ///@function       AudioObjectShow
    ///@abstract       Prints to standard out a textural description of the AudioObject.
    ///@param          inObjectID
    ///The AudioObject to show.
    pub fn AudioObjectShow(inObjectID: AudioObjectID);
}
extern "C" {
    ///@function       AudioObjectHasProperty
    ///@abstract       Queries an AudioObject about whether or not it has the given property.
    ///@param          inObjectID
    ///The AudioObject to query.
    ///@param          inAddress
    ///An AudioObjectPropertyAddress indicating which property is being queried.
    ///@result         A Boolean indicating whether or not the AudioObject has the given property.
    pub fn AudioObjectHasProperty(
        inObjectID: AudioObjectID,
        inAddress: *const AudioObjectPropertyAddress,
    ) -> Boolean;
}
extern "C" {
    ///@function       AudioObjectIsPropertySettable
    ///@abstract       Queries an AudioObject about whether or not the given property can be set using
    ///AudioObjectSetPropertyData.
    ///@param          inObjectID
    ///The AudioObject to query.
    ///@param          inAddress
    ///An AudioObjectPropertyAddress indicating which property is being queried.
    ///@param          outIsSettable
    ///A Boolean indicating whether or not the property can be set.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioObjectIsPropertySettable(
        inObjectID: AudioObjectID,
        inAddress: *const AudioObjectPropertyAddress,
        outIsSettable: *mut Boolean,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioObjectGetPropertyDataSize
    ///@abstract       Queries an AudioObject to find the size of the data for the given property.
    ///@param          inObjectID
    ///The AudioObject to query.
    ///@param          inAddress
    ///An AudioObjectPropertyAddress indicating which property is being queried.
    ///@param          inQualifierDataSize
    ///A UInt32 indicating the size of the buffer pointed to by inQualifierData.
    ///Note that not all properties require qualification, in which case this
    ///value will be 0.
    ///@param          inQualifierData,
    ///A buffer of data to be used in determining the data of the property being
    ///queried. Note that not all properties require qualification, in which case
    ///this value will be NULL.
    ///@param          outDataSize
    ///A UInt32 indicating how many bytes the data for the given property occupies.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioObjectGetPropertyDataSize(
        inObjectID: AudioObjectID,
        inAddress: *const AudioObjectPropertyAddress,
        inQualifierDataSize: UInt32,
        inQualifierData: *const ::std::os::raw::c_void,
        outDataSize: *mut UInt32,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioObjectGetPropertyData
    ///@abstract       Queries an AudioObject to get the data of the given property and places it in
    ///the provided buffer.
    ///@param          inObjectID
    ///The AudioObject to query.
    ///@param          inAddress
    ///An AudioObjectPropertyAddress indicating which property is being queried.
    ///@param          inQualifierDataSize
    ///A UInt32 indicating the size of the buffer pointed to by inQualifierData.
    ///Note that not all properties require qualification, in which case this
    ///value will be 0.
    ///@param          inQualifierData,
    ///A buffer of data to be used in determining the data of the property being
    ///queried. Note that not all properties require qualification, in which case
    ///this value will be NULL.
    ///@param          ioDataSize
    ///A UInt32 which on entry indicates the size of the buffer pointed to by
    ///outData and on exit indicates how much of the buffer was used.
    ///@param          outData
    ///The buffer into which the AudioObject will put the data for the given
    ///property.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioObjectGetPropertyData(
        inObjectID: AudioObjectID,
        inAddress: *const AudioObjectPropertyAddress,
        inQualifierDataSize: UInt32,
        inQualifierData: *const ::std::os::raw::c_void,
        ioDataSize: *mut UInt32,
        outData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioObjectSetPropertyData
    ///@abstract       Tells an AudioObject to change the value of the given property using the
    ///provided data.
    ///@discussion     Note that the value of the property should not be considered changed until the
    ///HAL has called the listeners as many properties values are changed
    ///asynchronously.
    ///@param          inObjectID
    ///The AudioObject to change.
    ///@param          inAddress
    ///An AudioObjectPropertyAddress indicating which property is being changed.
    ///@param          inQualifierDataSize
    ///A UInt32 indicating the size of the buffer pointed to by inQualifierData.
    ///Note that not all properties require qualification, in which case this
    ///value will be 0.
    ///@param          inQualifierData,
    ///A buffer of data to be used in determining the data of the property being
    ///queried. Note that not all properties require qualification, in which case
    ///this value will be NULL.
    ///@param          inDataSize
    ///A UInt32 indicating the size of the buffer pointed to by inData.
    ///@param          inData
    ///The buffer containing the data to be used to change the property's value.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioObjectSetPropertyData(
        inObjectID: AudioObjectID,
        inAddress: *const AudioObjectPropertyAddress,
        inQualifierDataSize: UInt32,
        inQualifierData: *const ::std::os::raw::c_void,
        inDataSize: UInt32,
        inData: *const ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioObjectAddPropertyListener
    ///@abstract       Registers the given AudioObjectPropertyListenerProc to receive notifications
    ///when the given properties change.
    ///@param          inObjectID
    ///The AudioObject to register the listener with.
    ///@param          inAddress
    ///The AudioObjectPropertyAddresses indicating which property the listener
    ///should be notified about.
    ///@param          inListener
    ///The AudioObjectPropertyListenerProc to call.
    ///@param          inClientData
    ///A pointer to client data that is passed to the listener when it is called.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioObjectAddPropertyListener(
        inObjectID: AudioObjectID,
        inAddress: *const AudioObjectPropertyAddress,
        inListener: AudioObjectPropertyListenerProc,
        inClientData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioObjectRemovePropertyListener
    ///@abstract       Unregisters the given AudioObjectPropertyListenerProc from receiving
    ///notifications when the given properties change.
    ///@param          inObjectID
    ///The AudioObject to unregister the listener from.
    ///@param          inAddress
    ///The AudioObjectPropertyAddress indicating from which property the listener
    ///should be removed.
    ///@param          inListener
    ///The AudioObjectPropertyListenerProc being removed.
    ///@param          inClientData
    ///A pointer to client data that is passed to the listener when it is called.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioObjectRemovePropertyListener(
        inObjectID: AudioObjectID,
        inAddress: *const AudioObjectPropertyAddress,
        inListener: AudioObjectPropertyListenerProc,
        inClientData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioObjectAddPropertyListenerBlock
    ///@abstract       Registers the given AudioObjectPropertyListenerBlock to receive notifications
    ///when the given properties change.
    ///@param          inObjectID
    ///The AudioObject to register the listener with.
    ///@param          inAddress
    ///The AudioObjectPropertyAddresses indicating which property the listener
    ///should be notified about.
    ///@param          inDispatchQueue
    ///The dispatch queue on which the listener block will be dispatched. All
    ///listener blocks will be dispatched asynchronously save for those dispatched
    ///from the IO context (of which kAudioDevicePropertyDeviceIsRunning and
    ///kAudioDeviceProcessorOverload are the only examples) which will be
    ///dispatched synchronously. Note that this dispatch queue will be retained
    ///until a matching call to AudioObjectRemovePropertyListenerBlock is made. If
    ///this value is NULL, then the block will be directly invoked.
    ///@param          inListener
    ///The AudioObjectPropertyListenerBlock to call. Note that this block will be
    ///Block_copy'd and the reference maintained until a matching call to
    ///AudioObjectRemovePropertyListenerBlock is made.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioObjectAddPropertyListenerBlock(
        inObjectID: AudioObjectID,
        inAddress: *const AudioObjectPropertyAddress,
        inDispatchQueue: dispatch_queue_t,
        inListener: AudioObjectPropertyListenerBlock,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioObjectRemovePropertyListenerBlock
    ///@abstract       Unregisters the given AudioObjectPropertyListenerBlock from receiving
    ///notifications when the given properties change.
    ///@param          inObjectID
    ///The AudioObject to unregister the listener from.
    ///@param          inAddress
    ///The AudioObjectPropertyAddress indicating from which property the listener
    ///should be removed.
    ///@param          inDispatchQueue
    ///The dispatch queue on which the listener block was being dispatched to.
    ///@param          inListener
    ///The AudioObjectPropertyListenerBlock being removed.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioObjectRemovePropertyListenerBlock(
        inObjectID: AudioObjectID,
        inAddress: *const AudioObjectPropertyAddress,
        inDispatchQueue: dispatch_queue_t,
        inListener: AudioObjectPropertyListenerBlock,
    ) -> OSStatus;
}
pub const kAudioSystemObjectClassID: _bindgen_ty_255 = 1634957683;
pub type _bindgen_ty_255 = u32;
///@enum           Power Hints
///@abstract       The values for kAudioHardwarePropertyPowerHint
///@discussion     The system object property, kAudioHardwarePropertyPowerHint, allows a process to
///to indicate how aggressive the system can be with optimizations that save power.
///Note that the value of this property can be set in an application's info.plist
///using the key, "AudioHardwarePowerHint". The values for this key are the strings
///that correspond to the values in the enum.
///@constant       kAudioHardwarePowerHintNone
///This is the default value and it indicates that the system will not make any
///power optimizations that compromise latency or quality in order to save
///power. The info.plist value is "None" or the "AudioHardwarePowerHint" entry
///can be omitted entirely.
///@constant       kAudioHardwarePowerHintFavorSavingPower
///The system will choose to save power even at the expense of latency. The
///info.plist value is "Favor Saving Power"
pub type AudioHardwarePowerHint = UInt32;
pub const kAudioHardwarePowerHintNone: _bindgen_ty_256 = 0;
pub const kAudioHardwarePowerHintFavorSavingPower: _bindgen_ty_256 = 1;
pub type _bindgen_ty_256 = u32;
pub const kAudioHardwarePropertyDevices: _bindgen_ty_257 = 1684370979;
pub const kAudioHardwarePropertyDefaultInputDevice: _bindgen_ty_257 = 1682533920;
pub const kAudioHardwarePropertyDefaultOutputDevice: _bindgen_ty_257 = 1682929012;
pub const kAudioHardwarePropertyDefaultSystemOutputDevice: _bindgen_ty_257 = 1934587252;
pub const kAudioHardwarePropertyTranslateUIDToDevice: _bindgen_ty_257 = 1969841252;
pub const kAudioHardwarePropertyMixStereoToMono: _bindgen_ty_257 = 1937010031;
pub const kAudioHardwarePropertyPlugInList: _bindgen_ty_257 = 1886152483;
pub const kAudioHardwarePropertyTranslateBundleIDToPlugIn: _bindgen_ty_257 = 1651074160;
pub const kAudioHardwarePropertyTransportManagerList: _bindgen_ty_257 = 1953326883;
pub const kAudioHardwarePropertyTranslateBundleIDToTransportManager: _bindgen_ty_257 = 1953325673;
pub const kAudioHardwarePropertyBoxList: _bindgen_ty_257 = 1651472419;
pub const kAudioHardwarePropertyTranslateUIDToBox: _bindgen_ty_257 = 1969841250;
pub const kAudioHardwarePropertyClockDeviceList: _bindgen_ty_257 = 1668049699;
pub const kAudioHardwarePropertyTranslateUIDToClockDevice: _bindgen_ty_257 = 1969841251;
pub const kAudioHardwarePropertyProcessIsMaster: _bindgen_ty_257 = 1835103092;
pub const kAudioHardwarePropertyIsInitingOrExiting: _bindgen_ty_257 = 1768845172;
pub const kAudioHardwarePropertyUserIDChanged: _bindgen_ty_257 = 1702193508;
pub const kAudioHardwarePropertyProcessIsAudible: _bindgen_ty_257 = 1886221684;
pub const kAudioHardwarePropertySleepingIsAllowed: _bindgen_ty_257 = 1936483696;
pub const kAudioHardwarePropertyUnloadingIsAllowed: _bindgen_ty_257 = 1970170980;
pub const kAudioHardwarePropertyHogModeIsAllowed: _bindgen_ty_257 = 1752131442;
pub const kAudioHardwarePropertyUserSessionIsActiveOrHeadless: _bindgen_ty_257 = 1970496882;
pub const kAudioHardwarePropertyServiceRestarted: _bindgen_ty_257 = 1936880500;
pub const kAudioHardwarePropertyPowerHint: _bindgen_ty_257 = 1886353256;
pub type _bindgen_ty_257 = u32;
extern "C" {
    ///@function       AudioHardwareUnload
    ///@abstract       When this routine is called, all IO on all devices within a process will be
    ///terminated and all resources capable of being released will be released. This
    ///routine essentially returns the HAL to its uninitialized state.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioHardwareUnload() -> OSStatus;
}
extern "C" {
    ///@function       AudioHardwareCreateAggregateDevice
    ///@abstract       This routine creates a new AudioAggregateDevice using the provided description.
    ///@param          inDescription
    ///The CFDictionary that specifies how to build the AudioAggregateDevice. The
    ///supported keys are described in the AudioAggregateDevice Constants section.
    ///@param          outDeviceID
    ///The AudioObjectID of the newly created AudioAggregateDevice.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioHardwareCreateAggregateDevice(
        inDescription: CFDictionaryRef,
        outDeviceID: *mut AudioObjectID,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioHardwareDestroyAggregateDevice
    ///@abstract       This routine destroys the given AudioAggregateDevice.
    ///@discussion     The actual destruction of the device is asynchronous and may take place after
    ///the call to this routine has returned.
    ///@param          inDeviceID
    ///The AudioObjectID of the AudioAggregateDevice to destroy.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioHardwareDestroyAggregateDevice(inDeviceID: AudioObjectID) -> OSStatus;
}
pub const kAudioPlugInCreateAggregateDevice: _bindgen_ty_258 = 1667327847;
pub const kAudioPlugInDestroyAggregateDevice: _bindgen_ty_258 = 1684105063;
pub type _bindgen_ty_258 = u32;
pub const kAudioTransportManagerCreateEndPointDevice: _bindgen_ty_259 = 1667523958;
pub const kAudioTransportManagerDestroyEndPointDevice: _bindgen_ty_259 = 1684301174;
pub type _bindgen_ty_259 = u32;
///@typedef        AudioDeviceIOProc
///@abstract       An AudioDeviceIOProc is called by an AudioDevice to provide input data read from
///the device and collect output data to be written to the device for the current
///IO cycle.
///@param          inDevice
///The AudioDevice doing the IO.
///@param          inNow
///An AudioTimeStamp that indicates the IO cycle started. Note that this time
///includes any scheduling latency that may have been incurred waking the
///thread on which IO is being done.
///@param          inInputData
///An AudioBufferList containing the input data for the current IO cycle. For
///streams that are disabled, the AudioBuffer's mData field will be NULL but
///the mDataByteSize field will still say how much data would have been there
///if it was enabled. Note that the contents of this structure should never be
///modified.
///@param          inInputTime
///An AudioTimeStamp that indicates the time at which the first frame in the
///data was acquired from the hardware. If the device has no input streams, the
///time stamp will be zeroed out.
///@param          outOutputData
///An AudioBufferList in which the output data for the current IO cycle is to
///be placed. On entry, each AudioBuffer's mDataByteSize field indicates the
///maximum amount of data that can be placed in the buffer and the buffer's
///memory has been zeroed out. For formats where the number of bytes per packet
///can vary (as with AC-3, for example), the client has to fill out on exit
///each mDataByteSize field in each AudioBuffer with the amount of data that
///was put in the buffer. Otherwise, the mDataByteSize field should not be
///changed. For streams that are disabled, the AudioBuffer's mData field will
///be NULL but the mDataByteSize field will still say how much data would have
///been there if it was enabled. Except as noted above, the contents of this
///structure should not other wise be modified.
///@param          inOutputTime
///An AudioTimeStamp that indicates the time at which the first frame in the
///data will be passed to the hardware. If the device has no output streams,
///the time stamp will be zeroed out.
///@param          inClientData
///A pointer to client data established when the AudioDeviceIOProc was
///registered with the AudioDevice.
///@result         The return value is currently unused and should always be 0.
pub type AudioDeviceIOProc = ::std::option::Option<
    unsafe extern "C" fn(
        inDevice: AudioObjectID,
        inNow: *const AudioTimeStamp,
        inInputData: *const AudioBufferList,
        inInputTime: *const AudioTimeStamp,
        outOutputData: *mut AudioBufferList,
        inOutputTime: *const AudioTimeStamp,
        inClientData: *mut ::std::os::raw::c_void,
    ) -> OSStatus,
>;
///@typedef        AudioDeviceIOBlock
///@abstract       An AudioDeviceIOBlock is called by an AudioDevice to provide input data read
///from the device and collect output data to be written to the device for the
///current IO cycle.
///@param          inNow
///An AudioTimeStamp that indicates the IO cycle started. Note that this time
///includes any scheduling latency that may have been incurred waking the
///thread on which IO is being done.
///@param          inInputData
///An AudioBufferList containing the input data for the current IO cycle. For
///streams that are disabled, the AudioBuffer's mData field will be NULL but
///the mDataByteSize field will still say how much data would have been there
///if it was enabled. Note that the contents of this structure should never be
///modified.
///@param          inInputTime
///An AudioTimeStamp that indicates the time at which the first frame in the
///data was acquired from the hardware. If the device has no input streams, the
///time stamp will be zeroed out.
///@param          outOutputData
///An AudioBufferList in which the output data for the current IO cycle is to
///be placed. On entry, each AudioBuffer's mDataByteSize field indicates the
///maximum amount of data that can be placed in the buffer and the buffer's
///memory has been zeroed out. For formats where the number of bytes per packet
///can vary (as with AC-3, for example), the client has to fill out on exit
///each mDataByteSize field in each AudioBuffer with the amount of data that
///was put in the buffer. Otherwise, the mDataByteSize field should not be
///changed. For streams that are disabled, the AudioBuffer's mData field will
///be NULL but the mDataByteSize field will still say how much data would have
///been there if it was enabled. Except as noted above, the contents of this
///structure should not other wise be modified.
///@param          inOutputTime
///An AudioTimeStamp that indicates the time at which the first frame in the
///data will be passed to the hardware. If the device has no output streams,
///the time stamp will be zeroed out.
pub type AudioDeviceIOBlock = *mut ::std::os::raw::c_void;
///@typedef        AudioDeviceIOProcID
///@abstract       An AudioDeviceIOProcID represents both an IOProc and the client data that goes
///with it. Once created, an AudioDeviceIOProcID can be used everywhere one would
///use a regular IOProc. The purpose for an AudioDeviceIOProcID is to allow a
///client to register the same function pointer as an IOProc with a device multiple
///times provided
pub type AudioDeviceIOProcID = AudioDeviceIOProc;
///@struct         AudioHardwareIOProcStreamUsage
///@abstract       This structure describes which streams a given AudioDeviceIOProc will use. It is
///used in conjunction with kAudioDevicePropertyIOProcStreamUsage.
///@field          mIOProc
///The IOProc whose stream usage is being specified.
///@field          mNumberStreams
///The number of streams being specified.
///@field          mStreamIsOn
///An array of UInt32's whose length is specified by mNumberStreams. Each
///element of the array corresponds to a stream. A value of 0 means the stream
///is not to be enabled. Any other value means the stream is to be used.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioHardwareIOProcStreamUsage {
    pub mIOProc: *mut ::std::os::raw::c_void,
    pub mNumberStreams: UInt32,
    pub mStreamIsOn: [UInt32; 1usize],
}
#[test]
fn bindgen_test_layout_AudioHardwareIOProcStreamUsage() {
    assert_eq!(
        ::std::mem::size_of::<AudioHardwareIOProcStreamUsage>(),
        16usize,
        concat!("Size of: ", stringify!(AudioHardwareIOProcStreamUsage))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioHardwareIOProcStreamUsage>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioHardwareIOProcStreamUsage))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioHardwareIOProcStreamUsage>())).mIOProc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioHardwareIOProcStreamUsage),
            "::",
            stringify!(mIOProc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioHardwareIOProcStreamUsage>())).mNumberStreams as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioHardwareIOProcStreamUsage),
            "::",
            stringify!(mNumberStreams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AudioHardwareIOProcStreamUsage>())).mStreamIsOn as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioHardwareIOProcStreamUsage),
            "::",
            stringify!(mStreamIsOn)
        )
    );
}
impl Default for AudioHardwareIOProcStreamUsage {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const kAudioDeviceStartTimeIsInputFlag: _bindgen_ty_260 = 1;
pub const kAudioDeviceStartTimeDontConsultDeviceFlag: _bindgen_ty_260 = 2;
pub const kAudioDeviceStartTimeDontConsultHALFlag: _bindgen_ty_260 = 4;
pub type _bindgen_ty_260 = u32;
pub const kAudioDevicePropertyPlugIn: _bindgen_ty_261 = 1886156135;
pub const kAudioDevicePropertyDeviceHasChanged: _bindgen_ty_261 = 1684629094;
pub const kAudioDevicePropertyDeviceIsRunningSomewhere: _bindgen_ty_261 = 1735356005;
pub const kAudioDeviceProcessorOverload: _bindgen_ty_261 = 1870030194;
pub const kAudioDevicePropertyIOStoppedAbnormally: _bindgen_ty_261 = 1937010788;
pub const kAudioDevicePropertyHogMode: _bindgen_ty_261 = 1869180523;
pub const kAudioDevicePropertyBufferFrameSize: _bindgen_ty_261 = 1718839674;
pub const kAudioDevicePropertyBufferFrameSizeRange: _bindgen_ty_261 = 1718843939;
pub const kAudioDevicePropertyUsesVariableBufferFrameSizes: _bindgen_ty_261 = 1986425722;
pub const kAudioDevicePropertyIOCycleUsage: _bindgen_ty_261 = 1852012899;
pub const kAudioDevicePropertyStreamConfiguration: _bindgen_ty_261 = 1936482681;
pub const kAudioDevicePropertyIOProcStreamUsage: _bindgen_ty_261 = 1937077093;
pub const kAudioDevicePropertyActualSampleRate: _bindgen_ty_261 = 1634955892;
pub const kAudioDevicePropertyClockDevice: _bindgen_ty_261 = 1634755428;
pub type _bindgen_ty_261 = u32;
pub const kAudioDevicePropertyJackIsConnected: _bindgen_ty_262 = 1784767339;
pub const kAudioDevicePropertyVolumeScalar: _bindgen_ty_262 = 1987013741;
pub const kAudioDevicePropertyVolumeDecibels: _bindgen_ty_262 = 1987013732;
pub const kAudioDevicePropertyVolumeRangeDecibels: _bindgen_ty_262 = 1986290211;
pub const kAudioDevicePropertyVolumeScalarToDecibels: _bindgen_ty_262 = 1983013986;
pub const kAudioDevicePropertyVolumeDecibelsToScalar: _bindgen_ty_262 = 1684157046;
pub const kAudioDevicePropertyStereoPan: _bindgen_ty_262 = 1936744814;
pub const kAudioDevicePropertyStereoPanChannels: _bindgen_ty_262 = 1936748067;
pub const kAudioDevicePropertyMute: _bindgen_ty_262 = 1836414053;
pub const kAudioDevicePropertySolo: _bindgen_ty_262 = 1936682095;
pub const kAudioDevicePropertyPhantomPower: _bindgen_ty_262 = 1885888878;
pub const kAudioDevicePropertyPhaseInvert: _bindgen_ty_262 = 1885893481;
pub const kAudioDevicePropertyClipLight: _bindgen_ty_262 = 1668049264;
pub const kAudioDevicePropertyTalkback: _bindgen_ty_262 = 1952541794;
pub const kAudioDevicePropertyListenback: _bindgen_ty_262 = 1819504226;
pub const kAudioDevicePropertyDataSource: _bindgen_ty_262 = 1936945763;
pub const kAudioDevicePropertyDataSources: _bindgen_ty_262 = 1936941859;
pub const kAudioDevicePropertyDataSourceNameForIDCFString: _bindgen_ty_262 = 1819501422;
pub const kAudioDevicePropertyDataSourceKindForID: _bindgen_ty_262 = 1936941931;
pub const kAudioDevicePropertyClockSource: _bindgen_ty_262 = 1668510307;
pub const kAudioDevicePropertyClockSources: _bindgen_ty_262 = 1668506403;
pub const kAudioDevicePropertyClockSourceNameForIDCFString: _bindgen_ty_262 = 1818456942;
pub const kAudioDevicePropertyClockSourceKindForID: _bindgen_ty_262 = 1668506475;
pub const kAudioDevicePropertyPlayThru: _bindgen_ty_262 = 1953002101;
pub const kAudioDevicePropertyPlayThruSolo: _bindgen_ty_262 = 1953002099;
pub const kAudioDevicePropertyPlayThruVolumeScalar: _bindgen_ty_262 = 1836479331;
pub const kAudioDevicePropertyPlayThruVolumeDecibels: _bindgen_ty_262 = 1836475490;
pub const kAudioDevicePropertyPlayThruVolumeRangeDecibels: _bindgen_ty_262 = 1836475427;
pub const kAudioDevicePropertyPlayThruVolumeScalarToDecibels: _bindgen_ty_262 = 1836462692;
pub const kAudioDevicePropertyPlayThruVolumeDecibelsToScalar: _bindgen_ty_262 = 1836462707;
pub const kAudioDevicePropertyPlayThruStereoPan: _bindgen_ty_262 = 1836281966;
pub const kAudioDevicePropertyPlayThruStereoPanChannels: _bindgen_ty_262 = 1836281891;
pub const kAudioDevicePropertyPlayThruDestination: _bindgen_ty_262 = 1835295859;
pub const kAudioDevicePropertyPlayThruDestinations: _bindgen_ty_262 = 1835295779;
pub const kAudioDevicePropertyPlayThruDestinationNameForIDCFString: _bindgen_ty_262 = 1835295843;
pub const kAudioDevicePropertyChannelNominalLineLevel: _bindgen_ty_262 = 1852601964;
pub const kAudioDevicePropertyChannelNominalLineLevels: _bindgen_ty_262 = 1852601891;
pub const kAudioDevicePropertyChannelNominalLineLevelNameForIDCFString: _bindgen_ty_262 =
    1818455660;
pub const kAudioDevicePropertyHighPassFilterSetting: _bindgen_ty_262 = 1751740518;
pub const kAudioDevicePropertyHighPassFilterSettings: _bindgen_ty_262 = 1751740451;
pub const kAudioDevicePropertyHighPassFilterSettingNameForIDCFString: _bindgen_ty_262 = 1751740524;
pub const kAudioDevicePropertySubVolumeScalar: _bindgen_ty_262 = 1937140845;
pub const kAudioDevicePropertySubVolumeDecibels: _bindgen_ty_262 = 1937140836;
pub const kAudioDevicePropertySubVolumeRangeDecibels: _bindgen_ty_262 = 1937138723;
pub const kAudioDevicePropertySubVolumeScalarToDecibels: _bindgen_ty_262 = 1937125988;
pub const kAudioDevicePropertySubVolumeDecibelsToScalar: _bindgen_ty_262 = 1935946358;
pub const kAudioDevicePropertySubMute: _bindgen_ty_262 = 1936553332;
pub type _bindgen_ty_262 = u32;
extern "C" {
    ///@function       AudioDeviceCreateIOProcID
    ///@abstract       Creates an AudioDeviceIOProcID from an AudioDeviceIOProc and a client data
    ///pointer.
    ///@discussion     AudioDeviceIOProcIDs allow for the client to register the same function pointer
    ///with a device multiple times
    ///@param          inDevice
    ///The AudioDevice to register the IOProc with.
    ///@param          inProc
    ///The AudioDeviceIOProc to register.
    ///@param          inClientData
    ///A pointer to client data that is passed back to the IOProc when it is
    ///called.
    ///@param          outIOProcID
    ///The newly created AudioDeviceIOProcID.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioDeviceCreateIOProcID(
        inDevice: AudioObjectID,
        inProc: AudioDeviceIOProc,
        inClientData: *mut ::std::os::raw::c_void,
        outIOProcID: *mut AudioDeviceIOProcID,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceCreateIOProcIDWithBlock
    ///@abstract       Creates an AudioDeviceIOProcID from an AudioDeviceIOBlock
    ///@param          outIOProcID
    ///The newly created AudioDeviceIOProcID.
    ///@param          inDevice
    ///The AudioDevice to register the Block with.
    ///@param          inDispatchQueue
    ///The dispatch queue on which the IOBlock will be dispatched. All
    ///IOBlocks are dispatched synchronously. Note that this dispatch queue will be
    ///retained until a matching call to AudioDeviceDestroyIOProcID is made. If
    ///this value is NULL, then the IOBlock will be directly invoked.
    ///@param          inBlock
    ///The AudioDeviceIOBlock to register.  Note that this block will be
    ///Block_copy'd and the reference maintained until a matching call to
    ///AudioDeviceDestroyIOProcID is made.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioDeviceCreateIOProcIDWithBlock(
        outIOProcID: *mut AudioDeviceIOProcID,
        inDevice: AudioObjectID,
        inDispatchQueue: dispatch_queue_t,
        inIOBlock: AudioDeviceIOBlock,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceDestroyIOProcID
    ///@abstract       Destroys an AudioDeviceIOProcID.
    ///@discussion     AudioDeviceIOProcIDs allow for the client to register the same function pointer
    ///with a device multiple times
    ///@param          inDevice
    ///The AudioDevice from which the ID came.
    ///@param          inIOProcID
    ///The AudioDeviceIOProcID to get rid of.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioDeviceDestroyIOProcID(
        inDevice: AudioObjectID,
        inIOProcID: AudioDeviceIOProcID,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceStart
    ///@abstract       Starts IO for the given AudioDeviceIOProcID.
    ///@param          inDevice
    ///The AudioDevice to start the IOProc on.
    ///@param          inProcID
    ///The AudioDeviceIOProcID to start. Note that this can be NULL, which starts
    ///the hardware regardless of whether or not there are any IOProcs registered.
    ///This is necessary if any of the AudioDevice's timing services are to be
    ///used. A balancing call to AudioDeviceStop with a NULL IOProc is required to
    ///stop the hardware.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioDeviceStart(inDevice: AudioObjectID, inProcID: AudioDeviceIOProcID) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceStartAtTime
    ///@abstract       Starts IO for the given AudioDeviceIOProcID and aligns the IO cycle of the
    ///AudioDevice with the given time.
    ///@param          inDevice
    ///The AudioDevice to start the IOProc on.
    ///@param          inProcID
    ///The AudioDeviceIOProcID to start. Note that this can be NULL, which starts
    ///the hardware regardless of whether or not there are any IOProcs registered.
    ///@param          ioRequestedStartTime
    ///A pointer to an AudioTimeStamp that, on entry, is the requested time to
    ///start the IOProc. On exit, it will be the actual time the IOProc will start.
    ///@param          inFlags
    ///A UInt32 containing flags that modify how this function behaves.
    ///@result         An OSStatus indicating success or failure.
    ///kAudioHardwareUnsupportedOperationError will be returned if the AudioDevice does
    ///not support starting at a specific time and inProc and ioRequestedStartTime are
    ///not NULL.
    pub fn AudioDeviceStartAtTime(
        inDevice: AudioObjectID,
        inProcID: AudioDeviceIOProcID,
        ioRequestedStartTime: *mut AudioTimeStamp,
        inFlags: UInt32,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceStop
    ///@abstract       Stops IO for the given AudioDeviceIOProcID.
    ///@param          inDevice
    ///The AudioDevice to stop the IOProc on.
    ///@param          inProcID
    ///The AudioDeviceIOProcID to stop.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioDeviceStop(inDevice: AudioObjectID, inProcID: AudioDeviceIOProcID) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceGetCurrentTime
    ///@abstract       Retrieves the current time from an AudioDevice. Note that the device has to be
    ///running.
    ///@param          inDevice
    ///The AudioDevice to from which to get the time.
    ///@param          outTime
    ///An AudioTimeStamp into which the current time is put. On entry, the
    ///mFlags field specifies which representations to provide. Because not every
    ///device supports all time representations, on exit, the mFlags field will
    ///indicate what values are actually valid.
    ///@result         An OSStatus indicating success or failure. kAudioHardwareNotRunningError will be
    ///returned if the AudioDevice isn't running.
    pub fn AudioDeviceGetCurrentTime(
        inDevice: AudioObjectID,
        outTime: *mut AudioTimeStamp,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceTranslateTime
    ///@abstract       Translates the time in the AudioDevice's time base from one representation to
    ///another. Note that the device has to be running
    ///@param          inDevice
    ///The AudioDevice whose time base governs the translation.
    ///@param          inTime
    ///An AudioTimeStamp containing the time to be translated.
    ///@param          outTime
    ///An AudioTimeStamp into which the translated time is put. On entry, the
    ///mFlags field specifies which representations to translate the input time
    ///into. Because not every device supports all time representations, on exit,
    ///the mFlags field will indicate which translations were actually done.
    ///@result         An OSStatus indicating success or failure. kAudioHardwareNotRunningError will be
    ///returned if the AudioDevice isn't running.
    pub fn AudioDeviceTranslateTime(
        inDevice: AudioObjectID,
        inTime: *const AudioTimeStamp,
        outTime: *mut AudioTimeStamp,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceGetNearestStartTime
    ///@abstract       Query an AudioDevice to get a time equal to or later than the given time that is
    ///the best time to start IO.
    ///@discussion     The time that is returned is dictated by the constraints of the device and the
    ///system. For instance, the driver of a device that provides both audio and video
    ///data may only allow start times that coincide with the edge of a video frame.
    ///Also, if the device already has one or more active IOProcs, the start time will
    ///be shifted to the beginning of the next IO cycle so as not to cause
    ///discontinuities in the existing IOProcs. Another reason the start time may shift
    ///is to allow for aligning the buffer accesses in an optimal fashion. Note that
    ///the device must be running to use this function.
    ///@param          inDevice
    ///The AudioDevice to query.
    ///@param          ioRequestedStartTime
    ///A pointer to an AudioTimeStamp that, on entry, is the requested start time.
    ///On exit, it will have the a time equal to or later than the requested time,
    ///as dictated by the device's constraints.
    ///@param          inFlags
    ///A UInt32 containing flags that modify how this function behaves.
    ///@result         An OSStatus indicating success or failure. kAudioHardwareNotRunningError will be
    ///returned if the AudioDevice isn't running.
    ///kAudioHardwareUnsupportedOperationError will be returned if the AudioDevice does
    ///not support starting at a specific time.
    pub fn AudioDeviceGetNearestStartTime(
        inDevice: AudioObjectID,
        ioRequestedStartTime: *mut AudioTimeStamp,
        inFlags: UInt32,
    ) -> OSStatus;
}
pub const kAudioAggregateDeviceClassID: _bindgen_ty_263 = 1633773415;
pub type _bindgen_ty_263 = u32;
pub const kAudioAggregateDevicePropertyFullSubDeviceList: _bindgen_ty_264 = 1735554416;
pub const kAudioAggregateDevicePropertyActiveSubDeviceList: _bindgen_ty_264 = 1634169456;
pub const kAudioAggregateDevicePropertyComposition: _bindgen_ty_264 = 1633906541;
pub const kAudioAggregateDevicePropertyMasterSubDevice: _bindgen_ty_264 = 1634562932;
pub const kAudioAggregateDevicePropertyClockDevice: _bindgen_ty_264 = 1634755428;
pub type _bindgen_ty_264 = u32;
pub const kAudioSubDeviceClassID: _bindgen_ty_265 = 1634956642;
pub type _bindgen_ty_265 = u32;
pub const kAudioSubDeviceDriftCompensationMinQuality: _bindgen_ty_266 = 0;
pub const kAudioSubDeviceDriftCompensationLowQuality: _bindgen_ty_266 = 32;
pub const kAudioSubDeviceDriftCompensationMediumQuality: _bindgen_ty_266 = 64;
pub const kAudioSubDeviceDriftCompensationHighQuality: _bindgen_ty_266 = 96;
pub const kAudioSubDeviceDriftCompensationMaxQuality: _bindgen_ty_266 = 127;
pub type _bindgen_ty_266 = u32;
pub const kAudioSubDevicePropertyExtraLatency: _bindgen_ty_267 = 2020373603;
pub const kAudioSubDevicePropertyDriftCompensation: _bindgen_ty_267 = 1685218932;
pub const kAudioSubDevicePropertyDriftCompensationQuality: _bindgen_ty_267 = 1685218929;
pub type _bindgen_ty_267 = u32;
pub const kAudioDevicePropertyScopeInput: _bindgen_ty_268 = 1768845428;
pub const kAudioDevicePropertyScopeOutput: _bindgen_ty_268 = 1869968496;
pub const kAudioDevicePropertyScopePlayThrough: _bindgen_ty_268 = 1886679669;
pub type _bindgen_ty_268 = u32;
pub const kAudioPropertyWildcardPropertyID: _bindgen_ty_269 = 707406378;
pub type _bindgen_ty_269 = u32;
pub const kAudioPropertyWildcardSection: _bindgen_ty_270 = 255;
pub type _bindgen_ty_270 = u32;
pub const kAudioPropertyWildcardChannel: _bindgen_ty_271 = 4294967295;
pub type _bindgen_ty_271 = u32;
pub const kAudioISubOwnerControlClassID: _bindgen_ty_272 = 1635017576;
pub type _bindgen_ty_272 = u32;
pub const kAudioLevelControlPropertyDecibelsToScalarTransferFunction: _bindgen_ty_273 = 1818457190;
pub type _bindgen_ty_273 = u32;
///@enum           Values for kAudioLevelControlPropertyDecibelsToScalarTransferFunction
///@abstract       The following constants are the only supported values for a volume control's
///transfer function.
///@discussion     The transfer function implemented in the volume control works by raising the
///scalar value to an exponent to map it into the decibel range. The constants
///in this enum express the exponent used in the name as a quotient. For example,
///kAudioLevelControlTranferFunction3Over4 represents the exponent 0.75.
pub type AudioLevelControlTransferFunction = UInt32;
pub const kAudioLevelControlTranferFunctionLinear: _bindgen_ty_274 = 0;
pub const kAudioLevelControlTranferFunction1Over3: _bindgen_ty_274 = 1;
pub const kAudioLevelControlTranferFunction1Over2: _bindgen_ty_274 = 2;
pub const kAudioLevelControlTranferFunction3Over4: _bindgen_ty_274 = 3;
pub const kAudioLevelControlTranferFunction3Over2: _bindgen_ty_274 = 4;
pub const kAudioLevelControlTranferFunction2Over1: _bindgen_ty_274 = 5;
pub const kAudioLevelControlTranferFunction3Over1: _bindgen_ty_274 = 6;
pub const kAudioLevelControlTranferFunction4Over1: _bindgen_ty_274 = 7;
pub const kAudioLevelControlTranferFunction5Over1: _bindgen_ty_274 = 8;
pub const kAudioLevelControlTranferFunction6Over1: _bindgen_ty_274 = 9;
pub const kAudioLevelControlTranferFunction7Over1: _bindgen_ty_274 = 10;
pub const kAudioLevelControlTranferFunction8Over1: _bindgen_ty_274 = 11;
pub const kAudioLevelControlTranferFunction9Over1: _bindgen_ty_274 = 12;
pub const kAudioLevelControlTranferFunction10Over1: _bindgen_ty_274 = 13;
pub const kAudioLevelControlTranferFunction11Over1: _bindgen_ty_274 = 14;
pub const kAudioLevelControlTranferFunction12Over1: _bindgen_ty_274 = 15;
pub type _bindgen_ty_274 = u32;
///@typedef        AudioHardwarePropertyID
///@abstract       An AudioHardwarePropertyID is a integer that identifies a specific piece of
///information about the AudioSystemObject.
pub type AudioHardwarePropertyID = AudioObjectPropertySelector;
///@typedef        AudioHardwarePropertyListenerProc
///@abstract       Clients register an AudioHardwarePropertyListenerProc with the AudioSystemObject
///in order to receive notifications when the properties of the object change.
///@discussion     Note that the same functionality is provided by AudioObjectPropertyListenerProc.
///@param          inPropertyID
///The AudioHardwarePropertyID of the property that changed.
///@param          inClientData
///A pointer to client data established when the listener proc was registered
///with the AudioSystemObject.
///@result         The return value is currently unused and should always be 0.
pub type AudioHardwarePropertyListenerProc = ::std::option::Option<
    unsafe extern "C" fn(
        inPropertyID: AudioHardwarePropertyID,
        inClientData: *mut ::std::os::raw::c_void,
    ) -> OSStatus,
>;
pub const kAudioHardwarePropertyRunLoop: _bindgen_ty_275 = 1919839344;
pub const kAudioHardwarePropertyDeviceForUID: _bindgen_ty_275 = 1685416292;
pub const kAudioHardwarePropertyPlugInForBundleID: _bindgen_ty_275 = 1885954665;
pub type _bindgen_ty_275 = u32;
pub const kAudioHardwarePropertyBootChimeVolumeScalar: _bindgen_ty_276 = 1650620019;
pub const kAudioHardwarePropertyBootChimeVolumeDecibels: _bindgen_ty_276 = 1650620004;
pub const kAudioHardwarePropertyBootChimeVolumeRangeDecibels: _bindgen_ty_276 = 1650615331;
pub const kAudioHardwarePropertyBootChimeVolumeScalarToDecibels: _bindgen_ty_276 = 1651913316;
pub const kAudioHardwarePropertyBootChimeVolumeDecibelsToScalar: _bindgen_ty_276 = 1650733686;
pub const kAudioHardwarePropertyBootChimeVolumeDecibelsToScalarTransferFunction: _bindgen_ty_276 =
    1651930214;
pub type _bindgen_ty_276 = u32;
extern "C" {
    ///@function       AudioHardwareAddRunLoopSource
    ///@abstract       Add the given CFRunLoopSource to the the HAL's notification CFRunLoop.
    ///@discussion     The CFRunLoop the HAL uses for notifications is specified by
    ///kAudioHardwarePropertyRunLoop. If kAudioHardwarePropertyRunLoop changes,
    ///CFRunLoopSources added with this function will automatically be transferred to
    ///the new CFRunLoop.
    ///Usage of the HAL's notification run loop is deprecated. Please use libdispatch
    ///instead.
    ///@param          inRunLoopSource
    ///The CFRunLoopSource to add.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioHardwareAddRunLoopSource(inRunLoopSource: CFRunLoopSourceRef) -> OSStatus;
}
extern "C" {
    ///@function       AudioHardwareRemoveRunLoopSource
    ///@abstract       Remove the given CFRunLoopSource from the the HAL's notification CFRunLoop.
    ///@discussion     The CFRunLoop the HAL uses for notifications is specified by
    ///kAudioHardwarePropertyRunLoop.
    ///Usage of the HAL's notification run loop is deprecated. Please use libdispatch
    ///instead.
    ///@param          inRunLoopSource
    ///The CFRunLoopSource to remove.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioHardwareRemoveRunLoopSource(inRunLoopSource: CFRunLoopSourceRef) -> OSStatus;
}
extern "C" {
    ///@function       AudioHardwareGetPropertyInfo
    ///@abstract       Retrieve information about the given property.
    ///@discussion     Note that the same functionality is provided by the functions
    ///AudioObjectHasProperty(), AudioObjectIsPropertySettable(), and
    ///AudioObjectGetPropertyDataSize().
    ///@param          inPropertyID
    ///The AudioHardwarePropertyID of the property to query.
    ///@param          outSize
    ///A pointer to a UInt32 that receives the size of the property data in bytes
    ///on exit. This can be NULL if the size information is not being requested.
    ///@param          outWritable
    ///A pointer to a Boolean that receives indication of whether or not the given
    ///property can be set. This can be NULL if the writability is not being
    ///requested.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioHardwareGetPropertyInfo(
        inPropertyID: AudioHardwarePropertyID,
        outSize: *mut UInt32,
        outWritable: *mut Boolean,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioHardwareGetProperty
    ///@abstract       Queries an the AudioSystemObject to get the data of the given property and
    ///places it in the provided buffer.
    ///@discussion     Note that the same functionality is provided by the function
    ///AudioObjectGetPropertyData().
    ///@param          inPropertyID
    ///The AudioHardwarePropertyID of the property to query.
    ///@param          ioDataSize
    ///A UInt32 which on entry indicates the size of the buffer pointed to by
    ///outData and on exit indicates how much of the buffer was used.
    ///@param          outData
    ///The buffer into which the AudioSystemObject will put the data for the given
    ///property.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioHardwareGetProperty(
        inPropertyID: AudioHardwarePropertyID,
        ioPropertyDataSize: *mut UInt32,
        outPropertyData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioHardwareSetProperty
    ///@abstract       Tells the AudioSystemObject to change the value of the given property using the
    ///provided data.
    ///@discussion     Note that the value of the property should not be considered changed until the
    ///HAL has called the listeners as many properties values are changed
    ///asynchronously. Also note that the same functionality is provided by the
    ///function AudioObjectGetPropertyData().
    ///@param          inPropertyID
    ///The AudioHardwarePropertyID of the property to change.
    ///@param          inDataSize
    ///A UInt32 indicating the size of the buffer pointed to by inData.
    ///@param          inData
    ///The buffer containing the data to be used to change the property's value.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioHardwareSetProperty(
        inPropertyID: AudioHardwarePropertyID,
        inPropertyDataSize: UInt32,
        inPropertyData: *const ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioHardwareAddPropertyListener
    ///@abstract       Registers the given AudioHardwarePropertyListenerProc to receive notifications
    ///when the given property changes.
    ///@discussion     Note that the same functionality is provided by AudioObjectAddPropertyListener
    ///in conjunction with AudioObjectPropertyListenerProc.
    ///@param          inPropertyID
    ///The AudioHardwarePropertyID of the property to listen to.
    ///@param          inProc
    ///AudioHardwarePropertyListenerProc to call.
    ///@param          inClientData
    ///A pointer to client data that is passed to the listener when it is called.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioHardwareAddPropertyListener(
        inPropertyID: AudioHardwarePropertyID,
        inProc: AudioHardwarePropertyListenerProc,
        inClientData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioHardwareRemovePropertyListener
    ///@abstract       Unregisters the given AudioHardwarePropertyListenerProc from receive
    ///notifications when the given property changes.
    ///@discussion     Note that the same functionality is provided by
    ///AudioObjectRemovePropertyListener in conjunction with
    ///AudioObjectPropertyListenerProc.
    ///@param          inPropertyID
    ///The AudioHardwarePropertyID of the property to stop listening to.
    ///@param          inProc
    ///AudioHardwarePropertyListenerProc to unregister.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioHardwareRemovePropertyListener(
        inPropertyID: AudioHardwarePropertyID,
        inProc: AudioHardwarePropertyListenerProc,
    ) -> OSStatus;
}
///@typedef        AudioDeviceID
///@abstract       AudioDevice is the base class for all objects that represent an audio device.
///@discussion     AudioDevice is a subclass of AudioObject. AudioDevices normally contain
///AudioStreams and AudioControls, but may contain other things depending on the
///kind of AudioDevice (e.g. aggregate devices contain other AudioDevices).
pub type AudioDeviceID = AudioObjectID;
///@typedef        AudioDevicePropertyID
///@abstract       An AudioDevicePropertyID is an integer that identifies a specific piece of
///information about the object.
pub type AudioDevicePropertyID = AudioObjectPropertySelector;
///@typedef        AudioDevicePropertyListenerProc
///@abstract       Clients register an AudioDevicePropertyListenerProc with the AudioDevice object
///in order to receive notifications when the properties of the object change.
///@discussion     Note that the same functionality is provided by AudioObjectPropertyListenerProc.
///@param          inDevice
///The AudioDevice whose property has changed.
///@param          inChannel
///The channel of the property that changed where 0 is the master channel.
///@param          isInput
///Which section of the AudioDevice changed.
///@param          inPropertyID
///The AudioDevicePropertyID of the property that changed.
///@param          inClientData
///A pointer to client data established when the listener proc was registered
///with the object.
///@result         The return value is currently unused and should always be 0.
pub type AudioDevicePropertyListenerProc = ::std::option::Option<
    unsafe extern "C" fn(
        inDevice: AudioDeviceID,
        inChannel: UInt32,
        isInput: Boolean,
        inPropertyID: AudioDevicePropertyID,
        inClientData: *mut ::std::os::raw::c_void,
    ) -> OSStatus,
>;
pub const kAudioDeviceUnknown: _bindgen_ty_277 = 0;
pub type _bindgen_ty_277 = u32;
pub const kAudioDeviceTransportTypeAutoAggregate: _bindgen_ty_278 = 1718055536;
pub type _bindgen_ty_278 = u32;
pub const kAudioDevicePropertyVolumeDecibelsToScalarTransferFunction: _bindgen_ty_279 = 1986229350;
pub const kAudioDevicePropertyPlayThruVolumeDecibelsToScalarTransferFunction: _bindgen_ty_279 =
    1836479590;
pub const kAudioDevicePropertyDriverShouldOwniSub: _bindgen_ty_279 = 1769174370;
pub const kAudioDevicePropertySubVolumeDecibelsToScalarTransferFunction: _bindgen_ty_279 =
    1937142886;
pub type _bindgen_ty_279 = u32;
pub const kAudioDevicePropertyDeviceName: _bindgen_ty_280 = 1851878757;
pub const kAudioDevicePropertyDeviceNameCFString: _bindgen_ty_280 = 1819173229;
pub const kAudioDevicePropertyDeviceManufacturer: _bindgen_ty_280 = 1835101042;
pub const kAudioDevicePropertyDeviceManufacturerCFString: _bindgen_ty_280 = 1819107691;
pub const kAudioDevicePropertyRegisterBufferList: _bindgen_ty_280 = 1919055206;
pub const kAudioDevicePropertyBufferSize: _bindgen_ty_280 = 1651730810;
pub const kAudioDevicePropertyBufferSizeRange: _bindgen_ty_280 = 1651735075;
pub const kAudioDevicePropertyChannelName: _bindgen_ty_280 = 1667788397;
pub const kAudioDevicePropertyChannelNameCFString: _bindgen_ty_280 = 1818454126;
pub const kAudioDevicePropertyChannelCategoryName: _bindgen_ty_280 = 1667460717;
pub const kAudioDevicePropertyChannelCategoryNameCFString: _bindgen_ty_280 = 1818452846;
pub const kAudioDevicePropertyChannelNumberName: _bindgen_ty_280 = 1668181613;
pub const kAudioDevicePropertyChannelNumberNameCFString: _bindgen_ty_280 = 1818455662;
pub const kAudioDevicePropertySupportsMixing: _bindgen_ty_280 = 1835628607;
pub const kAudioDevicePropertyStreamFormat: _bindgen_ty_280 = 1936092532;
pub const kAudioDevicePropertyStreamFormats: _bindgen_ty_280 = 1936092451;
pub const kAudioDevicePropertyStreamFormatSupported: _bindgen_ty_280 = 1936092479;
pub const kAudioDevicePropertyStreamFormatMatch: _bindgen_ty_280 = 1936092525;
pub const kAudioDevicePropertyDataSourceNameForID: _bindgen_ty_280 = 1936941934;
pub const kAudioDevicePropertyClockSourceNameForID: _bindgen_ty_280 = 1668506478;
pub const kAudioDevicePropertyPlayThruDestinationNameForID: _bindgen_ty_280 = 1835295854;
pub const kAudioDevicePropertyChannelNominalLineLevelNameForID: _bindgen_ty_280 = 1668181110;
pub const kAudioDevicePropertyHighPassFilterSettingNameForID: _bindgen_ty_280 = 1667787120;
pub type _bindgen_ty_280 = u32;
extern "C" {
    ///@function       AudioDeviceAddIOProc
    ///@abstract       Registers the given AudioDeviceIOProc with the AudioDevice.
    ///@discussion     A client may have multiple IOProcs for a given device, but the device is free to
    ///only accept as many as it can handle. Note that it is not recommended for
    ///clients to have more than a single IOProc registered at a time as this can be
    ///wasteful of system resources. Rather, it is recommended that the client do any
    ///necessary mixing itself so that only one IOProc is necessary.
    ///This routine has been deprecated in favor of AudioDeviceCreateIOProcID().
    ///@param          inDevice
    ///The AudioDevice to register the IOProc with.
    ///@param          inProc
    ///The AudioDeviceIOProc to register.
    ///@param          inClientData
    ///A pointer to client data that is passed back to the IOProc when it is
    ///called.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioDeviceAddIOProc(
        inDevice: AudioDeviceID,
        inProc: AudioDeviceIOProc,
        inClientData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceRemoveIOProc
    ///@abstract       Unregisters the given AudioDeviceIOProc from the AudioDevice.
    ///This routine has been deprecated in favor of AudioDeviceDestroyIOProcID().
    ///@param          inDevice
    ///The AudioDevice to unregister the IOProc from.
    ///@param          inProc
    ///The AudioDeviceIOProc to unregister.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioDeviceRemoveIOProc(inDevice: AudioDeviceID, inProc: AudioDeviceIOProc) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceRead
    ///@abstract       Read some data from an AudioDevice starting at the given time.
    ///@discussion     With the advent of aggregate devices, the need for AudioDeviceRead has gone
    ///away. Consequently, this function is now deprecated.
    ///@param          inDevice
    ///The AudioDevice to read from.
    ///@param          inStartTime
    ///An AudioTimeStamp indicating the time from which to read the data. In
    ///general, the valid range of time (in frames) is from the current time minus
    ///the maximum IO buffer size to the current time minus the safety offset.
    ///@param          outData
    ///An AudioBufferList that must be the same size and shape as that returned by
    ///kAudioDevicePropertyStreamConfiguration. Further, the AudioBufferList must
    ///have been previously registered with the device via
    ///kAudioDevicePropertyRegisterBufferList. On exit, the mDataSize fields will
    ///be updated with the amount of data read.
    ///@result         An OSStatus indicating success or failure.
    ///kAudioHardwareUnsupportedOperationError will be returned if the AudioDevice does
    ///not support direct reading.
    pub fn AudioDeviceRead(
        inDevice: AudioDeviceID,
        inStartTime: *const AudioTimeStamp,
        outData: *mut AudioBufferList,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceGetPropertyInfo
    ///@abstract       Retrieve information about the given property of an AudioDevice.
    ///@discussion     Note that the same functionality is provided by the functions
    ///AudioObjectHasProperty(), AudioObjectIsPropertySettable(), and
    ///AudioObjectGetPropertyDataSize().
    ///@param          inDevice
    ///The AudioDevice to query.
    ///@param          inChannel
    ///The channel of the property to query where 0 is the master channel.
    ///@param          isInput
    ///Which section of the AudioDevice to query.
    ///@param          inPropertyID
    ///The AudioDevicePropertyID of the property to query.
    ///@param          outSize
    ///A pointer to a UInt32 that receives the size of the property data in bytes
    ///on exit. This can be NULL if the size information is not being requested.
    ///@param          outWritable
    ///A pointer to a Boolean that receives indication of whether or not the given
    ///property can be set. This can be NULL if the writability is not being
    ///requested.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioDeviceGetPropertyInfo(
        inDevice: AudioDeviceID,
        inChannel: UInt32,
        isInput: Boolean,
        inPropertyID: AudioDevicePropertyID,
        outSize: *mut UInt32,
        outWritable: *mut Boolean,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceGetProperty
    ///@abstract       Queries an the AudioDevice object to get the data of the given property and
    ///places it in the provided buffer.
    ///@discussion     Note that the same functionality is provided by the function
    ///AudioObjectGetPropertyData().
    ///@param          inDevice
    ///The AudioDevice to query.
    ///@param          inChannel
    ///The channel of the property to query where 0 is the master channel.
    ///@param          isInput
    ///Which section of the AudioDevice to query.
    ///@param          inPropertyID
    ///The AudioDevicePropertyID of the property to query.
    ///@param          ioPropertyDataSize
    ///A UInt32 which on entry indicates the size of the buffer pointed to by
    ///outData and on exit indicates how much of the buffer was used.
    ///@param          outPropertyData
    ///The buffer into which the object will put the data for the given property.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioDeviceGetProperty(
        inDevice: AudioDeviceID,
        inChannel: UInt32,
        isInput: Boolean,
        inPropertyID: AudioDevicePropertyID,
        ioPropertyDataSize: *mut UInt32,
        outPropertyData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceSetProperty
    ///@abstract       Tells the AudioDevice object to change the value of the given property using the
    ///provided data.
    ///@discussion     Note that the value of the property should not be considered changed until the
    ///HAL has called the listeners as many properties values are changed
    ///asynchronously. Also note that the same functionality is provided by the
    ///function AudioObjectSetPropertyData().
    ///@param          inDevice
    ///The AudioDevice to change.
    ///@param          inWhen
    ///A pointer to an AudioTimeStamp that says when to change the property's value
    ///relative to the device's time base. NULL means execute the change
    ///immediately.
    ///@param          inChannel
    ///The channel of the property to change where 0 is the master channel.
    ///@param          isInput
    ///Which section of the AudioDevice to change.
    ///@param          inPropertyID
    ///The AudioDevicePropertyID of the property to change.
    ///@param          inPropertyDataSize
    ///A UInt32 indicating the size of the buffer pointed to by inData.
    ///@param          inPropertyData
    ///The buffer containing the data to be used to change the property's value.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioDeviceSetProperty(
        inDevice: AudioDeviceID,
        inWhen: *const AudioTimeStamp,
        inChannel: UInt32,
        isInput: Boolean,
        inPropertyID: AudioDevicePropertyID,
        inPropertyDataSize: UInt32,
        inPropertyData: *const ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceAddPropertyListener
    ///@abstract       Registers the given AudioDevicePropertyListenerProc to receive notifications
    ///when the given property changes.
    ///@discussion     Note that the same functionality is provided by AudioObjectAddPropertyListener
    ///in conjunction with AudioObjectPropertyListenerProc.
    ///@param          inDevice
    ///The AudioDevice with whom to register the listener.
    ///@param          inChannel
    ///The channel of the property to listen to.
    ///@param          isInput
    ///Which section of the AudioDevice to listen to.
    ///@param          inPropertyID
    ///The AudioDevicePropertyID of the property to listen to.
    ///@param          inProc
    ///AudioDevicePropertyListenerProc to call.
    ///@param          inClientData
    ///A pointer to client data that is passed to the listener when it is called.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioDeviceAddPropertyListener(
        inDevice: AudioDeviceID,
        inChannel: UInt32,
        isInput: Boolean,
        inPropertyID: AudioDevicePropertyID,
        inProc: AudioDevicePropertyListenerProc,
        inClientData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioDeviceRemovePropertyListener
    ///@abstract       Unregisters the given AudioDevicePropertyListenerProc from receiving
    ///notifications when the given property changes.
    ///@discussion     Note that the same functionality is provided by
    ///AudioObjectRemovePropertyListener in conjunction with
    ///AudioObjectPropertyListenerProc.
    ///@param          inDevice
    ///The AudioDevice with whom to unregister the listener.
    ///@param          inChannel
    ///The channel of the property to unregister from.
    ///@param          isInput
    ///Which section of the AudioDevice to unregister from.
    ///@param          inPropertyID
    ///The AudioDevicePropertyID of the property to stop listening to.
    ///@param          inProc
    ///AudioDevicePropertyListenerProc to unregister.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioDeviceRemovePropertyListener(
        inDevice: AudioDeviceID,
        inChannel: UInt32,
        isInput: Boolean,
        inPropertyID: AudioDevicePropertyID,
        inProc: AudioDevicePropertyListenerProc,
    ) -> OSStatus;
}
///@typedef        AudioStreamID
///@abstract       AudioStream is the base class for all objects that represent a stream of data on
///an audio device.
///@discussion     AudioStream is a subclass of AudioObject and can contain AudioControls.
pub type AudioStreamID = AudioObjectID;
///@typedef        AudioStreamPropertyListenerProc
///@abstract       Clients register an AudioStreamPropertyListenerProc with the AudioStream object
///in order to receive notifications when the properties of the object change.
///@discussion     Note that the same functionality is provided by AudioObjectPropertyListenerProc.
///@param          inStream
///The AudioStream whose property has changed.
///@param          inChannel
///The channel of the property that changed where 0 is the master channel.
///@param          inPropertyID
///The AudioDevicePropertyID of the property that changed.
///@param          inClientData
///A pointer to client data established when the listener proc was registered
///with the object.
///@result         The return value is currently unused and should always be 0.
pub type AudioStreamPropertyListenerProc = ::std::option::Option<
    unsafe extern "C" fn(
        inStream: AudioStreamID,
        inChannel: UInt32,
        inPropertyID: AudioDevicePropertyID,
        inClientData: *mut ::std::os::raw::c_void,
    ) -> OSStatus,
>;
pub const kAudioStreamUnknown: _bindgen_ty_281 = 0;
pub type _bindgen_ty_281 = u32;
pub const kAudioStreamPropertyOwningDevice: _bindgen_ty_282 = 1937007734;
pub const kAudioStreamPropertyPhysicalFormats: _bindgen_ty_282 = 1885762595;
pub const kAudioStreamPropertyPhysicalFormatSupported: _bindgen_ty_282 = 1885762623;
pub const kAudioStreamPropertyPhysicalFormatMatch: _bindgen_ty_282 = 1885762669;
pub type _bindgen_ty_282 = u32;
extern "C" {
    ///@function       AudioStreamGetPropertyInfo
    ///@abstract       Retrieve information about the given property of an AudioStream.
    ///@param          inStream
    ///The AudioStream to query.
    ///@param          inChannel
    ///The channel of the property to query where 0 is the master channel.
    ///@param          inPropertyID
    ///The AudioDevicePropertyID of the property to query.
    ///@param          outSize
    ///A pointer to a UInt32 that receives the size of the property data in bytes
    ///on exit. This can be NULL if the size information is not being requested.
    ///@param          outWritable
    ///A pointer to a Boolean that receives indication of whether or not the given
    ///property can be set. This can be NULL if the writability is not being
    ///requested.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioStreamGetPropertyInfo(
        inStream: AudioStreamID,
        inChannel: UInt32,
        inPropertyID: AudioDevicePropertyID,
        outSize: *mut UInt32,
        outWritable: *mut Boolean,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioStreamGetProperty
    ///@abstract       Queries an the AudioStream object to get the data of the given property and
    ///places it in the provided buffer.
    ///@discussion     Note that the same functionality is provided by the function
    ///AudioObjectGetPropertyData().
    ///@param          inStream
    ///The AudioStream to query.
    ///@param          inChannel
    ///The channel of the property to query where 0 is the master channel.
    ///@param          inPropertyID
    ///The AudioDevicePropertyID of the property to query.
    ///@param          ioPropertyDataSize
    ///A UInt32 which on entry indicates the size of the buffer pointed to by
    ///outData and on exit indicates how much of the buffer was used.
    ///@param          outPropertyData
    ///The buffer into which the object will put the data for the given property.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioStreamGetProperty(
        inStream: AudioStreamID,
        inChannel: UInt32,
        inPropertyID: AudioDevicePropertyID,
        ioPropertyDataSize: *mut UInt32,
        outPropertyData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioStreamSetProperty
    ///@abstract       Tells the AudioStream object to change the value of the given property using the
    ///provided data.
    ///@discussion     Note that the value of the property should not be considered changed until the
    ///HAL has called the listeners as many properties values are changed
    ///asynchronously. Also note that the same functionality is provided by the
    ///function AudioObjectSetPropertyData().
    ///@param          inStream
    ///The AudioStream to change.
    ///@param          inWhen
    ///A pointer to an AudioTimeStamp that says when to change the property's value
    ///relative to the device's time base. NULL means execute the change
    ///immediately.
    ///@param          inChannel
    ///The channel of the property to change where 0 is the master channel.
    ///@param          inPropertyID
    ///The AudioDevicePropertyID of the property to change.
    ///@param          inPropertyDataSize
    ///A UInt32 indicating the size of the buffer pointed to by inData.
    ///@param          inPropertyData
    ///The buffer containing the data to be used to change the property's value.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioStreamSetProperty(
        inStream: AudioStreamID,
        inWhen: *const AudioTimeStamp,
        inChannel: UInt32,
        inPropertyID: AudioDevicePropertyID,
        inPropertyDataSize: UInt32,
        inPropertyData: *const ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioStreamAddPropertyListener
    ///@abstract       Registers the given AudioStreamPropertyListenerProc to receive notifications
    ///when the given property changes.
    ///@discussion     Note that the same functionality is provided by AudioObjectAddPropertyListener
    ///in conjunction with AudioObjectPropertyListenerProc.
    ///@param          inStream
    ///The AudioStream with whom to register the listener.
    ///@param          inChannel
    ///The channel of the property to listen to.
    ///@param          inPropertyID
    ///The AudioDevicePropertyID of the property to listen to.
    ///@param          inProc
    ///AudioStreamPropertyListenerProc to call.
    ///@param          inClientData
    ///A pointer to client data that is passed to the listener when it is called.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioStreamAddPropertyListener(
        inStream: AudioStreamID,
        inChannel: UInt32,
        inPropertyID: AudioDevicePropertyID,
        inProc: AudioStreamPropertyListenerProc,
        inClientData: *mut ::std::os::raw::c_void,
    ) -> OSStatus;
}
extern "C" {
    ///@function       AudioStreamRemovePropertyListener
    ///@abstract       Unregisters the given AudioStreamPropertyListenerProc from receiving
    ///notifications when the given property changes.
    ///@discussion     Note that the same functionality is provided by
    ///AudioObjectRemovePropertyListener in conjunction with
    ///AudioObjectPropertyListenerProc.
    ///@param          inStream
    ///The AudioStream with whom to unregister the listener.
    ///@param          inChannel
    ///The channel of the property to unregister from.
    ///@param          inPropertyID
    ///The AudioDevicePropertyID of the property to stop listening to.
    ///@param          inProc
    ///AudioStreamPropertyListenerProc to unregister.
    ///@result         An OSStatus indicating success or failure.
    pub fn AudioStreamRemovePropertyListener(
        inStream: AudioStreamID,
        inChannel: UInt32,
        inPropertyID: AudioDevicePropertyID,
        inProc: AudioStreamPropertyListenerProc,
    ) -> OSStatus;
}
pub const kAudioBootChimeVolumeControlClassID: _bindgen_ty_283 = 1886544237;
pub type _bindgen_ty_283 = u32;
pub const kAudioControlPropertyVariant: _bindgen_ty_284 = 1668702578;
pub type _bindgen_ty_284 = u32;
pub const kAudioClockSourceControlPropertyItemKind: _bindgen_ty_285 = 1668049771;
pub type _bindgen_ty_285 = u32;
extern "C" {
    ///@function       AudioGetCurrentHostTime
    ///@abstract       Gets the current host time.
    ///@result         A UInt64 containing the current host time.
    pub fn AudioGetCurrentHostTime() -> UInt64;
}
extern "C" {
    ///@function       AudioGetHostClockFrequency
    ///@abstract       Gets the number of ticks per second in the host time base.
    ///@result         A Float64 containing the number of ticks per second in the host time base.
    pub fn AudioGetHostClockFrequency() -> Float64;
}
extern "C" {
    ///@function       AudioGetHostClockMinimumTimeDelta
    ///@abstract       Gets the smallest number of ticks that two succeeding values will ever differ.
    ///by.
    ///@result         A UInt32 containing the smallest number of ticks that two succeeding values will
    ///ever differ.
    pub fn AudioGetHostClockMinimumTimeDelta() -> UInt32;
}
extern "C" {
    ///@function       AudioConvertHostTimeToNanos
    ///@abstract       Convert the given host time into a time in nanoseconds.
    ///@param          inHostTime
    ///A UInt64 containing the host time to convert.
    ///@result         A UInt64 containining the converted host time.
    pub fn AudioConvertHostTimeToNanos(inHostTime: UInt64) -> UInt64;
}
extern "C" {
    ///@function       AudioConvertNanosToHostTime
    ///@abstract       Convert the given nanosecond time into a host time.
    ///@param          inNanos
    ///A UInt64 containing the nanosecond time to convert.
    ///@result         A UInt64 containining the converted nanosecond time.
    pub fn AudioConvertNanosToHostTime(inNanos: UInt64) -> UInt64;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _os_object_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_object_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_continuation_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_group_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_source_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_mach_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_mach_msg_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_source_attr_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_semaphore_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_io_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_operation_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dispatch_disk_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OpaqueAudioFileID {
    pub _address: u8,
}
