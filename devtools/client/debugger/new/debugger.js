(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("devtools/client/shared/vendor/react"), require("Services"), require("devtools/shared/flags"));
	else if(typeof define === 'function' && define.amd)
		define(["devtools/client/shared/vendor/react", "Services", "devtools/shared/flags"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("devtools/client/shared/vendor/react"), require("Services"), require("devtools/shared/flags")) : factory(root["devtools/client/shared/vendor/react"], root["Services"], root["devtools/shared/flags"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_29__, __WEBPACK_EXTERNAL_MODULE_121__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/build";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(22);

	var _require = __webpack_require__(131),
	    bootstrap = _require.bootstrap,
	    L10N = _require.L10N,
	    unmountRoot = _require.unmountRoot;

	var _require2 = __webpack_require__(828),
	    isFirefoxPanel = _require2.isFirefoxPanel;

	var _require3 = __webpack_require__(888),
	    onConnect = _require3.onConnect;

	var _require4 = __webpack_require__(897),
	    teardownWorkers = _require4.teardownWorkers;

	if (isFirefoxPanel()) {
	  module.exports = {
	    bootstrap: (_ref) => {
	      var threadClient = _ref.threadClient,
	          tabTarget = _ref.tabTarget,
	          debuggerClient = _ref.debuggerClient,
	          sourceMaps = _ref.sourceMaps;

	      return onConnect({
	        tab: { clientType: "firefox" },
	        tabConnection: {
	          tabTarget,
	          threadClient,
	          debuggerClient
	        }
	      }, {
	        sourceMaps
	      });
	    },
	    destroy: () => {
	      unmountRoot(ReactDOM);
	      teardownWorkers();
	    }
	  };
	} else {
	  window.L10N = L10N;
	  // $FlowIgnore:
	  window.L10N.setBundle(__webpack_require__(960));

	  bootstrap(React, ReactDOM).then(connection => {
	    onConnect(connection, {
	      sourceMaps: __webpack_require__(898)
	    });
	  });
	}

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

	var _createStore = __webpack_require__(4);

	var _createStore2 = _interopRequireDefault(_createStore);

	var _combineReducers = __webpack_require__(17);

	var _combineReducers2 = _interopRequireDefault(_combineReducers);

	var _bindActionCreators = __webpack_require__(19);

	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

	var _applyMiddleware = __webpack_require__(20);

	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

	var _compose = __webpack_require__(21);

	var _compose2 = _interopRequireDefault(_compose);

	var _warning = __webpack_require__(18);

	var _warning2 = _interopRequireDefault(_warning);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}

	if (false) {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}

	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;

	var _isPlainObject = __webpack_require__(5);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	var _symbolObservable = __webpack_require__(15);

	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};

	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;

	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }

	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }

	    return enhancer(createStore)(reducer, initialState);
	  }

	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }

	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;

	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }

	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }

	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }

	    var isSubscribed = true;

	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);

	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }

	      isSubscribed = false;

	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }

	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }

	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }

	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }

	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }

	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }

	    return action;
	  }

	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }

	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }

	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;

	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */

	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }

	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }

	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }

	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });

	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(6),
	    getPrototype = __webpack_require__(12),
	    isObjectLike = __webpack_require__(14);

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	module.exports = isPlainObject;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(7),
	    getRawTag = __webpack_require__(10),
	    objectToString = __webpack_require__(11);

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	module.exports = baseGetTag;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(8);

	/** Built-in value references. */
	var Symbol = root.Symbol;

	module.exports = Symbol;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(9);

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	module.exports = root;


/***/ },
/* 9 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	module.exports = freeGlobal;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(7);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	module.exports = getRawTag;


/***/ },
/* 11 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	module.exports = objectToString;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(13);

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	module.exports = getPrototype;


/***/ },
/* 13 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	module.exports = overArg;


/***/ },
/* 14 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	module.exports = isObjectLike;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';

	module.exports = __webpack_require__(16)(global || window || this);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 16 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;

		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}

		return result;
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports["default"] = combineReducers;

	var _createStore = __webpack_require__(4);

	var _isPlainObject = __webpack_require__(5);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	var _warning = __webpack_require__(18);

	var _warning2 = _interopRequireDefault(_warning);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}

	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';

	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }

	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }

	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });

	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}

	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });

	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }

	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}

	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);

	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }

	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];

	    if (sanityError) {
	      throw sanityError;
	    }

	    if (false) {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }

	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}

/***/ },
/* 18 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 19 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}

	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }

	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }

	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports["default"] = applyMiddleware;

	var _compose = __webpack_require__(21);

	var _compose2 = _interopRequireDefault(_compose);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }

	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];

	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);

	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 21 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */

	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }

	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();

	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ReactDOM v15.3.2
	 *
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	// Based off https://github.com/ForbesLindesay/umd/blob/master/template.js
	;(function(f) {
	  // CommonJS
	  if (true) {
	    module.exports = f(__webpack_require__(2));

	  // RequireJS
	  } else if (typeof define === "function" && define.amd) {
	    define(['react'], f);

	  // <script>
	  } else {
	    var g;
	    if (typeof window !== "undefined") {
	      g = window;
	    } else if (typeof global !== "undefined") {
	      g = global;
	    } else if (typeof self !== "undefined") {
	      g = self;
	    } else {
	      // works providing we're not in "use strict";
	      // needed for Java 8 Nashorn
	      // see https://github.com/facebook/react/issues/3037
	      g = this;
	    }
	    g.ReactDOM = f(g.React);
	  }

	})(function(React) {
	  return React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
	});


/***/ },
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_29__;

/***/ },
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(68);

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	module.exports = get;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(69),
	    toKey = __webpack_require__(111);

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	module.exports = baseGet;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(70),
	    isKey = __webpack_require__(71),
	    stringToPath = __webpack_require__(73),
	    toString = __webpack_require__(108);

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	module.exports = castPath;


/***/ },
/* 70 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	module.exports = isArray;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(70),
	    isSymbol = __webpack_require__(72);

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	module.exports = isKey;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(6),
	    isObjectLike = __webpack_require__(14);

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	module.exports = isSymbol;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var memoizeCapped = __webpack_require__(74);

	/** Used to match property names within property paths. */
	var reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	module.exports = stringToPath;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var memoize = __webpack_require__(75);

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	module.exports = memoizeCapped;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(76);

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	module.exports = memoize;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var mapCacheClear = __webpack_require__(77),
	    mapCacheDelete = __webpack_require__(102),
	    mapCacheGet = __webpack_require__(105),
	    mapCacheHas = __webpack_require__(106),
	    mapCacheSet = __webpack_require__(107);

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	module.exports = MapCache;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var Hash = __webpack_require__(78),
	    ListCache = __webpack_require__(93),
	    Map = __webpack_require__(101);

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	module.exports = mapCacheClear;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var hashClear = __webpack_require__(79),
	    hashDelete = __webpack_require__(89),
	    hashGet = __webpack_require__(90),
	    hashHas = __webpack_require__(91),
	    hashSet = __webpack_require__(92);

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	module.exports = Hash;


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(80);

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	module.exports = hashClear;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(81);

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	module.exports = nativeCreate;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsNative = __webpack_require__(82),
	    getValue = __webpack_require__(88);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	module.exports = getNative;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(83),
	    isMasked = __webpack_require__(85),
	    isObject = __webpack_require__(84),
	    toSource = __webpack_require__(87);

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	module.exports = baseIsNative;


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(6),
	    isObject = __webpack_require__(84);

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	module.exports = isFunction;


/***/ },
/* 84 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	module.exports = isObject;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var coreJsData = __webpack_require__(86);

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	module.exports = isMasked;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(8);

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	module.exports = coreJsData;


/***/ },
/* 87 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	module.exports = toSource;


/***/ },
/* 88 */
/***/ function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	module.exports = getValue;


/***/ },
/* 89 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = hashDelete;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(80);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	module.exports = hashGet;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(80);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	module.exports = hashHas;


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(80);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	module.exports = hashSet;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var listCacheClear = __webpack_require__(94),
	    listCacheDelete = __webpack_require__(95),
	    listCacheGet = __webpack_require__(98),
	    listCacheHas = __webpack_require__(99),
	    listCacheSet = __webpack_require__(100);

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	module.exports = ListCache;


/***/ },
/* 94 */
/***/ function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	module.exports = listCacheClear;


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(96);

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	module.exports = listCacheDelete;


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(97);

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	module.exports = assocIndexOf;


/***/ },
/* 97 */
/***/ function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	module.exports = eq;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(96);

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	module.exports = listCacheGet;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(96);

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	module.exports = listCacheHas;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(96);

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	module.exports = listCacheSet;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(81),
	    root = __webpack_require__(8);

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	module.exports = Map;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(103);

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = mapCacheDelete;


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var isKeyable = __webpack_require__(104);

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	module.exports = getMapData;


/***/ },
/* 104 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	module.exports = isKeyable;


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(103);

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	module.exports = mapCacheGet;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(103);

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	module.exports = mapCacheHas;


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(103);

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	module.exports = mapCacheSet;


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(109);

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	module.exports = toString;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(7),
	    arrayMap = __webpack_require__(110),
	    isArray = __webpack_require__(70),
	    isSymbol = __webpack_require__(72);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = baseToString;


/***/ },
/* 110 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	module.exports = arrayMap;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var isSymbol = __webpack_require__(72);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = toKey;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var baseSet = __webpack_require__(113);

	/**
	 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	 * it's created. Arrays are created for missing index properties while objects
	 * are created for all other missing properties. Use `_.setWith` to customize
	 * `path` creation.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.set(object, 'a[0].b.c', 4);
	 * console.log(object.a[0].b.c);
	 * // => 4
	 *
	 * _.set(object, ['x', '0', 'y', 'z'], 5);
	 * console.log(object.x[0].y.z);
	 * // => 5
	 */
	function set(object, path, value) {
	  return object == null ? object : baseSet(object, path, value);
	}

	module.exports = set;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(114),
	    castPath = __webpack_require__(69),
	    isIndex = __webpack_require__(117),
	    isObject = __webpack_require__(84),
	    toKey = __webpack_require__(111);

	/**
	 * The base implementation of `_.set`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseSet(object, path, value, customizer) {
	  if (!isObject(object)) {
	    return object;
	  }
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      lastIndex = length - 1,
	      nested = object;

	  while (nested != null && ++index < length) {
	    var key = toKey(path[index]),
	        newValue = value;

	    if (index != lastIndex) {
	      var objValue = nested[key];
	      newValue = customizer ? customizer(objValue, key, nested) : undefined;
	      if (newValue === undefined) {
	        newValue = isObject(objValue)
	          ? objValue
	          : (isIndex(path[index + 1]) ? [] : {});
	      }
	    }
	    assignValue(nested, key, newValue);
	    nested = nested[key];
	  }
	  return object;
	}

	module.exports = baseSet;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(115),
	    eq = __webpack_require__(97);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignValue;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var defineProperty = __webpack_require__(116);

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	module.exports = baseAssignValue;


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(81);

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	module.exports = defineProperty;


/***/ },
/* 117 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	module.exports = isIndex;


/***/ },
/* 118 */
/***/ function(module, exports) {



/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(120)))

/***/ },
/* 120 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 121 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_121__;

/***/ },
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */
/***/ function(module, exports) {

	module.exports=function(e){function t(i){if(n[i])return n[i].exports;var r=n[i]={exports:{},id:i,loaded:!1};return e[i].call(r.exports,r,r.exports,t),r.loaded=!0,r.exports}var n={};return t.m=e,t.c=n,t.p="",t(0)}([function(e,t,n){(function(t){"use strict";var i=n(2),r=n(3),o=n(41);e.exports=function(e,n){"function"==typeof e&&(n=e,e=void 0);var r=new i;return"function"==typeof n?(t.nextTick(function(){new o(e,r)}),r.on("connect",n)):new Promise(function(t,n){r.on("connect",t),r.on("error",n),r.on("disconnect",function(){n(new Error("Disconnected"))}),new o(e,r)})},e.exports.listTabs=r.List,e.exports.spawnTab=r.New,e.exports.closeTab=r.Close,e.exports.Protocol=r.Protocol,e.exports.List=r.List,e.exports.New=r.New,e.exports.Activate=r.Activate,e.exports.Close=r.Close,e.exports.Version=r.Version}).call(t,n(1))},function(e,t){function n(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function r(e){if(d===setTimeout)return setTimeout(e,0);if((d===n||!d)&&setTimeout)return d=setTimeout,setTimeout(e,0);try{return d(e,0)}catch(t){try{return d.call(null,e,0)}catch(t){return d.call(this,e,0)}}}function o(e){if(l===clearTimeout)return clearTimeout(e);if((l===i||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(e);try{return l(e)}catch(t){try{return l.call(null,e)}catch(t){return l.call(this,e)}}}function a(){f&&u&&(f=!1,u.length?h=u.concat(h):y=-1,h.length&&s())}function s(){if(!f){var e=r(a);f=!0;for(var t=h.length;t;){for(u=h,h=[];++y<t;)u&&u[y].run();y=-1,t=h.length}u=null,f=!1,o(e)}}function p(e,t){this.fun=e,this.array=t}function c(){}var d,l,m=e.exports={};!function(){try{d="function"==typeof setTimeout?setTimeout:n}catch(e){d=n}try{l="function"==typeof clearTimeout?clearTimeout:i}catch(e){l=i}}();var u,h=[],f=!1,y=-1;m.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];h.push(new p(e,t)),1!==h.length||f||r(s)},p.prototype.run=function(){this.fun.apply(null,this.array)},m.title="browser",m.browser=!0,m.env={},m.argv=[],m.version="",m.versions={},m.on=c,m.addListener=c,m.once=c,m.off=c,m.removeListener=c,m.removeAllListeners=c,m.emit=c,m.binding=function(e){throw new Error("process.binding is not supported")},m.cwd=function(){return"/"},m.chdir=function(e){throw new Error("process.chdir is not supported")},m.umask=function(){return 0}},function(e,t){function n(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function i(e){return"function"==typeof e}function r(e){return"number"==typeof e}function o(e){return"object"==typeof e&&null!==e}function a(e){return void 0===e}e.exports=n,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._maxListeners=void 0,n.defaultMaxListeners=10,n.prototype.setMaxListeners=function(e){if(!r(e)||e<0||isNaN(e))throw TypeError("n must be a positive number");return this._maxListeners=e,this},n.prototype.emit=function(e){var t,n,r,s,p,c;if(this._events||(this._events={}),"error"===e&&(!this._events.error||o(this._events.error)&&!this._events.error.length)){if(t=arguments[1],t instanceof Error)throw t;var d=new Error('Uncaught, unspecified "error" event. ('+t+")");throw d.context=t,d}if(n=this._events[e],a(n))return!1;if(i(n))switch(arguments.length){case 1:n.call(this);break;case 2:n.call(this,arguments[1]);break;case 3:n.call(this,arguments[1],arguments[2]);break;default:s=Array.prototype.slice.call(arguments,1),n.apply(this,s)}else if(o(n))for(s=Array.prototype.slice.call(arguments,1),c=n.slice(),r=c.length,p=0;p<r;p++)c[p].apply(this,s);return!0},n.prototype.addListener=function(e,t){var r;if(!i(t))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",e,i(t.listener)?t.listener:t),this._events[e]?o(this._events[e])?this._events[e].push(t):this._events[e]=[this._events[e],t]:this._events[e]=t,o(this._events[e])&&!this._events[e].warned&&(r=a(this._maxListeners)?n.defaultMaxListeners:this._maxListeners,r&&r>0&&this._events[e].length>r&&(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),"function"==typeof console.trace&&console.trace())),this},n.prototype.on=n.prototype.addListener,n.prototype.once=function(e,t){function n(){this.removeListener(e,n),r||(r=!0,t.apply(this,arguments))}if(!i(t))throw TypeError("listener must be a function");var r=!1;return n.listener=t,this.on(e,n),this},n.prototype.removeListener=function(e,t){var n,r,a,s;if(!i(t))throw TypeError("listener must be a function");if(!this._events||!this._events[e])return this;if(n=this._events[e],a=n.length,r=-1,n===t||i(n.listener)&&n.listener===t)delete this._events[e],this._events.removeListener&&this.emit("removeListener",e,t);else if(o(n)){for(s=a;s-- >0;)if(n[s]===t||n[s].listener&&n[s].listener===t){r=s;break}if(r<0)return this;1===n.length?(n.length=0,delete this._events[e]):n.splice(r,1),this._events.removeListener&&this.emit("removeListener",e,t)}return this},n.prototype.removeAllListeners=function(e){var t,n;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[e]&&delete this._events[e],this;if(0===arguments.length){for(t in this._events)"removeListener"!==t&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events={},this}if(n=this._events[e],i(n))this.removeListener(e,n);else if(n)for(;n.length;)this.removeListener(e,n[n.length-1]);return delete this._events[e],this},n.prototype.listeners=function(e){var t;return t=this._events&&this._events[e]?i(this._events[e])?[this._events[e]]:this._events[e].slice():[]},n.prototype.listenerCount=function(e){if(this._events){var t=this._events[e];if(i(t))return 1;if(t)return t.length}return 0},n.listenerCount=function(e,t){return e.listenerCount(t)}},function(e,t,n){(function(t){"use strict";function i(e,t){e.host=e.host||c.HOST,e.port=e.port||c.PORT,d(s,e,t)}function r(e){return function(t,n){return"function"==typeof t&&(n=t,t=void 0),t=t||{},"function"!=typeof n?new Promise(function(n,i){e(t,function(e,t){e?i(e):n(t)})}):void e(t,n)}}function o(e,n,i){function r(e){return e.split(".").map(function(e){return parseInt(e)})}var o=n["WebKit-Version"],a=n["V8-Version"],s=o.match(/\s\(@(\b[0-9a-f]{5,40}\b)/),c=s[1],l=c<=202666,m=void 0;if(l)m=["https://src.chromium.org/blink/trunk/Source/devtools/protocol.json?p="+c];else{var u="53.0.2758.1",h="55.0.2854.3",f=r(n.Browser.split("/")[1]),y=f[2]<=r(u)[2],g=f[2]<=r(h)[2];y?m=["https://chromium.googlesource.com/chromium/src/+/"+c+"/third_party/WebKit/Source/devtools/protocol.json?format=TEXT"]:g?m=["https://chromium.googlesource.com/chromium/src/+/"+c+"/third_party/WebKit/Source/core/inspector/browser_protocol.json?format=TEXT","https://chromium.googlesource.com/chromium/src/+/"+c+"/third_party/WebKit/Source/platform/v8_inspector/js_protocol.json?format=TEXT"]:a?m=["https://chromium.googlesource.com/chromium/src/+/"+c+"/third_party/WebKit/Source/core/inspector/browser_protocol.json?format=TEXT","https://chromium.googlesource.com/v8/v8/+/"+a+"/src/inspector/js_protocol.json?format=TEXT"]:(console.error("Warning: the protocol might be outdated, see: https://groups.google.com/d/topic/chrome-debugging-protocol/HjyOKainKus/discussion"),m=["https://chromium.googlesource.com/chromium/src/+/"+c+"/third_party/WebKit/Source/core/inspector/browser_protocol.json?format=TEXT","https://chromium.googlesource.com/chromium/src/+/"+h+"/third_party/WebKit/Source/platform/v8_inspector/js_protocol.json?format=TEXT"])}var b=[];m.forEach(function(e){d(p,e,function(e,n){var r=void 0;if(!e)try{l||(n=new t(n,"base64").toString()),r=JSON.parse(n)}catch(e){}if(b.push(r),b.length===m.length){if(b.indexOf(void 0)!==-1)return void i(new Error("Cannot fetch from Chromium repo"));b.forEach(function(e,t){0!==t&&Array.prototype.push.apply(b[0].domains,e.domains)}),i(null,b[0])}})})}function a(e,t,n){e.path="/json/protocol",i(e,function(e,t){e?n(e):n(null,JSON.parse(t))})}var s=n(8),p=n(37),c=n(38),d=n(39);e.exports.Protocol=r(function(t,i){if(!t.remote){var r=n(40);return void i(null,{remote:!1,descriptor:r})}e.exports.Version(t,function(e,n){if(e)return void i(e);var r=(n[0]||n).Browser,s=void 0;if(r.match(/^Chrome\//))s=o;else if(r.match(/^Microsoft Edge /))s=a;else{if(!r.match(/^node.js\//))return void i(new Error("Unknown implementation"));s=a}s(t,n,function(e,t){return e?void i(e):void i(null,{remote:!0,descriptor:t})})})}),e.exports.List=r(function(e,t){e.path="/json/list",i(e,function(e,n){e?t(e):t(null,JSON.parse(n))})}),e.exports.New=r(function(e,t){e.path="/json/new",Object.prototype.hasOwnProperty.call(e,"url")&&(e.path+="?"+e.url),i(e,function(e,n){e?t(e):t(null,JSON.parse(n))})}),e.exports.Activate=r(function(e,t){e.path="/json/activate/"+e.id,i(e,function(e){t(e?e:null)})}),e.exports.Close=r(function(e,t){e.path="/json/close/"+e.id,i(e,function(e){t(e?e:null)})}),e.exports.Version=r(function(e,t){e.path="/json/version",i(e,function(e,n){e?t(e):t(null,JSON.parse(n))})})}).call(t,n(4).Buffer)},function(e,t,n){(function(e,i){"use strict";function r(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}function o(){return e.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(t,n){if(o()<n)throw new RangeError("Invalid typed array length");return e.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(n),t.__proto__=e.prototype):(null===t&&(t=new e(n)),t.length=n),t}function e(t,n,i){if(!(e.TYPED_ARRAY_SUPPORT||this instanceof e))return new e(t,n,i);if("number"==typeof t){if("string"==typeof n)throw new Error("If encoding is specified then the first argument must be a string");return d(this,t)}return s(this,t,n,i)}function s(e,t,n,i){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?u(e,t,n,i):"string"==typeof t?l(e,t,n):h(e,t)}function p(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function c(e,t,n,i){return p(t),t<=0?a(e,t):void 0!==n?"string"==typeof i?a(e,t).fill(n,i):a(e,t).fill(n):a(e,t)}function d(t,n){if(p(n),t=a(t,n<0?0:0|f(n)),!e.TYPED_ARRAY_SUPPORT)for(var i=0;i<n;++i)t[i]=0;return t}function l(t,n,i){if("string"==typeof i&&""!==i||(i="utf8"),!e.isEncoding(i))throw new TypeError('"encoding" must be a valid string encoding');var r=0|g(n,i);t=a(t,r);var o=t.write(n,i);return o!==r&&(t=t.slice(0,o)),t}function m(e,t){var n=t.length<0?0:0|f(t.length);e=a(e,n);for(var i=0;i<n;i+=1)e[i]=255&t[i];return e}function u(t,n,i,r){if(n.byteLength,i<0||n.byteLength<i)throw new RangeError("'offset' is out of bounds");if(n.byteLength<i+(r||0))throw new RangeError("'length' is out of bounds");return n=void 0===i&&void 0===r?new Uint8Array(n):void 0===r?new Uint8Array(n,i):new Uint8Array(n,i,r),e.TYPED_ARRAY_SUPPORT?(t=n,t.__proto__=e.prototype):t=m(t,n),t}function h(t,n){if(e.isBuffer(n)){var i=0|f(n.length);return t=a(t,i),0===t.length?t:(n.copy(t,0,0,i),t)}if(n){if("undefined"!=typeof ArrayBuffer&&n.buffer instanceof ArrayBuffer||"length"in n)return"number"!=typeof n.length||J(n.length)?a(t,0):m(t,n);if("Buffer"===n.type&&Z(n.data))return m(t,n.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}function f(e){if(e>=o())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+o().toString(16)+" bytes");return 0|e}function y(t){return+t!=t&&(t=0),e.alloc(+t)}function g(t,n){if(e.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var i=t.length;if(0===i)return 0;for(var r=!1;;)switch(n){case"ascii":case"latin1":case"binary":return i;case"utf8":case"utf-8":case void 0:return z(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*i;case"hex":return i>>>1;case"base64":return Y(t).length;default:if(r)return z(t).length;n=(""+n).toLowerCase(),r=!0}}function b(e,t,n){var i=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if(n>>>=0,t>>>=0,n<=t)return"";for(e||(e="utf8");;)switch(e){case"hex":return D(this,t,n);case"utf8":case"utf-8":return j(this,t,n);case"ascii":return E(this,t,n);case"latin1":case"binary":return A(this,t,n);case"base64":return $(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return P(this,t,n);default:if(i)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),i=!0}}function v(e,t,n){var i=e[t];e[t]=e[n],e[n]=i}function w(t,n,i,r,o){if(0===t.length)return-1;if("string"==typeof i?(r=i,i=0):i>2147483647?i=2147483647:i<-2147483648&&(i=-2147483648),i=+i,isNaN(i)&&(i=o?0:t.length-1),i<0&&(i=t.length+i),i>=t.length){if(o)return-1;i=t.length-1}else if(i<0){if(!o)return-1;i=0}if("string"==typeof n&&(n=e.from(n,r)),e.isBuffer(n))return 0===n.length?-1:S(t,n,i,r,o);if("number"==typeof n)return n&=255,e.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(t,n,i):Uint8Array.prototype.lastIndexOf.call(t,n,i):S(t,[n],i,r,o);throw new TypeError("val must be string, number or Buffer")}function S(e,t,n,i,r){function o(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}var a=1,s=e.length,p=t.length;if(void 0!==i&&(i=String(i).toLowerCase(),"ucs2"===i||"ucs-2"===i||"utf16le"===i||"utf-16le"===i)){if(e.length<2||t.length<2)return-1;a=2,s/=2,p/=2,n/=2}var c;if(r){var d=-1;for(c=n;c<s;c++)if(o(e,c)===o(t,d===-1?0:c-d)){if(d===-1&&(d=c),c-d+1===p)return d*a}else d!==-1&&(c-=c-d),d=-1}else for(n+p>s&&(n=s-p),c=n;c>=0;c--){for(var l=!0,m=0;m<p;m++)if(o(e,c+m)!==o(t,m)){l=!1;break}if(l)return c}return-1}function x(e,t,n,i){n=Number(n)||0;var r=e.length-n;i?(i=Number(i),i>r&&(i=r)):i=r;var o=t.length;if(o%2!==0)throw new TypeError("Invalid hex string");i>o/2&&(i=o/2);for(var a=0;a<i;++a){var s=parseInt(t.substr(2*a,2),16);if(isNaN(s))return a;e[n+a]=s}return a}function I(e,t,n,i){return G(z(t,e.length-n),e,n,i)}function T(e,t,n,i){return G(V(t),e,n,i)}function R(e,t,n,i){return T(e,t,n,i)}function k(e,t,n,i){return G(Y(t),e,n,i)}function C(e,t,n,i){return G(X(t,e.length-n),e,n,i)}function $(e,t,n){return 0===t&&n===e.length?K.fromByteArray(e):K.fromByteArray(e.slice(t,n))}function j(e,t,n){n=Math.min(e.length,n);for(var i=[],r=t;r<n;){var o=e[r],a=null,s=o>239?4:o>223?3:o>191?2:1;if(r+s<=n){var p,c,d,l;switch(s){case 1:o<128&&(a=o);break;case 2:p=e[r+1],128===(192&p)&&(l=(31&o)<<6|63&p,l>127&&(a=l));break;case 3:p=e[r+1],c=e[r+2],128===(192&p)&&128===(192&c)&&(l=(15&o)<<12|(63&p)<<6|63&c,l>2047&&(l<55296||l>57343)&&(a=l));break;case 4:p=e[r+1],c=e[r+2],d=e[r+3],128===(192&p)&&128===(192&c)&&128===(192&d)&&(l=(15&o)<<18|(63&p)<<12|(63&c)<<6|63&d,l>65535&&l<1114112&&(a=l))}}null===a?(a=65533,s=1):a>65535&&(a-=65536,i.push(a>>>10&1023|55296),a=56320|1023&a),i.push(a),r+=s}return O(i)}function O(e){var t=e.length;if(t<=ee)return String.fromCharCode.apply(String,e);for(var n="",i=0;i<t;)n+=String.fromCharCode.apply(String,e.slice(i,i+=ee));return n}function E(e,t,n){var i="";n=Math.min(e.length,n);for(var r=t;r<n;++r)i+=String.fromCharCode(127&e[r]);return i}function A(e,t,n){var i="";n=Math.min(e.length,n);for(var r=t;r<n;++r)i+=String.fromCharCode(e[r]);return i}function D(e,t,n){var i=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>i)&&(n=i);for(var r="",o=t;o<n;++o)r+=H(e[o]);return r}function P(e,t,n){for(var i=e.slice(t,n),r="",o=0;o<i.length;o+=2)r+=String.fromCharCode(i[o]+256*i[o+1]);return r}function L(e,t,n){if(e%1!==0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function N(t,n,i,r,o,a){if(!e.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(n>o||n<a)throw new RangeError('"value" argument is out of bounds');if(i+r>t.length)throw new RangeError("Index out of range")}function M(e,t,n,i){t<0&&(t=65535+t+1);for(var r=0,o=Math.min(e.length-n,2);r<o;++r)e[n+r]=(t&255<<8*(i?r:1-r))>>>8*(i?r:1-r)}function q(e,t,n,i){t<0&&(t=4294967295+t+1);for(var r=0,o=Math.min(e.length-n,4);r<o;++r)e[n+r]=t>>>8*(i?r:3-r)&255}function U(e,t,n,i,r,o){if(n+i>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function _(e,t,n,i,r){return r||U(e,t,n,4,3.4028234663852886e38,-3.4028234663852886e38),Q.write(e,t,n,i,23,4),n+4}function F(e,t,n,i,r){return r||U(e,t,n,8,1.7976931348623157e308,-1.7976931348623157e308),Q.write(e,t,n,i,52,8),n+8}function B(e){if(e=W(e).replace(te,""),e.length<2)return"";for(;e.length%4!==0;)e+="=";return e}function W(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}function H(e){return e<16?"0"+e.toString(16):e.toString(16)}function z(e,t){t=t||1/0;for(var n,i=e.length,r=null,o=[],a=0;a<i;++a){if(n=e.charCodeAt(a),n>55295&&n<57344){if(!r){if(n>56319){(t-=3)>-1&&o.push(239,191,189);continue}if(a+1===i){(t-=3)>-1&&o.push(239,191,189);continue}r=n;continue}if(n<56320){(t-=3)>-1&&o.push(239,191,189),r=n;continue}n=(r-55296<<10|n-56320)+65536}else r&&(t-=3)>-1&&o.push(239,191,189);if(r=null,n<128){if((t-=1)<0)break;o.push(n)}else if(n<2048){if((t-=2)<0)break;o.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;o.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return o}function V(e){for(var t=[],n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}function X(e,t){for(var n,i,r,o=[],a=0;a<e.length&&!((t-=2)<0);++a)n=e.charCodeAt(a),i=n>>8,r=n%256,o.push(r),o.push(i);return o}function Y(e){return K.toByteArray(B(e))}function G(e,t,n,i){for(var r=0;r<i&&!(r+n>=t.length||r>=e.length);++r)t[r+n]=e[r];return r}function J(e){return e!==e}var K=n(5),Q=n(6),Z=n(7);t.Buffer=e,t.SlowBuffer=y,t.INSPECT_MAX_BYTES=50,e.TYPED_ARRAY_SUPPORT=void 0!==i.TYPED_ARRAY_SUPPORT?i.TYPED_ARRAY_SUPPORT:r(),t.kMaxLength=o(),e.poolSize=8192,e._augment=function(t){return t.__proto__=e.prototype,t},e.from=function(e,t,n){return s(null,e,t,n)},e.TYPED_ARRAY_SUPPORT&&(e.prototype.__proto__=Uint8Array.prototype,e.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&e[Symbol.species]===e&&Object.defineProperty(e,Symbol.species,{value:null,configurable:!0})),e.alloc=function(e,t,n){return c(null,e,t,n)},e.allocUnsafe=function(e){return d(null,e)},e.allocUnsafeSlow=function(e){return d(null,e)},e.isBuffer=function(e){return!(null==e||!e._isBuffer)},e.compare=function(t,n){if(!e.isBuffer(t)||!e.isBuffer(n))throw new TypeError("Arguments must be Buffers");if(t===n)return 0;for(var i=t.length,r=n.length,o=0,a=Math.min(i,r);o<a;++o)if(t[o]!==n[o]){i=t[o],r=n[o];break}return i<r?-1:r<i?1:0},e.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},e.concat=function(t,n){if(!Z(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return e.alloc(0);var i;if(void 0===n)for(n=0,i=0;i<t.length;++i)n+=t[i].length;var r=e.allocUnsafe(n),o=0;for(i=0;i<t.length;++i){var a=t[i];if(!e.isBuffer(a))throw new TypeError('"list" argument must be an Array of Buffers');a.copy(r,o),o+=a.length}return r},e.byteLength=g,e.prototype._isBuffer=!0,e.prototype.swap16=function(){var e=this.length;if(e%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)v(this,t,t+1);return this},e.prototype.swap32=function(){var e=this.length;if(e%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)v(this,t,t+3),v(this,t+1,t+2);return this},e.prototype.swap64=function(){var e=this.length;if(e%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)v(this,t,t+7),v(this,t+1,t+6),v(this,t+2,t+5),v(this,t+3,t+4);return this},e.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?j(this,0,e):b.apply(this,arguments)},e.prototype.equals=function(t){if(!e.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===e.compare(this,t)},e.prototype.inspect=function(){var e="",n=t.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,n).match(/.{2}/g).join(" "),this.length>n&&(e+=" ... ")),"<Buffer "+e+">"},e.prototype.compare=function(t,n,i,r,o){if(!e.isBuffer(t))throw new TypeError("Argument must be a Buffer");if(void 0===n&&(n=0),void 0===i&&(i=t?t.length:0),void 0===r&&(r=0),void 0===o&&(o=this.length),n<0||i>t.length||r<0||o>this.length)throw new RangeError("out of range index");if(r>=o&&n>=i)return 0;if(r>=o)return-1;if(n>=i)return 1;if(n>>>=0,i>>>=0,r>>>=0,o>>>=0,this===t)return 0;for(var a=o-r,s=i-n,p=Math.min(a,s),c=this.slice(r,o),d=t.slice(n,i),l=0;l<p;++l)if(c[l]!==d[l]){a=c[l],s=d[l];break}return a<s?-1:s<a?1:0},e.prototype.includes=function(e,t,n){return this.indexOf(e,t,n)!==-1},e.prototype.indexOf=function(e,t,n){return w(this,e,t,n,!0)},e.prototype.lastIndexOf=function(e,t,n){return w(this,e,t,n,!1)},e.prototype.write=function(e,t,n,i){if(void 0===t)i="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)i=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(n)?(n|=0,void 0===i&&(i="utf8")):(i=n,n=void 0)}var r=this.length-t;if((void 0===n||n>r)&&(n=r),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");i||(i="utf8");for(var o=!1;;)switch(i){case"hex":return x(this,e,t,n);case"utf8":case"utf-8":return I(this,e,t,n);case"ascii":return T(this,e,t,n);case"latin1":case"binary":return R(this,e,t,n);case"base64":return k(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return C(this,e,t,n);default:if(o)throw new TypeError("Unknown encoding: "+i);i=(""+i).toLowerCase(),o=!0}},e.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var ee=4096;e.prototype.slice=function(t,n){var i=this.length;t=~~t,n=void 0===n?i:~~n,t<0?(t+=i,t<0&&(t=0)):t>i&&(t=i),n<0?(n+=i,n<0&&(n=0)):n>i&&(n=i),n<t&&(n=t);var r;if(e.TYPED_ARRAY_SUPPORT)r=this.subarray(t,n),r.__proto__=e.prototype;else{var o=n-t;r=new e(o,void 0);for(var a=0;a<o;++a)r[a]=this[a+t]}return r},e.prototype.readUIntLE=function(e,t,n){e|=0,t|=0,n||L(e,t,this.length);for(var i=this[e],r=1,o=0;++o<t&&(r*=256);)i+=this[e+o]*r;return i},e.prototype.readUIntBE=function(e,t,n){e|=0,t|=0,n||L(e,t,this.length);for(var i=this[e+--t],r=1;t>0&&(r*=256);)i+=this[e+--t]*r;return i},e.prototype.readUInt8=function(e,t){return t||L(e,1,this.length),this[e]},e.prototype.readUInt16LE=function(e,t){return t||L(e,2,this.length),this[e]|this[e+1]<<8},e.prototype.readUInt16BE=function(e,t){return t||L(e,2,this.length),this[e]<<8|this[e+1]},e.prototype.readUInt32LE=function(e,t){return t||L(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},e.prototype.readUInt32BE=function(e,t){return t||L(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},e.prototype.readIntLE=function(e,t,n){e|=0,t|=0,n||L(e,t,this.length);for(var i=this[e],r=1,o=0;++o<t&&(r*=256);)i+=this[e+o]*r;return r*=128,i>=r&&(i-=Math.pow(2,8*t)),i},e.prototype.readIntBE=function(e,t,n){e|=0,t|=0,n||L(e,t,this.length);for(var i=t,r=1,o=this[e+--i];i>0&&(r*=256);)o+=this[e+--i]*r;return r*=128,o>=r&&(o-=Math.pow(2,8*t)),o},e.prototype.readInt8=function(e,t){return t||L(e,1,this.length),128&this[e]?(255-this[e]+1)*-1:this[e]},e.prototype.readInt16LE=function(e,t){t||L(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},e.prototype.readInt16BE=function(e,t){t||L(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},e.prototype.readInt32LE=function(e,t){return t||L(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},e.prototype.readInt32BE=function(e,t){return t||L(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},e.prototype.readFloatLE=function(e,t){return t||L(e,4,this.length),Q.read(this,e,!0,23,4)},e.prototype.readFloatBE=function(e,t){return t||L(e,4,this.length),Q.read(this,e,!1,23,4)},e.prototype.readDoubleLE=function(e,t){return t||L(e,8,this.length),Q.read(this,e,!0,52,8)},e.prototype.readDoubleBE=function(e,t){return t||L(e,8,this.length),Q.read(this,e,!1,52,8)},e.prototype.writeUIntLE=function(e,t,n,i){if(e=+e,t|=0,n|=0,!i){var r=Math.pow(2,8*n)-1;N(this,e,t,n,r,0)}var o=1,a=0;for(this[t]=255&e;++a<n&&(o*=256);)this[t+a]=e/o&255;return t+n},e.prototype.writeUIntBE=function(e,t,n,i){if(e=+e,t|=0,n|=0,!i){var r=Math.pow(2,8*n)-1;N(this,e,t,n,r,0)}var o=n-1,a=1;for(this[t+o]=255&e;--o>=0&&(a*=256);)this[t+o]=e/a&255;return t+n},e.prototype.writeUInt8=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,1,255,0),e.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[n]=255&t,n+1},e.prototype.writeUInt16LE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,2,65535,0),e.TYPED_ARRAY_SUPPORT?(this[n]=255&t,this[n+1]=t>>>8):M(this,t,n,!0),n+2},e.prototype.writeUInt16BE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,2,65535,0),e.TYPED_ARRAY_SUPPORT?(this[n]=t>>>8,this[n+1]=255&t):M(this,t,n,!1),n+2},e.prototype.writeUInt32LE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,4,4294967295,0),e.TYPED_ARRAY_SUPPORT?(this[n+3]=t>>>24,this[n+2]=t>>>16,this[n+1]=t>>>8,this[n]=255&t):q(this,t,n,!0),n+4},e.prototype.writeUInt32BE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,4,4294967295,0),e.TYPED_ARRAY_SUPPORT?(this[n]=t>>>24,this[n+1]=t>>>16,this[n+2]=t>>>8,this[n+3]=255&t):q(this,t,n,!1),n+4},e.prototype.writeIntLE=function(e,t,n,i){if(e=+e,t|=0,!i){var r=Math.pow(2,8*n-1);N(this,e,t,n,r-1,-r)}var o=0,a=1,s=0;for(this[t]=255&e;++o<n&&(a*=256);)e<0&&0===s&&0!==this[t+o-1]&&(s=1),this[t+o]=(e/a>>0)-s&255;return t+n},e.prototype.writeIntBE=function(e,t,n,i){if(e=+e,t|=0,!i){var r=Math.pow(2,8*n-1);N(this,e,t,n,r-1,-r)}var o=n-1,a=1,s=0;for(this[t+o]=255&e;--o>=0&&(a*=256);)e<0&&0===s&&0!==this[t+o+1]&&(s=1),this[t+o]=(e/a>>0)-s&255;return t+n},e.prototype.writeInt8=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,1,127,-128),e.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[n]=255&t,n+1},e.prototype.writeInt16LE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,2,32767,-32768),e.TYPED_ARRAY_SUPPORT?(this[n]=255&t,this[n+1]=t>>>8):M(this,t,n,!0),n+2},e.prototype.writeInt16BE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,2,32767,-32768),e.TYPED_ARRAY_SUPPORT?(this[n]=t>>>8,this[n+1]=255&t):M(this,t,n,!1),n+2},e.prototype.writeInt32LE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,4,2147483647,-2147483648),e.TYPED_ARRAY_SUPPORT?(this[n]=255&t,this[n+1]=t>>>8,this[n+2]=t>>>16,this[n+3]=t>>>24):q(this,t,n,!0),n+4},e.prototype.writeInt32BE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),e.TYPED_ARRAY_SUPPORT?(this[n]=t>>>24,this[n+1]=t>>>16,this[n+2]=t>>>8,this[n+3]=255&t):q(this,t,n,!1),n+4},e.prototype.writeFloatLE=function(e,t,n){return _(this,e,t,!0,n)},e.prototype.writeFloatBE=function(e,t,n){return _(this,e,t,!1,n)},e.prototype.writeDoubleLE=function(e,t,n){return F(this,e,t,!0,n)},e.prototype.writeDoubleBE=function(e,t,n){return F(this,e,t,!1,n)},e.prototype.copy=function(t,n,i,r){if(i||(i=0),r||0===r||(r=this.length),n>=t.length&&(n=t.length),n||(n=0),r>0&&r<i&&(r=i),r===i)return 0;if(0===t.length||0===this.length)return 0;if(n<0)throw new RangeError("targetStart out of bounds");if(i<0||i>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),t.length-n<r-i&&(r=t.length-n+i);var o,a=r-i;if(this===t&&i<n&&n<r)for(o=a-1;o>=0;--o)t[o+n]=this[o+i];else if(a<1e3||!e.TYPED_ARRAY_SUPPORT)for(o=0;o<a;++o)t[o+n]=this[o+i];else Uint8Array.prototype.set.call(t,this.subarray(i,i+a),n);return a},e.prototype.fill=function(t,n,i,r){if("string"==typeof t){if("string"==typeof n?(r=n,n=0,i=this.length):"string"==typeof i&&(r=i,i=this.length),1===t.length){var o=t.charCodeAt(0);o<256&&(t=o)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!e.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof t&&(t&=255);if(n<0||this.length<n||this.length<i)throw new RangeError("Out of range index");if(i<=n)return this;n>>>=0,i=void 0===i?this.length:i>>>0,t||(t=0);var a;if("number"==typeof t)for(a=n;a<i;++a)this[a]=t;else{var s=e.isBuffer(t)?t:z(new e(t,r).toString()),p=s.length;for(a=0;a<i-n;++a)this[a+n]=s[a%p]}return this};var te=/[^+\/0-9A-Za-z-_]/g}).call(t,n(4).Buffer,function(){return this}())},function(e,t){"use strict";function n(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");return"="===e[t-2]?2:"="===e[t-1]?1:0}function i(e){return 3*e.length/4-n(e)}function r(e){var t,i,r,o,a,s,p=e.length;a=n(e),s=new d(3*p/4-a),r=a>0?p-4:p;var l=0;for(t=0,i=0;t<r;t+=4,i+=3)o=c[e.charCodeAt(t)]<<18|c[e.charCodeAt(t+1)]<<12|c[e.charCodeAt(t+2)]<<6|c[e.charCodeAt(t+3)],s[l++]=o>>16&255,s[l++]=o>>8&255,s[l++]=255&o;return 2===a?(o=c[e.charCodeAt(t)]<<2|c[e.charCodeAt(t+1)]>>4,s[l++]=255&o):1===a&&(o=c[e.charCodeAt(t)]<<10|c[e.charCodeAt(t+1)]<<4|c[e.charCodeAt(t+2)]>>2,s[l++]=o>>8&255,s[l++]=255&o),s}function o(e){return p[e>>18&63]+p[e>>12&63]+p[e>>6&63]+p[63&e]}function a(e,t,n){for(var i,r=[],a=t;a<n;a+=3)i=(e[a]<<16)+(e[a+1]<<8)+e[a+2],r.push(o(i));return r.join("")}function s(e){for(var t,n=e.length,i=n%3,r="",o=[],s=16383,c=0,d=n-i;c<d;c+=s)o.push(a(e,c,c+s>d?d:c+s));return 1===i?(t=e[n-1],r+=p[t>>2],r+=p[t<<4&63],r+="=="):2===i&&(t=(e[n-2]<<8)+e[n-1],r+=p[t>>10],r+=p[t>>4&63],r+=p[t<<2&63],r+="="),o.push(r),o.join("")}t.byteLength=i,t.toByteArray=r,t.fromByteArray=s;for(var p=[],c=[],d="undefined"!=typeof Uint8Array?Uint8Array:Array,l="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",m=0,u=l.length;m<u;++m)p[m]=l[m],c[l.charCodeAt(m)]=m;c["-".charCodeAt(0)]=62,c["_".charCodeAt(0)]=63},function(e,t){t.read=function(e,t,n,i,r){var o,a,s=8*r-i-1,p=(1<<s)-1,c=p>>1,d=-7,l=n?r-1:0,m=n?-1:1,u=e[t+l];for(l+=m,o=u&(1<<-d)-1,u>>=-d,d+=s;d>0;o=256*o+e[t+l],l+=m,d-=8);for(a=o&(1<<-d)-1,o>>=-d,d+=i;d>0;a=256*a+e[t+l],l+=m,d-=8);if(0===o)o=1-c;else{if(o===p)return a?NaN:(u?-1:1)*(1/0);a+=Math.pow(2,i),o-=c}return(u?-1:1)*a*Math.pow(2,o-i)},t.write=function(e,t,n,i,r,o){var a,s,p,c=8*o-r-1,d=(1<<c)-1,l=d>>1,m=23===r?Math.pow(2,-24)-Math.pow(2,-77):0,u=i?0:o-1,h=i?1:-1,f=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,a=d):(a=Math.floor(Math.log(t)/Math.LN2),t*(p=Math.pow(2,-a))<1&&(a--,p*=2),t+=a+l>=1?m/p:m*Math.pow(2,1-l),t*p>=2&&(a++,p/=2),a+l>=d?(s=0,a=d):a+l>=1?(s=(t*p-1)*Math.pow(2,r),a+=l):(s=t*Math.pow(2,l-1)*Math.pow(2,r),a=0));r>=8;e[n+u]=255&s,u+=h,s/=256,r-=8);for(a=a<<r|s,c+=r;c>0;e[n+u]=255&a,u+=h,a/=256,c-=8);e[n+u-h]|=128*f}},function(e,t){var n={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==n.call(e)}},function(e,t,n){var i=e.exports,r=(n(2).EventEmitter,n(9)),o=n(31);i.request=function(e,t){"string"==typeof e&&(e=o.parse(e)),e||(e={}),e.host||e.port||(e.port=parseInt(window.location.port,10)),!e.host&&e.hostname&&(e.host=e.hostname),e.protocol||(e.scheme?e.protocol=e.scheme+":":e.protocol=window.location.protocol),e.host||(e.host=window.location.hostname||window.location.host),/:/.test(e.host)&&(e.port||(e.port=e.host.split(":")[1]),e.host=e.host.split(":")[0]),e.port||(e.port="https:"==e.protocol?443:80);
	var n=new r(new a,e);return t&&n.on("response",t),n},i.get=function(e,t){e.method="GET";var n=i.request(e,t);return n.end(),n},i.Agent=function(){},i.Agent.defaultMaxSockets=4;var a=function(){if("undefined"==typeof window)throw new Error("no window object present");if(window.XMLHttpRequest)return window.XMLHttpRequest;if(window.ActiveXObject){for(var e=["Msxml2.XMLHTTP.6.0","Msxml2.XMLHTTP.3.0","Microsoft.XMLHTTP"],t=0;t<e.length;t++)try{var n=new window.ActiveXObject(e[t]);return function(){if(n){var i=n;return n=null,i}return new window.ActiveXObject(e[t])}}catch(e){}throw new Error("ajax not supported in this browser")}throw new Error("ajax not supported in this browser")}();i.STATUS_CODES={100:"Continue",101:"Switching Protocols",102:"Processing",200:"OK",201:"Created",202:"Accepted",203:"Non-Authoritative Information",204:"No Content",205:"Reset Content",206:"Partial Content",207:"Multi-Status",300:"Multiple Choices",301:"Moved Permanently",302:"Moved Temporarily",303:"See Other",304:"Not Modified",305:"Use Proxy",307:"Temporary Redirect",400:"Bad Request",401:"Unauthorized",402:"Payment Required",403:"Forbidden",404:"Not Found",405:"Method Not Allowed",406:"Not Acceptable",407:"Proxy Authentication Required",408:"Request Time-out",409:"Conflict",410:"Gone",411:"Length Required",412:"Precondition Failed",413:"Request Entity Too Large",414:"Request-URI Too Large",415:"Unsupported Media Type",416:"Requested Range Not Satisfiable",417:"Expectation Failed",418:"I'm a teapot",422:"Unprocessable Entity",423:"Locked",424:"Failed Dependency",425:"Unordered Collection",426:"Upgrade Required",428:"Precondition Required",429:"Too Many Requests",431:"Request Header Fields Too Large",500:"Internal Server Error",501:"Not Implemented",502:"Bad Gateway",503:"Service Unavailable",504:"Gateway Time-out",505:"HTTP Version Not Supported",506:"Variant Also Negotiates",507:"Insufficient Storage",509:"Bandwidth Limit Exceeded",510:"Not Extended",511:"Network Authentication Required"}},function(e,t,n){var i=n(10),r=n(26),o=n(30),a=n(11),s=e.exports=function(e,t){var n=this;n.writable=!0,n.xhr=e,n.body=[],n.uri=(t.protocol||"http:")+"//"+t.host+(t.port?":"+t.port:"")+(t.path||"/"),"undefined"==typeof t.withCredentials&&(t.withCredentials=!0);try{e.withCredentials=t.withCredentials}catch(e){}if(t.responseType)try{e.responseType=t.responseType}catch(e){}if(e.open(t.method||"GET",n.uri,!0),e.onerror=function(e){n.emit("error",new Error("Network error"))},n._headers={},t.headers)for(var i=p(t.headers),a=0;a<i.length;a++){var s=i[a];if(n.isSafeRequestHeader(s)){var c=t.headers[s];n.setHeader(s,c)}}t.auth&&this.setHeader("Authorization","Basic "+o.btoa(t.auth));var d=new r;d.on("close",function(){n.emit("close")}),d.on("ready",function(){n.emit("response",d)}),d.on("error",function(e){n.emit("error",e)}),e.onreadystatechange=function(){e.__aborted||d.handle(e)}};a(s,i),s.prototype.setHeader=function(e,t){this._headers[e.toLowerCase()]=t},s.prototype.getHeader=function(e){return this._headers[e.toLowerCase()]},s.prototype.removeHeader=function(e){delete this._headers[e.toLowerCase()]},s.prototype.write=function(e){this.body.push(e)},s.prototype.destroy=function(e){this.xhr.__aborted=!0,this.xhr.abort(),this.emit("close")},s.prototype.end=function(e){void 0!==e&&this.body.push(e);for(var t=p(this._headers),n=0;n<t.length;n++){var i=t[n],r=this._headers[i];if(c(r))for(var o=0;o<r.length;o++)this.xhr.setRequestHeader(i,r[o]);else this.xhr.setRequestHeader(i,r)}if(0===this.body.length)this.xhr.send("");else if("string"==typeof this.body[0])this.xhr.send(this.body.join(""));else if(c(this.body[0])){for(var a=[],n=0;n<this.body.length;n++)a.push.apply(a,this.body[n]);this.xhr.send(a)}else if(/Array/.test(Object.prototype.toString.call(this.body[0]))){for(var s=0,n=0;n<this.body.length;n++)s+=this.body[n].length;for(var a=new this.body[0].constructor(s),d=0,n=0;n<this.body.length;n++)for(var m=this.body[n],o=0;o<m.length;o++)a[d++]=m[o];this.xhr.send(a)}else if(l(this.body[0]))this.xhr.send(this.body[0]);else{for(var a="",n=0;n<this.body.length;n++)a+=this.body[n].toString();this.xhr.send(a)}},s.unsafeHeaders=["accept-charset","accept-encoding","access-control-request-headers","access-control-request-method","connection","content-length","cookie","cookie2","content-transfer-encoding","date","expect","host","keep-alive","origin","referer","te","trailer","transfer-encoding","upgrade","user-agent","via"],s.prototype.isSafeRequestHeader=function(e){return!!e&&d(s.unsafeHeaders,e.toLowerCase())===-1};var p=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t},c=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)},d=function(e,t){if(e.indexOf)return e.indexOf(t);for(var n=0;n<e.length;n++)if(e[n]===t)return n;return-1},l=function(e){return"undefined"!=typeof Blob&&e instanceof Blob||("undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer||("undefined"!=typeof FormData&&e instanceof FormData||void 0))}},function(e,t,n){function i(){r.call(this)}e.exports=i;var r=n(2).EventEmitter,o=n(11);o(i,r),i.Readable=n(12),i.Writable=n(22),i.Duplex=n(23),i.Transform=n(24),i.PassThrough=n(25),i.Stream=i,i.prototype.pipe=function(e,t){function n(t){e.writable&&!1===e.write(t)&&c.pause&&c.pause()}function i(){c.readable&&c.resume&&c.resume()}function o(){d||(d=!0,e.end())}function a(){d||(d=!0,"function"==typeof e.destroy&&e.destroy())}function s(e){if(p(),0===r.listenerCount(this,"error"))throw e}function p(){c.removeListener("data",n),e.removeListener("drain",i),c.removeListener("end",o),c.removeListener("close",a),c.removeListener("error",s),e.removeListener("error",s),c.removeListener("end",p),c.removeListener("close",p),e.removeListener("close",p)}var c=this;c.on("data",n),e.on("drain",i),e._isStdio||t&&t.end===!1||(c.on("end",o),c.on("close",a));var d=!1;return c.on("error",s),e.on("error",s),c.on("end",p),c.on("close",p),e.on("close",p),e.emit("pipe",c),e}},function(e,t){"function"==typeof Object.create?e.exports=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:e.exports=function(e,t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e}},function(e,t,n){(function(i){t=e.exports=n(13),t.Stream=n(10),t.Readable=t,t.Writable=n(18),t.Duplex=n(17),t.Transform=n(20),t.PassThrough=n(21),i.browser||"disable"!==i.env.READABLE_STREAM||(e.exports=n(10))}).call(t,n(1))},function(e,t,n){(function(t){function i(e,t){var i=n(17);e=e||{};var r=e.highWaterMark,o=e.objectMode?16:16384;this.highWaterMark=r||0===r?r:o,this.highWaterMark=~~this.highWaterMark,this.buffer=[],this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.objectMode=!!e.objectMode,t instanceof i&&(this.objectMode=this.objectMode||!!e.readableObjectMode),this.defaultEncoding=e.defaultEncoding||"utf8",this.ranOut=!1,this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&&($||($=n(19).StringDecoder),this.decoder=new $(e.encoding),this.encoding=e.encoding)}function r(e){n(17);return this instanceof r?(this._readableState=new i(e,this),this.readable=!0,void k.call(this)):new r(e)}function o(e,t,n,i,r){var o=c(t,n);if(o)e.emit("error",o);else if(C.isNullOrUndefined(n))t.reading=!1,t.ended||d(e,t);else if(t.objectMode||n&&n.length>0)if(t.ended&&!r){var s=new Error("stream.push() after EOF");e.emit("error",s)}else if(t.endEmitted&&r){var s=new Error("stream.unshift() after end event");e.emit("error",s)}else!t.decoder||r||i||(n=t.decoder.write(n)),r||(t.reading=!1),t.flowing&&0===t.length&&!t.sync?(e.emit("data",n),e.read(0)):(t.length+=t.objectMode?1:n.length,r?t.buffer.unshift(n):t.buffer.push(n),t.needReadable&&l(e)),u(e,t);else r||(t.reading=!1);return a(t)}function a(e){return!e.ended&&(e.needReadable||e.length<e.highWaterMark||0===e.length)}function s(e){if(e>=O)e=O;else{e--;for(var t=1;t<32;t<<=1)e|=e>>t;e++}return e}function p(e,t){return 0===t.length&&t.ended?0:t.objectMode?0===e?0:1:isNaN(e)||C.isNull(e)?t.flowing&&t.buffer.length?t.buffer[0].length:t.length:e<=0?0:(e>t.highWaterMark&&(t.highWaterMark=s(e)),e>t.length?t.ended?t.length:(t.needReadable=!0,0):e)}function c(e,t){var n=null;return C.isBuffer(t)||C.isString(t)||C.isNullOrUndefined(t)||e.objectMode||(n=new TypeError("Invalid non-string/buffer chunk")),n}function d(e,t){if(t.decoder&&!t.ended){var n=t.decoder.end();n&&n.length&&(t.buffer.push(n),t.length+=t.objectMode?1:n.length)}t.ended=!0,l(e)}function l(e){var n=e._readableState;n.needReadable=!1,n.emittedReadable||(j("emitReadable",n.flowing),n.emittedReadable=!0,n.sync?t.nextTick(function(){m(e)}):m(e))}function m(e){j("emit readable"),e.emit("readable"),b(e)}function u(e,n){n.readingMore||(n.readingMore=!0,t.nextTick(function(){h(e,n)}))}function h(e,t){for(var n=t.length;!t.reading&&!t.flowing&&!t.ended&&t.length<t.highWaterMark&&(j("maybeReadMore read 0"),e.read(0),n!==t.length);)n=t.length;t.readingMore=!1}function f(e){return function(){var t=e._readableState;j("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&R.listenerCount(e,"data")&&(t.flowing=!0,b(e))}}function y(e,n){n.resumeScheduled||(n.resumeScheduled=!0,t.nextTick(function(){g(e,n)}))}function g(e,t){t.resumeScheduled=!1,e.emit("resume"),b(e),t.flowing&&!t.reading&&e.read(0)}function b(e){var t=e._readableState;if(j("flow",t.flowing),t.flowing)do var n=e.read();while(null!==n&&t.flowing)}function v(e,t){var n,i=t.buffer,r=t.length,o=!!t.decoder,a=!!t.objectMode;if(0===i.length)return null;if(0===r)n=null;else if(a)n=i.shift();else if(!e||e>=r)n=o?i.join(""):T.concat(i,r),i.length=0;else if(e<i[0].length){var s=i[0];n=s.slice(0,e),i[0]=s.slice(e)}else if(e===i[0].length)n=i.shift();else{n=o?"":new T(e);for(var p=0,c=0,d=i.length;c<d&&p<e;c++){var s=i[0],l=Math.min(e-p,s.length);o?n+=s.slice(0,l):s.copy(n,p,0,l),l<s.length?i[0]=s.slice(l):i.shift(),p+=l}}return n}function w(e){var n=e._readableState;if(n.length>0)throw new Error("endReadable called on non-empty stream");n.endEmitted||(n.ended=!0,t.nextTick(function(){n.endEmitted||0!==n.length||(n.endEmitted=!0,e.readable=!1,e.emit("end"))}))}function S(e,t){for(var n=0,i=e.length;n<i;n++)t(e[n],n)}function x(e,t){for(var n=0,i=e.length;n<i;n++)if(e[n]===t)return n;return-1}e.exports=r;var I=n(14),T=n(4).Buffer;r.ReadableState=i;var R=n(2).EventEmitter;R.listenerCount||(R.listenerCount=function(e,t){return e.listeners(t).length});var k=n(10),C=n(15);C.inherits=n(11);var $,j=n(16);j=j&&j.debuglog?j.debuglog("stream"):function(){},C.inherits(r,k),r.prototype.push=function(e,t){var n=this._readableState;return C.isString(e)&&!n.objectMode&&(t=t||n.defaultEncoding,t!==n.encoding&&(e=new T(e,t),t="")),o(this,n,e,t,!1)},r.prototype.unshift=function(e){var t=this._readableState;return o(this,t,e,"",!0)},r.prototype.setEncoding=function(e){return $||($=n(19).StringDecoder),this._readableState.decoder=new $(e),this._readableState.encoding=e,this};var O=8388608;r.prototype.read=function(e){j("read",e);var t=this._readableState,n=e;if((!C.isNumber(e)||e>0)&&(t.emittedReadable=!1),0===e&&t.needReadable&&(t.length>=t.highWaterMark||t.ended))return j("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?w(this):l(this),null;if(e=p(e,t),0===e&&t.ended)return 0===t.length&&w(this),null;var i=t.needReadable;j("need readable",i),(0===t.length||t.length-e<t.highWaterMark)&&(i=!0,j("length less than watermark",i)),(t.ended||t.reading)&&(i=!1,j("reading or ended",i)),i&&(j("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1),i&&!t.reading&&(e=p(n,t));var r;return r=e>0?v(e,t):null,C.isNull(r)&&(t.needReadable=!0,e=0),t.length-=e,0!==t.length||t.ended||(t.needReadable=!0),n!==e&&t.ended&&0===t.length&&w(this),C.isNull(r)||this.emit("data",r),r},r.prototype._read=function(e){this.emit("error",new Error("not implemented"))},r.prototype.pipe=function(e,n){function i(e){j("onunpipe"),e===l&&o()}function r(){j("onend"),e.end()}function o(){j("cleanup"),e.removeListener("close",p),e.removeListener("finish",c),e.removeListener("drain",y),e.removeListener("error",s),e.removeListener("unpipe",i),l.removeListener("end",r),l.removeListener("end",o),l.removeListener("data",a),!m.awaitDrain||e._writableState&&!e._writableState.needDrain||y()}function a(t){j("ondata");var n=e.write(t);!1===n&&(j("false write response, pause",l._readableState.awaitDrain),l._readableState.awaitDrain++,l.pause())}function s(t){j("onerror",t),d(),e.removeListener("error",s),0===R.listenerCount(e,"error")&&e.emit("error",t)}function p(){e.removeListener("finish",c),d()}function c(){j("onfinish"),e.removeListener("close",p),d()}function d(){j("unpipe"),l.unpipe(e)}var l=this,m=this._readableState;switch(m.pipesCount){case 0:m.pipes=e;break;case 1:m.pipes=[m.pipes,e];break;default:m.pipes.push(e)}m.pipesCount+=1,j("pipe count=%d opts=%j",m.pipesCount,n);var u=(!n||n.end!==!1)&&e!==t.stdout&&e!==t.stderr,h=u?r:o;m.endEmitted?t.nextTick(h):l.once("end",h),e.on("unpipe",i);var y=f(l);return e.on("drain",y),l.on("data",a),e._events&&e._events.error?I(e._events.error)?e._events.error.unshift(s):e._events.error=[s,e._events.error]:e.on("error",s),e.once("close",p),e.once("finish",c),e.emit("pipe",l),m.flowing||(j("pipe resume"),l.resume()),e},r.prototype.unpipe=function(e){var t=this._readableState;if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes?this:(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this),this);if(!e){var n=t.pipes,i=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var r=0;r<i;r++)n[r].emit("unpipe",this);return this}var r=x(t.pipes,e);return r===-1?this:(t.pipes.splice(r,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this),this)},r.prototype.on=function(e,n){var i=k.prototype.on.call(this,e,n);if("data"===e&&!1!==this._readableState.flowing&&this.resume(),"readable"===e&&this.readable){var r=this._readableState;if(!r.readableListening)if(r.readableListening=!0,r.emittedReadable=!1,r.needReadable=!0,r.reading)r.length&&l(this,r);else{var o=this;t.nextTick(function(){j("readable nexttick read 0"),o.read(0)})}}return i},r.prototype.addListener=r.prototype.on,r.prototype.resume=function(){var e=this._readableState;return e.flowing||(j("resume"),e.flowing=!0,e.reading||(j("resume read 0"),this.read(0)),y(this,e)),this},r.prototype.pause=function(){return j("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(j("pause"),this._readableState.flowing=!1,this.emit("pause")),this},r.prototype.wrap=function(e){var t=this._readableState,n=!1,i=this;e.on("end",function(){if(j("wrapped end"),t.decoder&&!t.ended){var e=t.decoder.end();e&&e.length&&i.push(e)}i.push(null)}),e.on("data",function(r){if(j("wrapped data"),t.decoder&&(r=t.decoder.write(r)),r&&(t.objectMode||r.length)){var o=i.push(r);o||(n=!0,e.pause())}});for(var r in e)C.isFunction(e[r])&&C.isUndefined(this[r])&&(this[r]=function(t){return function(){return e[t].apply(e,arguments)}}(r));var o=["error","close","destroy","pause","resume"];return S(o,function(t){e.on(t,i.emit.bind(i,t))}),i._read=function(t){j("wrapped _read",t),n&&(n=!1,e.resume())},i},r._fromList=v}).call(t,n(1))},function(e,t){e.exports=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)}},function(e,t,n){(function(e){function n(e){return Array.isArray?Array.isArray(e):"[object Array]"===y(e)}function i(e){return"boolean"==typeof e}function r(e){return null===e}function o(e){return null==e}function a(e){return"number"==typeof e}function s(e){return"string"==typeof e}function p(e){return"symbol"==typeof e}function c(e){return void 0===e}function d(e){return"[object RegExp]"===y(e)}function l(e){return"object"==typeof e&&null!==e}function m(e){return"[object Date]"===y(e)}function u(e){return"[object Error]"===y(e)||e instanceof Error}function h(e){return"function"==typeof e}function f(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||"undefined"==typeof e}function y(e){return Object.prototype.toString.call(e)}t.isArray=n,t.isBoolean=i,t.isNull=r,t.isNullOrUndefined=o,t.isNumber=a,t.isString=s,t.isSymbol=p,t.isUndefined=c,t.isRegExp=d,t.isObject=l,t.isDate=m,t.isError=u,t.isFunction=h,t.isPrimitive=f,t.isBuffer=e.isBuffer}).call(t,n(4).Buffer)},function(e,t){},function(e,t,n){(function(t){function i(e){return this instanceof i?(p.call(this,e),c.call(this,e),e&&e.readable===!1&&(this.readable=!1),e&&e.writable===!1&&(this.writable=!1),this.allowHalfOpen=!0,e&&e.allowHalfOpen===!1&&(this.allowHalfOpen=!1),void this.once("end",r)):new i(e)}function r(){this.allowHalfOpen||this._writableState.ended||t.nextTick(this.end.bind(this))}function o(e,t){for(var n=0,i=e.length;n<i;n++)t(e[n],n)}e.exports=i;var a=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t},s=n(15);s.inherits=n(11);var p=n(13),c=n(18);s.inherits(i,p),o(a(c.prototype),function(e){i.prototype[e]||(i.prototype[e]=c.prototype[e])})}).call(t,n(1))},function(e,t,n){(function(t){function i(e,t,n){this.chunk=e,this.encoding=t,this.callback=n}function r(e,t){var i=n(17);e=e||{};var r=e.highWaterMark,o=e.objectMode?16:16384;this.highWaterMark=r||0===r?r:o,this.objectMode=!!e.objectMode,t instanceof i&&(this.objectMode=this.objectMode||!!e.writableObjectMode),this.highWaterMark=~~this.highWaterMark,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1;var a=e.decodeStrings===!1;this.decodeStrings=!a,this.defaultEncoding=e.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){u(t,e)},this.writecb=null,this.writelen=0,this.buffer=[],this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1}function o(e){var t=n(17);return this instanceof o||this instanceof t?(this._writableState=new r(e,this),this.writable=!0,void I.call(this)):new o(e)}function a(e,n,i){var r=new Error("write after end");e.emit("error",r),t.nextTick(function(){i(r)})}function s(e,n,i,r){var o=!0;if(!(x.isBuffer(i)||x.isString(i)||x.isNullOrUndefined(i)||n.objectMode)){var a=new TypeError("Invalid non-string/buffer chunk");e.emit("error",a),t.nextTick(function(){r(a)}),o=!1}return o}function p(e,t,n){return!e.objectMode&&e.decodeStrings!==!1&&x.isString(t)&&(t=new S(t,n)),t}function c(e,t,n,r,o){n=p(t,n,r),x.isBuffer(n)&&(r="buffer");var a=t.objectMode?1:n.length;t.length+=a;var s=t.length<t.highWaterMark;return s||(t.needDrain=!0),t.writing||t.corked?t.buffer.push(new i(n,r,o)):d(e,t,!1,a,n,r,o),s}function d(e,t,n,i,r,o,a){t.writelen=i,t.writecb=a,t.writing=!0,t.sync=!0,n?e._writev(r,t.onwrite):e._write(r,o,t.onwrite),t.sync=!1}function l(e,n,i,r,o){i?t.nextTick(function(){n.pendingcb--,o(r)}):(n.pendingcb--,o(r)),e._writableState.errorEmitted=!0,e.emit("error",r)}function m(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}function u(e,n){var i=e._writableState,r=i.sync,o=i.writecb;if(m(i),n)l(e,i,r,n,o);else{var a=g(e,i);a||i.corked||i.bufferProcessing||!i.buffer.length||y(e,i),r?t.nextTick(function(){h(e,i,a,o)}):h(e,i,a,o)}}function h(e,t,n,i){n||f(e,t),t.pendingcb--,i(),v(e,t)}function f(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"))}function y(e,t){if(t.bufferProcessing=!0,e._writev&&t.buffer.length>1){for(var n=[],i=0;i<t.buffer.length;i++)n.push(t.buffer[i].callback);t.pendingcb++,d(e,t,!0,t.length,t.buffer,"",function(e){for(var i=0;i<n.length;i++)t.pendingcb--,n[i](e)}),t.buffer=[]}else{for(var i=0;i<t.buffer.length;i++){var r=t.buffer[i],o=r.chunk,a=r.encoding,s=r.callback,p=t.objectMode?1:o.length;if(d(e,t,!1,p,o,a,s),t.writing){i++;break}}i<t.buffer.length?t.buffer=t.buffer.slice(i):t.buffer.length=0}t.bufferProcessing=!1}function g(e,t){return t.ending&&0===t.length&&!t.finished&&!t.writing}function b(e,t){t.prefinished||(t.prefinished=!0,e.emit("prefinish"))}function v(e,t){var n=g(e,t);return n&&(0===t.pendingcb?(b(e,t),t.finished=!0,e.emit("finish")):b(e,t)),n}function w(e,n,i){n.ending=!0,v(e,n),i&&(n.finished?t.nextTick(i):e.once("finish",i)),n.ended=!0}e.exports=o;var S=n(4).Buffer;o.WritableState=r;var x=n(15);x.inherits=n(11);var I=n(10);x.inherits(o,I),o.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe. Not readable."))},o.prototype.write=function(e,t,n){var i=this._writableState,r=!1;return x.isFunction(t)&&(n=t,t=null),x.isBuffer(e)?t="buffer":t||(t=i.defaultEncoding),x.isFunction(n)||(n=function(){}),i.ended?a(this,i,n):s(this,i,e,n)&&(i.pendingcb++,r=c(this,i,e,t,n)),r},o.prototype.cork=function(){var e=this._writableState;e.corked++},o.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.finished||e.bufferProcessing||!e.buffer.length||y(this,e))},o.prototype._write=function(e,t,n){n(new Error("not implemented"))},o.prototype._writev=null,o.prototype.end=function(e,t,n){var i=this._writableState;x.isFunction(e)?(n=e,e=null,t=null):x.isFunction(t)&&(n=t,t=null),x.isNullOrUndefined(e)||this.write(e,t),i.corked&&(i.corked=1,this.uncork()),i.ending||i.finished||w(this,i,n)}}).call(t,n(1))},function(e,t,n){function i(e){if(e&&!p(e))throw new Error("Unknown encoding: "+e)}function r(e){return e.toString(this.encoding)}function o(e){this.charReceived=e.length%2,this.charLength=this.charReceived?2:0}function a(e){this.charReceived=e.length%3,this.charLength=this.charReceived?3:0}var s=n(4).Buffer,p=s.isEncoding||function(e){switch(e&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}},c=t.StringDecoder=function(e){switch(this.encoding=(e||"utf8").toLowerCase().replace(/[-_]/,""),i(e),this.encoding){case"utf8":this.surrogateSize=3;break;case"ucs2":case"utf16le":this.surrogateSize=2,this.detectIncompleteChar=o;break;case"base64":this.surrogateSize=3,this.detectIncompleteChar=a;break;default:return void(this.write=r)}this.charBuffer=new s(6),this.charReceived=0,this.charLength=0};c.prototype.write=function(e){for(var t="";this.charLength;){var n=e.length>=this.charLength-this.charReceived?this.charLength-this.charReceived:e.length;if(e.copy(this.charBuffer,this.charReceived,0,n),this.charReceived+=n,this.charReceived<this.charLength)return"";e=e.slice(n,e.length),t=this.charBuffer.slice(0,this.charLength).toString(this.encoding);var i=t.charCodeAt(t.length-1);if(!(i>=55296&&i<=56319)){if(this.charReceived=this.charLength=0,0===e.length)return t;break}this.charLength+=this.surrogateSize,t=""}this.detectIncompleteChar(e);var r=e.length;this.charLength&&(e.copy(this.charBuffer,0,e.length-this.charReceived,r),r-=this.charReceived),t+=e.toString(this.encoding,0,r);var r=t.length-1,i=t.charCodeAt(r);if(i>=55296&&i<=56319){var o=this.surrogateSize;return this.charLength+=o,this.charReceived+=o,this.charBuffer.copy(this.charBuffer,o,0,o),e.copy(this.charBuffer,0,0,o),t.substring(0,r)}return t},c.prototype.detectIncompleteChar=function(e){for(var t=e.length>=3?3:e.length;t>0;t--){var n=e[e.length-t];if(1==t&&n>>5==6){this.charLength=2;break}if(t<=2&&n>>4==14){this.charLength=3;break}if(t<=3&&n>>3==30){this.charLength=4;break}}this.charReceived=t},c.prototype.end=function(e){var t="";if(e&&e.length&&(t=this.write(e)),this.charReceived){var n=this.charReceived,i=this.charBuffer,r=this.encoding;t+=i.slice(0,n).toString(r)}return t}},function(e,t,n){function i(e,t){this.afterTransform=function(e,n){return r(t,e,n)},this.needTransform=!1,this.transforming=!1,this.writecb=null,this.writechunk=null}function r(e,t,n){var i=e._transformState;i.transforming=!1;var r=i.writecb;if(!r)return e.emit("error",new Error("no writecb in Transform class"));i.writechunk=null,i.writecb=null,p.isNullOrUndefined(n)||e.push(n),r&&r(t);var o=e._readableState;o.reading=!1,(o.needReadable||o.length<o.highWaterMark)&&e._read(o.highWaterMark)}function o(e){if(!(this instanceof o))return new o(e);s.call(this,e),this._transformState=new i(e,this);var t=this;this._readableState.needReadable=!0,this._readableState.sync=!1,this.once("prefinish",function(){p.isFunction(this._flush)?this._flush(function(e){a(t,e)}):a(t)})}function a(e,t){if(t)return e.emit("error",t);var n=e._writableState,i=e._transformState;if(n.length)throw new Error("calling transform done when ws.length != 0");if(i.transforming)throw new Error("calling transform done when still transforming");return e.push(null)}e.exports=o;var s=n(17),p=n(15);p.inherits=n(11),p.inherits(o,s),o.prototype.push=function(e,t){return this._transformState.needTransform=!1,s.prototype.push.call(this,e,t)},o.prototype._transform=function(e,t,n){throw new Error("not implemented")},o.prototype._write=function(e,t,n){var i=this._transformState;if(i.writecb=n,i.writechunk=e,i.writeencoding=t,!i.transforming){var r=this._readableState;(i.needTransform||r.needReadable||r.length<r.highWaterMark)&&this._read(r.highWaterMark)}},o.prototype._read=function(e){var t=this._transformState;p.isNull(t.writechunk)||!t.writecb||t.transforming?t.needTransform=!0:(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform))}},function(e,t,n){function i(e){return this instanceof i?void r.call(this,e):new i(e)}e.exports=i;var r=n(20),o=n(15);o.inherits=n(11),o.inherits(i,r),i.prototype._transform=function(e,t,n){n(null,e)}},function(e,t,n){e.exports=n(18)},function(e,t,n){e.exports=n(17)},function(e,t,n){e.exports=n(20)},function(e,t,n){e.exports=n(21)},function(e,t,n){function i(e){for(var t=e.getAllResponseHeaders().split(/\r?\n/),n={},i=0;i<t.length;i++){var r=t[i];if(""!==r){var o=r.match(/^([^:]+):\s*(.*)/);if(o){var a=o[1].toLowerCase(),s=o[2];void 0!==n[a]?p(n[a])?n[a].push(s):n[a]=[n[a],s]:n[a]=s}else n[r]=!0}}return n}var r=n(10),o=n(27),a=e.exports=function(e){this.offset=0,this.readable=!0};o.inherits(a,r);var s={streaming:!0,status2:!0};a.prototype.getResponse=function(e){var t=String(e.responseType).toLowerCase();return"blob"===t?e.responseBlob||e.response:"arraybuffer"===t?e.response:e.responseText},a.prototype.getHeader=function(e){return this.headers[e.toLowerCase()]},a.prototype.handle=function(e){if(2===e.readyState&&s.status2){try{this.statusCode=e.status,this.headers=i(e)}catch(e){s.status2=!1}s.status2&&this.emit("ready")}else if(s.streaming&&3===e.readyState){try{this.statusCode||(this.statusCode=e.status,this.headers=i(e),this.emit("ready"))}catch(e){}try{this._emitData(e)}catch(e){s.streaming=!1}}else 4===e.readyState&&(this.statusCode||(this.statusCode=e.status,this.emit("ready")),this._emitData(e),e.error?this.emit("error",this.getResponse(e)):this.emit("end"),this.emit("close"))},a.prototype._emitData=function(e){var t=this.getResponse(e);return t.toString().match(/ArrayBuffer/)?(this.emit("data",new Uint8Array(t,this.offset)),void(this.offset=t.byteLength)):void(t.length>this.offset&&(this.emit("data",t.slice(this.offset)),this.offset=t.length))};var p=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}},function(e,t,n){(function(e,i){function r(e,n){var i={seen:[],stylize:a};return arguments.length>=3&&(i.depth=arguments[2]),arguments.length>=4&&(i.colors=arguments[3]),f(n)?i.showHidden=n:n&&t._extend(i,n),S(i.showHidden)&&(i.showHidden=!1),S(i.depth)&&(i.depth=2),S(i.colors)&&(i.colors=!1),S(i.customInspect)&&(i.customInspect=!0),i.colors&&(i.stylize=o),p(i,e,i.depth)}function o(e,t){var n=r.styles[t];return n?"["+r.colors[n][0]+"m"+e+"["+r.colors[n][1]+"m":e}function a(e,t){return e}function s(e){var t={};return e.forEach(function(e,n){t[e]=!0}),t}function p(e,n,i){if(e.customInspect&&n&&k(n.inspect)&&n.inspect!==t.inspect&&(!n.constructor||n.constructor.prototype!==n)){var r=n.inspect(i,e);return v(r)||(r=p(e,r,i)),r}var o=c(e,n);if(o)return o;var a=Object.keys(n),f=s(a);if(e.showHidden&&(a=Object.getOwnPropertyNames(n)),R(n)&&(a.indexOf("message")>=0||a.indexOf("description")>=0))return d(n);if(0===a.length){if(k(n)){var y=n.name?": "+n.name:"";return e.stylize("[Function"+y+"]","special")}if(x(n))return e.stylize(RegExp.prototype.toString.call(n),"regexp");if(T(n))return e.stylize(Date.prototype.toString.call(n),"date");if(R(n))return d(n)}var g="",b=!1,w=["{","}"];if(h(n)&&(b=!0,w=["[","]"]),k(n)){var S=n.name?": "+n.name:"";g=" [Function"+S+"]"}if(x(n)&&(g=" "+RegExp.prototype.toString.call(n)),T(n)&&(g=" "+Date.prototype.toUTCString.call(n)),R(n)&&(g=" "+d(n)),0===a.length&&(!b||0==n.length))return w[0]+g+w[1];if(i<0)return x(n)?e.stylize(RegExp.prototype.toString.call(n),"regexp"):e.stylize("[Object]","special");e.seen.push(n);var I;return I=b?l(e,n,i,f,a):a.map(function(t){return m(e,n,i,f,t,b)}),e.seen.pop(),u(I,g,w)}function c(e,t){if(S(t))return e.stylize("undefined","undefined");if(v(t)){var n="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(n,"string")}return b(t)?e.stylize(""+t,"number"):f(t)?e.stylize(""+t,"boolean"):y(t)?e.stylize("null","null"):void 0}function d(e){return"["+Error.prototype.toString.call(e)+"]"}function l(e,t,n,i,r){for(var o=[],a=0,s=t.length;a<s;++a)E(t,String(a))?o.push(m(e,t,n,i,String(a),!0)):o.push("");return r.forEach(function(r){r.match(/^\d+$/)||o.push(m(e,t,n,i,r,!0))}),o}function m(e,t,n,i,r,o){var a,s,c;if(c=Object.getOwnPropertyDescriptor(t,r)||{value:t[r]},c.get?s=c.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):c.set&&(s=e.stylize("[Setter]","special")),E(i,r)||(a="["+r+"]"),s||(e.seen.indexOf(c.value)<0?(s=y(n)?p(e,c.value,null):p(e,c.value,n-1),s.indexOf("\n")>-1&&(s=o?s.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+s.split("\n").map(function(e){return"   "+e}).join("\n"))):s=e.stylize("[Circular]","special")),S(a)){if(o&&r.match(/^\d+$/))return s;a=JSON.stringify(""+r),a.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(a=a.substr(1,a.length-2),a=e.stylize(a,"name")):(a=a.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),a=e.stylize(a,"string"))}return a+": "+s}function u(e,t,n){var i=0,r=e.reduce(function(e,t){return i++,t.indexOf("\n")>=0&&i++,e+t.replace(/\u001b\[\d\d?m/g,"").length+1},0);return r>60?n[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+n[1]:n[0]+t+" "+e.join(", ")+" "+n[1]}function h(e){return Array.isArray(e)}function f(e){return"boolean"==typeof e}function y(e){return null===e}function g(e){return null==e}function b(e){return"number"==typeof e}function v(e){return"string"==typeof e}function w(e){return"symbol"==typeof e}function S(e){return void 0===e}function x(e){return I(e)&&"[object RegExp]"===$(e)}function I(e){return"object"==typeof e&&null!==e}function T(e){return I(e)&&"[object Date]"===$(e)}function R(e){return I(e)&&("[object Error]"===$(e)||e instanceof Error)}function k(e){return"function"==typeof e}function C(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||"undefined"==typeof e}function $(e){return Object.prototype.toString.call(e)}function j(e){return e<10?"0"+e.toString(10):e.toString(10)}function O(){var e=new Date,t=[j(e.getHours()),j(e.getMinutes()),j(e.getSeconds())].join(":");return[e.getDate(),L[e.getMonth()],t].join(" ")}function E(e,t){return Object.prototype.hasOwnProperty.call(e,t)}var A=/%[sdj%]/g;t.format=function(e){if(!v(e)){for(var t=[],n=0;n<arguments.length;n++)t.push(r(arguments[n]));return t.join(" ")}for(var n=1,i=arguments,o=i.length,a=String(e).replace(A,function(e){if("%%"===e)return"%";if(n>=o)return e;switch(e){case"%s":return String(i[n++]);case"%d":return Number(i[n++]);case"%j":try{return JSON.stringify(i[n++])}catch(e){return"[Circular]"}default:return e}}),s=i[n];n<o;s=i[++n])a+=y(s)||!I(s)?" "+s:" "+r(s);return a},t.deprecate=function(n,r){function o(){
	if(!a){if(i.throwDeprecation)throw new Error(r);i.traceDeprecation?console.trace(r):console.error(r),a=!0}return n.apply(this,arguments)}if(S(e.process))return function(){return t.deprecate(n,r).apply(this,arguments)};if(i.noDeprecation===!0)return n;var a=!1;return o};var D,P={};t.debuglog=function(e){if(S(D)&&(D=i.env.NODE_DEBUG||""),e=e.toUpperCase(),!P[e])if(new RegExp("\\b"+e+"\\b","i").test(D)){var n=i.pid;P[e]=function(){var i=t.format.apply(t,arguments);console.error("%s %d: %s",e,n,i)}}else P[e]=function(){};return P[e]},t.inspect=r,r.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},r.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},t.isArray=h,t.isBoolean=f,t.isNull=y,t.isNullOrUndefined=g,t.isNumber=b,t.isString=v,t.isSymbol=w,t.isUndefined=S,t.isRegExp=x,t.isObject=I,t.isDate=T,t.isError=R,t.isFunction=k,t.isPrimitive=C,t.isBuffer=n(28);var L=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];t.log=function(){console.log("%s - %s",O(),t.format.apply(t,arguments))},t.inherits=n(29),t._extend=function(e,t){if(!t||!I(t))return e;for(var n=Object.keys(t),i=n.length;i--;)e[n[i]]=t[n[i]];return e}}).call(t,function(){return this}(),n(1))},function(e,t){e.exports=function(e){return e&&"object"==typeof e&&"function"==typeof e.copy&&"function"==typeof e.fill&&"function"==typeof e.readUInt8}},function(e,t){"function"==typeof Object.create?e.exports=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:e.exports=function(e,t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e}},function(e,t,n){!function(){function e(e){this.message=e}var n=t,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";e.prototype=new Error,e.prototype.name="InvalidCharacterError",n.btoa||(n.btoa=function(t){for(var n,r,o=0,a=i,s="";t.charAt(0|o)||(a="=",o%1);s+=a.charAt(63&n>>8-o%1*8)){if(r=t.charCodeAt(o+=.75),r>255)throw new e("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");n=n<<8|r}return s}),n.atob||(n.atob=function(t){if(t=t.replace(/=+$/,""),t.length%4==1)throw new e("'atob' failed: The string to be decoded is not correctly encoded.");for(var n,r,o=0,a=0,s="";r=t.charAt(a++);~r&&(n=o%4?64*n+r:r,o++%4)?s+=String.fromCharCode(255&n>>(-2*o&6)):0)r=i.indexOf(r);return s})}()},function(e,t,n){function i(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}function r(e,t,n){if(e&&c(e)&&e instanceof i)return e;var r=new i;return r.parse(e,t,n),r}function o(e){return p(e)&&(e=r(e)),e instanceof i?e.format():i.prototype.format.call(e)}function a(e,t){return r(e,!1,!0).resolve(t)}function s(e,t){return e?r(e,!1,!0).resolveObject(t):t}function p(e){return"string"==typeof e}function c(e){return"object"==typeof e&&null!==e}function d(e){return null===e}function l(e){return null==e}var m=n(32);t.parse=r,t.resolve=a,t.resolveObject=s,t.format=o,t.Url=i;var u=/^([a-z0-9.+-]+:)/i,h=/:[0-9]*$/,f=["<",">",'"',"`"," ","\r","\n","\t"],y=["{","}","|","\\","^","`"].concat(f),g=["'"].concat(y),b=["%","/","?",";","#"].concat(g),v=["/","?","#"],w=255,S=/^[a-z0-9A-Z_-]{0,63}$/,x=/^([a-z0-9A-Z_-]{0,63})(.*)$/,I={javascript:!0,"javascript:":!0},T={javascript:!0,"javascript:":!0},R={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0},k=n(34);i.prototype.parse=function(e,t,n){if(!p(e))throw new TypeError("Parameter 'url' must be a string, not "+typeof e);var i=e;i=i.trim();var r=u.exec(i);if(r){r=r[0];var o=r.toLowerCase();this.protocol=o,i=i.substr(r.length)}if(n||r||i.match(/^\/\/[^@\/]+@[^@\/]+/)){var a="//"===i.substr(0,2);!a||r&&T[r]||(i=i.substr(2),this.slashes=!0)}if(!T[r]&&(a||r&&!R[r])){for(var s=-1,c=0;c<v.length;c++){var d=i.indexOf(v[c]);d!==-1&&(s===-1||d<s)&&(s=d)}var l,h;h=s===-1?i.lastIndexOf("@"):i.lastIndexOf("@",s),h!==-1&&(l=i.slice(0,h),i=i.slice(h+1),this.auth=decodeURIComponent(l)),s=-1;for(var c=0;c<b.length;c++){var d=i.indexOf(b[c]);d!==-1&&(s===-1||d<s)&&(s=d)}s===-1&&(s=i.length),this.host=i.slice(0,s),i=i.slice(s),this.parseHost(),this.hostname=this.hostname||"";var f="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];if(!f)for(var y=this.hostname.split(/\./),c=0,C=y.length;c<C;c++){var $=y[c];if($&&!$.match(S)){for(var j="",O=0,E=$.length;O<E;O++)j+=$.charCodeAt(O)>127?"x":$[O];if(!j.match(S)){var A=y.slice(0,c),D=y.slice(c+1),P=$.match(x);P&&(A.push(P[1]),D.unshift(P[2])),D.length&&(i="/"+D.join(".")+i),this.hostname=A.join(".");break}}}if(this.hostname.length>w?this.hostname="":this.hostname=this.hostname.toLowerCase(),!f){for(var L=this.hostname.split("."),N=[],c=0;c<L.length;++c){var M=L[c];N.push(M.match(/[^A-Za-z0-9_-]/)?"xn--"+m.encode(M):M)}this.hostname=N.join(".")}var q=this.port?":"+this.port:"",U=this.hostname||"";this.host=U+q,this.href+=this.host,f&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),"/"!==i[0]&&(i="/"+i))}if(!I[o])for(var c=0,C=g.length;c<C;c++){var _=g[c],F=encodeURIComponent(_);F===_&&(F=escape(_)),i=i.split(_).join(F)}var B=i.indexOf("#");B!==-1&&(this.hash=i.substr(B),i=i.slice(0,B));var W=i.indexOf("?");if(W!==-1?(this.search=i.substr(W),this.query=i.substr(W+1),t&&(this.query=k.parse(this.query)),i=i.slice(0,W)):t&&(this.search="",this.query={}),i&&(this.pathname=i),R[o]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){var q=this.pathname||"",M=this.search||"";this.path=q+M}return this.href=this.format(),this},i.prototype.format=function(){var e=this.auth||"";e&&(e=encodeURIComponent(e),e=e.replace(/%3A/i,":"),e+="@");var t=this.protocol||"",n=this.pathname||"",i=this.hash||"",r=!1,o="";this.host?r=e+this.host:this.hostname&&(r=e+(this.hostname.indexOf(":")===-1?this.hostname:"["+this.hostname+"]"),this.port&&(r+=":"+this.port)),this.query&&c(this.query)&&Object.keys(this.query).length&&(o=k.stringify(this.query));var a=this.search||o&&"?"+o||"";return t&&":"!==t.substr(-1)&&(t+=":"),this.slashes||(!t||R[t])&&r!==!1?(r="//"+(r||""),n&&"/"!==n.charAt(0)&&(n="/"+n)):r||(r=""),i&&"#"!==i.charAt(0)&&(i="#"+i),a&&"?"!==a.charAt(0)&&(a="?"+a),n=n.replace(/[?#]/g,function(e){return encodeURIComponent(e)}),a=a.replace("#","%23"),t+r+n+a+i},i.prototype.resolve=function(e){return this.resolveObject(r(e,!1,!0)).format()},i.prototype.resolveObject=function(e){if(p(e)){var t=new i;t.parse(e,!1,!0),e=t}var n=new i;if(Object.keys(this).forEach(function(e){n[e]=this[e]},this),n.hash=e.hash,""===e.href)return n.href=n.format(),n;if(e.slashes&&!e.protocol)return Object.keys(e).forEach(function(t){"protocol"!==t&&(n[t]=e[t])}),R[n.protocol]&&n.hostname&&!n.pathname&&(n.path=n.pathname="/"),n.href=n.format(),n;if(e.protocol&&e.protocol!==n.protocol){if(!R[e.protocol])return Object.keys(e).forEach(function(t){n[t]=e[t]}),n.href=n.format(),n;if(n.protocol=e.protocol,e.host||T[e.protocol])n.pathname=e.pathname;else{for(var r=(e.pathname||"").split("/");r.length&&!(e.host=r.shift()););e.host||(e.host=""),e.hostname||(e.hostname=""),""!==r[0]&&r.unshift(""),r.length<2&&r.unshift(""),n.pathname=r.join("/")}if(n.search=e.search,n.query=e.query,n.host=e.host||"",n.auth=e.auth,n.hostname=e.hostname||e.host,n.port=e.port,n.pathname||n.search){var o=n.pathname||"",a=n.search||"";n.path=o+a}return n.slashes=n.slashes||e.slashes,n.href=n.format(),n}var s=n.pathname&&"/"===n.pathname.charAt(0),c=e.host||e.pathname&&"/"===e.pathname.charAt(0),m=c||s||n.host&&e.pathname,u=m,h=n.pathname&&n.pathname.split("/")||[],r=e.pathname&&e.pathname.split("/")||[],f=n.protocol&&!R[n.protocol];if(f&&(n.hostname="",n.port=null,n.host&&(""===h[0]?h[0]=n.host:h.unshift(n.host)),n.host="",e.protocol&&(e.hostname=null,e.port=null,e.host&&(""===r[0]?r[0]=e.host:r.unshift(e.host)),e.host=null),m=m&&(""===r[0]||""===h[0])),c)n.host=e.host||""===e.host?e.host:n.host,n.hostname=e.hostname||""===e.hostname?e.hostname:n.hostname,n.search=e.search,n.query=e.query,h=r;else if(r.length)h||(h=[]),h.pop(),h=h.concat(r),n.search=e.search,n.query=e.query;else if(!l(e.search)){if(f){n.hostname=n.host=h.shift();var y=!!(n.host&&n.host.indexOf("@")>0)&&n.host.split("@");y&&(n.auth=y.shift(),n.host=n.hostname=y.shift())}return n.search=e.search,n.query=e.query,d(n.pathname)&&d(n.search)||(n.path=(n.pathname?n.pathname:"")+(n.search?n.search:"")),n.href=n.format(),n}if(!h.length)return n.pathname=null,n.search?n.path="/"+n.search:n.path=null,n.href=n.format(),n;for(var g=h.slice(-1)[0],b=(n.host||e.host)&&("."===g||".."===g)||""===g,v=0,w=h.length;w>=0;w--)g=h[w],"."==g?h.splice(w,1):".."===g?(h.splice(w,1),v++):v&&(h.splice(w,1),v--);if(!m&&!u)for(;v--;v)h.unshift("..");!m||""===h[0]||h[0]&&"/"===h[0].charAt(0)||h.unshift(""),b&&"/"!==h.join("/").substr(-1)&&h.push("");var S=""===h[0]||h[0]&&"/"===h[0].charAt(0);if(f){n.hostname=n.host=S?"":h.length?h.shift():"";var y=!!(n.host&&n.host.indexOf("@")>0)&&n.host.split("@");y&&(n.auth=y.shift(),n.host=n.hostname=y.shift())}return m=m||n.host&&h.length,m&&!S&&h.unshift(""),h.length?n.pathname=h.join("/"):(n.pathname=null,n.path=null),d(n.pathname)&&d(n.search)||(n.path=(n.pathname?n.pathname:"")+(n.search?n.search:"")),n.auth=e.auth||n.auth,n.slashes=n.slashes||e.slashes,n.href=n.format(),n},i.prototype.parseHost=function(){var e=this.host,t=h.exec(e);t&&(t=t[0],":"!==t&&(this.port=t.substr(1)),e=e.substr(0,e.length-t.length)),e&&(this.hostname=e)}},function(e,t,n){var i;(function(e,r){!function(o){function a(e){throw RangeError(A[e])}function s(e,t){for(var n=e.length,i=[];n--;)i[n]=t(e[n]);return i}function p(e,t){var n=e.split("@"),i="";n.length>1&&(i=n[0]+"@",e=n[1]),e=e.replace(E,".");var r=e.split("."),o=s(r,t).join(".");return i+o}function c(e){for(var t,n,i=[],r=0,o=e.length;r<o;)t=e.charCodeAt(r++),t>=55296&&t<=56319&&r<o?(n=e.charCodeAt(r++),56320==(64512&n)?i.push(((1023&t)<<10)+(1023&n)+65536):(i.push(t),r--)):i.push(t);return i}function d(e){return s(e,function(e){var t="";return e>65535&&(e-=65536,t+=L(e>>>10&1023|55296),e=56320|1023&e),t+=L(e)}).join("")}function l(e){return e-48<10?e-22:e-65<26?e-65:e-97<26?e-97:S}function m(e,t){return e+22+75*(e<26)-((0!=t)<<5)}function u(e,t,n){var i=0;for(e=n?P(e/R):e>>1,e+=P(e/t);e>D*I>>1;i+=S)e=P(e/D);return P(i+(D+1)*e/(e+T))}function h(e){var t,n,i,r,o,s,p,c,m,h,f=[],y=e.length,g=0,b=C,v=k;for(n=e.lastIndexOf($),n<0&&(n=0),i=0;i<n;++i)e.charCodeAt(i)>=128&&a("not-basic"),f.push(e.charCodeAt(i));for(r=n>0?n+1:0;r<y;){for(o=g,s=1,p=S;r>=y&&a("invalid-input"),c=l(e.charCodeAt(r++)),(c>=S||c>P((w-g)/s))&&a("overflow"),g+=c*s,m=p<=v?x:p>=v+I?I:p-v,!(c<m);p+=S)h=S-m,s>P(w/h)&&a("overflow"),s*=h;t=f.length+1,v=u(g-o,t,0==o),P(g/t)>w-b&&a("overflow"),b+=P(g/t),g%=t,f.splice(g++,0,b)}return d(f)}function f(e){var t,n,i,r,o,s,p,d,l,h,f,y,g,b,v,T=[];for(e=c(e),y=e.length,t=C,n=0,o=k,s=0;s<y;++s)f=e[s],f<128&&T.push(L(f));for(i=r=T.length,r&&T.push($);i<y;){for(p=w,s=0;s<y;++s)f=e[s],f>=t&&f<p&&(p=f);for(g=i+1,p-t>P((w-n)/g)&&a("overflow"),n+=(p-t)*g,t=p,s=0;s<y;++s)if(f=e[s],f<t&&++n>w&&a("overflow"),f==t){for(d=n,l=S;h=l<=o?x:l>=o+I?I:l-o,!(d<h);l+=S)v=d-h,b=S-h,T.push(L(m(h+v%b,0))),d=P(v/b);T.push(L(m(d,0))),o=u(n,g,i==r),n=0,++i}++n,++t}return T.join("")}function y(e){return p(e,function(e){return j.test(e)?h(e.slice(4).toLowerCase()):e})}function g(e){return p(e,function(e){return O.test(e)?"xn--"+f(e):e})}var b=("object"==typeof t&&t&&!t.nodeType&&t,"object"==typeof e&&e&&!e.nodeType&&e,"object"==typeof r&&r);b.global!==b&&b.window!==b&&b.self!==b||(o=b);var v,w=2147483647,S=36,x=1,I=26,T=38,R=700,k=72,C=128,$="-",j=/^xn--/,O=/[^\x20-\x7E]/,E=/[\x2E\u3002\uFF0E\uFF61]/g,A={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},D=S-x,P=Math.floor,L=String.fromCharCode;v={version:"1.3.2",ucs2:{decode:c,encode:d},decode:h,encode:f,toASCII:g,toUnicode:y},i=function(){return v}.call(t,n,t,e),!(void 0!==i&&(e.exports=i))}(this)}).call(t,n(33)(e),function(){return this}())},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children=[],e.webpackPolyfill=1),e}},function(e,t,n){"use strict";t.decode=t.parse=n(35),t.encode=t.stringify=n(36)},function(e,t){"use strict";function n(e,t){return Object.prototype.hasOwnProperty.call(e,t)}e.exports=function(e,t,i,r){t=t||"&",i=i||"=";var o={};if("string"!=typeof e||0===e.length)return o;var a=/\+/g;e=e.split(t);var s=1e3;r&&"number"==typeof r.maxKeys&&(s=r.maxKeys);var p=e.length;s>0&&p>s&&(p=s);for(var c=0;c<p;++c){var d,l,m,u,h=e[c].replace(a,"%20"),f=h.indexOf(i);f>=0?(d=h.substr(0,f),l=h.substr(f+1)):(d=h,l=""),m=decodeURIComponent(d),u=decodeURIComponent(l),n(o,m)?Array.isArray(o[m])?o[m].push(u):o[m]=[o[m],u]:o[m]=u}return o}},function(e,t){"use strict";var n=function(e){switch(typeof e){case"string":return e;case"boolean":return e?"true":"false";case"number":return isFinite(e)?e:"";default:return""}};e.exports=function(e,t,i,r){return t=t||"&",i=i||"=",null===e&&(e=void 0),"object"==typeof e?Object.keys(e).map(function(r){var o=encodeURIComponent(n(r))+i;return Array.isArray(e[r])?e[r].map(function(e){return o+encodeURIComponent(n(e))}).join(t):o+encodeURIComponent(n(e[r]))}).join(t):r?encodeURIComponent(n(r))+i+encodeURIComponent(n(e)):""}},function(e,t,n){var i=n(8),r=e.exports;for(var o in i)i.hasOwnProperty(o)&&(r[o]=i[o]);r.request=function(e,t){return e||(e={}),e.scheme="https",i.request.call(this,e,t)}},function(e,t){"use strict";e.exports.HOST="localhost",e.exports.PORT=9222},function(e,t){e.exports=function(e,t,n){window.criRequest(t,n)}},function(e,t){e.exports={version:{major:"1",minor:"2"},domains:[{domain:"Inspector",experimental:!0,types:[],commands:[{name:"enable",description:"Enables inspector domain notifications."},{name:"disable",description:"Disables inspector domain notifications."}],events:[{name:"detached",description:"Fired when remote debugging connection is about to be terminated. Contains detach reason.",parameters:[{name:"reason",type:"string",description:"The reason why connection has been terminated."}]},{name:"targetCrashed",description:"Fired when debugging target has crashed"}]},{domain:"Memory",experimental:!0,types:[{id:"PressureLevel",type:"string",enum:["moderate","critical"],description:"Memory pressure level."}],commands:[{name:"getDOMCounters",returns:[{name:"documents",type:"integer"},{name:"nodes",type:"integer"},{name:"jsEventListeners",type:"integer"}]},{name:"setPressureNotificationsSuppressed",description:"Enable/disable suppressing memory pressure notifications in all processes.",parameters:[{name:"suppressed",type:"boolean",description:"If true, memory pressure notifications will be suppressed."}]},{name:"simulatePressureNotification",description:"Simulate a memory pressure notification in all processes.",parameters:[{name:"level",$ref:"PressureLevel",description:"Memory pressure level of the notification."}]}]},{domain:"Page",description:"Actions and events related to the inspected page belong to the page domain.",dependencies:["Debugger","DOM"],types:[{id:"ResourceType",type:"string",enum:["Document","Stylesheet","Image","Media","Font","Script","TextTrack","XHR","Fetch","EventSource","WebSocket","Manifest","Other"],description:"Resource type as it was perceived by the rendering engine."},{id:"FrameId",type:"string",description:"Unique frame identifier."},{id:"Frame",type:"object",description:"Information about the Frame on the page.",properties:[{name:"id",type:"string",description:"Frame unique identifier."},{name:"parentId",type:"string",optional:!0,description:"Parent frame identifier."},{name:"loaderId",$ref:"Network.LoaderId",description:"Identifier of the loader associated with this frame."},{name:"name",type:"string",optional:!0,description:"Frame's name as specified in the tag."},{name:"url",type:"string",description:"Frame document's URL."},{name:"securityOrigin",type:"string",description:"Frame document's security origin."},{name:"mimeType",type:"string",description:"Frame document's mimeType as determined by the browser."}]},{id:"FrameResource",type:"object",description:"Information about the Resource on the page.",properties:[{name:"url",type:"string",description:"Resource URL."},{name:"type",$ref:"ResourceType",description:"Type of this resource."},{name:"mimeType",type:"string",description:"Resource mimeType as determined by the browser."},{name:"lastModified",$ref:"Network.Timestamp",description:"last-modified timestamp as reported by server.",optional:!0},{name:"contentSize",type:"number",description:"Resource content size.",optional:!0},{name:"failed",type:"boolean",optional:!0,description:"True if the resource failed to load."},{name:"canceled",type:"boolean",optional:!0,description:"True if the resource was canceled during loading."}],experimental:!0},{id:"FrameResourceTree",type:"object",description:"Information about the Frame hierarchy along with their cached resources.",properties:[{name:"frame",$ref:"Frame",description:"Frame information for this tree item."},{name:"childFrames",type:"array",optional:!0,items:{$ref:"FrameResourceTree"},description:"Child frames."},{name:"resources",type:"array",items:{$ref:"FrameResource"},description:"Information about frame resources."}],experimental:!0},{id:"ScriptIdentifier",type:"string",description:"Unique script identifier.",experimental:!0},{id:"NavigationEntry",type:"object",description:"Navigation history entry.",properties:[{name:"id",type:"integer",description:"Unique id of the navigation history entry."},{name:"url",type:"string",description:"URL of the navigation history entry."},{name:"title",type:"string",description:"Title of the navigation history entry."}],experimental:!0},{id:"ScreencastFrameMetadata",type:"object",description:"Screencast frame metadata.",properties:[{name:"offsetTop",type:"number",experimental:!0,description:"Top offset in DIP."},{name:"pageScaleFactor",type:"number",experimental:!0,description:"Page scale factor."},{name:"deviceWidth",type:"number",experimental:!0,description:"Device screen width in DIP."},{name:"deviceHeight",type:"number",experimental:!0,description:"Device screen height in DIP."},{name:"scrollOffsetX",type:"number",experimental:!0,description:"Position of horizontal scroll in CSS pixels."},{name:"scrollOffsetY",type:"number",experimental:!0,description:"Position of vertical scroll in CSS pixels."},{name:"timestamp",type:"number",optional:!0,experimental:!0,description:"Frame swap timestamp."}],experimental:!0},{id:"DialogType",description:"Javascript dialog type.",type:"string",enum:["alert","confirm","prompt","beforeunload"],experimental:!0},{id:"AppManifestError",description:"Error while paring app manifest.",type:"object",properties:[{name:"message",type:"string",description:"Error message."},{name:"critical",type:"integer",description:"If criticial, this is a non-recoverable parse error."},{name:"line",type:"integer",description:"Error line."},{name:"column",type:"integer",description:"Error column."}],experimental:!0},{id:"NavigationResponse",description:"Proceed: allow the navigation; Cancel: cancel the navigation; CancelAndIgnore: cancels the navigation and makes the requester of the navigation acts like the request was never made.",type:"string",enum:["Proceed","Cancel","CancelAndIgnore"],experimental:!0},{id:"LayoutViewport",type:"object",description:"Layout viewport position and dimensions.",experimental:!0,properties:[{name:"pageX",type:"integer",description:"Horizontal offset relative to the document (CSS pixels)."},{name:"pageY",type:"integer",description:"Vertical offset relative to the document (CSS pixels)."},{name:"clientWidth",type:"integer",description:"Width (CSS pixels), excludes scrollbar if present."},{name:"clientHeight",type:"integer",description:"Height (CSS pixels), excludes scrollbar if present."}]},{id:"VisualViewport",type:"object",description:"Visual viewport position, dimensions, and scale.",experimental:!0,properties:[{name:"offsetX",type:"number",description:"Horizontal offset relative to the layout viewport (CSS pixels)."},{name:"offsetY",type:"number",description:"Vertical offset relative to the layout viewport (CSS pixels)."},{name:"pageX",type:"number",description:"Horizontal offset relative to the document (CSS pixels)."},{name:"pageY",type:"number",description:"Vertical offset relative to the document (CSS pixels)."},{name:"clientWidth",type:"number",description:"Width (CSS pixels), excludes scrollbar if present."},{name:"clientHeight",type:"number",description:"Height (CSS pixels), excludes scrollbar if present."},{name:"scale",type:"number",description:"Scale relative to the ideal viewport (size at width=device-width)."}]}],commands:[{name:"enable",description:"Enables page domain notifications."},{name:"disable",description:"Disables page domain notifications."},{name:"addScriptToEvaluateOnLoad",parameters:[{name:"scriptSource",type:"string"}],returns:[{name:"identifier",$ref:"ScriptIdentifier",description:"Identifier of the added script."}],experimental:!0},{name:"removeScriptToEvaluateOnLoad",parameters:[{name:"identifier",$ref:"ScriptIdentifier"}],experimental:!0},{name:"setAutoAttachToCreatedPages",parameters:[{name:"autoAttach",type:"boolean",description:"If true, browser will open a new inspector window for every page created from this one."}],description:"Controls whether browser will open a new inspector window for connected pages.",experimental:!0},{name:"reload",parameters:[{name:"ignoreCache",type:"boolean",optional:!0,description:"If true, browser cache is ignored (as if the user pressed Shift+refresh)."},{name:"scriptToEvaluateOnLoad",type:"string",optional:!0,description:"If set, the script will be injected into all frames of the inspected page after reload."}],description:"Reloads given page optionally ignoring the cache."},{name:"navigate",parameters:[{name:"url",type:"string",description:"URL to navigate the page to."}],returns:[{name:"frameId",$ref:"FrameId",experimental:!0,description:"Frame id that will be navigated."}],description:"Navigates current page to the given URL."},{name:"stopLoading",description:"Force the page stop all navigations and pending resource fetches.",experimental:!0},{name:"getNavigationHistory",returns:[{name:"currentIndex",type:"integer",description:"Index of the current navigation history entry."},{name:"entries",type:"array",items:{$ref:"NavigationEntry"},description:"Array of navigation history entries."}],description:"Returns navigation history for the current page.",experimental:!0},{name:"navigateToHistoryEntry",parameters:[{name:"entryId",type:"integer",description:"Unique id of the entry to navigate to."}],description:"Navigates current page to the given history entry.",experimental:!0},{name:"getCookies",returns:[{name:"cookies",type:"array",items:{$ref:"Network.Cookie"},description:"Array of cookie objects."}],description:"Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.",experimental:!0,redirect:"Network"},{name:"deleteCookie",parameters:[{name:"cookieName",type:"string",description:"Name of the cookie to remove."},{name:"url",type:"string",description:"URL to match cooke domain and path."}],description:"Deletes browser cookie with given name, domain and path.",experimental:!0,redirect:"Network"},{name:"getResourceTree",description:"Returns present frame / resource tree structure.",returns:[{name:"frameTree",$ref:"FrameResourceTree",description:"Present frame / resource tree structure."}],experimental:!0},{name:"getResourceContent",description:"Returns content of the given resource.",parameters:[{name:"frameId",$ref:"FrameId",description:"Frame id to get resource for."},{name:"url",type:"string",description:"URL of the resource to get content for."}],returns:[{name:"content",type:"string",description:"Resource content."},{name:"base64Encoded",type:"boolean",description:"True, if content was served as base64."}],experimental:!0},{name:"searchInResource",description:"Searches for given string in resource content.",parameters:[{name:"frameId",$ref:"FrameId",description:"Frame id for resource to search in."},{name:"url",type:"string",description:"URL of the resource to search in."},{name:"query",type:"string",description:"String to search for."},{name:"caseSensitive",type:"boolean",optional:!0,description:"If true, search is case sensitive."},{name:"isRegex",type:"boolean",optional:!0,description:"If true, treats string parameter as regex."}],returns:[{name:"result",type:"array",items:{$ref:"Debugger.SearchMatch"},description:"List of search matches."}],experimental:!0},{name:"setDocumentContent",description:"Sets given markup as the document's HTML.",parameters:[{name:"frameId",$ref:"FrameId",description:"Frame id to set HTML for."},{name:"html",type:"string",description:"HTML content to set."}],experimental:!0},{name:"setDeviceMetricsOverride",description:'Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media query results).',parameters:[{name:"width",type:"integer",description:"Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override."},{name:"height",type:"integer",description:"Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override."},{name:"deviceScaleFactor",type:"number",description:"Overriding device scale factor value. 0 disables the override."},{name:"mobile",type:"boolean",description:"Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more."},{name:"fitWindow",type:"boolean",description:"Whether a view that exceeds the available browser window area should be scaled down to fit."},{name:"scale",type:"number",optional:!0,description:"Scale to apply to resulting view image. Ignored in |fitWindow| mode."},{name:"offsetX",type:"number",optional:!0,description:"X offset to shift resulting view image by. Ignored in |fitWindow| mode."},{name:"offsetY",type:"number",optional:!0,description:"Y offset to shift resulting view image by. Ignored in |fitWindow| mode."},{name:"screenWidth",type:"integer",optional:!0,description:"Overriding screen width value in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"screenHeight",type:"integer",optional:!0,description:"Overriding screen height value in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"positionX",type:"integer",optional:!0,description:"Overriding view X position on screen in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"positionY",type:"integer",optional:!0,description:"Overriding view Y position on screen in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"screenOrientation",$ref:"Emulation.ScreenOrientation",optional:!0,description:"Screen orientation override."}],redirect:"Emulation",experimental:!0},{name:"clearDeviceMetricsOverride",description:"Clears the overriden device metrics.",redirect:"Emulation",experimental:!0},{name:"setGeolocationOverride",description:"Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.",parameters:[{name:"latitude",type:"number",optional:!0,description:"Mock latitude"},{name:"longitude",type:"number",optional:!0,description:"Mock longitude"},{name:"accuracy",type:"number",optional:!0,description:"Mock accuracy"}],redirect:"Emulation"},{name:"clearGeolocationOverride",description:"Clears the overriden Geolocation Position and Error.",redirect:"Emulation"},{name:"setDeviceOrientationOverride",description:"Overrides the Device Orientation.",parameters:[{name:"alpha",type:"number",description:"Mock alpha"},{name:"beta",type:"number",description:"Mock beta"},{name:"gamma",type:"number",description:"Mock gamma"}],redirect:"DeviceOrientation",experimental:!0},{name:"clearDeviceOrientationOverride",description:"Clears the overridden Device Orientation.",redirect:"DeviceOrientation",experimental:!0},{name:"setTouchEmulationEnabled",parameters:[{name:"enabled",type:"boolean",description:"Whether the touch event emulation should be enabled."},{name:"configuration",type:"string",enum:["mobile","desktop"],optional:!0,description:"Touch/gesture events configuration. Default: current platform."}],description:"Toggles mouse event-based touch event emulation.",experimental:!0,redirect:"Emulation"},{name:"captureScreenshot",description:"Capture page screenshot.",returns:[{name:"data",type:"string",description:"Base64-encoded image data (PNG)."}],experimental:!0},{name:"startScreencast",description:"Starts sending each frame using the <code>screencastFrame</code> event.",parameters:[{name:"format",type:"string",optional:!0,enum:["jpeg","png"],description:"Image compression format."},{name:"quality",type:"integer",optional:!0,description:"Compression quality from range [0..100]."},{name:"maxWidth",type:"integer",optional:!0,description:"Maximum screenshot width."},{name:"maxHeight",type:"integer",optional:!0,description:"Maximum screenshot height."},{name:"everyNthFrame",type:"integer",optional:!0,description:"Send every n-th frame."}],experimental:!0},{name:"stopScreencast",description:"Stops sending each frame in the <code>screencastFrame</code>.",experimental:!0},{name:"screencastFrameAck",description:"Acknowledges that a screencast frame has been received by the frontend.",parameters:[{name:"sessionId",type:"integer",description:"Frame number."}],experimental:!0},{name:"handleJavaScriptDialog",description:"Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).",parameters:[{name:"accept",type:"boolean",description:"Whether to accept or dismiss the dialog."},{name:"promptText",type:"string",optional:!0,description:"The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog."}]},{name:"setColorPickerEnabled",parameters:[{name:"enabled",type:"boolean",description:"Shows / hides color picker"}],description:"Shows / hides color picker",experimental:!0},{name:"configureOverlay",parameters:[{name:"suspended",type:"boolean",optional:!0,description:"Whether overlay should be suspended and not consume any resources."},{name:"message",type:"string",optional:!0,description:"Overlay message to display."}],experimental:!0,description:"Configures overlay."},{name:"getAppManifest",experimental:!0,returns:[{name:"url",type:"string",description:"Manifest location."},{name:"errors",type:"array",items:{$ref:"AppManifestError"}},{name:"data",type:"string",optional:!0,description:"Manifest content."}]},{name:"requestAppBanner",experimental:!0},{name:"setControlNavigations",parameters:[{name:"enabled",type:"boolean"}],description:"Toggles navigation throttling which allows programatic control over navigation and redirect response.",experimental:!0},{name:"processNavigation",parameters:[{name:"response",$ref:"NavigationResponse"},{name:"navigationId",type:"integer"}],description:"Should be sent in response to a navigationRequested or a redirectRequested event, telling the browser how to handle the navigation.",experimental:!0},{name:"getLayoutMetrics",description:"Returns metrics relating to the layouting of the page, such as viewport bounds/scale.",experimental:!0,returns:[{name:"layoutViewport",$ref:"LayoutViewport",description:"Metrics relating to the layout viewport."},{name:"visualViewport",
	$ref:"VisualViewport",description:"Metrics relating to the visual viewport."}]}],events:[{name:"domContentEventFired",parameters:[{name:"timestamp",type:"number"}]},{name:"loadEventFired",parameters:[{name:"timestamp",type:"number"}]},{name:"frameAttached",description:"Fired when frame has been attached to its parent.",parameters:[{name:"frameId",$ref:"FrameId",description:"Id of the frame that has been attached."},{name:"parentFrameId",$ref:"FrameId",description:"Parent frame identifier."}]},{name:"frameNavigated",description:"Fired once navigation of the frame has completed. Frame is now associated with the new loader.",parameters:[{name:"frame",$ref:"Frame",description:"Frame object."}]},{name:"frameDetached",description:"Fired when frame has been detached from its parent.",parameters:[{name:"frameId",$ref:"FrameId",description:"Id of the frame that has been detached."}]},{name:"frameStartedLoading",description:"Fired when frame has started loading.",parameters:[{name:"frameId",$ref:"FrameId",description:"Id of the frame that has started loading."}],experimental:!0},{name:"frameStoppedLoading",description:"Fired when frame has stopped loading.",parameters:[{name:"frameId",$ref:"FrameId",description:"Id of the frame that has stopped loading."}],experimental:!0},{name:"frameScheduledNavigation",description:"Fired when frame schedules a potential navigation.",parameters:[{name:"frameId",$ref:"FrameId",description:"Id of the frame that has scheduled a navigation."},{name:"delay",type:"number",description:"Delay (in seconds) until the navigation is scheduled to begin. The navigation is not guaranteed to start."}],experimental:!0},{name:"frameClearedScheduledNavigation",description:"Fired when frame no longer has a scheduled navigation.",parameters:[{name:"frameId",$ref:"FrameId",description:"Id of the frame that has cleared its scheduled navigation."}],experimental:!0},{name:"frameResized",experimental:!0},{name:"javascriptDialogOpening",description:"Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to open.",parameters:[{name:"message",type:"string",description:"Message that will be displayed by the dialog."},{name:"type",$ref:"DialogType",description:"Dialog type."}]},{name:"javascriptDialogClosed",description:"Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been closed.",parameters:[{name:"result",type:"boolean",description:"Whether dialog was confirmed."}]},{name:"screencastFrame",description:"Compressed image data requested by the <code>startScreencast</code>.",parameters:[{name:"data",type:"string",description:"Base64-encoded compressed image."},{name:"metadata",$ref:"ScreencastFrameMetadata",description:"Screencast frame metadata."},{name:"sessionId",type:"integer",description:"Frame number."}],experimental:!0},{name:"screencastVisibilityChanged",description:"Fired when the page with currently enabled screencast was shown or hidden </code>.",parameters:[{name:"visible",type:"boolean",description:"True if the page is visible."}],experimental:!0},{name:"colorPicked",description:"Fired when a color has been picked.",parameters:[{name:"color",$ref:"DOM.RGBA",description:"RGBA of the picked color."}],experimental:!0},{name:"interstitialShown",description:"Fired when interstitial page was shown"},{name:"interstitialHidden",description:"Fired when interstitial page was hidden"},{name:"navigationRequested",description:"Fired when a navigation is started if navigation throttles are enabled.  The navigation will be deferred until processNavigation is called.",parameters:[{name:"isInMainFrame",type:"boolean",description:"Whether the navigation is taking place in the main frame or in a subframe."},{name:"isRedirect",type:"boolean",description:"Whether the navigation has encountered a server redirect or not."},{name:"navigationId",type:"integer"},{name:"url",type:"string",description:"URL of requested navigation."}]}]},{domain:"Rendering",description:"This domain allows to control rendering of the page.",experimental:!0,commands:[{name:"setShowPaintRects",description:"Requests that backend shows paint rectangles",parameters:[{name:"result",type:"boolean",description:"True for showing paint rectangles"}]},{name:"setShowDebugBorders",description:"Requests that backend shows debug borders on layers",parameters:[{name:"show",type:"boolean",description:"True for showing debug borders"}]},{name:"setShowFPSCounter",description:"Requests that backend shows the FPS counter",parameters:[{name:"show",type:"boolean",description:"True for showing the FPS counter"}]},{name:"setShowScrollBottleneckRects",description:"Requests that backend shows scroll bottleneck rects",parameters:[{name:"show",type:"boolean",description:"True for showing scroll bottleneck rects"}]},{name:"setShowViewportSizeOnResize",description:"Paints viewport size upon main frame resize.",parameters:[{name:"show",type:"boolean",description:"Whether to paint size or not."}]}]},{domain:"Emulation",description:"This domain emulates different environments for the page.",types:[{id:"ScreenOrientation",type:"object",description:"Screen orientation.",properties:[{name:"type",type:"string",enum:["portraitPrimary","portraitSecondary","landscapePrimary","landscapeSecondary"],description:"Orientation type."},{name:"angle",type:"integer",description:"Orientation angle."}]},{id:"VirtualTimePolicy",type:"string",enum:["advance","pause","pauseIfNetworkFetchesPending"],experimental:!0,description:"advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to allow the next delayed task (if any) to run; pause: The virtual time base may not advance; pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending resource fetches."}],commands:[{name:"setDeviceMetricsOverride",description:'Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media query results).',parameters:[{name:"width",type:"integer",description:"Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override."},{name:"height",type:"integer",description:"Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override."},{name:"deviceScaleFactor",type:"number",description:"Overriding device scale factor value. 0 disables the override."},{name:"mobile",type:"boolean",description:"Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more."},{name:"fitWindow",type:"boolean",description:"Whether a view that exceeds the available browser window area should be scaled down to fit."},{name:"scale",type:"number",optional:!0,experimental:!0,description:"Scale to apply to resulting view image. Ignored in |fitWindow| mode."},{name:"offsetX",type:"number",optional:!0,deprecated:!0,experimental:!0,description:"Not used."},{name:"offsetY",type:"number",optional:!0,deprecated:!0,experimental:!0,description:"Not used."},{name:"screenWidth",type:"integer",optional:!0,experimental:!0,description:"Overriding screen width value in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"screenHeight",type:"integer",optional:!0,experimental:!0,description:"Overriding screen height value in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"positionX",type:"integer",optional:!0,experimental:!0,description:"Overriding view X position on screen in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"positionY",type:"integer",optional:!0,experimental:!0,description:"Overriding view Y position on screen in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"screenOrientation",$ref:"ScreenOrientation",optional:!0,description:"Screen orientation override."}]},{name:"clearDeviceMetricsOverride",description:"Clears the overriden device metrics."},{name:"forceViewport",description:"Overrides the visible area of the page. The change is hidden from the page, i.e. the observable scroll position and page scale does not change. In effect, the command moves the specified area of the page into the top-left corner of the frame.",experimental:!0,parameters:[{name:"x",type:"number",description:"X coordinate of top-left corner of the area (CSS pixels)."},{name:"y",type:"number",description:"Y coordinate of top-left corner of the area (CSS pixels)."},{name:"scale",type:"number",description:"Scale to apply to the area (relative to a page scale of 1.0)."}]},{name:"resetViewport",description:"Resets the visible area of the page to the original viewport, undoing any effects of the <code>forceViewport</code> command.",experimental:!0},{name:"resetPageScaleFactor",experimental:!0,description:"Requests that page scale factor is reset to initial values."},{name:"setPageScaleFactor",description:"Sets a specified page scale factor.",experimental:!0,parameters:[{name:"pageScaleFactor",type:"number",description:"Page scale factor."}]},{name:"setVisibleSize",description:"Resizes the frame/viewport of the page. Note that this does not affect the frame's container (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported on Android.",experimental:!0,parameters:[{name:"width",type:"integer",description:"Frame width (DIP)."},{name:"height",type:"integer",description:"Frame height (DIP)."}]},{name:"setScriptExecutionDisabled",description:"Switches script execution in the page.",experimental:!0,parameters:[{name:"value",type:"boolean",description:"Whether script execution should be disabled in the page."}]},{name:"setGeolocationOverride",description:"Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.",experimental:!0,parameters:[{name:"latitude",type:"number",optional:!0,description:"Mock latitude"},{name:"longitude",type:"number",optional:!0,description:"Mock longitude"},{name:"accuracy",type:"number",optional:!0,description:"Mock accuracy"}]},{name:"clearGeolocationOverride",description:"Clears the overriden Geolocation Position and Error.",experimental:!0},{name:"setTouchEmulationEnabled",parameters:[{name:"enabled",type:"boolean",description:"Whether the touch event emulation should be enabled."},{name:"configuration",type:"string",enum:["mobile","desktop"],optional:!0,description:"Touch/gesture events configuration. Default: current platform."}],description:"Toggles mouse event-based touch event emulation."},{name:"setEmulatedMedia",parameters:[{name:"media",type:"string",description:"Media type to emulate. Empty string disables the override."}],description:"Emulates the given media for CSS media queries."},{name:"setCPUThrottlingRate",parameters:[{name:"rate",type:"number",description:"Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc)."}],experimental:!0,description:"Enables CPU throttling to emulate slow CPUs."},{name:"canEmulate",description:"Tells whether emulation is supported.",returns:[{name:"result",type:"boolean",description:"True if emulation is supported."}],experimental:!0},{name:"setVirtualTimePolicy",description:"Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets the current virtual time policy.  Note this supersedes any previous time budget.",parameters:[{name:"policy",$ref:"VirtualTimePolicy"},{name:"budget",type:"integer",optional:!0,description:"If set, after this many virtual milliseconds have elapsed virtual time will be paused and a virtualTimeBudgetExpired event is sent."}],experimental:!0}],events:[{name:"virtualTimeBudgetExpired",experimental:!0,description:"Notification sent after the virual time budget for the current VirtualTimePolicy has run out."}]},{domain:"Security",description:"Security",experimental:!0,types:[{id:"CertificateId",type:"integer",description:"An internal certificate ID value."},{id:"SecurityState",type:"string",enum:["unknown","neutral","insecure","warning","secure","info"],description:"The security level of a page or resource."},{id:"SecurityStateExplanation",type:"object",properties:[{name:"securityState",$ref:"SecurityState",description:"Security state representing the severity of the factor being explained."},{name:"summary",type:"string",description:"Short phrase describing the type of factor."},{name:"description",type:"string",description:"Full text explanation of the factor."},{name:"hasCertificate",type:"boolean",description:"True if the page has a certificate."}],description:"An explanation of an factor contributing to the security state."},{id:"InsecureContentStatus",type:"object",properties:[{name:"ranMixedContent",type:"boolean",description:"True if the page was loaded over HTTPS and ran mixed (HTTP) content such as scripts."},{name:"displayedMixedContent",type:"boolean",description:"True if the page was loaded over HTTPS and displayed mixed (HTTP) content such as images."},{name:"ranContentWithCertErrors",type:"boolean",description:"True if the page was loaded over HTTPS without certificate errors, and ran content such as scripts that were loaded with certificate errors."},{name:"displayedContentWithCertErrors",type:"boolean",description:"True if the page was loaded over HTTPS without certificate errors, and displayed content such as images that were loaded with certificate errors."},{name:"ranInsecureContentStyle",$ref:"SecurityState",description:"Security state representing a page that ran insecure content."},{name:"displayedInsecureContentStyle",$ref:"SecurityState",description:"Security state representing a page that displayed insecure content."}],description:"Information about insecure content on the page."}],commands:[{name:"enable",description:"Enables tracking security state changes."},{name:"disable",description:"Disables tracking security state changes."},{name:"showCertificateViewer",description:"Displays native dialog with the certificate details."}],events:[{name:"securityStateChanged",description:"The security state of the page changed.",parameters:[{name:"securityState",$ref:"SecurityState",description:"Security state."},{name:"explanations",type:"array",items:{$ref:"SecurityStateExplanation"},description:"List of explanations for the security state. If the overall security state is `insecure` or `warning`, at least one corresponding explanation should be included.",optional:!0},{name:"insecureContentStatus",$ref:"InsecureContentStatus",description:"Information about insecure content on the page.",optional:!0},{name:"schemeIsCryptographic",type:"boolean",description:"True if the page was loaded over cryptographic transport such as HTTPS.",optional:!0}]}]},{domain:"Network",description:"Network domain allows tracking network activities of the page. It exposes information about http, file, data and other requests and responses, their headers, bodies, timing, etc.",dependencies:["Runtime","Security"],types:[{id:"LoaderId",type:"string",description:"Unique loader identifier."},{id:"RequestId",type:"string",description:"Unique request identifier."},{id:"Timestamp",type:"number",description:"Number of seconds since epoch."},{id:"Headers",type:"object",description:"Request / response headers as keys / values of JSON object."},{id:"ConnectionType",type:"string",enum:["none","cellular2g","cellular3g","cellular4g","bluetooth","ethernet","wifi","wimax","other"],description:"Loading priority of a resource request."},{id:"CookieSameSite",type:"string",enum:["Strict","Lax"],description:"Represents the cookie's 'SameSite' status: https://tools.ietf.org/html/draft-west-first-party-cookies"},{id:"ResourceTiming",type:"object",description:"Timing information for the request.",properties:[{name:"requestTime",type:"number",description:"Timing's requestTime is a baseline in seconds, while the other numbers are ticks in milliseconds relatively to this requestTime."},{name:"proxyStart",type:"number",description:"Started resolving proxy."},{name:"proxyEnd",type:"number",description:"Finished resolving proxy."},{name:"dnsStart",type:"number",description:"Started DNS address resolve."},{name:"dnsEnd",type:"number",description:"Finished DNS address resolve."},{name:"connectStart",type:"number",description:"Started connecting to the remote host."},{name:"connectEnd",type:"number",description:"Connected to the remote host."},{name:"sslStart",type:"number",description:"Started SSL handshake."},{name:"sslEnd",type:"number",description:"Finished SSL handshake."},{name:"workerStart",type:"number",description:"Started running ServiceWorker.",experimental:!0},{name:"workerReady",type:"number",description:"Finished Starting ServiceWorker.",experimental:!0},{name:"sendStart",type:"number",description:"Started sending request."},{name:"sendEnd",type:"number",description:"Finished sending request."},{name:"pushStart",type:"number",description:"Time the server started pushing request.",experimental:!0},{name:"pushEnd",type:"number",description:"Time the server finished pushing request.",experimental:!0},{name:"receiveHeadersEnd",type:"number",description:"Finished receiving response headers."}]},{id:"ResourcePriority",type:"string",enum:["VeryLow","Low","Medium","High","VeryHigh"],description:"Loading priority of a resource request."},{id:"Request",type:"object",description:"HTTP request data.",properties:[{name:"url",type:"string",description:"Request URL."},{name:"method",type:"string",description:"HTTP request method."},{name:"headers",$ref:"Headers",description:"HTTP request headers."},{name:"postData",type:"string",optional:!0,description:"HTTP POST request data."},{name:"mixedContentType",optional:!0,type:"string",enum:["blockable","optionally-blockable","none"],description:"The mixed content status of the request, as defined in http://www.w3.org/TR/mixed-content/"},{name:"initialPriority",$ref:"ResourcePriority",description:"Priority of the resource request at the time request is sent."}]},{id:"SignedCertificateTimestamp",type:"object",description:"Details of a signed certificate timestamp (SCT).",properties:[{name:"status",type:"string",description:"Validation status."},{name:"origin",type:"string",description:"Origin."},{name:"logDescription",type:"string",description:"Log name / description."},{name:"logId",type:"string",description:"Log ID."},{name:"timestamp",$ref:"Timestamp",description:"Issuance date."},{name:"hashAlgorithm",type:"string",description:"Hash algorithm."},{name:"signatureAlgorithm",type:"string",description:"Signature algorithm."},{name:"signatureData",type:"string",description:"Signature data."}]},{id:"SecurityDetails",type:"object",description:"Security details about a request.",properties:[{name:"protocol",type:"string",description:'Protocol name (e.g. "TLS 1.2" or "QUIC").'},{name:"keyExchange",type:"string",description:"Key Exchange used by the connection, or the empty string if not applicable."},{name:"keyExchangeGroup",type:"string",optional:!0,description:"(EC)DH group used by the connection, if applicable."},{name:"cipher",type:"string",description:"Cipher name."},{name:"mac",type:"string",optional:!0,description:"TLS MAC. Note that AEAD ciphers do not have separate MACs."},{name:"certificateId",$ref:"Security.CertificateId",description:"Certificate ID value."},{name:"subjectName",type:"string",description:"Certificate subject name."},{name:"sanList",type:"array",items:{type:"string"},description:"Subject Alternative Name (SAN) DNS names and IP addresses."},{name:"issuer",type:"string",description:"Name of the issuing CA."},{name:"validFrom",$ref:"Timestamp",description:"Certificate valid from date."},{name:"validTo",$ref:"Timestamp",description:"Certificate valid to (expiration) date"},{name:"signedCertificateTimestampList",type:"array",items:{$ref:"SignedCertificateTimestamp"},description:"List of signed certificate timestamps (SCTs)."}]},{id:"BlockedReason",type:"string",description:"The reason why request was blocked.",enum:["csp","mixed-content","origin","inspector","subresource-filter","other"],experimental:!0},{id:"Response",type:"object",description:"HTTP response data.",properties:[{name:"url",type:"string",description:"Response URL. This URL can be different from CachedResource.url in case of redirect."},{name:"status",type:"number",description:"HTTP response status code."},{name:"statusText",type:"string",description:"HTTP response status text."},{name:"headers",$ref:"Headers",description:"HTTP response headers."},{name:"headersText",type:"string",optional:!0,description:"HTTP response headers text."},{name:"mimeType",type:"string",description:"Resource mimeType as determined by the browser."},{name:"requestHeaders",$ref:"Headers",optional:!0,description:"Refined HTTP request headers that were actually transmitted over the network."},{name:"requestHeadersText",type:"string",optional:!0,description:"HTTP request headers text."},{name:"connectionReused",type:"boolean",description:"Specifies whether physical connection was actually reused for this request."},{name:"connectionId",type:"number",description:"Physical connection id that was actually used for this request."},{name:"remoteIPAddress",type:"string",optional:!0,experimental:!0,description:"Remote IP address."},{name:"remotePort",type:"integer",optional:!0,experimental:!0,description:"Remote port."},{name:"fromDiskCache",type:"boolean",optional:!0,description:"Specifies that the request was served from the disk cache."},{name:"fromServiceWorker",type:"boolean",optional:!0,description:"Specifies that the request was served from the ServiceWorker."},{name:"encodedDataLength",type:"number",optional:!1,description:"Total number of bytes received for this request so far."},{name:"timing",$ref:"ResourceTiming",optional:!0,description:"Timing information for the given request."},{name:"protocol",type:"string",optional:!0,description:"Protocol used to fetch this request."},{name:"securityState",$ref:"Security.SecurityState",description:"Security state of the request resource."},{name:"securityDetails",$ref:"SecurityDetails",optional:!0,description:"Security details for the request."}]},{id:"WebSocketRequest",type:"object",description:"WebSocket request data.",experimental:!0,properties:[{name:"headers",$ref:"Headers",description:"HTTP request headers."}]},{id:"WebSocketResponse",type:"object",description:"WebSocket response data.",experimental:!0,properties:[{name:"status",type:"number",description:"HTTP response status code."},{name:"statusText",type:"string",description:"HTTP response status text."},{name:"headers",$ref:"Headers",description:"HTTP response headers."},{name:"headersText",type:"string",optional:!0,description:"HTTP response headers text."},{name:"requestHeaders",$ref:"Headers",optional:!0,description:"HTTP request headers."},{name:"requestHeadersText",type:"string",optional:!0,description:"HTTP request headers text."}]},{id:"WebSocketFrame",type:"object",description:"WebSocket frame data.",experimental:!0,properties:[{name:"opcode",type:"number",description:"WebSocket frame opcode."},{name:"mask",type:"boolean",description:"WebSocke frame mask."},{name:"payloadData",type:"string",description:"WebSocke frame payload data."}]},{id:"CachedResource",type:"object",description:"Information about the cached resource.",properties:[{name:"url",type:"string",description:"Resource URL. This is the url of the original network request."},{name:"type",$ref:"Page.ResourceType",description:"Type of this resource."},{name:"response",$ref:"Response",optional:!0,description:"Cached response data."},{name:"bodySize",type:"number",description:"Cached response body size."}]},{id:"Initiator",type:"object",description:"Information about the request initiator.",properties:[{name:"type",type:"string",enum:["parser","script","other"],description:"Type of this initiator."},{name:"stack",$ref:"Runtime.StackTrace",optional:!0,description:"Initiator JavaScript stack trace, set for Script only."},{name:"url",type:"string",optional:!0,description:"Initiator URL, set for Parser type only."},{name:"lineNumber",type:"number",optional:!0,description:"Initiator line number, set for Parser type only (0-based)."}]},{id:"Cookie",type:"object",description:"Cookie object",properties:[{name:"name",type:"string",description:"Cookie name."},{name:"value",type:"string",description:"Cookie value."},{name:"domain",type:"string",description:"Cookie domain."},{name:"path",type:"string",description:"Cookie path."},{name:"expires",type:"number",description:"Cookie expiration date as the number of seconds since the UNIX epoch."},{name:"size",type:"integer",description:"Cookie size."},{name:"httpOnly",type:"boolean",description:"True if cookie is http-only."},{name:"secure",type:"boolean",description:"True if cookie is secure."},{name:"session",type:"boolean",description:"True in case of session cookie."},{name:"sameSite",$ref:"CookieSameSite",optional:!0,description:"Cookie SameSite type."}],experimental:!0}],commands:[{name:"enable",description:"Enables network tracking, network events will now be delivered to the client.",parameters:[{name:"maxTotalBufferSize",type:"integer",optional:!0,experimental:!0,description:"Buffer size in bytes to use when preserving network payloads (XHRs, etc)."},{name:"maxResourceBufferSize",type:"integer",optional:!0,experimental:!0,description:"Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc)."}]},{name:"disable",description:"Disables network tracking, prevents network events from being sent to the client."},{name:"setUserAgentOverride",description:"Allows overriding user agent with the given string.",parameters:[{name:"userAgent",type:"string",description:"User agent to use."}]},{name:"setExtraHTTPHeaders",description:"Specifies whether to always send extra HTTP headers with the requests from this page.",parameters:[{name:"headers",$ref:"Headers",description:"Map with extra HTTP headers."}]},{name:"getResponseBody",description:"Returns content served for the given request.",parameters:[{name:"requestId",$ref:"RequestId",description:"Identifier of the network request to get content for."}],returns:[{name:"body",type:"string",description:"Response body."},{name:"base64Encoded",type:"boolean",description:"True, if content was sent as base64."}]},{name:"addBlockedURL",description:"Blocks specific URL from loading.",parameters:[{name:"url",type:"string",description:"URL to block."}],experimental:!0},{name:"removeBlockedURL",description:"Cancels blocking of a specific URL from loading.",parameters:[{name:"url",type:"string",description:"URL to stop blocking."}],experimental:!0},{name:"replayXHR",description:"This method sends a new XMLHttpRequest which is identical to the original one. The following parameters should be identical: method, url, async, request body, extra headers, withCredentials attribute, user, password.",parameters:[{name:"requestId",$ref:"RequestId",description:"Identifier of XHR to replay."}],experimental:!0},{name:"setMonitoringXHREnabled",parameters:[{name:"enabled",type:"boolean",description:"Monitoring enabled state."}],description:"Toggles monitoring of XMLHttpRequest. If <code>true</code>, console will receive messages upon each XHR issued.",experimental:!0},{name:"canClearBrowserCache",description:"Tells whether clearing browser cache is supported.",returns:[{name:"result",type:"boolean",description:"True if browser cache can be cleared."}]},{name:"clearBrowserCache",description:"Clears browser cache."},{name:"canClearBrowserCookies",description:"Tells whether clearing browser cookies is supported.",returns:[{name:"result",type:"boolean",description:"True if browser cookies can be cleared."}]},{name:"clearBrowserCookies",description:"Clears browser cookies."},{name:"getCookies",returns:[{name:"cookies",type:"array",items:{$ref:"Cookie"},description:"Array of cookie objects."}],description:"Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.",experimental:!0},{name:"deleteCookie",parameters:[{name:"cookieName",type:"string",description:"Name of the cookie to remove."},{name:"url",type:"string",description:"URL to match cooke domain and path."}],description:"Deletes browser cookie with given name, domain and path.",experimental:!0},{name:"setCookie",parameters:[{name:"url",type:"string",description:"The request-URI to associate with the setting of the cookie. This value can affect the default domain and path values of the created cookie."},{name:"name",type:"string",description:"The name of the cookie."},{name:"value",type:"string",description:"The value of the cookie."},{name:"domain",type:"string",optional:!0,description:"If omitted, the cookie becomes a host-only cookie."},{name:"path",type:"string",optional:!0,description:"Defaults to the path portion of the url parameter."},{name:"secure",type:"boolean",optional:!0,description:"Defaults ot false."},{name:"httpOnly",type:"boolean",optional:!0,description:"Defaults to false."},{name:"sameSite",$ref:"CookieSameSite",optional:!0,description:"Defaults to browser default behavior."},{name:"expirationDate",$ref:"Timestamp",optional:!0,description:"If omitted, the cookie becomes a session cookie."}],returns:[{name:"success",type:"boolean",description:"True if successfully set cookie."}],description:"Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.",experimental:!0},{name:"canEmulateNetworkConditions",description:"Tells whether emulation of network conditions is supported.",returns:[{name:"result",type:"boolean",description:"True if emulation of network conditions is supported."}],experimental:!0},{name:"emulateNetworkConditions",description:"Activates emulation of network conditions.",parameters:[{name:"offline",type:"boolean",description:"True to emulate internet disconnection."},{name:"latency",type:"number",description:"Additional latency (ms)."},{name:"downloadThroughput",type:"number",description:"Maximal aggregated download throughput."},{name:"uploadThroughput",type:"number",description:"Maximal aggregated upload throughput."},{name:"connectionType",$ref:"ConnectionType",optional:!0,description:"Connection type if known."}]},{name:"setCacheDisabled",parameters:[{name:"cacheDisabled",type:"boolean",description:"Cache disabled state."}],description:"Toggles ignoring cache for each request. If <code>true</code>, cache will not be used."},{name:"setBypassServiceWorker",parameters:[{name:"bypass",type:"boolean",description:"Bypass service worker and load from network."}],experimental:!0,description:"Toggles ignoring of service worker for each request."},{name:"setDataSizeLimitsForTest",parameters:[{name:"maxTotalSize",type:"integer",description:"Maximum total buffer size."},{name:"maxResourceSize",type:"integer",description:"Maximum per-resource size."}],description:"For testing.",experimental:!0},{name:"getCertificate",description:"Returns the DER-encoded certificate.",parameters:[{name:"origin",type:"string",description:"Origin to get certificate for."}],returns:[{name:"tableNames",type:"array",items:{type:"string"}}],experimental:!0}],events:[{name:"resourceChangedPriority",description:"Fired when resource loading priority is changed",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"newPriority",$ref:"ResourcePriority",description:"New priority"},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."}],experimental:!0},{name:"requestWillBeSent",description:"Fired when page is about to send HTTP request.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"frameId",$ref:"Page.FrameId",description:"Frame identifier.",experimental:!0},{name:"loaderId",$ref:"LoaderId",description:"Loader identifier."},{name:"documentURL",type:"string",description:"URL of the document this request is loaded for."
	},{name:"request",$ref:"Request",description:"Request data."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"wallTime",$ref:"Timestamp",experimental:!0,description:"UTC Timestamp."},{name:"initiator",$ref:"Initiator",description:"Request initiator."},{name:"redirectResponse",optional:!0,$ref:"Response",description:"Redirect response data."},{name:"type",$ref:"Page.ResourceType",optional:!0,experimental:!0,description:"Type of this resource."}]},{name:"requestServedFromCache",description:"Fired if request ended up loading from cache.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."}]},{name:"responseReceived",description:"Fired when HTTP response is available.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"frameId",$ref:"Page.FrameId",description:"Frame identifier.",experimental:!0},{name:"loaderId",$ref:"LoaderId",description:"Loader identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"type",$ref:"Page.ResourceType",description:"Resource type."},{name:"response",$ref:"Response",description:"Response data."}]},{name:"dataReceived",description:"Fired when data chunk was received over the network.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"dataLength",type:"integer",description:"Data chunk length."},{name:"encodedDataLength",type:"integer",description:"Actual bytes received (might be less than dataLength for compressed encodings)."}]},{name:"loadingFinished",description:"Fired when HTTP request has finished loading.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"encodedDataLength",type:"number",description:"Total number of bytes received for this request."}]},{name:"loadingFailed",description:"Fired when HTTP request has failed to load.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"type",$ref:"Page.ResourceType",description:"Resource type."},{name:"errorText",type:"string",description:"User friendly error message."},{name:"canceled",type:"boolean",optional:!0,description:"True if loading was canceled."},{name:"blockedReason",$ref:"BlockedReason",optional:!0,description:"The reason why loading was blocked, if any.",experimental:!0}]},{name:"webSocketWillSendHandshakeRequest",description:"Fired when WebSocket is about to initiate handshake.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"wallTime",$ref:"Timestamp",experimental:!0,description:"UTC Timestamp."},{name:"request",$ref:"WebSocketRequest",description:"WebSocket request data."}],experimental:!0},{name:"webSocketHandshakeResponseReceived",description:"Fired when WebSocket handshake response becomes available.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"response",$ref:"WebSocketResponse",description:"WebSocket response data."}],experimental:!0},{name:"webSocketCreated",description:"Fired upon WebSocket creation.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"url",type:"string",description:"WebSocket request URL."},{name:"initiator",$ref:"Initiator",optional:!0,description:"Request initiator."}],experimental:!0},{name:"webSocketClosed",description:"Fired when WebSocket is closed.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."}],experimental:!0},{name:"webSocketFrameReceived",description:"Fired when WebSocket frame is received.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"response",$ref:"WebSocketFrame",description:"WebSocket response data."}],experimental:!0},{name:"webSocketFrameError",description:"Fired when WebSocket frame error occurs.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"errorMessage",type:"string",description:"WebSocket frame error message."}],experimental:!0},{name:"webSocketFrameSent",description:"Fired when WebSocket frame is sent.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"response",$ref:"WebSocketFrame",description:"WebSocket response data."}],experimental:!0},{name:"eventSourceMessageReceived",description:"Fired when EventSource message is received.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"eventName",type:"string",description:"Message type."},{name:"eventId",type:"string",description:"Message identifier."},{name:"data",type:"string",description:"Message content."}],experimental:!0}]},{domain:"Database",experimental:!0,types:[{id:"DatabaseId",type:"string",description:"Unique identifier of Database object.",experimental:!0},{id:"Database",type:"object",description:"Database object.",experimental:!0,properties:[{name:"id",$ref:"DatabaseId",description:"Database ID."},{name:"domain",type:"string",description:"Database domain."},{name:"name",type:"string",description:"Database name."},{name:"version",type:"string",description:"Database version."}]},{id:"Error",type:"object",description:"Database error.",properties:[{name:"message",type:"string",description:"Error message."},{name:"code",type:"integer",description:"Error code."}]}],commands:[{name:"enable",description:"Enables database tracking, database events will now be delivered to the client."},{name:"disable",description:"Disables database tracking, prevents database events from being sent to the client."},{name:"getDatabaseTableNames",parameters:[{name:"databaseId",$ref:"DatabaseId"}],returns:[{name:"tableNames",type:"array",items:{type:"string"}}]},{name:"executeSQL",parameters:[{name:"databaseId",$ref:"DatabaseId"},{name:"query",type:"string"}],returns:[{name:"columnNames",type:"array",optional:!0,items:{type:"string"}},{name:"values",type:"array",optional:!0,items:{type:"any"}},{name:"sqlError",$ref:"Error",optional:!0}]}],events:[{name:"addDatabase",parameters:[{name:"database",$ref:"Database"}]}]},{domain:"IndexedDB",dependencies:["Runtime"],experimental:!0,types:[{id:"DatabaseWithObjectStores",type:"object",description:"Database with an array of object stores.",properties:[{name:"name",type:"string",description:"Database name."},{name:"version",type:"integer",description:"Database version."},{name:"objectStores",type:"array",items:{$ref:"ObjectStore"},description:"Object stores in this database."}]},{id:"ObjectStore",type:"object",description:"Object store.",properties:[{name:"name",type:"string",description:"Object store name."},{name:"keyPath",$ref:"KeyPath",description:"Object store key path."},{name:"autoIncrement",type:"boolean",description:"If true, object store has auto increment flag set."},{name:"indexes",type:"array",items:{$ref:"ObjectStoreIndex"},description:"Indexes in this object store."}]},{id:"ObjectStoreIndex",type:"object",description:"Object store index.",properties:[{name:"name",type:"string",description:"Index name."},{name:"keyPath",$ref:"KeyPath",description:"Index key path."},{name:"unique",type:"boolean",description:"If true, index is unique."},{name:"multiEntry",type:"boolean",description:"If true, index allows multiple entries for a key."}]},{id:"Key",type:"object",description:"Key.",properties:[{name:"type",type:"string",enum:["number","string","date","array"],description:"Key type."},{name:"number",type:"number",optional:!0,description:"Number value."},{name:"string",type:"string",optional:!0,description:"String value."},{name:"date",type:"number",optional:!0,description:"Date value."},{name:"array",type:"array",optional:!0,items:{$ref:"Key"},description:"Array value."}]},{id:"KeyRange",type:"object",description:"Key range.",properties:[{name:"lower",$ref:"Key",optional:!0,description:"Lower bound."},{name:"upper",$ref:"Key",optional:!0,description:"Upper bound."},{name:"lowerOpen",type:"boolean",description:"If true lower bound is open."},{name:"upperOpen",type:"boolean",description:"If true upper bound is open."}]},{id:"DataEntry",type:"object",description:"Data entry.",properties:[{name:"key",$ref:"Runtime.RemoteObject",description:"Key object."},{name:"primaryKey",$ref:"Runtime.RemoteObject",description:"Primary key object."},{name:"value",$ref:"Runtime.RemoteObject",description:"Value object."}]},{id:"KeyPath",type:"object",description:"Key path.",properties:[{name:"type",type:"string",enum:["null","string","array"],description:"Key path type."},{name:"string",type:"string",optional:!0,description:"String value."},{name:"array",type:"array",optional:!0,items:{type:"string"},description:"Array value."}]}],commands:[{name:"enable",description:"Enables events from backend."},{name:"disable",description:"Disables events from backend."},{name:"requestDatabaseNames",parameters:[{name:"securityOrigin",type:"string",description:"Security origin."}],returns:[{name:"databaseNames",type:"array",items:{type:"string"},description:"Database names for origin."}],description:"Requests database names for given security origin."},{name:"requestDatabase",parameters:[{name:"securityOrigin",type:"string",description:"Security origin."},{name:"databaseName",type:"string",description:"Database name."}],returns:[{name:"databaseWithObjectStores",$ref:"DatabaseWithObjectStores",description:"Database with an array of object stores."}],description:"Requests database with given name in given frame."},{name:"requestData",parameters:[{name:"securityOrigin",type:"string",description:"Security origin."},{name:"databaseName",type:"string",description:"Database name."},{name:"objectStoreName",type:"string",description:"Object store name."},{name:"indexName",type:"string",description:"Index name, empty string for object store data requests."},{name:"skipCount",type:"integer",description:"Number of records to skip."},{name:"pageSize",type:"integer",description:"Number of records to fetch."},{name:"keyRange",$ref:"KeyRange",optional:!0,description:"Key range."}],returns:[{name:"objectStoreDataEntries",type:"array",items:{$ref:"DataEntry"},description:"Array of object store data entries."},{name:"hasMore",type:"boolean",description:"If true, there are more entries to fetch in the given range."}],description:"Requests data from object store or index."},{name:"clearObjectStore",parameters:[{name:"securityOrigin",type:"string",description:"Security origin."},{name:"databaseName",type:"string",description:"Database name."},{name:"objectStoreName",type:"string",description:"Object store name."}],returns:[],description:"Clears all entries from an object store."}]},{domain:"CacheStorage",experimental:!0,types:[{id:"CacheId",type:"string",description:"Unique identifier of the Cache object."},{id:"DataEntry",type:"object",description:"Data entry.",properties:[{name:"request",type:"string",description:"Request url spec."},{name:"response",type:"string",description:"Response stataus text."}]},{id:"Cache",type:"object",description:"Cache identifier.",properties:[{name:"cacheId",$ref:"CacheId",description:"An opaque unique id of the cache."},{name:"securityOrigin",type:"string",description:"Security origin of the cache."},{name:"cacheName",type:"string",description:"The name of the cache."}]}],commands:[{name:"requestCacheNames",parameters:[{name:"securityOrigin",type:"string",description:"Security origin."}],returns:[{name:"caches",type:"array",items:{$ref:"Cache"},description:"Caches for the security origin."}],description:"Requests cache names."},{name:"requestEntries",parameters:[{name:"cacheId",$ref:"CacheId",description:"ID of cache to get entries from."},{name:"skipCount",type:"integer",description:"Number of records to skip."},{name:"pageSize",type:"integer",description:"Number of records to fetch."}],returns:[{name:"cacheDataEntries",type:"array",items:{$ref:"DataEntry"},description:"Array of object store data entries."},{name:"hasMore",type:"boolean",description:"If true, there are more entries to fetch in the given range."}],description:"Requests data from cache."},{name:"deleteCache",parameters:[{name:"cacheId",$ref:"CacheId",description:"Id of cache for deletion."}],description:"Deletes a cache."},{name:"deleteEntry",parameters:[{name:"cacheId",$ref:"CacheId",description:"Id of cache where the entry will be deleted."},{name:"request",type:"string",description:"URL spec of the request."}],description:"Deletes a cache entry."}]},{domain:"DOMStorage",experimental:!0,description:"Query and modify DOM storage.",types:[{id:"StorageId",type:"object",description:"DOM Storage identifier.",experimental:!0,properties:[{name:"securityOrigin",type:"string",description:"Security origin for the storage."},{name:"isLocalStorage",type:"boolean",description:"Whether the storage is local storage (not session storage)."}]},{id:"Item",type:"array",description:"DOM Storage item.",experimental:!0,items:{type:"string"}}],commands:[{name:"enable",description:"Enables storage tracking, storage events will now be delivered to the client."},{name:"disable",description:"Disables storage tracking, prevents storage events from being sent to the client."},{name:"getDOMStorageItems",parameters:[{name:"storageId",$ref:"StorageId"}],returns:[{name:"entries",type:"array",items:{$ref:"Item"}}]},{name:"setDOMStorageItem",parameters:[{name:"storageId",$ref:"StorageId"},{name:"key",type:"string"},{name:"value",type:"string"}]},{name:"removeDOMStorageItem",parameters:[{name:"storageId",$ref:"StorageId"},{name:"key",type:"string"}]}],events:[{name:"domStorageItemsCleared",parameters:[{name:"storageId",$ref:"StorageId"}]},{name:"domStorageItemRemoved",parameters:[{name:"storageId",$ref:"StorageId"},{name:"key",type:"string"}]},{name:"domStorageItemAdded",parameters:[{name:"storageId",$ref:"StorageId"},{name:"key",type:"string"},{name:"newValue",type:"string"}]},{name:"domStorageItemUpdated",parameters:[{name:"storageId",$ref:"StorageId"},{name:"key",type:"string"},{name:"oldValue",type:"string"},{name:"newValue",type:"string"}]}]},{domain:"ApplicationCache",experimental:!0,types:[{id:"ApplicationCacheResource",type:"object",description:"Detailed application cache resource information.",properties:[{name:"url",type:"string",description:"Resource url."},{name:"size",type:"integer",description:"Resource size."},{name:"type",type:"string",description:"Resource type."}]},{id:"ApplicationCache",type:"object",description:"Detailed application cache information.",properties:[{name:"manifestURL",type:"string",description:"Manifest URL."},{name:"size",type:"number",description:"Application cache size."},{name:"creationTime",type:"number",description:"Application cache creation time."},{name:"updateTime",type:"number",description:"Application cache update time."},{name:"resources",type:"array",items:{$ref:"ApplicationCacheResource"},description:"Application cache resources."}]},{id:"FrameWithManifest",type:"object",description:"Frame identifier - manifest URL pair.",properties:[{name:"frameId",$ref:"Page.FrameId",description:"Frame identifier."},{name:"manifestURL",type:"string",description:"Manifest URL."},{name:"status",type:"integer",description:"Application cache status."}]}],commands:[{name:"getFramesWithManifests",returns:[{name:"frameIds",type:"array",items:{$ref:"FrameWithManifest"},description:"Array of frame identifiers with manifest urls for each frame containing a document associated with some application cache."}],description:"Returns array of frame identifiers with manifest urls for each frame containing a document associated with some application cache."},{name:"enable",description:"Enables application cache domain notifications."},{name:"getManifestForFrame",parameters:[{name:"frameId",$ref:"Page.FrameId",description:"Identifier of the frame containing document whose manifest is retrieved."}],returns:[{name:"manifestURL",type:"string",description:"Manifest URL for document in the given frame."}],description:"Returns manifest URL for document in the given frame."},{name:"getApplicationCacheForFrame",parameters:[{name:"frameId",$ref:"Page.FrameId",description:"Identifier of the frame containing document whose application cache is retrieved."}],returns:[{name:"applicationCache",$ref:"ApplicationCache",description:"Relevant application cache data for the document in given frame."}],description:"Returns relevant application cache data for the document in given frame."}],events:[{name:"applicationCacheStatusUpdated",parameters:[{name:"frameId",$ref:"Page.FrameId",description:"Identifier of the frame containing document whose application cache updated status."},{name:"manifestURL",type:"string",description:"Manifest URL."},{name:"status",type:"integer",description:"Updated application cache status."}]},{name:"networkStateUpdated",parameters:[{name:"isNowOnline",type:"boolean"}]}]},{domain:"DOM",description:"This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object that has an <code>id</code>. This <code>id</code> can be used to get additional information on the Node, resolve it into the JavaScript object wrapper, etc. It is important that client receives DOM events only for the nodes that are known to the client. Backend keeps track of the nodes that were sent to the client and never sends the same node twice. It is client's responsibility to collect information about the nodes that were sent to the client.<p>Note that <code>iframe</code> owner elements will return corresponding document elements as their child nodes.</p>",dependencies:["Runtime"],types:[{id:"NodeId",type:"integer",description:"Unique DOM node identifier."},{id:"BackendNodeId",type:"integer",description:"Unique DOM node identifier used to reference a node that may not have been pushed to the front-end.",experimental:!0},{id:"BackendNode",type:"object",properties:[{name:"nodeType",type:"integer",description:"<code>Node</code>'s nodeType."},{name:"nodeName",type:"string",description:"<code>Node</code>'s nodeName."},{name:"backendNodeId",$ref:"BackendNodeId"}],experimental:!0,description:"Backend node with a friendly name."},{id:"PseudoType",type:"string",enum:["first-line","first-letter","before","after","backdrop","selection","first-line-inherited","scrollbar","scrollbar-thumb","scrollbar-button","scrollbar-track","scrollbar-track-piece","scrollbar-corner","resizer","input-list-button"],description:"Pseudo element type."},{id:"ShadowRootType",type:"string",enum:["user-agent","open","closed"],description:"Shadow root type."},{id:"Node",type:"object",properties:[{name:"nodeId",$ref:"NodeId",description:"Node identifier that is passed into the rest of the DOM messages as the <code>nodeId</code>. Backend will only push node with given <code>id</code> once. It is aware of all requested nodes and will only fire DOM events for nodes known to the client."},{name:"backendNodeId",$ref:"BackendNodeId",description:"The BackendNodeId for this node.",experimental:!0},{name:"nodeType",type:"integer",description:"<code>Node</code>'s nodeType."},{name:"nodeName",type:"string",description:"<code>Node</code>'s nodeName."},{name:"localName",type:"string",description:"<code>Node</code>'s localName."},{name:"nodeValue",type:"string",description:"<code>Node</code>'s nodeValue."},{name:"childNodeCount",type:"integer",optional:!0,description:"Child count for <code>Container</code> nodes."},{name:"children",type:"array",optional:!0,items:{$ref:"Node"},description:"Child nodes of this node when requested with children."},{name:"attributes",type:"array",optional:!0,items:{type:"string"},description:"Attributes of the <code>Element</code> node in the form of flat array <code>[name1, value1, name2, value2]</code>."},{name:"documentURL",type:"string",optional:!0,description:"Document URL that <code>Document</code> or <code>FrameOwner</code> node points to."},{name:"baseURL",type:"string",optional:!0,description:"Base URL that <code>Document</code> or <code>FrameOwner</code> node uses for URL completion.",experimental:!0},{name:"publicId",type:"string",optional:!0,description:"<code>DocumentType</code>'s publicId."},{name:"systemId",type:"string",optional:!0,description:"<code>DocumentType</code>'s systemId."},{name:"internalSubset",type:"string",optional:!0,description:"<code>DocumentType</code>'s internalSubset."},{name:"xmlVersion",type:"string",optional:!0,description:"<code>Document</code>'s XML version in case of XML documents."},{name:"name",type:"string",optional:!0,description:"<code>Attr</code>'s name."},{name:"value",type:"string",optional:!0,description:"<code>Attr</code>'s value."},{name:"pseudoType",$ref:"PseudoType",optional:!0,description:"Pseudo element type for this node."},{name:"shadowRootType",$ref:"ShadowRootType",optional:!0,description:"Shadow root type."},{name:"frameId",$ref:"Page.FrameId",optional:!0,description:"Frame ID for frame owner elements.",experimental:!0},{name:"contentDocument",$ref:"Node",optional:!0,description:"Content document for frame owner elements."},{name:"shadowRoots",type:"array",optional:!0,items:{$ref:"Node"},description:"Shadow root list for given element host.",experimental:!0},{name:"templateContent",$ref:"Node",optional:!0,description:"Content document fragment for template elements.",experimental:!0},{name:"pseudoElements",type:"array",items:{$ref:"Node"},optional:!0,description:"Pseudo elements associated with this node.",experimental:!0},{name:"importedDocument",$ref:"Node",optional:!0,description:"Import document for the HTMLImport links."},{name:"distributedNodes",type:"array",items:{$ref:"BackendNode"},optional:!0,description:"Distributed nodes for given insertion point.",experimental:!0}],description:"DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type."},{id:"RGBA",type:"object",properties:[{name:"r",type:"integer",description:"The red component, in the [0-255] range."},{name:"g",type:"integer",description:"The green component, in the [0-255] range."},{name:"b",type:"integer",description:"The blue component, in the [0-255] range."},{name:"a",type:"number",optional:!0,description:"The alpha component, in the [0-1] range (default: 1)."}],description:"A structure holding an RGBA color."},{id:"Quad",type:"array",items:{type:"number"},minItems:8,maxItems:8,description:"An array of quad vertices, x immediately followed by y for each point, points clock-wise.",experimental:!0},{id:"BoxModel",type:"object",experimental:!0,properties:[{name:"content",$ref:"Quad",description:"Content box"},{name:"padding",$ref:"Quad",description:"Padding box"},{name:"border",$ref:"Quad",description:"Border box"},{name:"margin",$ref:"Quad",description:"Margin box"},{name:"width",type:"integer",description:"Node width"},{name:"height",type:"integer",description:"Node height"},{name:"shapeOutside",$ref:"ShapeOutsideInfo",optional:!0,description:"Shape outside coordinates"}],description:"Box model."},{id:"ShapeOutsideInfo",type:"object",experimental:!0,properties:[{name:"bounds",$ref:"Quad",description:"Shape bounds"},{name:"shape",type:"array",items:{type:"any"},description:"Shape coordinate details"},{name:"marginShape",type:"array",items:{type:"any"},description:"Margin shape bounds"}],description:"CSS Shape Outside details."},{id:"Rect",type:"object",experimental:!0,properties:[{name:"x",type:"number",description:"X coordinate"},{name:"y",type:"number",description:"Y coordinate"},{name:"width",type:"number",description:"Rectangle width"},{name:"height",type:"number",description:"Rectangle height"}],description:"Rectangle."},{id:"HighlightConfig",type:"object",properties:[{name:"showInfo",type:"boolean",optional:!0,description:"Whether the node info tooltip should be shown (default: false)."},{name:"showRulers",type:"boolean",optional:!0,description:"Whether the rulers should be shown (default: false)."},{name:"showExtensionLines",type:"boolean",optional:!0,description:"Whether the extension lines from node to the rulers should be shown (default: false)."},{name:"displayAsMaterial",type:"boolean",optional:!0,experimental:!0},{name:"contentColor",$ref:"RGBA",optional:!0,description:"The content box highlight fill color (default: transparent)."},{name:"paddingColor",$ref:"RGBA",optional:!0,description:"The padding highlight fill color (default: transparent)."},{name:"borderColor",$ref:"RGBA",optional:!0,description:"The border highlight fill color (default: transparent)."},{name:"marginColor",$ref:"RGBA",optional:!0,description:"The margin highlight fill color (default: transparent)."},{name:"eventTargetColor",$ref:"RGBA",optional:!0,experimental:!0,description:"The event target element highlight fill color (default: transparent)."},{name:"shapeColor",$ref:"RGBA",optional:!0,experimental:!0,description:"The shape outside fill color (default: transparent)."},{name:"shapeMarginColor",$ref:"RGBA",optional:!0,experimental:!0,description:"The shape margin fill color (default: transparent)."},{name:"selectorList",type:"string",optional:!0,description:"Selectors to highlight relevant nodes."}],description:"Configuration data for the highlighting of page elements."},{id:"InspectMode",type:"string",experimental:!0,enum:["searchForNode","searchForUAShadowDOM","none"]}],commands:[{name:"enable",description:"Enables DOM agent for the given page."},{name:"disable",description:"Disables DOM agent for the given page."},{name:"getDocument",parameters:[{name:"depth",type:"integer",optional:!0,description:"The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.",experimental:!0},{name:"pierce",type:"boolean",optional:!0,description:"Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).",experimental:!0}],returns:[{name:"root",$ref:"Node",description:"Resulting node."}],description:"Returns the root DOM node (and optionally the subtree) to the caller."},{name:"collectClassNamesFromSubtree",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to collect class names."}],returns:[{name:"classNames",type:"array",items:{type:"string"},description:"Class name list."}],description:"Collects class names for the node with given id and all of it's child nodes.",experimental:!0},{name:"requestChildNodes",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to get children for."},{name:"depth",type:"integer",optional:!0,description:"The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.",experimental:!0},{name:"pierce",type:"boolean",optional:!0,description:"Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).",experimental:!0}],description:"Requests that children of the node with given id are returned to the caller in form of <code>setChildNodes</code> events where not only immediate children are retrieved, but all children down to the specified depth."},{name:"querySelector",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to query upon."},{name:"selector",type:"string",description:"Selector string."}],returns:[{name:"nodeId",$ref:"NodeId",description:"Query selector result."}],description:"Executes <code>querySelector</code> on a given node."},{name:"querySelectorAll",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to query upon."},{name:"selector",type:"string",description:"Selector string."}],returns:[{name:"nodeIds",type:"array",items:{$ref:"NodeId"},description:"Query selector result."}],description:"Executes <code>querySelectorAll</code> on a given node."},{name:"setNodeName",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to set name for."},{name:"name",type:"string",description:"New node's name."}],returns:[{name:"nodeId",$ref:"NodeId",description:"New node's id."}],description:"Sets node name for a node with given id."},{name:"setNodeValue",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to set value for."},{name:"value",type:"string",description:"New node's value."}],description:"Sets node value for a node with given id."},{name:"removeNode",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to remove."}],description:"Removes node with given id."},{name:"setAttributeValue",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the element to set attribute for."},{name:"name",type:"string",description:"Attribute name."},{name:"value",type:"string",description:"Attribute value."}],description:"Sets attribute for an element with given id."},{name:"setAttributesAsText",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the element to set attributes for."},{name:"text",type:"string",description:"Text with a number of attributes. Will parse this text using HTML parser."},{name:"name",type:"string",optional:!0,description:"Attribute name to replace with new attributes derived from text in case text parsed successfully."}],description:"Sets attributes on element with given id. This method is useful when user edits some existing attribute value and types in several attribute name/value pairs."},{name:"removeAttribute",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the element to remove attribute from."},{name:"name",type:"string",description:"Name of the attribute to remove."}],description:"Removes attribute with given name from an element with given id."},{name:"getOuterHTML",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to get markup for."}],returns:[{name:"outerHTML",type:"string",description:"Outer HTML markup."}],description:"Returns node's HTML markup."},{name:"setOuterHTML",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to set markup for."},{name:"outerHTML",type:"string",description:"Outer HTML markup to set."}],description:"Sets node HTML markup, returns new node id."},{name:"performSearch",parameters:[{name:"query",type:"string",description:"Plain text or query selector or XPath search query."},{name:"includeUserAgentShadowDOM",type:"boolean",optional:!0,description:"True to search in user agent shadow DOM.",experimental:!0}],returns:[{name:"searchId",type:"string",description:"Unique search session identifier."},{name:"resultCount",type:"integer",description:"Number of search results."}],description:"Searches for a given string in the DOM tree. Use <code>getSearchResults</code> to access search results or <code>cancelSearch</code> to end this search session.",experimental:!0},{name:"getSearchResults",parameters:[{name:"searchId",type:"string",description:"Unique search session identifier."},{name:"fromIndex",type:"integer",description:"Start index of the search result to be returned."},{name:"toIndex",type:"integer",description:"End index of the search result to be returned."}],returns:[{name:"nodeIds",type:"array",items:{$ref:"NodeId"},description:"Ids of the search result nodes."}],description:"Returns search results from given <code>fromIndex</code> to given <code>toIndex</code> from the sarch with the given identifier.",experimental:!0},{name:"discardSearchResults",parameters:[{name:"searchId",type:"string",description:"Unique search session identifier."}],description:"Discards search results from the session with the given id. <code>getSearchResults</code> should no longer be called for that search.",
	experimental:!0},{name:"requestNode",parameters:[{name:"objectId",$ref:"Runtime.RemoteObjectId",description:"JavaScript object id to convert into node."}],returns:[{name:"nodeId",$ref:"NodeId",description:"Node id for given object."}],description:"Requests that the node is sent to the caller given the JavaScript node object reference. All nodes that form the path from the node to the root are also sent to the client as a series of <code>setChildNodes</code> notifications."},{name:"setInspectMode",experimental:!0,parameters:[{name:"mode",$ref:"InspectMode",description:"Set an inspection mode."},{name:"highlightConfig",$ref:"HighlightConfig",optional:!0,description:"A descriptor for the highlight appearance of hovered-over nodes. May be omitted if <code>enabled == false</code>."}],description:"Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted. Backend then generates 'inspectNodeRequested' event upon element selection."},{name:"highlightRect",parameters:[{name:"x",type:"integer",description:"X coordinate"},{name:"y",type:"integer",description:"Y coordinate"},{name:"width",type:"integer",description:"Rectangle width"},{name:"height",type:"integer",description:"Rectangle height"},{name:"color",$ref:"RGBA",optional:!0,description:"The highlight fill color (default: transparent)."},{name:"outlineColor",$ref:"RGBA",optional:!0,description:"The highlight outline color (default: transparent)."}],description:"Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport."},{name:"highlightQuad",parameters:[{name:"quad",$ref:"Quad",description:"Quad to highlight"},{name:"color",$ref:"RGBA",optional:!0,description:"The highlight fill color (default: transparent)."},{name:"outlineColor",$ref:"RGBA",optional:!0,description:"The highlight outline color (default: transparent)."}],description:"Highlights given quad. Coordinates are absolute with respect to the main frame viewport.",experimental:!0},{name:"highlightNode",parameters:[{name:"highlightConfig",$ref:"HighlightConfig",description:"A descriptor for the highlight appearance."},{name:"nodeId",$ref:"NodeId",optional:!0,description:"Identifier of the node to highlight."},{name:"backendNodeId",$ref:"BackendNodeId",optional:!0,description:"Identifier of the backend node to highlight."},{name:"objectId",$ref:"Runtime.RemoteObjectId",optional:!0,description:"JavaScript object id of the node to be highlighted.",experimental:!0}],description:"Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or objectId must be specified."},{name:"hideHighlight",description:"Hides DOM node highlight."},{name:"highlightFrame",parameters:[{name:"frameId",$ref:"Page.FrameId",description:"Identifier of the frame to highlight."},{name:"contentColor",$ref:"RGBA",optional:!0,description:"The content box highlight fill color (default: transparent)."},{name:"contentOutlineColor",$ref:"RGBA",optional:!0,description:"The content box highlight outline color (default: transparent)."}],description:"Highlights owner element of the frame with given id.",experimental:!0},{name:"pushNodeByPathToFrontend",parameters:[{name:"path",type:"string",description:"Path to node in the proprietary format."}],returns:[{name:"nodeId",$ref:"NodeId",description:"Id of the node for given path."}],description:"Requests that the node is sent to the caller given its path. // FIXME, use XPath",experimental:!0},{name:"pushNodesByBackendIdsToFrontend",parameters:[{name:"backendNodeIds",type:"array",items:{$ref:"BackendNodeId"},description:"The array of backend node ids."}],returns:[{name:"nodeIds",type:"array",items:{$ref:"NodeId"},description:"The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds."}],description:"Requests that a batch of nodes is sent to the caller given their backend node ids.",experimental:!0},{name:"setInspectedNode",parameters:[{name:"nodeId",$ref:"NodeId",description:"DOM node id to be accessible by means of $x command line API."}],description:"Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).",experimental:!0},{name:"resolveNode",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to resolve."},{name:"objectGroup",type:"string",optional:!0,description:"Symbolic group name that can be used to release multiple objects."}],returns:[{name:"object",$ref:"Runtime.RemoteObject",description:"JavaScript object wrapper for given node."}],description:"Resolves JavaScript node object for given node id."},{name:"getAttributes",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to retrieve attibutes for."}],returns:[{name:"attributes",type:"array",items:{type:"string"},description:"An interleaved array of node attribute names and values."}],description:"Returns attributes for the specified node."},{name:"copyTo",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to copy."},{name:"targetNodeId",$ref:"NodeId",description:"Id of the element to drop the copy into."},{name:"insertBeforeNodeId",$ref:"NodeId",optional:!0,description:"Drop the copy before this node (if absent, the copy becomes the last child of <code>targetNodeId</code>)."}],returns:[{name:"nodeId",$ref:"NodeId",description:"Id of the node clone."}],description:"Creates a deep copy of the specified node and places it into the target container before the given anchor.",experimental:!0},{name:"moveTo",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to move."},{name:"targetNodeId",$ref:"NodeId",description:"Id of the element to drop the moved node into."},{name:"insertBeforeNodeId",$ref:"NodeId",optional:!0,description:"Drop node before this one (if absent, the moved node becomes the last child of <code>targetNodeId</code>)."}],returns:[{name:"nodeId",$ref:"NodeId",description:"New id of the moved node."}],description:"Moves node into the new container, places it before the given anchor."},{name:"undo",description:"Undoes the last performed action.",experimental:!0},{name:"redo",description:"Re-does the last undone action.",experimental:!0},{name:"markUndoableState",description:"Marks last undoable state.",experimental:!0},{name:"focus",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to focus."}],description:"Focuses the given element.",experimental:!0},{name:"setFileInputFiles",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the file input node to set files for."},{name:"files",type:"array",items:{type:"string"},description:"Array of file paths to set."}],description:"Sets files for the given file input element.",experimental:!0},{name:"getBoxModel",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to get box model for."}],returns:[{name:"model",$ref:"BoxModel",description:"Box model for the node."}],description:"Returns boxes for the currently selected nodes.",experimental:!0},{name:"getNodeForLocation",parameters:[{name:"x",type:"integer",description:"X coordinate."},{name:"y",type:"integer",description:"Y coordinate."}],returns:[{name:"nodeId",$ref:"NodeId",description:"Id of the node at given coordinates."}],description:"Returns node id at given location.",experimental:!0},{name:"getRelayoutBoundary",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node."}],returns:[{name:"nodeId",$ref:"NodeId",description:"Relayout boundary node id for the given node."}],description:"Returns the id of the nearest ancestor that is a relayout boundary.",experimental:!0},{name:"getHighlightObjectForTest",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to get highlight object for."}],returns:[{name:"highlight",type:"object",description:"Highlight data for the node."}],description:"For testing.",experimental:!0}],events:[{name:"documentUpdated",description:"Fired when <code>Document</code> has been totally updated. Node ids are no longer valid."},{name:"inspectNodeRequested",parameters:[{name:"backendNodeId",$ref:"BackendNodeId",description:"Id of the node to inspect."}],description:"Fired when the node should be inspected. This happens after call to <code>setInspectMode</code>.",experimental:!0},{name:"setChildNodes",parameters:[{name:"parentId",$ref:"NodeId",description:"Parent node id to populate with children."},{name:"nodes",type:"array",items:{$ref:"Node"},description:"Child nodes array."}],description:"Fired when backend wants to provide client with the missing DOM structure. This happens upon most of the calls requesting node ids."},{name:"attributeModified",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node that has changed."},{name:"name",type:"string",description:"Attribute name."},{name:"value",type:"string",description:"Attribute value."}],description:"Fired when <code>Element</code>'s attribute is modified."},{name:"attributeRemoved",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node that has changed."},{name:"name",type:"string",description:"A ttribute name."}],description:"Fired when <code>Element</code>'s attribute is removed."},{name:"inlineStyleInvalidated",parameters:[{name:"nodeIds",type:"array",items:{$ref:"NodeId"},description:"Ids of the nodes for which the inline styles have been invalidated."}],description:"Fired when <code>Element</code>'s inline style is modified via a CSS property modification.",experimental:!0},{name:"characterDataModified",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node that has changed."},{name:"characterData",type:"string",description:"New text value."}],description:"Mirrors <code>DOMCharacterDataModified</code> event."},{name:"childNodeCountUpdated",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node that has changed."},{name:"childNodeCount",type:"integer",description:"New node count."}],description:"Fired when <code>Container</code>'s child node count has changed."},{name:"childNodeInserted",parameters:[{name:"parentNodeId",$ref:"NodeId",description:"Id of the node that has changed."},{name:"previousNodeId",$ref:"NodeId",description:"If of the previous siblint."},{name:"node",$ref:"Node",description:"Inserted node data."}],description:"Mirrors <code>DOMNodeInserted</code> event."},{name:"childNodeRemoved",parameters:[{name:"parentNodeId",$ref:"NodeId",description:"Parent id."},{name:"nodeId",$ref:"NodeId",description:"Id of the node that has been removed."}],description:"Mirrors <code>DOMNodeRemoved</code> event."},{name:"shadowRootPushed",parameters:[{name:"hostId",$ref:"NodeId",description:"Host element id."},{name:"root",$ref:"Node",description:"Shadow root."}],description:"Called when shadow root is pushed into the element.",experimental:!0},{name:"shadowRootPopped",parameters:[{name:"hostId",$ref:"NodeId",description:"Host element id."},{name:"rootId",$ref:"NodeId",description:"Shadow root id."}],description:"Called when shadow root is popped from the element.",experimental:!0},{name:"pseudoElementAdded",parameters:[{name:"parentId",$ref:"NodeId",description:"Pseudo element's parent element id."},{name:"pseudoElement",$ref:"Node",description:"The added pseudo element."}],description:"Called when a pseudo element is added to an element.",experimental:!0},{name:"pseudoElementRemoved",parameters:[{name:"parentId",$ref:"NodeId",description:"Pseudo element's parent element id."},{name:"pseudoElementId",$ref:"NodeId",description:"The removed pseudo element id."}],description:"Called when a pseudo element is removed from an element.",experimental:!0},{name:"distributedNodesUpdated",parameters:[{name:"insertionPointId",$ref:"NodeId",description:"Insertion point where distrubuted nodes were updated."},{name:"distributedNodes",type:"array",items:{$ref:"BackendNode"},description:"Distributed nodes for given insertion point."}],description:"Called when distrubution is changed.",experimental:!0},{name:"nodeHighlightRequested",parameters:[{name:"nodeId",$ref:"NodeId"}],experimental:!0}]},{domain:"CSS",experimental:!0,description:"This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles) have an associated <code>id</code> used in subsequent operations on the related object. Each object type has a specific <code>id</code> structure, and those are not interchangeable between objects of different kinds. CSS objects can be loaded using the <code>get*ForNode()</code> calls (which accept a DOM node id). A client can also discover all the existing stylesheets with the <code>getAllStyleSheets()</code> method (or keeping track of the <code>styleSheetAdded</code>/<code>styleSheetRemoved</code> events) and subsequently load the required stylesheet contents using the <code>getStyleSheet[Text]()</code> methods.",dependencies:["DOM"],types:[{id:"StyleSheetId",type:"string"},{id:"StyleSheetOrigin",type:"string",enum:["injected","user-agent","inspector","regular"],description:'Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via inspector" rules), "regular" for regular stylesheets.'},{id:"PseudoElementMatches",type:"object",properties:[{name:"pseudoType",$ref:"DOM.PseudoType",description:"Pseudo element type."},{name:"matches",type:"array",items:{$ref:"RuleMatch"},description:"Matches of CSS rules applicable to the pseudo style."}],description:"CSS rule collection for a single pseudo style."},{id:"InheritedStyleEntry",type:"object",properties:[{name:"inlineStyle",$ref:"CSSStyle",optional:!0,description:"The ancestor node's inline style, if any, in the style inheritance chain."},{name:"matchedCSSRules",type:"array",items:{$ref:"RuleMatch"},description:"Matches of CSS rules matching the ancestor node in the style inheritance chain."}],description:"Inherited CSS rule collection from ancestor node."},{id:"RuleMatch",type:"object",properties:[{name:"rule",$ref:"CSSRule",description:"CSS rule in the match."},{name:"matchingSelectors",type:"array",items:{type:"integer"},description:"Matching selector indices in the rule's selectorList selectors (0-based)."}],description:"Match data for a CSS rule."},{id:"Value",type:"object",properties:[{name:"text",type:"string",description:"Value text."},{name:"range",$ref:"SourceRange",optional:!0,description:"Value range in the underlying resource (if available)."}],description:"Data for a simple selector (these are delimited by commas in a selector list)."},{id:"SelectorList",type:"object",properties:[{name:"selectors",type:"array",items:{$ref:"Value"},description:"Selectors in the list."},{name:"text",type:"string",description:"Rule selector text."}],description:"Selector list data."},{id:"CSSStyleSheetHeader",type:"object",properties:[{name:"styleSheetId",$ref:"StyleSheetId",description:"The stylesheet identifier."},{name:"frameId",$ref:"Page.FrameId",description:"Owner frame identifier."},{name:"sourceURL",type:"string",description:"Stylesheet resource URL."},{name:"sourceMapURL",type:"string",optional:!0,description:"URL of source map associated with the stylesheet (if any)."},{name:"origin",$ref:"StyleSheetOrigin",description:"Stylesheet origin."},{name:"title",type:"string",description:"Stylesheet title."},{name:"ownerNode",$ref:"DOM.BackendNodeId",optional:!0,description:"The backend id for the owner node of the stylesheet."},{name:"disabled",type:"boolean",description:"Denotes whether the stylesheet is disabled."},{name:"hasSourceURL",type:"boolean",optional:!0,description:"Whether the sourceURL field value comes from the sourceURL comment."},{name:"isInline",type:"boolean",description:"Whether this stylesheet is created for STYLE tag by parser. This flag is not set for document.written STYLE tags."},{name:"startLine",type:"number",description:"Line offset of the stylesheet within the resource (zero based)."},{name:"startColumn",type:"number",description:"Column offset of the stylesheet within the resource (zero based)."}],description:"CSS stylesheet metainformation."},{id:"CSSRule",type:"object",properties:[{name:"styleSheetId",$ref:"StyleSheetId",optional:!0,description:"The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from."},{name:"selectorList",$ref:"SelectorList",description:"Rule selector data."},{name:"origin",$ref:"StyleSheetOrigin",description:"Parent stylesheet's origin."},{name:"style",$ref:"CSSStyle",description:"Associated style declaration."},{name:"media",type:"array",items:{$ref:"CSSMedia"},optional:!0,description:"Media list array (for rules involving media queries). The array enumerates media queries starting with the innermost one, going outwards."}],description:"CSS rule representation."},{id:"RuleUsage",type:"object",properties:[{name:"styleSheetId",$ref:"StyleSheetId",description:"The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from."},{name:"range",$ref:"SourceRange",description:"Style declaration range in the enclosing stylesheet (if available)."},{name:"used",type:"boolean",description:"Indicates whether the rule was actually used by some element in the page."}],description:"CSS rule usage information.",experimental:!0},{id:"SourceRange",type:"object",properties:[{name:"startLine",type:"integer",description:"Start line of range."},{name:"startColumn",type:"integer",description:"Start column of range (inclusive)."},{name:"endLine",type:"integer",description:"End line of range"},{name:"endColumn",type:"integer",description:"End column of range (exclusive)."}],description:"Text range within a resource. All numbers are zero-based."},{id:"ShorthandEntry",type:"object",properties:[{name:"name",type:"string",description:"Shorthand name."},{name:"value",type:"string",description:"Shorthand value."},{name:"important",type:"boolean",optional:!0,description:'Whether the property has "!important" annotation (implies <code>false</code> if absent).'}]},{id:"CSSComputedStyleProperty",type:"object",properties:[{name:"name",type:"string",description:"Computed style property name."},{name:"value",type:"string",description:"Computed style property value."}]},{id:"CSSStyle",type:"object",properties:[{name:"styleSheetId",$ref:"StyleSheetId",optional:!0,description:"The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from."},{name:"cssProperties",type:"array",items:{$ref:"CSSProperty"},description:"CSS properties in the style."},{name:"shorthandEntries",type:"array",items:{$ref:"ShorthandEntry"},description:"Computed values for all shorthands found in the style."},{name:"cssText",type:"string",optional:!0,description:"Style declaration text (if available)."},{name:"range",$ref:"SourceRange",optional:!0,description:"Style declaration range in the enclosing stylesheet (if available)."}],description:"CSS style representation."},{id:"CSSProperty",type:"object",properties:[{name:"name",type:"string",description:"The property name."},{name:"value",type:"string",description:"The property value."},{name:"important",type:"boolean",optional:!0,description:'Whether the property has "!important" annotation (implies <code>false</code> if absent).'},{name:"implicit",type:"boolean",optional:!0,description:"Whether the property is implicit (implies <code>false</code> if absent)."},{name:"text",type:"string",optional:!0,description:"The full property text as specified in the style."},{name:"parsedOk",type:"boolean",optional:!0,description:"Whether the property is understood by the browser (implies <code>true</code> if absent)."},{name:"disabled",type:"boolean",optional:!0,description:"Whether the property is disabled by the user (present for source-based properties only)."},{name:"range",$ref:"SourceRange",optional:!0,description:"The entire property range in the enclosing style declaration (if available)."}],description:"CSS property declaration data."},{id:"CSSMedia",type:"object",properties:[{name:"text",type:"string",description:"Media query text."},{name:"source",type:"string",enum:["mediaRule","importRule","linkedSheet","inlineSheet"],description:'Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked stylesheet\'s LINK tag, "inlineSheet" if specified by a "media" attribute in an inline stylesheet\'s STYLE tag.'},{name:"sourceURL",type:"string",optional:!0,description:"URL of the document containing the media query description."},{name:"range",$ref:"SourceRange",optional:!0,description:"The associated rule (@media or @import) header range in the enclosing stylesheet (if available)."},{name:"styleSheetId",$ref:"StyleSheetId",optional:!0,description:"Identifier of the stylesheet containing this object (if exists)."},{name:"mediaList",type:"array",items:{$ref:"MediaQuery"},optional:!0,experimental:!0,description:"Array of media queries."}],description:"CSS media rule descriptor."},{id:"MediaQuery",type:"object",properties:[{name:"expressions",type:"array",items:{$ref:"MediaQueryExpression"},description:"Array of media query expressions."},{name:"active",type:"boolean",description:"Whether the media query condition is satisfied."}],description:"Media query descriptor.",experimental:!0},{id:"MediaQueryExpression",type:"object",properties:[{name:"value",type:"number",description:"Media query expression value."},{name:"unit",type:"string",description:"Media query expression units."},{name:"feature",type:"string",description:"Media query expression feature."},{name:"valueRange",$ref:"SourceRange",optional:!0,description:"The associated range of the value text in the enclosing stylesheet (if available)."},{name:"computedLength",type:"number",optional:!0,description:"Computed length of media query expression (if applicable)."}],description:"Media query expression descriptor.",experimental:!0},{id:"PlatformFontUsage",type:"object",properties:[{name:"familyName",type:"string",description:"Font's family name reported by platform."},{name:"isCustomFont",type:"boolean",description:"Indicates if the font was downloaded or resolved locally."},{name:"glyphCount",type:"number",description:"Amount of glyphs that were rendered with this font."}],description:"Information about amount of glyphs that were rendered with given font.",experimental:!0},{id:"CSSKeyframesRule",type:"object",properties:[{name:"animationName",$ref:"Value",description:"Animation name."},{name:"keyframes",type:"array",items:{$ref:"CSSKeyframeRule"},description:"List of keyframes."}],description:"CSS keyframes rule representation."},{id:"CSSKeyframeRule",type:"object",properties:[{name:"styleSheetId",$ref:"StyleSheetId",optional:!0,description:"The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from."},{name:"origin",$ref:"StyleSheetOrigin",description:"Parent stylesheet's origin."},{name:"keyText",$ref:"Value",description:"Associated key text."},{name:"style",$ref:"CSSStyle",description:"Associated style declaration."}],description:"CSS keyframe rule representation."},{id:"StyleDeclarationEdit",type:"object",properties:[{name:"styleSheetId",$ref:"StyleSheetId",description:"The css style sheet identifier."},{name:"range",$ref:"SourceRange",description:"The range of the style text in the enclosing stylesheet."},{name:"text",type:"string",description:"New style text."}],description:"A descriptor of operation to mutate style declaration text."},{id:"InlineTextBox",type:"object",properties:[{name:"boundingBox",$ref:"DOM.Rect",description:"The absolute position bounding box."},{name:"startCharacterIndex",type:"integer",description:"The starting index in characters, for this post layout textbox substring."},{name:"numCharacters",type:"integer",description:"The number of characters in this post layout textbox substring."}],description:"Details of post layout rendered text positions. The exact layout should not be regarded as stable and may change between versions.",experimental:!0},{id:"LayoutTreeNode",type:"object",properties:[{name:"nodeId",$ref:"DOM.NodeId",description:"The id of the related DOM node matching one from DOM.GetDocument."},{name:"boundingBox",$ref:"DOM.Rect",description:"The absolute position bounding box."},{name:"layoutText",type:"string",optional:!0,description:"Contents of the LayoutText if any"},{name:"inlineTextNodes",type:"array",optional:!0,items:{$ref:"InlineTextBox"},description:"The post layout inline text nodes, if any."},{name:"styleIndex",type:"integer",optional:!0,description:"Index into the computedStyles array returned by getLayoutTreeAndStyles."}],description:"Details of an element in the DOM tree with a LayoutObject.",experimental:!0},{id:"ComputedStyle",type:"object",properties:[{name:"properties",type:"array",items:{$ref:"CSSComputedStyleProperty"}}],description:"A subset of the full ComputedStyle as defined by the request whitelist.",experimental:!0}],commands:[{name:"enable",description:"Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been enabled until the result of this command is received."},{name:"disable",description:"Disables the CSS agent for the given page."},{name:"getMatchedStylesForNode",parameters:[{name:"nodeId",$ref:"DOM.NodeId"}],returns:[{name:"inlineStyle",$ref:"CSSStyle",optional:!0,description:"Inline style for the specified DOM node."},{name:"attributesStyle",$ref:"CSSStyle",optional:!0,description:'Attribute-defined element style (e.g. resulting from "width=20 height=100%").'},{name:"matchedCSSRules",type:"array",items:{$ref:"RuleMatch"},optional:!0,description:"CSS rules matching this node, from all applicable stylesheets."},{name:"pseudoElements",type:"array",items:{$ref:"PseudoElementMatches"},optional:!0,description:"Pseudo style matches for this node."},{name:"inherited",type:"array",items:{$ref:"InheritedStyleEntry"},optional:!0,description:"A chain of inherited styles (from the immediate node parent up to the DOM tree root)."},{name:"cssKeyframesRules",type:"array",items:{$ref:"CSSKeyframesRule"},optional:!0,description:"A list of CSS keyframed animations matching this node."}],description:"Returns requested styles for a DOM node identified by <code>nodeId</code>."},{name:"getInlineStylesForNode",parameters:[{name:"nodeId",$ref:"DOM.NodeId"}],returns:[{name:"inlineStyle",$ref:"CSSStyle",optional:!0,description:"Inline style for the specified DOM node."},{name:"attributesStyle",$ref:"CSSStyle",optional:!0,description:'Attribute-defined element style (e.g. resulting from "width=20 height=100%").'}],description:'Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM attributes) for a DOM node identified by <code>nodeId</code>.'},{name:"getComputedStyleForNode",parameters:[{name:"nodeId",$ref:"DOM.NodeId"}],returns:[{name:"computedStyle",type:"array",items:{$ref:"CSSComputedStyleProperty"},description:"Computed style for the specified DOM node."}],description:"Returns the computed style for a DOM node identified by <code>nodeId</code>."},{name:"getPlatformFontsForNode",parameters:[{name:"nodeId",$ref:"DOM.NodeId"}],returns:[{name:"fonts",type:"array",items:{$ref:"PlatformFontUsage"},description:"Usage statistics for every employed platform font."}],description:"Requests information about platform fonts which we used to render child TextNodes in the given node.",experimental:!0},{name:"getStyleSheetText",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"}],returns:[{name:"text",type:"string",description:"The stylesheet text."}],description:"Returns the current textual content and the URL for a stylesheet."},{name:"collectClassNames",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"}],returns:[{name:"classNames",type:"array",items:{type:"string"},description:"Class name list."}],description:"Returns all class names from specified stylesheet.",experimental:!0},{name:"setStyleSheetText",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"},{name:"text",type:"string"}],returns:[{name:"sourceMapURL",type:"string",optional:!0,description:"URL of source map associated with script (if any)."}],description:"Sets the new stylesheet text."},{name:"setRuleSelector",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"},{name:"range",$ref:"SourceRange"},{name:"selector",type:"string"}],returns:[{name:"selectorList",$ref:"SelectorList",description:"The resulting selector list after modification."}],description:"Modifies the rule selector."},{name:"setKeyframeKey",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"},{name:"range",$ref:"SourceRange"},{name:"keyText",type:"string"}],returns:[{name:"keyText",$ref:"Value",description:"The resulting key text after modification."}],description:"Modifies the keyframe rule key text."},{name:"setStyleTexts",parameters:[{name:"edits",type:"array",items:{$ref:"StyleDeclarationEdit"}}],returns:[{name:"styles",type:"array",items:{$ref:"CSSStyle"},description:"The resulting styles after modification."}],description:"Applies specified style edits one after another in the given order."},{name:"setMediaText",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"},{name:"range",$ref:"SourceRange"},{name:"text",type:"string"}],returns:[{name:"media",$ref:"CSSMedia",description:"The resulting CSS media rule after modification."}],description:"Modifies the rule selector."},{name:"createStyleSheet",parameters:[{name:"frameId",$ref:"Page.FrameId",description:'Identifier of the frame where "via-inspector" stylesheet should be created.'}],returns:[{name:"styleSheetId",$ref:"StyleSheetId",description:'Identifier of the created "via-inspector" stylesheet.'}],description:'Creates a new special "via-inspector" stylesheet in the frame with given <code>frameId</code>.'},{name:"addRule",parameters:[{name:"styleSheetId",$ref:"StyleSheetId",description:"The css style sheet identifier where a new rule should be inserted."},{name:"ruleText",type:"string",description:"The text of a new rule."},{name:"location",$ref:"SourceRange",description:"Text position of a new rule in the target style sheet."}],returns:[{name:"rule",$ref:"CSSRule",description:"The newly created rule."}],description:"Inserts a new rule with the given <code>ruleText</code> in a stylesheet with given <code>styleSheetId</code>, at the position specified by <code>location</code>."},{name:"forcePseudoState",parameters:[{name:"nodeId",$ref:"DOM.NodeId",description:"The element id for which to force the pseudo state."},{name:"forcedPseudoClasses",type:"array",items:{type:"string",enum:["active","focus","hover","visited"]},description:"Element pseudo classes to force when computing the element's style."}],description:"Ensures that the given node will have specified pseudo-classes whenever its style is computed by the browser."},{name:"getMediaQueries",returns:[{name:"medias",type:"array",items:{$ref:"CSSMedia"}}],description:"Returns all media queries parsed by the rendering engine.",experimental:!0},{name:"setEffectivePropertyValueForNode",parameters:[{name:"nodeId",$ref:"DOM.NodeId",description:"The element id for which to set property."},{name:"propertyName",type:"string"},{name:"value",type:"string"}],description:"Find a rule with the given active property for the given node and set the new value for this property",experimental:!0},{name:"getBackgroundColors",parameters:[{name:"nodeId",$ref:"DOM.NodeId",description:"Id of the node to get background colors for."}],returns:[{name:"backgroundColors",type:"array",items:{type:"string"},description:"The range of background colors behind this element, if it contains any visible text. If no visible text is present, this will be undefined. In the case of a flat background color, this will consist of simply that color. In the case of a gradient, this will consist of each of the color stops. For anything more complicated, this will be an empty array. Images will be ignored (as if the image had failed to load).",
	optional:!0}],experimental:!0},{name:"getLayoutTreeAndStyles",parameters:[{name:"computedStyleWhitelist",type:"array",items:{type:"string"},description:"Whitelist of computed styles to return."}],returns:[{name:"layoutTreeNodes",type:"array",items:{$ref:"LayoutTreeNode"}},{name:"computedStyles",type:"array",items:{$ref:"ComputedStyle"}}],description:"For the main document and any content documents, return the LayoutTreeNodes and a whitelisted subset of the computed style. It only returns pushed nodes, on way to pull all nodes is to call DOM.getDocument with a depth of -1.",experimental:!0},{name:"startRuleUsageTracking",description:"Enables the selector recording.",experimental:!0},{name:"stopRuleUsageTracking",returns:[{name:"ruleUsage",type:"array",items:{$ref:"RuleUsage"}}],description:"The list of rules with an indication of whether these were used",experimental:!0}],events:[{name:"mediaQueryResultChanged",description:"Fires whenever a MediaQuery result changes (for example, after a browser window has been resized.) The current implementation considers only viewport-dependent media features."},{name:"fontsUpdated",description:"Fires whenever a web font gets loaded."},{name:"styleSheetChanged",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"}],description:"Fired whenever a stylesheet is changed as a result of the client operation."},{name:"styleSheetAdded",parameters:[{name:"header",$ref:"CSSStyleSheetHeader",description:"Added stylesheet metainfo."}],description:"Fired whenever an active document stylesheet is added."},{name:"styleSheetRemoved",parameters:[{name:"styleSheetId",$ref:"StyleSheetId",description:"Identifier of the removed stylesheet."}],description:"Fired whenever an active document stylesheet is removed."}]},{domain:"IO",description:"Input/Output operations for streams produced by DevTools.",experimental:!0,types:[{id:"StreamHandle",type:"string"}],commands:[{name:"read",description:"Read a chunk of the stream",parameters:[{name:"handle",$ref:"StreamHandle",description:"Handle of the stream to read."},{name:"offset",type:"integer",optional:!0,description:"Seek to the specified offset before reading (if not specificed, proceed with offset following the last read)."},{name:"size",type:"integer",optional:!0,description:"Maximum number of bytes to read (left upon the agent discretion if not specified)."}],returns:[{name:"data",type:"string",description:"Data that were read."},{name:"eof",type:"boolean",description:"Set if the end-of-file condition occured while reading."}]},{name:"close",description:"Close the stream, discard any temporary backing storage.",parameters:[{name:"handle",$ref:"StreamHandle",description:"Handle of the stream to close."}]}]},{domain:"DOMDebugger",description:"DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript execution will stop on these operations as if there was a regular breakpoint set.",dependencies:["DOM","Debugger"],types:[{id:"DOMBreakpointType",type:"string",enum:["subtree-modified","attribute-modified","node-removed"],description:"DOM breakpoint type."},{id:"EventListener",type:"object",description:"Object event listener.",properties:[{name:"type",type:"string",description:"<code>EventListener</code>'s type."},{name:"useCapture",type:"boolean",description:"<code>EventListener</code>'s useCapture."},{name:"passive",type:"boolean",description:"<code>EventListener</code>'s passive flag."},{name:"once",type:"boolean",description:"<code>EventListener</code>'s once flag."},{name:"scriptId",$ref:"Runtime.ScriptId",description:"Script id of the handler code."},{name:"lineNumber",type:"integer",description:"Line number in the script (0-based)."},{name:"columnNumber",type:"integer",description:"Column number in the script (0-based)."},{name:"handler",$ref:"Runtime.RemoteObject",optional:!0,description:"Event handler function value."},{name:"originalHandler",$ref:"Runtime.RemoteObject",optional:!0,description:"Event original handler function value."},{name:"removeFunction",$ref:"Runtime.RemoteObject",optional:!0,description:"Event listener remove function."}],experimental:!0}],commands:[{name:"setDOMBreakpoint",parameters:[{name:"nodeId",$ref:"DOM.NodeId",description:"Identifier of the node to set breakpoint on."},{name:"type",$ref:"DOMBreakpointType",description:"Type of the operation to stop upon."}],description:"Sets breakpoint on particular operation with DOM."},{name:"removeDOMBreakpoint",parameters:[{name:"nodeId",$ref:"DOM.NodeId",description:"Identifier of the node to remove breakpoint from."},{name:"type",$ref:"DOMBreakpointType",description:"Type of the breakpoint to remove."}],description:"Removes DOM breakpoint that was set using <code>setDOMBreakpoint</code>."},{name:"setEventListenerBreakpoint",parameters:[{name:"eventName",type:"string",description:"DOM Event name to stop on (any DOM event will do)."},{name:"targetName",type:"string",optional:!0,description:'EventTarget interface name to stop on. If equal to <code>"*"</code> or not provided, will stop on any EventTarget.',experimental:!0}],description:"Sets breakpoint on particular DOM event."},{name:"removeEventListenerBreakpoint",parameters:[{name:"eventName",type:"string",description:"Event name."},{name:"targetName",type:"string",optional:!0,description:"EventTarget interface name.",experimental:!0}],description:"Removes breakpoint on particular DOM event."},{name:"setInstrumentationBreakpoint",parameters:[{name:"eventName",type:"string",description:"Instrumentation name to stop on."}],description:"Sets breakpoint on particular native event.",experimental:!0},{name:"removeInstrumentationBreakpoint",parameters:[{name:"eventName",type:"string",description:"Instrumentation name to stop on."}],description:"Removes breakpoint on particular native event.",experimental:!0},{name:"setXHRBreakpoint",parameters:[{name:"url",type:"string",description:"Resource URL substring. All XHRs having this substring in the URL will get stopped upon."}],description:"Sets breakpoint on XMLHttpRequest."},{name:"removeXHRBreakpoint",parameters:[{name:"url",type:"string",description:"Resource URL substring."}],description:"Removes breakpoint from XMLHttpRequest."},{name:"getEventListeners",experimental:!0,parameters:[{name:"objectId",$ref:"Runtime.RemoteObjectId",description:"Identifier of the object to return listeners for."}],returns:[{name:"listeners",type:"array",items:{$ref:"EventListener"},description:"Array of relevant listeners."}],description:"Returns event listeners of the given object."}]},{domain:"Target",description:"Supports additional targets discovery and allows to attach to them.",experimental:!0,types:[{id:"TargetID",type:"string"},{id:"BrowserContextID",type:"string"},{id:"TargetInfo",type:"object",properties:[{name:"targetId",$ref:"TargetID"},{name:"type",type:"string"},{name:"title",type:"string"},{name:"url",type:"string"}]},{id:"RemoteLocation",type:"object",properties:[{name:"host",type:"string"},{name:"port",type:"integer"}]}],commands:[{name:"setDiscoverTargets",description:"Controls whether to discover available targets and notify via <code>targetCreated/targetDestroyed</code> events.",parameters:[{name:"discover",type:"boolean",description:"Whether to discover available targets."}]},{name:"setAutoAttach",description:"Controls whether to automatically attach to new targets which are considered to be related to this one. When turned on, attaches to all existing related targets as well. When turned off, automatically detaches from all currently attached targets.",parameters:[{name:"autoAttach",type:"boolean",description:"Whether to auto-attach to related targets."},{name:"waitForDebuggerOnStart",type:"boolean",description:"Whether to pause new targets when attaching to them. Use <code>Runtime.runIfWaitingForDebugger</code> to run paused targets."}]},{name:"setAttachToFrames",parameters:[{name:"value",type:"boolean",description:"Whether to attach to frames."}]},{name:"setRemoteLocations",description:"Enables target discovery for the specified locations, when <code>setDiscoverTargets</code> was set to <code>true</code>.",parameters:[{name:"locations",type:"array",items:{$ref:"RemoteLocation"},description:"List of remote locations."}]},{name:"sendMessageToTarget",description:"Sends protocol message to the target with given id.",parameters:[{name:"targetId",type:"string"},{name:"message",type:"string"}]},{name:"getTargetInfo",description:"Returns information about a target.",parameters:[{name:"targetId",$ref:"TargetID"}],returns:[{name:"targetInfo",$ref:"TargetInfo"}]},{name:"activateTarget",description:"Activates (focuses) the target.",parameters:[{name:"targetId",$ref:"TargetID"}]},{name:"closeTarget",description:"Closes the target. If the target is a page that gets closed too.",parameters:[{name:"targetId",$ref:"TargetID"}],returns:[{name:"success",type:"boolean"}]},{name:"attachToTarget",description:"Attaches to the target with given id.",parameters:[{name:"targetId",$ref:"TargetID"}],returns:[{name:"success",type:"boolean",description:"Whether attach succeeded."}]},{name:"detachFromTarget",description:"Detaches from the target with given id.",parameters:[{name:"targetId",$ref:"TargetID"}]},{name:"createBrowserContext",description:"Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than one.",returns:[{name:"browserContextId",$ref:"BrowserContextID",description:"The id of the context created."}]},{name:"disposeBrowserContext",description:"Deletes a BrowserContext, will fail of any open page uses it.",parameters:[{name:"browserContextId",$ref:"BrowserContextID"}],returns:[{name:"success",type:"boolean"}]},{name:"createTarget",description:"Creates a new page.",parameters:[{name:"url",type:"string",description:"The initial URL the page will be navigated to."},{name:"width",type:"integer",description:"Frame width in DIP (headless chrome only).",optional:!0},{name:"height",type:"integer",description:"Frame height in DIP (headless chrome only).",optional:!0},{name:"browserContextId",$ref:"BrowserContextID",description:"The browser context to create the page in (headless chrome only).",optional:!0}],returns:[{name:"targetId",$ref:"TargetID",description:"The id of the page opened."}]},{name:"getTargets",description:"Retrieves a list of available targets.",returns:[{name:"targetInfos",type:"array",items:{$ref:"TargetInfo"},description:"The list of targets."}]}],events:[{name:"targetCreated",description:"Issued when a possible inspection target is created.",parameters:[{name:"targetInfo",$ref:"TargetInfo"}]},{name:"targetDestroyed",description:"Issued when a target is destroyed.",parameters:[{name:"targetId",$ref:"TargetID"}]},{name:"attachedToTarget",description:"Issued when attached to target because of auto-attach or <code>attachToTarget</code> command.",parameters:[{name:"targetInfo",$ref:"TargetInfo"},{name:"waitingForDebugger",type:"boolean"}]},{name:"detachedFromTarget",description:"Issued when detached from target for any reason (including <code>detachFromTarget</code> command).",parameters:[{name:"targetId",$ref:"TargetID"}]},{name:"receivedMessageFromTarget",description:"Notifies about new protocol message from attached target.",parameters:[{name:"targetId",$ref:"TargetID"},{name:"message",type:"string"}]}]},{domain:"ServiceWorker",experimental:!0,types:[{id:"ServiceWorkerRegistration",type:"object",description:"ServiceWorker registration.",properties:[{name:"registrationId",type:"string"},{name:"scopeURL",type:"string"},{name:"isDeleted",type:"boolean"}]},{id:"ServiceWorkerVersionRunningStatus",type:"string",enum:["stopped","starting","running","stopping"]},{id:"ServiceWorkerVersionStatus",type:"string",enum:["new","installing","installed","activating","activated","redundant"]},{id:"ServiceWorkerVersion",type:"object",description:"ServiceWorker version.",properties:[{name:"versionId",type:"string"},{name:"registrationId",type:"string"},{name:"scriptURL",type:"string"},{name:"runningStatus",$ref:"ServiceWorkerVersionRunningStatus"},{name:"status",$ref:"ServiceWorkerVersionStatus"},{name:"scriptLastModified",type:"number",optional:!0,description:"The Last-Modified header value of the main script."},{name:"scriptResponseTime",type:"number",optional:!0,description:"The time at which the response headers of the main script were received from the server.  For cached script it is the last time the cache entry was validated."},{name:"controlledClients",type:"array",optional:!0,items:{$ref:"Target.TargetID"}},{name:"targetId",$ref:"Target.TargetID",optional:!0}]},{id:"ServiceWorkerErrorMessage",type:"object",description:"ServiceWorker error message.",properties:[{name:"errorMessage",type:"string"},{name:"registrationId",type:"string"},{name:"versionId",type:"string"},{name:"sourceURL",type:"string"},{name:"lineNumber",type:"integer"},{name:"columnNumber",type:"integer"}]}],commands:[{name:"enable"},{name:"disable"},{name:"unregister",parameters:[{name:"scopeURL",type:"string"}]},{name:"updateRegistration",parameters:[{name:"scopeURL",type:"string"}]},{name:"startWorker",parameters:[{name:"scopeURL",type:"string"}]},{name:"skipWaiting",parameters:[{name:"scopeURL",type:"string"}]},{name:"stopWorker",parameters:[{name:"versionId",type:"string"}]},{name:"inspectWorker",parameters:[{name:"versionId",type:"string"}]},{name:"setForceUpdateOnPageLoad",parameters:[{name:"forceUpdateOnPageLoad",type:"boolean"}]},{name:"deliverPushMessage",parameters:[{name:"origin",type:"string"},{name:"registrationId",type:"string"},{name:"data",type:"string"}]},{name:"dispatchSyncEvent",parameters:[{name:"origin",type:"string"},{name:"registrationId",type:"string"},{name:"tag",type:"string"},{name:"lastChance",type:"boolean"}]}],events:[{name:"workerRegistrationUpdated",parameters:[{name:"registrations",type:"array",items:{$ref:"ServiceWorkerRegistration"}}]},{name:"workerVersionUpdated",parameters:[{name:"versions",type:"array",items:{$ref:"ServiceWorkerVersion"}}]},{name:"workerErrorReported",parameters:[{name:"errorMessage",$ref:"ServiceWorkerErrorMessage"}]}]},{domain:"Input",types:[{id:"TouchPoint",type:"object",experimental:!0,properties:[{name:"state",type:"string",enum:["touchPressed","touchReleased","touchMoved","touchStationary","touchCancelled"],description:"State of the touch point."},{name:"x",type:"integer",description:"X coordinate of the event relative to the main frame's viewport."},{name:"y",type:"integer",description:"Y coordinate of the event relative to the main frame's viewport. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport."},{name:"radiusX",type:"integer",optional:!0,description:"X radius of the touch area (default: 1)."},{name:"radiusY",type:"integer",optional:!0,description:"Y radius of the touch area (default: 1)."},{name:"rotationAngle",type:"number",optional:!0,description:"Rotation angle (default: 0.0)."},{name:"force",type:"number",optional:!0,description:"Force (default: 1.0)."},{name:"id",type:"number",optional:!0,description:"Identifier used to track touch sources between events, must be unique within an event."}]},{id:"GestureSourceType",type:"string",experimental:!0,enum:["default","touch","mouse"]}],commands:[{name:"dispatchKeyEvent",parameters:[{name:"type",type:"string",enum:["keyDown","keyUp","rawKeyDown","char"],description:"Type of the key event."},{name:"modifiers",type:"integer",optional:!0,description:"Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0)."},{name:"timestamp",type:"number",optional:!0,description:"Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970 (default: current time)."},{name:"text",type:"string",optional:!0,description:'Text as generated by processing a virtual key code with a keyboard layout. Not needed for for <code>keyUp</code> and <code>rawKeyDown</code> events (default: "")'},{name:"unmodifiedText",type:"string",optional:!0,description:'Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").'},{name:"keyIdentifier",type:"string",optional:!0,description:"Unique key identifier (e.g., 'U+0041') (default: \"\")."},{name:"code",type:"string",optional:!0,description:"Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: \"\")."},{name:"key",type:"string",optional:!0,description:"Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: \"\")."},{name:"windowsVirtualKeyCode",type:"integer",optional:!0,description:"Windows virtual key code (default: 0)."},{name:"nativeVirtualKeyCode",type:"integer",optional:!0,description:"Native virtual key code (default: 0)."},{name:"autoRepeat",type:"boolean",optional:!0,description:"Whether the event was generated from auto repeat (default: false)."},{name:"isKeypad",type:"boolean",optional:!0,description:"Whether the event was generated from the keypad (default: false)."},{name:"isSystemKey",type:"boolean",optional:!0,description:"Whether the event was a system key event (default: false)."}],description:"Dispatches a key event to the page."},{name:"dispatchMouseEvent",parameters:[{name:"type",type:"string",enum:["mousePressed","mouseReleased","mouseMoved"],description:"Type of the mouse event."},{name:"x",type:"integer",description:"X coordinate of the event relative to the main frame's viewport."},{name:"y",type:"integer",description:"Y coordinate of the event relative to the main frame's viewport. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport."},{name:"modifiers",type:"integer",optional:!0,description:"Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0)."},{name:"timestamp",type:"number",optional:!0,description:"Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970 (default: current time)."},{name:"button",type:"string",enum:["none","left","middle","right"],optional:!0,description:'Mouse button (default: "none").'},{name:"clickCount",type:"integer",optional:!0,description:"Number of times the mouse button was clicked (default: 0)."}],description:"Dispatches a mouse event to the page."},{name:"dispatchTouchEvent",experimental:!0,parameters:[{name:"type",type:"string",enum:["touchStart","touchEnd","touchMove"],description:"Type of the touch event."},{name:"touchPoints",type:"array",items:{$ref:"TouchPoint"},description:"Touch points."},{name:"modifiers",type:"integer",optional:!0,description:"Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0)."},{name:"timestamp",type:"number",optional:!0,description:"Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970 (default: current time)."}],description:"Dispatches a touch event to the page."},{name:"emulateTouchFromMouseEvent",experimental:!0,parameters:[{name:"type",type:"string",enum:["mousePressed","mouseReleased","mouseMoved","mouseWheel"],description:"Type of the mouse event."},{name:"x",type:"integer",description:"X coordinate of the mouse pointer in DIP."},{name:"y",type:"integer",description:"Y coordinate of the mouse pointer in DIP."},{name:"timestamp",type:"number",description:"Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970."},{name:"button",type:"string",enum:["none","left","middle","right"],description:"Mouse button."},{name:"deltaX",type:"number",optional:!0,description:"X delta in DIP for mouse wheel event (default: 0)."},{name:"deltaY",type:"number",optional:!0,description:"Y delta in DIP for mouse wheel event (default: 0)."},{name:"modifiers",type:"integer",optional:!0,description:"Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0)."},{name:"clickCount",type:"integer",optional:!0,description:"Number of times the mouse button was clicked (default: 0)."}],description:"Emulates touch event from the mouse event parameters."},{name:"synthesizePinchGesture",parameters:[{name:"x",type:"integer",description:"X coordinate of the start of the gesture in CSS pixels."},{name:"y",type:"integer",description:"Y coordinate of the start of the gesture in CSS pixels."},{name:"scaleFactor",type:"number",description:"Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out)."},{name:"relativeSpeed",type:"integer",optional:!0,description:"Relative pointer speed in pixels per second (default: 800)."},{name:"gestureSourceType",$ref:"GestureSourceType",optional:!0,description:"Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type)."}],description:"Synthesizes a pinch gesture over a time period by issuing appropriate touch events.",experimental:!0},{name:"synthesizeScrollGesture",parameters:[{name:"x",type:"integer",description:"X coordinate of the start of the gesture in CSS pixels."},{name:"y",type:"integer",description:"Y coordinate of the start of the gesture in CSS pixels."},{name:"xDistance",type:"integer",optional:!0,description:"The distance to scroll along the X axis (positive to scroll left)."},{name:"yDistance",type:"integer",optional:!0,description:"The distance to scroll along the Y axis (positive to scroll up)."},{name:"xOverscroll",type:"integer",optional:!0,description:"The number of additional pixels to scroll back along the X axis, in addition to the given distance."},{name:"yOverscroll",type:"integer",optional:!0,description:"The number of additional pixels to scroll back along the Y axis, in addition to the given distance."},{name:"preventFling",type:"boolean",optional:!0,description:"Prevent fling (default: true)."},{name:"speed",type:"integer",optional:!0,description:"Swipe speed in pixels per second (default: 800)."},{name:"gestureSourceType",$ref:"GestureSourceType",optional:!0,description:"Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type)."},{name:"repeatCount",type:"integer",optional:!0,description:"The number of times to repeat the gesture (default: 0)."},{name:"repeatDelayMs",type:"integer",optional:!0,description:"The number of milliseconds delay between each repeat. (default: 250)."},{name:"interactionMarkerName",type:"string",optional:!0,description:'The name of the interaction markers to generate, if not empty (default: "").'}],description:"Synthesizes a scroll gesture over a time period by issuing appropriate touch events.",experimental:!0},{name:"synthesizeTapGesture",parameters:[{name:"x",type:"integer",description:"X coordinate of the start of the gesture in CSS pixels."},{name:"y",type:"integer",description:"Y coordinate of the start of the gesture in CSS pixels."},{name:"duration",type:"integer",optional:!0,description:"Duration between touchdown and touchup events in ms (default: 50)."},{name:"tapCount",type:"integer",optional:!0,description:"Number of times to perform the tap (e.g. 2 for double tap, default: 1)."},{name:"gestureSourceType",$ref:"GestureSourceType",optional:!0,description:"Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type)."}],description:"Synthesizes a tap gesture over a time period by issuing appropriate touch events.",experimental:!0}],events:[]},{domain:"LayerTree",experimental:!0,dependencies:["DOM"],types:[{id:"LayerId",type:"string",description:"Unique Layer identifier."},{id:"SnapshotId",type:"string",description:"Unique snapshot identifier."},{id:"ScrollRect",type:"object",description:"Rectangle where scrolling happens on the main thread.",properties:[{name:"rect",$ref:"DOM.Rect",description:"Rectangle itself."},{name:"type",type:"string",enum:["RepaintsOnScroll","TouchEventHandler","WheelEventHandler"],description:"Reason for rectangle to force scrolling on the main thread"}]},{id:"PictureTile",type:"object",description:"Serialized fragment of layer picture along with its offset within the layer.",properties:[{name:"x",type:"number",description:"Offset from owning layer left boundary"},{name:"y",type:"number",description:"Offset from owning layer top boundary"},{name:"picture",type:"string",description:"Base64-encoded snapshot data."}]},{id:"Layer",type:"object",description:"Information about a compositing layer.",properties:[{name:"layerId",$ref:"LayerId",description:"The unique id for this layer."},{name:"parentLayerId",$ref:"LayerId",optional:!0,description:"The id of parent (not present for root)."},{name:"backendNodeId",$ref:"DOM.BackendNodeId",optional:!0,description:"The backend id for the node associated with this layer."},{name:"offsetX",type:"number",description:"Offset from parent layer, X coordinate."},{name:"offsetY",type:"number",description:"Offset from parent layer, Y coordinate."},{name:"width",type:"number",description:"Layer width."},{name:"height",type:"number",description:"Layer height."},{name:"transform",type:"array",items:{type:"number"},minItems:16,maxItems:16,optional:!0,description:"Transformation matrix for layer, default is identity matrix"},{name:"anchorX",type:"number",optional:!0,description:"Transform anchor point X, absent if no transform specified"},{name:"anchorY",type:"number",optional:!0,description:"Transform anchor point Y, absent if no transform specified"},{name:"anchorZ",type:"number",optional:!0,description:"Transform anchor point Z, absent if no transform specified"},{name:"paintCount",type:"integer",description:"Indicates how many time this layer has painted."},{name:"drawsContent",type:"boolean",description:"Indicates whether this layer hosts any content, rather than being used for transform/scrolling purposes only."},{name:"invisible",type:"boolean",optional:!0,description:"Set if layer is not visible."},{name:"scrollRects",type:"array",items:{$ref:"ScrollRect"},optional:!0,description:"Rectangles scrolling on main thread only."}]},{id:"PaintProfile",type:"array",description:"Array of timings, one per paint step.",items:{type:"number",description:"A time in seconds since the end of previous step (for the first step, time since painting started)"}}],commands:[{name:"enable",description:"Enables compositing tree inspection."},{name:"disable",description:"Disables compositing tree inspection."},{name:"compositingReasons",parameters:[{name:"layerId",$ref:"LayerId",description:"The id of the layer for which we want to get the reasons it was composited."}],description:"Provides the reasons why the given layer was composited.",returns:[{name:"compositingReasons",type:"array",items:{type:"string"},description:"A list of strings specifying reasons for the given layer to become composited."}]},{name:"makeSnapshot",parameters:[{name:"layerId",$ref:"LayerId",description:"The id of the layer."}],description:"Returns the layer snapshot identifier.",returns:[{name:"snapshotId",$ref:"SnapshotId",description:"The id of the layer snapshot."}]},{name:"loadSnapshot",parameters:[{name:"tiles",type:"array",items:{$ref:"PictureTile"},minItems:1,description:"An array of tiles composing the snapshot."}],description:"Returns the snapshot identifier.",returns:[{name:"snapshotId",$ref:"SnapshotId",description:"The id of the snapshot."}]},{name:"releaseSnapshot",parameters:[{name:"snapshotId",$ref:"SnapshotId",description:"The id of the layer snapshot."}],description:"Releases layer snapshot captured by the back-end."},{name:"profileSnapshot",parameters:[{name:"snapshotId",$ref:"SnapshotId",description:"The id of the layer snapshot."},{name:"minRepeatCount",type:"integer",optional:!0,description:"The maximum number of times to replay the snapshot (1, if not specified)."},{name:"minDuration",type:"number",optional:!0,description:"The minimum duration (in seconds) to replay the snapshot."},{name:"clipRect",$ref:"DOM.Rect",optional:!0,description:"The clip rectangle to apply when replaying the snapshot."}],returns:[{name:"timings",type:"array",items:{$ref:"PaintProfile"},description:"The array of paint profiles, one per run."}]},{name:"replaySnapshot",parameters:[{name:"snapshotId",$ref:"SnapshotId",description:"The id of the layer snapshot."},{name:"fromStep",type:"integer",optional:!0,description:"The first step to replay from (replay from the very start if not specified)."},{name:"toStep",type:"integer",optional:!0,description:"The last step to replay to (replay till the end if not specified)."},{name:"scale",type:"number",optional:!0,description:"The scale to apply while replaying (defaults to 1)."}],description:"Replays the layer snapshot and returns the resulting bitmap.",returns:[{name:"dataURL",type:"string",description:"A data: URL for resulting image."}]},{name:"snapshotCommandLog",parameters:[{name:"snapshotId",$ref:"SnapshotId",description:"The id of the layer snapshot."}],description:"Replays the layer snapshot and returns canvas log.",returns:[{name:"commandLog",type:"array",items:{type:"object"},description:"The array of canvas function calls."}]}],events:[{name:"layerTreeDidChange",parameters:[{name:"layers",type:"array",items:{$ref:"Layer"},optional:!0,description:"Layer tree, absent if not in the comspositing mode."}]},{name:"layerPainted",parameters:[{name:"layerId",$ref:"LayerId",description:"The id of the painted layer."},{name:"clip",$ref:"DOM.Rect",description:"Clip rectangle."}]}]},{domain:"DeviceOrientation",experimental:!0,commands:[{name:"setDeviceOrientationOverride",description:"Overrides the Device Orientation.",parameters:[{name:"alpha",type:"number",description:"Mock alpha"},{name:"beta",type:"number",description:"Mock beta"},{name:"gamma",type:"number",description:"Mock gamma"}]},{name:"clearDeviceOrientationOverride",description:"Clears the overridden Device Orientation."}]},{domain:"Tracing",dependencies:["IO"],experimental:!0,types:[{id:"MemoryDumpConfig",type:"object",description:'Configuration for memory dump. Used only when "memory-infra" category is enabled.'},{id:"TraceConfig",type:"object",properties:[{name:"recordMode",type:"string",optional:!0,enum:["recordUntilFull","recordContinuously","recordAsMuchAsPossible","echoToConsole"],description:"Controls how the trace buffer stores data."},{name:"enableSampling",type:"boolean",optional:!0,description:"Turns on JavaScript stack sampling."},{name:"enableSystrace",type:"boolean",optional:!0,description:"Turns on system tracing."},{name:"enableArgumentFilter",type:"boolean",optional:!0,description:"Turns on argument filter."},{name:"includedCategories",type:"array",items:{type:"string"},optional:!0,description:"Included category filters."},{name:"excludedCategories",type:"array",items:{type:"string"},optional:!0,description:"Excluded category filters."},{name:"syntheticDelays",type:"array",items:{type:"string"},optional:!0,description:"Configuration to synthesize the delays in tracing."},{name:"memoryDumpConfig",$ref:"MemoryDumpConfig",optional:!0,description:'Configuration for memory dump triggers. Used only when "memory-infra" category is enabled.'}]}],commands:[{name:"start",description:"Start trace events collection.",parameters:[{name:"categories",type:"string",optional:!0,deprecated:!0,description:"Category/tag filter"},{name:"options",type:"string",optional:!0,deprecated:!0,description:"Tracing options"},{name:"bufferUsageReportingInterval",type:"number",optional:!0,description:"If set, the agent will issue bufferUsage events at this interval, specified in milliseconds"},{name:"transferMode",type:"string",enum:["ReportEvents","ReturnAsStream"],optional:!0,description:"Whether to report trace events as series of dataCollected events or to save trace to a stream (defaults to <code>ReportEvents</code>)."},{name:"traceConfig",$ref:"TraceConfig",optional:!0,description:""}]},{name:"end",description:"Stop trace events collection."},{name:"getCategories",description:"Gets supported tracing categories.",
	returns:[{name:"categories",type:"array",items:{type:"string"},description:"A list of supported tracing categories."}]},{name:"requestMemoryDump",description:"Request a global memory dump.",returns:[{name:"dumpGuid",type:"string",description:"GUID of the resulting global memory dump."},{name:"success",type:"boolean",description:"True iff the global memory dump succeeded."}]},{name:"recordClockSyncMarker",description:"Record a clock sync marker in the trace.",parameters:[{name:"syncId",type:"string",description:"The ID of this clock sync marker"}]}],events:[{name:"dataCollected",parameters:[{name:"value",type:"array",items:{type:"object"}}],description:"Contains an bucket of collected trace events. When tracing is stopped collected events will be send as a sequence of dataCollected events followed by tracingComplete event."},{name:"tracingComplete",description:"Signals that tracing is stopped and there is no trace buffers pending flush, all data were delivered via dataCollected events.",parameters:[{name:"stream",$ref:"IO.StreamHandle",optional:!0,description:"A handle of the stream that holds resulting trace data."}]},{name:"bufferUsage",parameters:[{name:"percentFull",type:"number",optional:!0,description:"A number in range [0..1] that indicates the used size of event buffer as a fraction of its total size."},{name:"eventCount",type:"number",optional:!0,description:"An approximate number of events in the trace log."},{name:"value",type:"number",optional:!0,description:"A number in range [0..1] that indicates the used size of event buffer as a fraction of its total size."}]}]},{domain:"Animation",experimental:!0,dependencies:["Runtime","DOM"],types:[{id:"Animation",type:"object",experimental:!0,properties:[{name:"id",type:"string",description:"<code>Animation</code>'s id."},{name:"name",type:"string",description:"<code>Animation</code>'s name."},{name:"pausedState",type:"boolean",experimental:!0,description:"<code>Animation</code>'s internal paused state."},{name:"playState",type:"string",description:"<code>Animation</code>'s play state."},{name:"playbackRate",type:"number",description:"<code>Animation</code>'s playback rate."},{name:"startTime",type:"number",description:"<code>Animation</code>'s start time."},{name:"currentTime",type:"number",description:"<code>Animation</code>'s current time."},{name:"source",$ref:"AnimationEffect",description:"<code>Animation</code>'s source animation node."},{name:"type",type:"string",enum:["CSSTransition","CSSAnimation","WebAnimation"],description:"Animation type of <code>Animation</code>."},{name:"cssId",type:"string",optional:!0,description:"A unique ID for <code>Animation</code> representing the sources that triggered this CSS animation/transition."}],description:"Animation instance."},{id:"AnimationEffect",type:"object",experimental:!0,properties:[{name:"delay",type:"number",description:"<code>AnimationEffect</code>'s delay."},{name:"endDelay",type:"number",description:"<code>AnimationEffect</code>'s end delay."},{name:"iterationStart",type:"number",description:"<code>AnimationEffect</code>'s iteration start."},{name:"iterations",type:"number",description:"<code>AnimationEffect</code>'s iterations."},{name:"duration",type:"number",description:"<code>AnimationEffect</code>'s iteration duration."},{name:"direction",type:"string",description:"<code>AnimationEffect</code>'s playback direction."},{name:"fill",type:"string",description:"<code>AnimationEffect</code>'s fill mode."},{name:"backendNodeId",$ref:"DOM.BackendNodeId",description:"<code>AnimationEffect</code>'s target node."},{name:"keyframesRule",$ref:"KeyframesRule",optional:!0,description:"<code>AnimationEffect</code>'s keyframes."},{name:"easing",type:"string",description:"<code>AnimationEffect</code>'s timing function."}],description:"AnimationEffect instance"},{id:"KeyframesRule",type:"object",properties:[{name:"name",type:"string",optional:!0,description:"CSS keyframed animation's name."},{name:"keyframes",type:"array",items:{$ref:"KeyframeStyle"},description:"List of animation keyframes."}],description:"Keyframes Rule"},{id:"KeyframeStyle",type:"object",properties:[{name:"offset",type:"string",description:"Keyframe's time offset."},{name:"easing",type:"string",description:"<code>AnimationEffect</code>'s timing function."}],description:"Keyframe Style"}],commands:[{name:"enable",description:"Enables animation domain notifications."},{name:"disable",description:"Disables animation domain notifications."},{name:"getPlaybackRate",returns:[{name:"playbackRate",type:"number",description:"Playback rate for animations on page."}],description:"Gets the playback rate of the document timeline."},{name:"setPlaybackRate",parameters:[{name:"playbackRate",type:"number",description:"Playback rate for animations on page"}],description:"Sets the playback rate of the document timeline."},{name:"getCurrentTime",parameters:[{name:"id",type:"string",description:"Id of animation."}],returns:[{name:"currentTime",type:"number",description:"Current time of the page."}],description:"Returns the current time of the an animation."},{name:"setPaused",parameters:[{name:"animations",type:"array",items:{type:"string"},description:"Animations to set the pause state of."},{name:"paused",type:"boolean",description:"Paused state to set to."}],description:"Sets the paused state of a set of animations."},{name:"setTiming",parameters:[{name:"animationId",type:"string",description:"Animation id."},{name:"duration",type:"number",description:"Duration of the animation."},{name:"delay",type:"number",description:"Delay of the animation."}],description:"Sets the timing of an animation node."},{name:"seekAnimations",parameters:[{name:"animations",type:"array",items:{type:"string"},description:"List of animation ids to seek."},{name:"currentTime",type:"number",description:"Set the current time of each animation."}],description:"Seek a set of animations to a particular time within each animation."},{name:"releaseAnimations",parameters:[{name:"animations",type:"array",items:{type:"string"},description:"List of animation ids to seek."}],description:"Releases a set of animations to no longer be manipulated."},{name:"resolveAnimation",parameters:[{name:"animationId",type:"string",description:"Animation id."}],returns:[{name:"remoteObject",$ref:"Runtime.RemoteObject",description:"Corresponding remote object."}],description:"Gets the remote object of the Animation."}],events:[{name:"animationCreated",parameters:[{name:"id",type:"string",description:"Id of the animation that was created."}],description:"Event for each animation that has been created."},{name:"animationStarted",parameters:[{name:"animation",$ref:"Animation",description:"Animation that was started."}],description:"Event for animation that has been started."},{name:"animationCanceled",parameters:[{name:"id",type:"string",description:"Id of the animation that was cancelled."}],description:"Event for when an animation has been cancelled."}]},{domain:"Accessibility",experimental:!0,dependencies:["DOM"],types:[{id:"AXNodeId",type:"string",description:"Unique accessibility node identifier."},{id:"AXValueType",type:"string",enum:["boolean","tristate","booleanOrUndefined","idref","idrefList","integer","node","nodeList","number","string","computedString","token","tokenList","domRelation","role","internalRole","valueUndefined"],description:"Enum of possible property types."},{id:"AXValueSourceType",type:"string",enum:["attribute","implicit","style","contents","placeholder","relatedElement"],description:"Enum of possible property sources."},{id:"AXValueNativeSourceType",type:"string",enum:["figcaption","label","labelfor","labelwrapped","legend","tablecaption","title","other"],description:"Enum of possible native property sources (as a subtype of a particular AXValueSourceType)."},{id:"AXValueSource",type:"object",properties:[{name:"type",$ref:"AXValueSourceType",description:"What type of source this is."},{name:"value",$ref:"AXValue",description:"The value of this property source.",optional:!0},{name:"attribute",type:"string",description:"The name of the relevant attribute, if any.",optional:!0},{name:"attributeValue",$ref:"AXValue",description:"The value of the relevant attribute, if any.",optional:!0},{name:"superseded",type:"boolean",description:"Whether this source is superseded by a higher priority source.",optional:!0},{name:"nativeSource",$ref:"AXValueNativeSourceType",description:"The native markup source for this value, e.g. a <label> element.",optional:!0},{name:"nativeSourceValue",$ref:"AXValue",description:"The value, such as a node or node list, of the native source.",optional:!0},{name:"invalid",type:"boolean",description:"Whether the value for this property is invalid.",optional:!0},{name:"invalidReason",type:"string",description:"Reason for the value being invalid, if it is.",optional:!0}],description:"A single source for a computed AX property."},{id:"AXRelatedNode",type:"object",properties:[{name:"backendDOMNodeId",$ref:"DOM.BackendNodeId",description:"The BackendNodeId of the related DOM node."},{name:"idref",type:"string",description:"The IDRef value provided, if any.",optional:!0},{name:"text",type:"string",description:"The text alternative of this node in the current context.",optional:!0}]},{id:"AXProperty",type:"object",properties:[{name:"name",type:"string",description:"The name of this property."},{name:"value",$ref:"AXValue",description:"The value of this property."}]},{id:"AXValue",type:"object",properties:[{name:"type",$ref:"AXValueType",description:"The type of this value."},{name:"value",type:"any",description:"The computed value of this property.",optional:!0},{name:"relatedNodes",type:"array",items:{$ref:"AXRelatedNode"},description:"One or more related nodes, if applicable.",optional:!0},{name:"sources",type:"array",items:{$ref:"AXValueSource"},description:"The sources which contributed to the computation of this property.",optional:!0}],description:"A single computed AX property."},{id:"AXGlobalStates",type:"string",enum:["disabled","hidden","hiddenRoot","invalid"],description:"States which apply to every AX node."},{id:"AXLiveRegionAttributes",type:"string",enum:["live","atomic","relevant","busy","root"],description:"Attributes which apply to nodes in live regions."},{id:"AXWidgetAttributes",type:"string",enum:["autocomplete","haspopup","level","multiselectable","orientation","multiline","readonly","required","valuemin","valuemax","valuetext"],description:"Attributes which apply to widgets."},{id:"AXWidgetStates",type:"string",enum:["checked","expanded","pressed","selected"],description:"States which apply to widgets."},{id:"AXRelationshipAttributes",type:"string",enum:["activedescendant","flowto","controls","describedby","labelledby","owns"],description:"Relationships between elements other than parent/child/sibling."},{id:"AXNode",type:"object",properties:[{name:"nodeId",$ref:"AXNodeId",description:"Unique identifier for this node."},{name:"ignored",type:"boolean",description:"Whether this node is ignored for accessibility"},{name:"ignoredReasons",type:"array",items:{$ref:"AXProperty"},description:"Collection of reasons why this node is hidden.",optional:!0},{name:"role",$ref:"AXValue",description:"This <code>Node</code>'s role, whether explicit or implicit.",optional:!0},{name:"name",$ref:"AXValue",description:"The accessible name for this <code>Node</code>.",optional:!0},{name:"description",$ref:"AXValue",description:"The accessible description for this <code>Node</code>.",optional:!0},{name:"value",$ref:"AXValue",description:"The value for this <code>Node</code>.",optional:!0},{name:"properties",type:"array",items:{$ref:"AXProperty"},description:"All other properties",optional:!0},{name:"childIds",type:"array",items:{$ref:"AXNodeId"},description:"IDs for each of this node's child nodes.",optional:!0},{name:"backendDOMNodeId",$ref:"DOM.BackendNodeId",description:"The backend ID for the associated DOM node, if any.",optional:!0}],description:"A node in the accessibility tree."}],commands:[{name:"getPartialAXTree",parameters:[{name:"nodeId",$ref:"DOM.NodeId",description:"ID of node to get the partial accessibility tree for."},{name:"fetchRelatives",type:"boolean",description:"Whether to fetch this nodes ancestors, siblings and children. Defaults to true.",optional:!0}],returns:[{name:"nodes",type:"array",items:{$ref:"AXNode"},description:"The <code>Accessibility.AXNode</code> for this DOM node, if it exists, plus its ancestors, siblings and children, if requested."}],description:"Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.",experimental:!0}]},{domain:"Storage",experimental:!0,types:[{id:"StorageType",type:"string",enum:["appcache","cookies","file_systems","indexeddb","local_storage","shader_cache","websql","service_workers","cache_storage","all"],description:"Enum of possible storage types."}],commands:[{name:"clearDataForOrigin",parameters:[{name:"origin",type:"string",description:"Security origin."},{name:"storageTypes",type:"string",description:"Comma separated origin names."}],description:"Clears storage for origin."}]},{domain:"Log",description:"Provides access to log entries.",dependencies:["Runtime","Network"],experimental:!0,types:[{id:"LogEntry",type:"object",description:"Log entry.",properties:[{name:"source",type:"string",enum:["xml","javascript","network","storage","appcache","rendering","security","deprecation","worker","violation","other"],description:"Log entry source."},{name:"level",type:"string",enum:["log","warning","error","debug","info"],description:"Log entry severity."},{name:"text",type:"string",description:"Logged text."},{name:"timestamp",$ref:"Runtime.Timestamp",description:"Timestamp when this entry was added."},{name:"url",type:"string",optional:!0,description:"URL of the resource if known."},{name:"lineNumber",type:"integer",optional:!0,description:"Line number in the resource."},{name:"stackTrace",$ref:"Runtime.StackTrace",optional:!0,description:"JavaScript stack trace."},{name:"networkRequestId",$ref:"Network.RequestId",optional:!0,description:"Identifier of the network request associated with this entry."},{name:"workerId",type:"string",optional:!0,description:"Identifier of the worker associated with this entry."}]},{id:"ViolationSetting",type:"object",description:"Violation configuration setting.",properties:[{name:"name",type:"string",enum:["longTask","longLayout","blockedEvent","blockedParser","handler","recurringHandler"],description:"Violation type."},{name:"threshold",type:"number",description:"Time threshold to trigger upon."}]}],commands:[{name:"enable",description:"Enables log domain, sends the entries collected so far to the client by means of the <code>entryAdded</code> notification."},{name:"disable",description:"Disables log domain, prevents further log entries from being reported to the client."},{name:"clear",description:"Clears the log."},{name:"startViolationsReport",parameters:[{name:"config",type:"array",items:{$ref:"ViolationSetting"},description:"Configuration for violations."}],description:"start violation reporting."},{name:"stopViolationsReport",description:"Stop violation reporting."}],events:[{name:"entryAdded",parameters:[{name:"entry",$ref:"LogEntry",description:"The entry."}],description:"Issued when new message was logged."}]},{domain:"SystemInfo",description:"The SystemInfo domain defines methods and events for querying low-level system information.",experimental:!0,types:[{id:"GPUDevice",type:"object",properties:[{name:"vendorId",type:"number",description:"PCI ID of the GPU vendor, if available; 0 otherwise."},{name:"deviceId",type:"number",description:"PCI ID of the GPU device, if available; 0 otherwise."},{name:"vendorString",type:"string",description:"String description of the GPU vendor, if the PCI ID is not available."},{name:"deviceString",type:"string",description:"String description of the GPU device, if the PCI ID is not available."}],description:"Describes a single graphics processor (GPU)."},{id:"GPUInfo",type:"object",properties:[{name:"devices",type:"array",items:{$ref:"GPUDevice"},description:"The graphics devices on the system. Element 0 is the primary GPU."},{name:"auxAttributes",type:"object",optional:!0,description:"An optional dictionary of additional GPU related attributes."},{name:"featureStatus",type:"object",optional:!0,description:"An optional dictionary of graphics features and their status."},{name:"driverBugWorkarounds",type:"array",items:{type:"string"},description:"An optional array of GPU driver bug workarounds."}],description:"Provides information about the GPU(s) on the system."}],commands:[{name:"getInfo",description:"Returns information about the system.",returns:[{name:"gpu",$ref:"GPUInfo",description:"Information about the GPUs on the system."},{name:"modelName",type:"string",description:"A platform-dependent description of the model of the machine. On Mac OS, this is, for example, 'MacBookPro'. Will be the empty string if not supported."},{name:"modelVersion",type:"string",description:"A platform-dependent description of the version of the machine. On Mac OS, this is, for example, '10.1'. Will be the empty string if not supported."}]}]},{domain:"Tethering",description:"The Tethering domain defines methods and events for browser port binding.",experimental:!0,commands:[{name:"bind",description:"Request browser port binding.",parameters:[{name:"port",type:"integer",description:"Port number to bind."}]},{name:"unbind",description:"Request browser port unbinding.",parameters:[{name:"port",type:"integer",description:"Port number to unbind."}]}],events:[{name:"accepted",description:"Informs that port was successfully bound and got a specified connection id.",parameters:[{name:"port",type:"integer",description:"Port number that was successfully bound."},{name:"connectionId",type:"string",description:"Connection id to be used."}]}]},{domain:"Schema",description:"Provides information about the protocol schema.",types:[{id:"Domain",type:"object",description:"Description of the protocol domain.",exported:!0,properties:[{name:"name",type:"string",description:"Domain name."},{name:"version",type:"string",description:"Domain version."}]}],commands:[{name:"getDomains",description:"Returns supported domains.",handlers:["browser","renderer"],returns:[{name:"domains",type:"array",items:{$ref:"Domain"},description:"List of supported domains."}]}]},{domain:"Runtime",description:"Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects. Evaluation results are returned as mirror object that expose object type, string representation and unique identifier that can be used for further object reference. Original objects are maintained in memory unless they are either explicitly released or are released along with the other objects in their object group.",types:[{id:"ScriptId",type:"string",description:"Unique script identifier."},{id:"RemoteObjectId",type:"string",description:"Unique object identifier."},{id:"UnserializableValue",type:"string",enum:["Infinity","NaN","-Infinity","-0"],description:"Primitive value which cannot be JSON-stringified."},{id:"RemoteObject",type:"object",description:"Mirror object referencing original JavaScript object.",exported:!0,properties:[{name:"type",type:"string",enum:["object","function","undefined","string","number","boolean","symbol"],description:"Object type."},{name:"subtype",type:"string",optional:!0,enum:["array","null","node","regexp","date","map","set","iterator","generator","error","proxy","promise","typedarray"],description:"Object subtype hint. Specified for <code>object</code> type values only."},{name:"className",type:"string",optional:!0,description:"Object class (constructor) name. Specified for <code>object</code> type values only."},{name:"value",type:"any",optional:!0,description:"Remote object value in case of primitive values or JSON values (if it was requested)."},{name:"unserializableValue",$ref:"UnserializableValue",optional:!0,description:"Primitive value which can not be JSON-stringified does not have <code>value</code>, but gets this property."},{name:"description",type:"string",optional:!0,description:"String representation of the object."},{name:"objectId",$ref:"RemoteObjectId",optional:!0,description:"Unique object identifier (for non-primitive values)."},{name:"preview",$ref:"ObjectPreview",optional:!0,description:"Preview containing abbreviated property values. Specified for <code>object</code> type values only.",experimental:!0},{name:"customPreview",$ref:"CustomPreview",optional:!0,experimental:!0}]},{id:"CustomPreview",type:"object",experimental:!0,properties:[{name:"header",type:"string"},{name:"hasBody",type:"boolean"},{name:"formatterObjectId",$ref:"RemoteObjectId"},{name:"bindRemoteObjectFunctionId",$ref:"RemoteObjectId"},{name:"configObjectId",$ref:"RemoteObjectId",optional:!0}]},{id:"ObjectPreview",type:"object",experimental:!0,description:"Object containing abbreviated remote object value.",properties:[{name:"type",type:"string",enum:["object","function","undefined","string","number","boolean","symbol"],description:"Object type."},{name:"subtype",type:"string",optional:!0,enum:["array","null","node","regexp","date","map","set","iterator","generator","error"],description:"Object subtype hint. Specified for <code>object</code> type values only."},{name:"description",type:"string",optional:!0,description:"String representation of the object."},{name:"overflow",type:"boolean",description:"True iff some of the properties or entries of the original object did not fit."},{name:"properties",type:"array",items:{$ref:"PropertyPreview"},description:"List of the properties."},{name:"entries",type:"array",items:{$ref:"EntryPreview"},optional:!0,description:"List of the entries. Specified for <code>map</code> and <code>set</code> subtype values only."}]},{id:"PropertyPreview",type:"object",experimental:!0,properties:[{name:"name",type:"string",description:"Property name."},{name:"type",type:"string",enum:["object","function","undefined","string","number","boolean","symbol","accessor"],description:"Object type. Accessor means that the property itself is an accessor property."},{name:"value",type:"string",optional:!0,description:"User-friendly property value string."},{name:"valuePreview",$ref:"ObjectPreview",optional:!0,description:"Nested value preview."},{name:"subtype",type:"string",optional:!0,enum:["array","null","node","regexp","date","map","set","iterator","generator","error"],description:"Object subtype hint. Specified for <code>object</code> type values only."}]},{id:"EntryPreview",type:"object",experimental:!0,properties:[{name:"key",$ref:"ObjectPreview",optional:!0,description:"Preview of the key. Specified for map-like collection entries."},{name:"value",$ref:"ObjectPreview",description:"Preview of the value."}]},{id:"PropertyDescriptor",type:"object",description:"Object property descriptor.",properties:[{name:"name",type:"string",description:"Property name or symbol description."},{name:"value",$ref:"RemoteObject",optional:!0,description:"The value associated with the property."},{name:"writable",type:"boolean",optional:!0,description:"True if the value associated with the property may be changed (data descriptors only)."},{name:"get",$ref:"RemoteObject",optional:!0,description:"A function which serves as a getter for the property, or <code>undefined</code> if there is no getter (accessor descriptors only)."},{name:"set",$ref:"RemoteObject",optional:!0,description:"A function which serves as a setter for the property, or <code>undefined</code> if there is no setter (accessor descriptors only)."},{name:"configurable",type:"boolean",description:"True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object."},{name:"enumerable",type:"boolean",description:"True if this property shows up during enumeration of the properties on the corresponding object."},{name:"wasThrown",type:"boolean",optional:!0,description:"True if the result was thrown during the evaluation."},{name:"isOwn",optional:!0,type:"boolean",description:"True if the property is owned for the object."},{name:"symbol",$ref:"RemoteObject",optional:!0,description:"Property symbol object, if the property is of the <code>symbol</code> type."}]},{id:"InternalPropertyDescriptor",type:"object",description:"Object internal property descriptor. This property isn't normally visible in JavaScript code.",properties:[{name:"name",type:"string",description:"Conventional property name."},{name:"value",$ref:"RemoteObject",optional:!0,description:"The value associated with the property."}]},{id:"CallArgument",type:"object",description:"Represents function call argument. Either remote object id <code>objectId</code>, primitive <code>value</code>, unserializable primitive value or neither of (for undefined) them should be specified.",properties:[{name:"value",type:"any",optional:!0,description:"Primitive value."},{name:"unserializableValue",$ref:"UnserializableValue",optional:!0,description:"Primitive value which can not be JSON-stringified."},{name:"objectId",$ref:"RemoteObjectId",optional:!0,description:"Remote object handle."}]},{id:"ExecutionContextId",type:"integer",description:"Id of an execution context."},{id:"ExecutionContextDescription",type:"object",description:"Description of an isolated world.",properties:[{name:"id",$ref:"ExecutionContextId",description:"Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed."},{name:"origin",type:"string",description:"Execution context origin."},{name:"name",type:"string",description:"Human readable name describing given context."},{name:"auxData",type:"object",optional:!0,description:"Embedder-specific auxiliary data."}]},{id:"ExceptionDetails",type:"object",description:"Detailed information about exception (or error) that was thrown during script compilation or execution.",properties:[{name:"exceptionId",type:"integer",description:"Exception id."},{name:"text",type:"string",description:"Exception text, which should be used together with exception object when available."},{name:"lineNumber",type:"integer",description:"Line number of the exception location (0-based)."},{name:"columnNumber",type:"integer",description:"Column number of the exception location (0-based)."},{name:"scriptId",$ref:"ScriptId",optional:!0,description:"Script ID of the exception location."},{name:"url",type:"string",optional:!0,description:"URL of the exception location, to be used when the script was not reported."},{name:"stackTrace",$ref:"StackTrace",optional:!0,description:"JavaScript stack trace if available."},{name:"exception",$ref:"RemoteObject",optional:!0,description:"Exception object if available."},{name:"executionContextId",$ref:"ExecutionContextId",optional:!0,description:"Identifier of the context where exception happened."}]},{id:"Timestamp",type:"number",description:"Number of milliseconds since epoch."},{id:"CallFrame",type:"object",description:"Stack entry for runtime errors and assertions.",properties:[{name:"functionName",type:"string",description:"JavaScript function name."},{name:"scriptId",$ref:"ScriptId",description:"JavaScript script id."},{name:"url",type:"string",description:"JavaScript script name or url."},{name:"lineNumber",type:"integer",description:"JavaScript script line number (0-based)."},{name:"columnNumber",type:"integer",description:"JavaScript script column number (0-based)."}]},{id:"StackTrace",type:"object",description:"Call frames for assertions or error messages.",exported:!0,properties:[{name:"description",type:"string",optional:!0,description:"String label of this stack trace. For async traces this may be a name of the function that initiated the async call."},{name:"callFrames",type:"array",items:{$ref:"CallFrame"},description:"JavaScript function name."},{name:"parent",$ref:"StackTrace",optional:!0,description:"Asynchronous JavaScript stack trace that preceded this stack, if available."}]}],commands:[{name:"evaluate",parameters:[{name:"expression",type:"string",description:"Expression to evaluate."},{name:"objectGroup",type:"string",optional:!0,description:"Symbolic group name that can be used to release multiple objects."},{name:"includeCommandLineAPI",type:"boolean",optional:!0,description:"Determines whether Command Line API should be available during the evaluation."},{name:"silent",type:"boolean",optional:!0,description:"In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state."},{name:"contextId",$ref:"ExecutionContextId",optional:!0,description:"Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page."},{name:"returnByValue",type:"boolean",optional:!0,description:"Whether the result is expected to be a JSON object that should be sent by value."},{name:"generatePreview",type:"boolean",optional:!0,experimental:!0,description:"Whether preview should be generated for the result."},{name:"userGesture",type:"boolean",optional:!0,experimental:!0,description:"Whether execution should be treated as initiated by user in the UI."},{name:"awaitPromise",type:"boolean",optional:!0,description:"Whether execution should wait for promise to be resolved. If the result of evaluation is not a Promise, it's considered to be an error."}],returns:[{name:"result",$ref:"RemoteObject",description:"Evaluation result."},{name:"exceptionDetails",$ref:"ExceptionDetails",optional:!0,description:"Exception details."}],description:"Evaluates expression on global object."},{name:"awaitPromise",parameters:[{name:"promiseObjectId",$ref:"RemoteObjectId",description:"Identifier of the promise."},{name:"returnByValue",type:"boolean",optional:!0,description:"Whether the result is expected to be a JSON object that should be sent by value."},{name:"generatePreview",type:"boolean",optional:!0,description:"Whether preview should be generated for the result."}],returns:[{name:"result",$ref:"RemoteObject",description:"Promise result. Will contain rejected value if promise was rejected."},{name:"exceptionDetails",$ref:"ExceptionDetails",optional:!0,description:"Exception details if stack strace is available."}],description:"Add handler to promise with given promise object id."},{name:"callFunctionOn",parameters:[{name:"objectId",$ref:"RemoteObjectId",description:"Identifier of the object to call function on."},{name:"functionDeclaration",type:"string",description:"Declaration of the function to call."},{name:"arguments",type:"array",items:{$ref:"CallArgument",description:"Call argument."},optional:!0,description:"Call arguments. All call arguments must belong to the same JavaScript world as the target object."},{name:"silent",type:"boolean",optional:!0,description:"In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state."},{name:"returnByValue",type:"boolean",optional:!0,description:"Whether the result is expected to be a JSON object which should be sent by value."},{name:"generatePreview",type:"boolean",optional:!0,experimental:!0,description:"Whether preview should be generated for the result."},{name:"userGesture",type:"boolean",optional:!0,experimental:!0,description:"Whether execution should be treated as initiated by user in the UI."},{name:"awaitPromise",type:"boolean",optional:!0,description:"Whether execution should wait for promise to be resolved. If the result of evaluation is not a Promise, it's considered to be an error."}],returns:[{name:"result",$ref:"RemoteObject",description:"Call result."},{name:"exceptionDetails",$ref:"ExceptionDetails",optional:!0,description:"Exception details."}],description:"Calls function with given declaration on the given object. Object group of the result is inherited from the target object."
	},{name:"getProperties",parameters:[{name:"objectId",$ref:"RemoteObjectId",description:"Identifier of the object to return properties for."},{name:"ownProperties",optional:!0,type:"boolean",description:"If true, returns properties belonging only to the element itself, not to its prototype chain."},{name:"accessorPropertiesOnly",optional:!0,type:"boolean",description:"If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.",experimental:!0},{name:"generatePreview",type:"boolean",optional:!0,experimental:!0,description:"Whether preview should be generated for the results."}],returns:[{name:"result",type:"array",items:{$ref:"PropertyDescriptor"},description:"Object properties."},{name:"internalProperties",optional:!0,type:"array",items:{$ref:"InternalPropertyDescriptor"},description:"Internal object properties (only of the element itself)."},{name:"exceptionDetails",$ref:"ExceptionDetails",optional:!0,description:"Exception details."}],description:"Returns properties of a given object. Object group of the result is inherited from the target object."},{name:"releaseObject",parameters:[{name:"objectId",$ref:"RemoteObjectId",description:"Identifier of the object to release."}],description:"Releases remote object with given id."},{name:"releaseObjectGroup",parameters:[{name:"objectGroup",type:"string",description:"Symbolic object group name."}],description:"Releases all remote objects that belong to a given group."},{name:"runIfWaitingForDebugger",description:"Tells inspected instance to run if it was waiting for debugger to attach."},{name:"enable",description:"Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context."},{name:"disable",description:"Disables reporting of execution contexts creation."},{name:"discardConsoleEntries",description:"Discards collected exceptions and console API calls."},{name:"setCustomObjectFormatterEnabled",parameters:[{name:"enabled",type:"boolean"}],experimental:!0},{name:"compileScript",parameters:[{name:"expression",type:"string",description:"Expression to compile."},{name:"sourceURL",type:"string",description:"Source url to be set for the script."},{name:"persistScript",type:"boolean",description:"Specifies whether the compiled script should be persisted."},{name:"executionContextId",$ref:"ExecutionContextId",optional:!0,description:"Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page."}],returns:[{name:"scriptId",$ref:"ScriptId",optional:!0,description:"Id of the script."},{name:"exceptionDetails",$ref:"ExceptionDetails",optional:!0,description:"Exception details."}],description:"Compiles expression."},{name:"runScript",parameters:[{name:"scriptId",$ref:"ScriptId",description:"Id of the script to run."},{name:"executionContextId",$ref:"ExecutionContextId",optional:!0,description:"Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page."},{name:"objectGroup",type:"string",optional:!0,description:"Symbolic group name that can be used to release multiple objects."},{name:"silent",type:"boolean",optional:!0,description:"In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state."},{name:"includeCommandLineAPI",type:"boolean",optional:!0,description:"Determines whether Command Line API should be available during the evaluation."},{name:"returnByValue",type:"boolean",optional:!0,description:"Whether the result is expected to be a JSON object which should be sent by value."},{name:"generatePreview",type:"boolean",optional:!0,description:"Whether preview should be generated for the result."},{name:"awaitPromise",type:"boolean",optional:!0,description:"Whether execution should wait for promise to be resolved. If the result of evaluation is not a Promise, it's considered to be an error."}],returns:[{name:"result",$ref:"RemoteObject",description:"Run result."},{name:"exceptionDetails",$ref:"ExceptionDetails",optional:!0,description:"Exception details."}],description:"Runs script with given id in a given context."}],events:[{name:"executionContextCreated",parameters:[{name:"context",$ref:"ExecutionContextDescription",description:"A newly created execution contex."}],description:"Issued when new execution context is created."},{name:"executionContextDestroyed",parameters:[{name:"executionContextId",$ref:"ExecutionContextId",description:"Id of the destroyed context"}],description:"Issued when execution context is destroyed."},{name:"executionContextsCleared",description:"Issued when all executionContexts were cleared in browser"},{name:"exceptionThrown",description:"Issued when exception was thrown and unhandled.",parameters:[{name:"timestamp",$ref:"Timestamp",description:"Timestamp of the exception."},{name:"exceptionDetails",$ref:"ExceptionDetails"}]},{name:"exceptionRevoked",description:"Issued when unhandled exception was revoked.",parameters:[{name:"reason",type:"string",description:"Reason describing why exception was revoked."},{name:"exceptionId",type:"integer",description:"The id of revoked exception, as reported in <code>exceptionUnhandled</code>."}]},{name:"consoleAPICalled",description:"Issued when console API was called.",parameters:[{name:"type",type:"string",enum:["log","debug","info","error","warning","dir","dirxml","table","trace","clear","startGroup","startGroupCollapsed","endGroup","assert","profile","profileEnd"],description:"Type of the call."},{name:"args",type:"array",items:{$ref:"RemoteObject"},description:"Call arguments."},{name:"executionContextId",$ref:"ExecutionContextId",description:"Identifier of the context where the call was made."},{name:"timestamp",$ref:"Timestamp",description:"Call timestamp."},{name:"stackTrace",$ref:"StackTrace",optional:!0,description:"Stack trace captured when the call was made."}]},{name:"inspectRequested",description:"Issued when object should be inspected (for example, as a result of inspect() command line API call).",parameters:[{name:"object",$ref:"RemoteObject"},{name:"hints",type:"object"}]}]},{domain:"Debugger",description:"Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing breakpoints, stepping through execution, exploring stack traces, etc.",dependencies:["Runtime"],types:[{id:"BreakpointId",type:"string",description:"Breakpoint identifier."},{id:"CallFrameId",type:"string",description:"Call frame identifier."},{id:"Location",type:"object",properties:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Script identifier as reported in the <code>Debugger.scriptParsed</code>."},{name:"lineNumber",type:"integer",description:"Line number in the script (0-based)."},{name:"columnNumber",type:"integer",optional:!0,description:"Column number in the script (0-based)."}],description:"Location in the source code."},{id:"ScriptPosition",experimental:!0,type:"object",properties:[{name:"lineNumber",type:"integer"},{name:"columnNumber",type:"integer"}],description:"Location in the source code."},{id:"CallFrame",type:"object",properties:[{name:"callFrameId",$ref:"CallFrameId",description:"Call frame identifier. This identifier is only valid while the virtual machine is paused."},{name:"functionName",type:"string",description:"Name of the JavaScript function called on this call frame."},{name:"functionLocation",$ref:"Location",optional:!0,experimental:!0,description:"Location in the source code."},{name:"location",$ref:"Location",description:"Location in the source code."},{name:"scopeChain",type:"array",items:{$ref:"Scope"},description:"Scope chain for this call frame."},{name:"this",$ref:"Runtime.RemoteObject",description:"<code>this</code> object for this call frame."},{name:"returnValue",$ref:"Runtime.RemoteObject",optional:!0,description:"The value being returned, if the function is at return point."}],description:"JavaScript call frame. Array of call frames form the call stack."},{id:"Scope",type:"object",properties:[{name:"type",type:"string",enum:["global","local","with","closure","catch","block","script","eval"],description:"Scope type."},{name:"object",$ref:"Runtime.RemoteObject",description:"Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties."},{name:"name",type:"string",optional:!0},{name:"startLocation",$ref:"Location",optional:!0,description:"Location in the source code where scope starts"},{name:"endLocation",$ref:"Location",optional:!0,description:"Location in the source code where scope ends"}],description:"Scope description."},{id:"SearchMatch",type:"object",description:"Search match for resource.",exported:!0,properties:[{name:"lineNumber",type:"number",description:"Line number in resource content."},{name:"lineContent",type:"string",description:"Line with match content."}],experimental:!0}],commands:[{name:"enable",description:"Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received."},{name:"disable",description:"Disables debugger for given page."},{name:"setBreakpointsActive",parameters:[{name:"active",type:"boolean",description:"New value for breakpoints active state."}],description:"Activates / deactivates all breakpoints on the page."},{name:"setSkipAllPauses",parameters:[{name:"skip",type:"boolean",description:"New value for skip pauses state."}],description:"Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc)."},{name:"setBreakpointByUrl",parameters:[{name:"lineNumber",type:"integer",description:"Line number to set breakpoint at."},{name:"url",type:"string",optional:!0,description:"URL of the resources to set breakpoint on."},{name:"urlRegex",type:"string",optional:!0,description:"Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified."},{name:"columnNumber",type:"integer",optional:!0,description:"Offset in the line to set breakpoint at."},{name:"condition",type:"string",optional:!0,description:"Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true."}],returns:[{name:"breakpointId",$ref:"BreakpointId",description:"Id of the created breakpoint for further reference."},{name:"locations",type:"array",items:{$ref:"Location"},description:"List of the locations this breakpoint resolved into upon addition."}],description:"Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads."},{name:"setBreakpoint",parameters:[{name:"location",$ref:"Location",description:"Location to set breakpoint in."},{name:"condition",type:"string",optional:!0,description:"Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true."}],returns:[{name:"breakpointId",$ref:"BreakpointId",description:"Id of the created breakpoint for further reference."},{name:"actualLocation",$ref:"Location",description:"Location this breakpoint resolved into."}],description:"Sets JavaScript breakpoint at a given location."},{name:"removeBreakpoint",parameters:[{name:"breakpointId",$ref:"BreakpointId"}],description:"Removes JavaScript breakpoint."},{name:"getPossibleBreakpoints",parameters:[{name:"start",$ref:"Location",description:"Start of range to search possible breakpoint locations in."},{name:"end",$ref:"Location",optional:!0,description:"End of range to search possible breakpoint locations in (excluding). When not specifed, end of scripts is used as end of range."}],returns:[{name:"locations",type:"array",items:{$ref:"Location"},description:"List of the possible breakpoint locations."}],description:"Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.",experimental:!0},{name:"continueToLocation",parameters:[{name:"location",$ref:"Location",description:"Location to continue to."}],description:"Continues execution until specific location is reached."},{name:"stepOver",description:"Steps over the statement."},{name:"stepInto",description:"Steps into the function call."},{name:"stepOut",description:"Steps out of the function call."},{name:"pause",description:"Stops on the next JavaScript statement."},{name:"resume",description:"Resumes JavaScript execution."},{name:"searchInContent",parameters:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Id of the script to search in."},{name:"query",type:"string",description:"String to search for."},{name:"caseSensitive",type:"boolean",optional:!0,description:"If true, search is case sensitive."},{name:"isRegex",type:"boolean",optional:!0,description:"If true, treats string parameter as regex."}],returns:[{name:"result",type:"array",items:{$ref:"SearchMatch"},description:"List of search matches."}],experimental:!0,description:"Searches for given string in script content."},{name:"setScriptSource",parameters:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Id of the script to edit."},{name:"scriptSource",type:"string",description:"New content of the script."},{name:"dryRun",type:"boolean",optional:!0,description:" If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code."}],returns:[{name:"callFrames",type:"array",optional:!0,items:{$ref:"CallFrame"},description:"New stack trace in case editing has happened while VM was stopped."},{name:"stackChanged",type:"boolean",optional:!0,description:"Whether current call stack  was modified after applying the changes."},{name:"asyncStackTrace",$ref:"Runtime.StackTrace",optional:!0,description:"Async stack trace, if any."},{name:"exceptionDetails",optional:!0,$ref:"Runtime.ExceptionDetails",description:"Exception details if any."}],description:"Edits JavaScript source live."},{name:"restartFrame",parameters:[{name:"callFrameId",$ref:"CallFrameId",description:"Call frame identifier to evaluate on."}],returns:[{name:"callFrames",type:"array",items:{$ref:"CallFrame"},description:"New stack trace."},{name:"asyncStackTrace",$ref:"Runtime.StackTrace",optional:!0,description:"Async stack trace, if any."}],description:"Restarts particular call frame from the beginning."},{name:"getScriptSource",parameters:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Id of the script to get source for."}],returns:[{name:"scriptSource",type:"string",description:"Script source."}],description:"Returns source for the script with given id."},{name:"setPauseOnExceptions",parameters:[{name:"state",type:"string",enum:["none","uncaught","all"],description:"Pause on exceptions mode."}],description:"Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>."},{name:"evaluateOnCallFrame",parameters:[{name:"callFrameId",$ref:"CallFrameId",description:"Call frame identifier to evaluate on."},{name:"expression",type:"string",description:"Expression to evaluate."},{name:"objectGroup",type:"string",optional:!0,description:"String object group name to put result into (allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>)."},{name:"includeCommandLineAPI",type:"boolean",optional:!0,description:"Specifies whether command line API should be available to the evaluated expression, defaults to false."},{name:"silent",type:"boolean",optional:!0,description:"In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state."},{name:"returnByValue",type:"boolean",optional:!0,description:"Whether the result is expected to be a JSON object that should be sent by value."},{name:"generatePreview",type:"boolean",optional:!0,experimental:!0,description:"Whether preview should be generated for the result."}],returns:[{name:"result",$ref:"Runtime.RemoteObject",description:"Object wrapper for the evaluation result."},{name:"exceptionDetails",$ref:"Runtime.ExceptionDetails",optional:!0,description:"Exception details."}],description:"Evaluates expression on a given call frame."},{name:"setVariableValue",parameters:[{name:"scopeNumber",type:"integer",description:"0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually."},{name:"variableName",type:"string",description:"Variable name."},{name:"newValue",$ref:"Runtime.CallArgument",description:"New variable value."},{name:"callFrameId",$ref:"CallFrameId",description:"Id of callframe that holds variable."}],description:"Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually."},{name:"setAsyncCallStackDepth",parameters:[{name:"maxDepth",type:"integer",description:"Maximum depth of async call stacks. Setting to <code>0</code> will effectively disable collecting async call stacks (default)."}],description:"Enables or disables async call stacks tracking."},{name:"setBlackboxPatterns",parameters:[{name:"patterns",type:"array",items:{type:"string"},description:"Array of regexps that will be used to check script url for blackbox state."}],experimental:!0,description:"Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful."},{name:"setBlackboxedRanges",parameters:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Id of the script."},{name:"positions",type:"array",items:{$ref:"ScriptPosition"}}],experimental:!0,description:"Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted."}],events:[{name:"scriptParsed",parameters:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Identifier of the script parsed."},{name:"url",type:"string",description:"URL or name of the script parsed (if any)."},{name:"startLine",type:"integer",description:"Line offset of the script within the resource with given URL (for script tags)."},{name:"startColumn",type:"integer",description:"Column offset of the script within the resource with given URL."},{name:"endLine",type:"integer",description:"Last line of the script."},{name:"endColumn",type:"integer",description:"Length of the last line of the script."},{name:"executionContextId",$ref:"Runtime.ExecutionContextId",description:"Specifies script creation context."},{name:"hash",type:"string",description:"Content hash of the script."},{name:"executionContextAuxData",type:"object",optional:!0,description:"Embedder-specific auxiliary data."},{name:"isLiveEdit",type:"boolean",optional:!0,description:"True, if this script is generated as a result of the live edit operation.",experimental:!0},{name:"sourceMapURL",type:"string",optional:!0,description:"URL of source map associated with script (if any)."},{name:"hasSourceURL",type:"boolean",optional:!0,description:"True, if this script has sourceURL.",experimental:!0}],description:"Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger."},{name:"scriptFailedToParse",parameters:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Identifier of the script parsed."},{name:"url",type:"string",description:"URL or name of the script parsed (if any)."},{name:"startLine",type:"integer",description:"Line offset of the script within the resource with given URL (for script tags)."},{name:"startColumn",type:"integer",description:"Column offset of the script within the resource with given URL."},{name:"endLine",type:"integer",description:"Last line of the script."},{name:"endColumn",type:"integer",description:"Length of the last line of the script."},{name:"executionContextId",$ref:"Runtime.ExecutionContextId",description:"Specifies script creation context."},{name:"hash",type:"string",description:"Content hash of the script."},{name:"executionContextAuxData",type:"object",optional:!0,description:"Embedder-specific auxiliary data."},{name:"sourceMapURL",type:"string",optional:!0,description:"URL of source map associated with script (if any)."},{name:"hasSourceURL",type:"boolean",optional:!0,description:"True, if this script has sourceURL.",experimental:!0}],description:"Fired when virtual machine fails to parse the script."},{name:"breakpointResolved",parameters:[{name:"breakpointId",$ref:"BreakpointId",description:"Breakpoint unique identifier."},{name:"location",$ref:"Location",description:"Actual breakpoint location."}],description:"Fired when breakpoint is resolved to an actual script and location."},{name:"paused",parameters:[{name:"callFrames",type:"array",items:{$ref:"CallFrame"},description:"Call stack the virtual machine stopped on."},{name:"reason",type:"string",enum:["XHR","DOM","EventListener","exception","assert","debugCommand","promiseRejection","other"],description:"Pause reason.",exported:!0},{name:"data",type:"object",optional:!0,description:"Object containing break-specific auxiliary properties."},{name:"hitBreakpoints",type:"array",optional:!0,items:{type:"string"},description:"Hit breakpoints IDs"},{name:"asyncStackTrace",$ref:"Runtime.StackTrace",optional:!0,description:"Async stack trace, if any."}],description:"Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria."},{name:"resumed",description:"Fired when the virtual machine resumed execution."}]},{domain:"Console",description:"This domain is deprecated - use Runtime or Log instead.",dependencies:["Runtime"],deprecated:!0,types:[{id:"ConsoleMessage",type:"object",description:"Console message.",properties:[{name:"source",type:"string",enum:["xml","javascript","network","console-api","storage","appcache","rendering","security","other","deprecation","worker"],description:"Message source."},{name:"level",type:"string",enum:["log","warning","error","debug","info"],description:"Message severity."},{name:"text",type:"string",description:"Message text."},{name:"url",type:"string",optional:!0,description:"URL of the message origin."},{name:"line",type:"integer",optional:!0,description:"Line number in the resource that generated this message (1-based)."},{name:"column",type:"integer",optional:!0,description:"Column number in the resource that generated this message (1-based)."}]}],commands:[{name:"enable",description:"Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification."},{name:"disable",description:"Disables console domain, prevents further console messages from being reported to the client."},{name:"clearMessages",description:"Does nothing."}],events:[{name:"messageAdded",parameters:[{name:"message",$ref:"ConsoleMessage",description:"Console message that has been added."}],description:"Issued when new console message is added."}]},{domain:"Profiler",dependencies:["Runtime","Debugger"],types:[{id:"ProfileNode",type:"object",description:"Profile node. Holds callsite information, execution statistics and child nodes.",properties:[{name:"id",type:"integer",description:"Unique id of the node."},{name:"callFrame",$ref:"Runtime.CallFrame",description:"Function location."},{name:"hitCount",type:"integer",optional:!0,experimental:!0,description:"Number of samples where this node was on top of the call stack."},{name:"children",type:"array",items:{type:"integer"},optional:!0,description:"Child node ids."},{name:"deoptReason",type:"string",optional:!0,description:"The reason of being not optimized. The function may be deoptimized or marked as don't optimize."},{name:"positionTicks",type:"array",items:{$ref:"PositionTickInfo"},optional:!0,experimental:!0,description:"An array of source position ticks."}]},{id:"Profile",type:"object",description:"Profile.",properties:[{name:"nodes",type:"array",items:{$ref:"ProfileNode"},description:"The list of profile nodes. First item is the root node."},{name:"startTime",type:"number",description:"Profiling start timestamp in microseconds."},{name:"endTime",type:"number",description:"Profiling end timestamp in microseconds."},{name:"samples",optional:!0,type:"array",items:{type:"integer"},description:"Ids of samples top nodes."},{name:"timeDeltas",optional:!0,type:"array",items:{type:"integer"},description:"Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime."}]},{id:"PositionTickInfo",type:"object",experimental:!0,description:"Specifies a number of samples attributed to a certain source position.",properties:[{name:"line",type:"integer",description:"Source line number (1-based)."},{name:"ticks",type:"integer",description:"Number of samples attributed to the source line."}]}],commands:[{name:"enable"},{name:"disable"},{name:"setSamplingInterval",parameters:[{name:"interval",type:"integer",description:"New sampling interval in microseconds."}],description:"Changes CPU profiler sampling interval. Must be called before CPU profiles recording started."},{name:"start"},{name:"stop",returns:[{name:"profile",$ref:"Profile",description:"Recorded profile."}]}],events:[{name:"consoleProfileStarted",parameters:[{name:"id",type:"string"},{name:"location",$ref:"Debugger.Location",description:"Location of console.profile()."},{name:"title",type:"string",optional:!0,description:"Profile title passed as an argument to console.profile()."}],description:"Sent when new profile recodring is started using console.profile() call."},{name:"consoleProfileFinished",parameters:[{name:"id",type:"string"},{name:"location",$ref:"Debugger.Location",description:"Location of console.profileEnd()."},{name:"profile",$ref:"Profile"},{name:"title",type:"string",optional:!0,description:"Profile title passed as an argument to console.profile()."}]}]},{domain:"HeapProfiler",dependencies:["Runtime"],experimental:!0,types:[{id:"HeapSnapshotObjectId",type:"string",description:"Heap snapshot object id."},{id:"SamplingHeapProfileNode",type:"object",description:"Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.",properties:[{name:"callFrame",$ref:"Runtime.CallFrame",description:"Function location."},{name:"selfSize",type:"number",description:"Allocations size in bytes for the node excluding children."},{name:"children",type:"array",items:{$ref:"SamplingHeapProfileNode"},description:"Child nodes."}]},{id:"SamplingHeapProfile",type:"object",description:"Profile.",properties:[{name:"head",$ref:"SamplingHeapProfileNode"}]}],commands:[{name:"enable"},{name:"disable"},{name:"startTrackingHeapObjects",parameters:[{name:"trackAllocations",type:"boolean",optional:!0}]},{name:"stopTrackingHeapObjects",parameters:[{name:"reportProgress",type:"boolean",optional:!0,description:"If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped."}]},{name:"takeHeapSnapshot",parameters:[{name:"reportProgress",type:"boolean",optional:!0,description:"If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken."}]},{name:"collectGarbage"},{name:"getObjectByHeapObjectId",parameters:[{name:"objectId",$ref:"HeapSnapshotObjectId"},{name:"objectGroup",type:"string",optional:!0,description:"Symbolic group name that can be used to release multiple objects."}],returns:[{name:"result",$ref:"Runtime.RemoteObject",description:"Evaluation result."}]},{name:"addInspectedHeapObject",parameters:[{name:"heapObjectId",$ref:"HeapSnapshotObjectId",description:"Heap snapshot object id to be accessible by means of $x command line API."}],description:"Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions)."},{name:"getHeapObjectId",parameters:[{name:"objectId",$ref:"Runtime.RemoteObjectId",description:"Identifier of the object to get heap object id for."}],returns:[{name:"heapSnapshotObjectId",$ref:"HeapSnapshotObjectId",description:"Id of the heap snapshot object corresponding to the passed remote object id."}]},{name:"startSampling",parameters:[{name:"samplingInterval",type:"number",optional:!0,description:"Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes."}]},{name:"stopSampling",returns:[{name:"profile",$ref:"SamplingHeapProfile",description:"Recorded sampling heap profile."}]}],events:[{name:"addHeapSnapshotChunk",parameters:[{name:"chunk",type:"string"}]},{name:"resetProfiles"},{name:"reportHeapSnapshotProgress",parameters:[{name:"done",type:"integer"},{name:"total",type:"integer"},{name:"finished",type:"boolean",optional:!0}]},{name:"lastSeenObjectId",description:"If heap objects tracking has been started then backend regulary sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.",parameters:[{name:"lastSeenObjectId",type:"integer"},{name:"timestamp",type:"number"}]},{name:"heapStatsUpdate",description:"If heap objects tracking has been started then backend may send update for one or more fragments",parameters:[{name:"statsUpdate",type:"array",items:{type:"integer"},description:"An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment."}]}]}]}},function(e,t,n){(function(t){"use strict";function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function o(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}function a(e,t,n){var i=this,r=i._nextCommandId++,o={id:r,method:e,params:t};i._ws.send(JSON.stringify(o)),i._callbacks[r]=n}function s(){var e=this,n={host:e.host,port:e.port};Promise.all([p.call(e,n).then(y.prepare.bind(e)),c.call(e,n)]).then(function(t){var n=t[1];return d.call(e,n)}).then(function(){t.nextTick(function(){e._notifier.emit("connect",e)})}).catch(function(t){e._notifier.emit("error",t)})}function p(e){var t=this;return new Promise(function(n,i){t.protocol?n(t.protocol):(e.remote=t.remote,b.Protocol(e).then(function(e){n(e.descriptor)}).catch(i))})}function c(e){var t=this;return new Promise(function(n,i){var r=new Error("Tab does not support inspection"),o=void 0;switch(m(t.tab)){case"string":n(t.tab);break;case"object":o=t.tab.webSocketDebuggerUrl,o?n(o):i(r);break;case"function":b.List(e).then(function(e){
	var a=e[t.tab(e)];a?(o=a.webSocketDebuggerUrl,o?n(o):i(r)):i(new Error("Invalid tab index"))}).catch(i);break;default:i(new Error("Invalid requested tab"))}})}function d(e){var t=this;return new Promise(function(n,i){try{t._ws=new f(e,{perMessageDeflate:!1})}catch(e){return void i(e)}t._ws.on("open",function(){n()}),t._ws.on("message",function(e){var n=JSON.parse(e);l.call(t,n)}),t._ws.on("close",function(){t._notifier.emit("disconnect")}),t._ws.on("error",function(e){i(e)})})}function l(e){var t=this;if(e.id){var n=t._callbacks[e.id];if(!n)return;e.error?n(!0,e.error):n(!1,e.result||{}),delete t._callbacks[e.id],0===Object.keys(t._callbacks).length&&t.emit("ready")}else e.method&&(t.emit("event",e),t.emit(e.method,e.params))}var m="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},u=n(2),h=n(27),f=n(42),y=n(43),g=n(38),b=n(3),v=function(e){function t(e,n){i(this,t);var o=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return e=e||{},o.host=e.host||g.HOST,o.port=e.port||g.PORT,o.protocol=e.protocol,o.remote=!!e.remote,o.tab=e.tab||e.chooseTab||function(){return 0},u.call(o),o._notifier=n,o._callbacks={},o._nextCommandId=1,s.call(o),o}return o(t,e),t}(u);v.prototype.inspect=function(e,t){return t.customInspect=!1,h.inspect(this,t)},v.prototype.send=function(e,t,n){var i=this;return"function"==typeof t&&(n=t,t=void 0),"function"!=typeof n?new Promise(function(n,r){a.call(i,e,t,function(e,t){e?r(t):n(t)})}):void a.call(i,e,t,n)},v.prototype.close=function(e){function t(e){n._ws.removeAllListeners("close"),n._ws.close(),n._ws.once("close",function(){n._ws.removeAllListeners(),e()})}var n=this;return"function"!=typeof e?new Promise(function(e,n){t(e)}):void t(e)},e.exports=v}).call(t,n(1))},function(e,t,n){"use strict";function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function o(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),s=n(2),p=function(e){function t(e){i(this,t);var n=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return n._ws=new WebSocket(e),n._ws.onopen=function(){n.emit("open")},n._ws.onclose=function(){n.emit("close")},n._ws.onmessage=function(e){n.emit("message",e.data)},n._ws.onerror=function(){n.emit("error",new Error("WebSocket error"))},n}return o(t,e),a(t,[{key:"close",value:function(){this._ws.close()}},{key:"send",value:function(e){this._ws.send(e)}}]),t}(s);e.exports=p},function(e,t){"use strict";function n(e){var t={};return e.forEach(function(e){var n=e.name;delete e.name,t[n]=e}),t}function i(e,t,i){e.category=t,Object.keys(i).forEach(function(r){"name"!==r&&("type"===t&&"properties"===r||"parameters"===r?e[r]=n(i[r]):e[r]=i[r])})}function r(e,t,n){var r=function(i,r){return e.send(t+"."+n.name,i,r)};i(r,"command",n),e[t][n.name]=r}function o(e,t,n){var r=function(i){e.on(t+"."+n.name,i)};i(r,"event",n),e[t][n.name]=r}function a(e,t,n){var r={};i(r,"type",n),e[t][n.id]=r}function s(e){var t=this;return new Promise(function(n,i){t.protocol=e,e.domains.forEach(function(e){var n=e.domain;t[n]={},(e.commands||[]).forEach(function(e){r(t,n,e)}),(e.events||[]).forEach(function(e){o(t,n,e)}),(e.types||[]).forEach(function(e){a(t,n,e)})}),n()})}e.exports.prepare=s}]);

/***/ },
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var updateConfig = (() => {
	  var _ref = _asyncToGenerator(function* () {
	    var response = yield fetch("/getconfig", {
	      method: "get"
	    });

	    var config = yield response.json();
	    setConfig(config);
	    return config;
	  });

	  return function updateConfig() {
	    return _ref.apply(this, arguments);
	  };
	})();

	var initApp = (() => {
	  var _ref2 = _asyncToGenerator(function* () {
	    var configureStore = __webpack_require__(132);
	    var reducers = __webpack_require__(143);
	    var LaunchpadApp = __webpack_require__(149);

	    var createStore = configureStore({
	      log: getValue("logging.actions"),
	      makeThunkArgs: function (args, state) {
	        return Object.assign({}, args, {});
	      }
	    });

	    var store = createStore(combineReducers(reducers));
	    var actions = bindActionCreators(__webpack_require__(181), store.dispatch);

	    debugGlobal("launchpadStore", store);

	    if (isDevelopment()) {
	      var config = yield updateConfig();
	      actions.setConfig(config);
	      AppConstants.DEBUG_JS_MODULES = true;
	    }

	    return { store, actions, LaunchpadApp };
	  });

	  return function initApp() {
	    return _ref2.apply(this, arguments);
	  };
	})();

	var connectClients = (() => {
	  var _ref3 = _asyncToGenerator(function* (actions) {
	    var firefoxTabs = yield firefox.connectClient();
	    actions.newTabs(firefoxTabs);

	    chrome.connectClient().then(actions.newTabs);

	    chrome.connectNodeClient().then(actions.newTabs);
	  });

	  return function connectClients(_x) {
	    return _ref3.apply(this, arguments);
	  };
	})();

	var getTabs = (() => {
	  var _ref4 = _asyncToGenerator(function* (actions) {
	    var firefoxTabs = yield firefox.getTabs();
	    var chromeTabs = yield chrome.connectClient();
	    var nodeTabs = yield chrome.connectNodeClient();

	    actions.clearTabs();

	    actions.newTabs(firefoxTabs);
	    actions.newTabs(chromeTabs);
	    actions.newTabs(nodeTabs);
	  });

	  return function getTabs(_x2) {
	    return _ref4.apply(this, arguments);
	  };
	})();

	var bootstrap = (() => {
	  var _ref5 = _asyncToGenerator(function* (React, ReactDOM) {
	    var connTarget = getTargetFromQuery();
	    if (connTarget) {
	      var _ref6 = yield startDebugging(connTarget),
	          tab = _ref6.tab,
	          tabConnection = _ref6.tabConnection;

	      yield updateConfig();
	      return { tab, connTarget, tabConnection };
	    }

	    var _ref7 = yield initApp(),
	        store = _ref7.store,
	        actions = _ref7.actions,
	        LaunchpadApp = _ref7.LaunchpadApp;

	    renderRoot(React, ReactDOM, LaunchpadApp, store);
	    yield connectClients(actions);
	    setInterval(_asyncToGenerator(function* () {
	      return yield getTabs(actions);
	    }), 3000);
	  });

	  return function bootstrap(_x3, _x4) {
	    return _ref5.apply(this, arguments);
	  };
	})();

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	/* global window, document, DebuggerConfig */

	var _require = __webpack_require__(3),
	    bindActionCreators = _require.bindActionCreators,
	    combineReducers = _require.combineReducers;

	var _require2 = __webpack_require__(151),
	    Provider = _require2.Provider;

	var _require3 = __webpack_require__(830),
	    DevToolsUtils = _require3.DevToolsUtils,
	    AppConstants = _require3.AppConstants,
	    defer = _require3.defer;

	var _require4 = __webpack_require__(184),
	    debugGlobal = _require4.debugGlobal;

	var _require5 = __webpack_require__(828),
	    setConfig = _require5.setConfig,
	    getValue = _require5.getValue,
	    isDevelopment = _require5.isDevelopment;

	var L10N = __webpack_require__(185);

	var _require6 = __webpack_require__(180),
	    showMenu = _require6.showMenu,
	    buildMenu = _require6.buildMenu;

	setConfig(({"environment":"firefox-panel","logging":false,"clientLogging":false,"firefox":{"mcPath":"./firefox"},"workers":{"parserURL":"resource://devtools/client/debugger/new/parser-worker.js","prettyPrintURL":"resource://devtools/client/debugger/new/pretty-print-worker.js"},"features":{"blackbox":{"enabled":true},"watchExpressions":{"enabled":true},"chromeScopes":{"enabled":false},"eventListeners":{"enabled":false},"codeCoverage":{"enabled":false},"searchModifiers":{"enabled":true},"symbolSearch":{"enabled":true},"editorPreview":{"enabled":true},"showSource":{"enabled":true}}}));

	// Set various flags before requiring app code.
	if (getValue("logging.client")) {
	  DevToolsUtils.dumpn.wantLogging = true;
	}

	var _require7 = __webpack_require__(885),
	    firefox = _require7.firefox,
	    chrome = _require7.chrome,
	    startDebugging = _require7.startDebugging;

	var Root = __webpack_require__(186);

	// Using this static variable allows webpack to know at compile-time
	// to avoid this require and not include it at all in the output.
	if (false) {
	  require("./lib/themes/dark-theme.css");
	  require("./lib/themes/light-theme.css");
	  require("./lib/themes/firebug-theme.css");
	}

	function updateTheme() {
	  if (false) {
	    var theme = getValue("theme");
	    var root = document.body.parentNode;
	    var appRoot = document.querySelector(".launchpad-root");

	    root.className = "";
	    appRoot.className = "launchpad-root";

	    root.classList.add(`theme-${theme}`);
	    appRoot.classList.add(`theme-${theme}`);
	  }
	}

	function updateDir() {
	  var dir = getValue("dir");
	  var root = document.body.parentNode;
	  root.dir = dir;
	}

	function renderRoot(_React, _ReactDOM, component, _store) {
	  var createElement = _React.createElement;

	  var mount = document.querySelector("#mount");

	  // bail in test environments that do not have a mount
	  if (!mount) {
	    return;
	  }

	  var root = Root("launchpad-root theme-body");
	  mount.appendChild(root);

	  if (component.props || component.propTypes) {
	    _ReactDOM.render(createElement(Provider, { store: _store }, createElement(component)), root);
	  } else {
	    root.appendChild(component);
	  }

	  if (isDevelopment()) {
	    updateConfig();
	    updateTheme();
	  }
	}

	function unmountRoot(_ReactDOM) {
	  var mount = document.querySelector("#mount .launchpad-root");
	  _ReactDOM.unmountComponentAtNode(mount);
	}

	function getTargetFromQuery() {
	  var href = window.location.href;
	  var nodeMatch = href.match(/node-tab=([^&#]*)/);
	  var firefoxMatch = href.match(/firefox-tab=([^&#]*)/);
	  var chromeMatch = href.match(/chrome-tab=([^&#]*)/);

	  if (nodeMatch) {
	    return { type: "node", param: nodeMatch[1] };
	  } else if (firefoxMatch) {
	    return { type: "firefox", param: firefoxMatch[1] };
	  } else if (chromeMatch) {
	    return { type: "chrome", param: chromeMatch[1] };
	  }

	  return null;
	}

	module.exports = {
	  bootstrap,
	  buildMenu,
	  debugGlobal,
	  defer,
	  renderRoot,
	  L10N,
	  showMenu,
	  unmountRoot,
	  updateTheme,
	  updateDir
	};

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* global window */

	var _require = __webpack_require__(3),
	    createStore = _require.createStore,
	    applyMiddleware = _require.applyMiddleware;

	var _require2 = __webpack_require__(133),
	    waitUntilService = _require2.waitUntilService;

	var _require3 = __webpack_require__(134),
	    log = _require3.log;

	var _require4 = __webpack_require__(135),
	    history = _require4.history;

	var _require5 = __webpack_require__(136),
	    promise = _require5.promise;

	var _require6 = __webpack_require__(142),
	    thunk = _require6.thunk;

	/**
	 * This creates a dispatcher with all the standard middleware in place
	 * that all code requires. It can also be optionally configured in
	 * various ways, such as logging and recording.
	 *
	 * @param {object} opts:
	 *        - log: log all dispatched actions to console
	 *        - history: an array to store every action in. Should only be
	 *                   used in tests.
	 *        - middleware: array of middleware to be included in the redux store
	 */
	var configureStore = function () {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var middleware = [thunk(opts.makeThunkArgs), promise,

	  // Order is important: services must go last as they always
	  // operate on "already transformed" actions. Actions going through
	  // them shouldn't have any special fields like promises, they
	  // should just be normal JSON objects.
	  waitUntilService];

	  if (opts.history) {
	    middleware.push(history(opts.history));
	  }

	  if (opts.middleware) {
	    opts.middleware.forEach(fn => middleware.push(fn));
	  }

	  if (opts.log) {
	    middleware.push(log);
	  }

	  // Hook in the redux devtools browser extension if it exists
	  var devtoolsExt = typeof window === "object" && window.devToolsExtension ? window.devToolsExtension() : f => f;

	  return applyMiddleware.apply(undefined, middleware)(devtoolsExt(createStore));
	};

	module.exports = configureStore;

/***/ },
/* 133 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * A middleware which acts like a service, because it is stateful
	 * and "long-running" in the background. It provides the ability
	 * for actions to install a function to be run once when a specific
	 * condition is met by an action coming through the system. Think of
	 * it as a thunk that blocks until the condition is met. Example:
	 *
	 * ```js
	 * const services = { WAIT_UNTIL: require('wait-service').NAME };
	 *
	 * { type: services.WAIT_UNTIL,
	 *   predicate: action => action.type === constants.ADD_ITEM,
	 *   run: (dispatch, getState, action) => {
	 *     // Do anything here. You only need to accept the arguments
	 *     // if you need them. `action` is the action that satisfied
	 *     // the predicate.
	 *   }
	 * }
	 * ```
	 */
	var NAME = exports.NAME = "@@service/waitUntil";

	function waitUntilService(_ref) {
	  var dispatch = _ref.dispatch,
	      getState = _ref.getState;

	  var pending = [];

	  function checkPending(action) {
	    var readyRequests = [];
	    var stillPending = [];

	    // Find the pending requests whose predicates are satisfied with
	    // this action. Wait to run the requests until after we update the
	    // pending queue because the request handler may synchronously
	    // dispatch again and run this service (that use case is
	    // completely valid).
	    for (var request of pending) {
	      if (request.predicate(action)) {
	        readyRequests.push(request);
	      } else {
	        stillPending.push(request);
	      }
	    }

	    pending = stillPending;
	    for (var _request of readyRequests) {
	      _request.run(dispatch, getState, action);
	    }
	  }

	  return next => action => {
	    if (action.type === NAME) {
	      pending.push(action);
	      return null;
	    }
	    var result = next(action);
	    checkPending(action);
	    return result;
	  };
	}
	exports.waitUntilService = waitUntilService;

/***/ },
/* 134 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * A middleware that logs all actions coming through the system
	 * to the console.
	 */
	function log(_ref) {
	  var dispatch = _ref.dispatch,
	      getState = _ref.getState;

	  return next => action => {
	    var actionText = JSON.stringify(action, null, 2);
	    var truncatedActionText = `${actionText.slice(0, 1000)}...`;
	    console.log(`[DISPATCH ${action.type}]`, action, truncatedActionText);
	    next(action);
	  };
	}

	exports.log = log;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var _require = __webpack_require__(828),
	    isDevelopment = _require.isDevelopment;

	/**
	 * A middleware that stores every action coming through the store in the passed
	 * in logging object. Should only be used for tests, as it collects all
	 * action information, which will cause memory bloat.
	 */


	exports.history = function () {
	  var log = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;

	    if (isDevelopment()) {
	      console.warn("Using history middleware stores all actions in state for " + "testing and devtools is not currently running in test " + "mode. Be sure this is intentional.");
	    }
	    return next => action => {
	      log.push(action);
	      next(action);
	    };
	  };
	};

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var _require = __webpack_require__(830),
	    defer = _require.defer;

	var _require2 = __webpack_require__(138),
	    entries = _require2.entries,
	    toObject = _require2.toObject;

	var _require3 = __webpack_require__(140),
	    executeSoon = _require3.executeSoon;

	var PROMISE = exports.PROMISE = "@@dispatch/promise";
	var seqIdVal = 1;

	function seqIdGen() {
	  return seqIdVal++;
	}

	function promiseMiddleware(_ref) {
	  var dispatch = _ref.dispatch,
	      getState = _ref.getState;

	  return next => action => {
	    if (!(PROMISE in action)) {
	      return next(action);
	    }

	    var promiseInst = action[PROMISE];
	    var seqId = seqIdGen().toString();

	    // Create a new action that doesn't have the promise field and has
	    // the `seqId` field that represents the sequence id
	    action = Object.assign(toObject(entries(action).filter(pair => pair[0] !== PROMISE)), { seqId });

	    dispatch(Object.assign({}, action, { status: "start" }));

	    // Return the promise so action creators can still compose if they
	    // want to.
	    var deferred = defer();
	    promiseInst.then(value => {
	      executeSoon(() => {
	        dispatch(Object.assign({}, action, {
	          status: "done",
	          value: value
	        }));
	        deferred.resolve(value);
	      });
	    }, error => {
	      executeSoon(() => {
	        dispatch(Object.assign({}, action, {
	          status: "error",
	          error: error.message || error
	        }));
	        deferred.reject(error);
	      });
	    });
	    return deferred.promise;
	  };
	}

	exports.promise = promiseMiddleware;

/***/ },
/* 137 */,
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var co = __webpack_require__(882);

	function asPaused(client, func) {
	  if (client.state != "paused") {
	    return co(function* () {
	      yield client.interrupt();
	      var result = void 0;

	      try {
	        result = yield func();
	      } catch (e) {
	        // Try to put the debugger back in a working state by resuming
	        // it
	        yield client.resume();
	        throw e;
	      }

	      yield client.resume();
	      return result;
	    });
	  }
	  return func();
	}

	function handleError(err) {
	  console.log("ERROR: ", err);
	}

	function promisify(context, method) {
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }

	  return new Promise((resolve, reject) => {
	    args.push(response => {
	      if (response.error) {
	        reject(response);
	      } else {
	        resolve(response);
	      }
	    });
	    method.apply(context, args);
	  });
	}

	function truncateStr(str, size) {
	  if (str.length > size) {
	    return `${str.slice(0, size)}...`;
	  }
	  return str;
	}

	function endTruncateStr(str, size) {
	  if (str.length > size) {
	    return `...${str.slice(str.length - size)}`;
	  }
	  return str;
	}

	var msgId = 1;
	function workerTask(worker, method) {
	  return function () {
	    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }

	    return new Promise((resolve, reject) => {
	      var id = msgId++;
	      worker.postMessage({ id, method, args });

	      var listener = (_ref) => {
	        var result = _ref.data;

	        if (result.id !== id) {
	          return;
	        }

	        worker.removeEventListener("message", listener);
	        if (result.error) {
	          reject(result.error);
	        } else {
	          resolve(result.response);
	        }
	      };

	      worker.addEventListener("message", listener);
	    });
	  };
	}

	/**
	 * Interleaves two arrays element by element, returning the combined array, like
	 * a zip. In the case of arrays with different sizes, undefined values will be
	 * interleaved at the end along with the extra values of the larger array.
	 *
	 * @param Array a
	 * @param Array b
	 * @returns Array
	 *          The combined array, in the form [a1, b1, a2, b2, ...]
	 */
	function zip(a, b) {
	  if (!b) {
	    return a;
	  }
	  if (!a) {
	    return b;
	  }
	  var pairs = [];
	  for (var i = 0, aLength = a.length, bLength = b.length; i < aLength || i < bLength; i++) {
	    pairs.push([a[i], b[i]]);
	  }
	  return pairs;
	}

	/**
	 * Converts an object into an array with 2-element arrays as key/value
	 * pairs of the object. `{ foo: 1, bar: 2}` would become
	 * `[[foo, 1], [bar 2]]` (order not guaranteed);
	 *
	 * @param object obj
	 * @returns array
	 */
	function entries(obj) {
	  return Object.keys(obj).map(k => [k, obj[k]]);
	}

	function mapObject(obj, iteratee) {
	  return toObject(entries(obj).map((_ref2) => {
	    var _ref3 = _slicedToArray(_ref2, 2),
	        key = _ref3[0],
	        value = _ref3[1];

	    return [key, iteratee(key, value)];
	  }));
	}

	/**
	 * Takes an array of 2-element arrays as key/values pairs and
	 * constructs an object using them.
	 */
	function toObject(arr) {
	  var obj = {};
	  for (var pair of arr) {
	    obj[pair[0]] = pair[1];
	  }
	  return obj;
	}

	/**
	 * Composes the given functions into a single function, which will
	 * apply the results of each function right-to-left, starting with
	 * applying the given arguments to the right-most function.
	 * `compose(foo, bar, baz)` === `args => foo(bar(baz(args)`
	 *
	 * @param ...function funcs
	 * @returns function
	 */
	function compose() {
	  for (var _len3 = arguments.length, funcs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	    funcs[_key3] = arguments[_key3];
	  }

	  return function () {
	    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	      args[_key4] = arguments[_key4];
	    }

	    var initialValue = funcs[funcs.length - 1].apply(null, args);
	    var leftFuncs = funcs.slice(0, -1);
	    return leftFuncs.reduceRight((composed, f) => f(composed), initialValue);
	  };
	}

	function updateObj(obj, fields) {
	  return Object.assign({}, obj, fields);
	}

	function throttle(func, ms) {
	  var timeout = void 0,
	      _this = void 0;
	  return function () {
	    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	      args[_key5] = arguments[_key5];
	    }

	    _this = this;
	    if (!timeout) {
	      timeout = setTimeout(() => {
	        func.apply.apply(func, [_this].concat(_toConsumableArray(args)));
	        timeout = null;
	      }, ms);
	    }
	  };
	}

	module.exports = {
	  asPaused,
	  handleError,
	  promisify,
	  truncateStr,
	  endTruncateStr,
	  workerTask,
	  zip,
	  entries,
	  toObject,
	  mapObject,
	  compose,
	  updateObj,
	  throttle
	};

/***/ },
/* 139 */,
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var assert = __webpack_require__(141);

	function reportException(who, exception) {
	  var msg = `${who} threw an exception: `;
	  console.error(msg, exception);
	}

	function executeSoon(fn) {
	  setTimeout(fn, 0);
	}

	module.exports = {
	  reportException,
	  executeSoon,
	  assert
	};

/***/ },
/* 141 */
/***/ function(module, exports) {

	"use strict";

	function assert(condition, message) {
	  if (!condition) {
	    throw new Error(`Assertion failure: ${message}`);
	  }
	}

	module.exports = assert;

/***/ },
/* 142 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * A middleware that allows thunks (functions) to be dispatched. If
	 * it's a thunk, it is called with an argument that contains
	 * `dispatch`, `getState`, and any additional args passed in via the
	 * middleware constructure. This allows the action to create multiple
	 * actions (most likely asynchronously).
	 */
	function thunk(makeArgs) {
	  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;

	    var args = { dispatch, getState };

	    return next => action => {
	      return typeof action === "function" ? action(makeArgs ? makeArgs(args, getState()) : args) : next(action);
	    };
	  };
	}
	exports.thunk = thunk;

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var tabs = __webpack_require__(144);
	var config = __webpack_require__(148);

	module.exports = {
	  tabs,
	  config
	};

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var constants = __webpack_require__(145);
	var Immutable = __webpack_require__(146);
	var fromJS = __webpack_require__(147);

	var initialState = fromJS({
	  tabs: {},
	  selectedTab: null,
	  filterString: ""
	});

	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	  var action = arguments[1];

	  switch (action.type) {
	    case constants.CLEAR_TABS:
	      return state.setIn(["tabs"], Immutable.Map()).setIn("selectedTab", null);

	    case constants.ADD_TABS:
	      var tabs = action.value;
	      if (!tabs) {
	        return state;
	      }

	      return state.mergeIn(["tabs"], Immutable.Map(tabs.map(tab => {
	        tab = Object.assign({}, tab, { id: getTabId(tab) });
	        return [tab.id, Immutable.Map(tab)];
	      })));

	    case constants.SELECT_TAB:
	      var tabToSelect = state.getIn(["tabs", action.id]);
	      return state.setIn(["selectedTab"], tabToSelect);

	    case constants.FILTER_TABS:
	      return state.setIn(["filterString"], action.value);
	  }

	  return state;
	}

	function getTabId(tab) {
	  var id = tab.id;
	  var isFirefox = tab.clientType == "firefox";

	  // NOTE: we're getting the last part of the actor because
	  // we want to ignore the connection id
	  if (isFirefox) {
	    id = tab.id.split(".").pop();
	  }

	  return id;
	}

	module.exports = update;

/***/ },
/* 145 */
/***/ function(module, exports) {

	"use strict";

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	module.exports = {
	  CLEAR_TABS: "CLEAR_TABS",
	  ADD_TABS: "ADD_TABS",
	  SELECT_TAB: "SELECT_TAB",
	  FILTER_TABS: "FILTER_TABS",
	  SET_VALUE: "SET_VALUE",
	  SET_CONFIG: "SET_CONFIG"
	};

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Immutable = factory());
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }

	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }


	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }


	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }


	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }



	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;

	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;


	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32−1.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }

	  /* global Symbol */

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


	  function Iterator(next) {
	      this.next = next;
	    }

	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };


	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };


	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }

	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function() {
	      return this;
	    };

	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };



	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }

	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };



	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }

	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };

	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };

	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };



	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }

	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };



	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;



	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function()
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };



	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };

	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }

	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };



	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };




	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }

	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }

	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }

	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }

	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }

	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  createClass(Repeat, IndexedSeq);

	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function()
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };

	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };


	  var EMPTY_REPEAT;

	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }

	  createClass(Range, IndexedSeq);

	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step !== 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };

	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };

	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };

	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };

	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };


	  var EMPTY_RANGE;

	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }


	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

	  createClass(SetCollection, Collection);function SetCollection() {}


	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }

	  createClass(Map, KeyedCollection);

	    // @pragma Construction

	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
	      return emptyMap().withMutations(function(map ) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };

	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };

	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };

	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };

	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };

	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };


	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;


	  // #pragma Trie Nodes



	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }

	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && entries.length === 1) {
	        return; // undefined
	      }

	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new ArrayMapNode(ownerID, newEntries);
	    };




	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }

	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };

	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;

	      if (!exists && value === NOT_SET) {
	        return this;
	      }

	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	      if (newNode === node) {
	        return this;
	      }

	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }

	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }

	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };




	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }

	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };

	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];

	      if (removed && !node) {
	        return this;
	      }

	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }

	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };




	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }

	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }

	      var removed = value === NOT_SET;

	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };




	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }

	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };

	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }

	      SetRef(didAlter);

	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }

	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }

	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };



	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }

	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }

	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }

	  createClass(MapIterator, Iterator);

	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };


	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }

	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  createClass(List, IndexedCollection);

	    // @pragma Construction

	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }

	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };

	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };

	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };

	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };


	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;



	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }

	    // TODO: seems like these methods are very similar

	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };

	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }

	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }

	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };



	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }

	  createClass(OrderedMap, Map);

	    // @pragma Construction

	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };

	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };


	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };

	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };

	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };



	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };



	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };


	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;


	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }


	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }


	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue)
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }


	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }


	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }


	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }


	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;

	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }

	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(iterable);

	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }

	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }

	    return sliceSeq;
	  }


	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }


	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }


	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});

	    if (iters.length === 0) {
	      return iterable;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }


	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }


	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }


	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }


	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }


	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }


	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }


	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }

	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }

	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }

	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }

	  createClass(Record, KeyedCollection);

	    function Record(defaultValues, name) {
	      var hasInitialized;

	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };

	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;

	      return RecordType;
	    }

	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };

	    // @pragma Access

	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };

	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };

	    // @pragma Modification

	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };

	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      if (this._map && !this._map.has(k)) {
	        var defaultVal = this._defaultValues[k];
	        if (v === defaultVal) {
	          return this;
	        }
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };

	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };

	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };


	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }

	  createClass(Set, SetCollection);

	    // @pragma Construction

	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };

	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };

	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };


	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  createClass(OrderedSet, Set);

	    // @pragma Construction

	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };


	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  createClass(Stack, IndexedCollection);

	    // @pragma Construction

	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }

	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };

	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };

	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };

	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };

	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };


	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;


	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  Iterable.Iterator = Iterator;

	  mixin(Iterable, {

	    // ### Conversion to other types

	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },

	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },

	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },

	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },

	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },


	    // ### Common JavaScript methods and properties

	    toString: function() {
	      return '[Iterable]';
	    },

	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },

	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },

	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },

	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },


	    // ### More sequential methods

	    butLast: function() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },

	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },

	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },

	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findEntry: function(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    findLastEntry: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },

	    findLastKey: function(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },

	    first: function() {
	      return this.find(returnTrue);
	    },

	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },

	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },

	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },

	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },

	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },

	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },

	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function() {
	      return this.toSeq().reverse().first();
	    },

	    lastKeyOf: function(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },

	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function() {
	      return this.slice(1);
	    },

	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },

	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },

	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },


	    // ### Hashable Object

	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }


	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;

	  mixin(KeyedIterable, {

	    // ### More sequential methods

	    flip: function() {
	      return reify(this, flipFactory(this));
	    },

	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },

	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }

	  });

	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



	  mixin(IndexedIterable, {

	    // ### Conversion to other types

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },


	    // ### More collection methods

	    findLastIndex: function(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    first: function() {
	      return this.get(0);
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },

	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },

	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },

	    keySeq: function() {
	      return Range(0, this.size);
	    },

	    last: function() {
	      return this.get(-1);
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },

	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }

	  });

	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



	  mixin(SetIterable, {

	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function(value) {
	      return this.has(value);
	    },


	    // ### More sequential methods

	    keySeq: function() {
	      return this.valueSeq();
	    }

	  });

	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;


	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);

	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);


	  // #pragma Helper functions

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }

	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }

	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var Immutable = {

	    Iterable: Iterable,

	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS

	  };

	  return Immutable;

	}));

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Immutable = __webpack_require__(146);

	// When our app state is fully types, we should be able to get rid of
	// this function. This is only temporarily necessary to support
	// converting typed objects to immutable.js, which usually happens in
	// reducers.
	function fromJS(value) {
	  if (Array.isArray(value)) {
	    return Immutable.Seq(value).map(fromJS).toList();
	  }
	  if (value && value.constructor.meta) {
	    // This adds support for tcomb objects which are native JS objects
	    // but are not "plain", so the above checks fail. Since they
	    // behave the same we can use the same constructors, but we need
	    // special checks for them.
	    var kind = value.constructor.meta.kind;
	    if (kind === "struct") {
	      return Immutable.Seq(value).map(fromJS).toMap();
	    } else if (kind === "list") {
	      return Immutable.Seq(value).map(fromJS).toList();
	    }
	  }

	  // If it's a primitive type, just return the value. Note `==` check
	  // for null, which is intentionally used to match either `null` or
	  // `undefined`.
	  if (value == null || typeof value !== "object") {
	    return value;
	  }

	  // Otherwise, treat it like an object. We can't reliably detect if
	  // it's a plain object because we might be objects from other JS
	  // contexts so `Object !== Object`.
	  return Immutable.Seq(value).map(fromJS).toMap();
	}

	module.exports = fromJS;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var constants = __webpack_require__(145);
	var fromJS = __webpack_require__(147);
	var I = __webpack_require__(146);

	var initialState = fromJS({
	  config: I.Map()
	});

	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	  var action = arguments[1];

	  switch (action.type) {
	    case constants.SET_VALUE:
	      return state.setIn(["config"].concat(_toConsumableArray(action.path.split("."))), action.value);

	    case constants.SET_CONFIG:
	      return state.setIn(["config"], fromJS(action.config));
	  }

	  return state;
	}

	module.exports = update;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(2);
	var PropTypes = React.PropTypes;

	var ImPropTypes = __webpack_require__(150);

	var _require = __webpack_require__(151),
	    connect = _require.connect;

	var _require2 = __webpack_require__(3),
	    bindActionCreators = _require2.bindActionCreators;

	var _require3 = __webpack_require__(160),
	    getTabs = _require3.getTabs,
	    getFilterString = _require3.getFilterString,
	    getConfig = _require3.getConfig;

	var _require4 = __webpack_require__(828),
	    getValue = _require4.getValue;

	var LandingPage = React.createFactory(__webpack_require__(167));

	var LaunchpadApp = React.createClass({
	  propTypes: {
	    tabs: ImPropTypes.map.isRequired,
	    filterString: PropTypes.string,
	    actions: PropTypes.object,
	    config: PropTypes.object
	  },

	  displayName: "LaunchpadApp",

	  render() {
	    var _props = this.props,
	        filterString = _props.filterString,
	        _props$actions = _props.actions,
	        setValue = _props$actions.setValue,
	        filterTabs = _props$actions.filterTabs,
	        config = _props.config;


	    return LandingPage({
	      tabs: this.props.tabs,
	      supportsFirefox: !!getValue("firefox"),
	      supportsChrome: !!getValue("chrome"),
	      title: getValue("title"),
	      filterString,
	      onFilterChange: filterTabs,
	      onTabClick: url => {
	        window.location = url;
	      },
	      config,
	      setValue
	    });
	  }
	});

	function mapStateToProps(state) {
	  return {
	    tabs: getTabs(state),
	    filterString: getFilterString(state),
	    config: getConfig(state)
	  };
	}

	function mapDispatchToProps(dispatch) {
	  return {
	    actions: bindActionCreators(__webpack_require__(181), dispatch)
	  };
	}

	module.exports = connect(mapStateToProps, mapDispatchToProps)(LaunchpadApp);

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This is a straight rip-off of the React.js ReactPropTypes.js proptype validators,
	 * modified to make it possible to validate Immutable.js data.
	 *     ImmutableTypes.listOf is patterned after React.PropTypes.arrayOf, but for Immutable.List
	 *     ImmutableTypes.shape  is based on React.PropTypes.shape, but for any Immutable.Iterable
	 */
	"use strict";

	var Immutable = __webpack_require__(146);

	var ANONYMOUS = "<<anonymous>>";

	var ImmutablePropTypes = {
	  listOf: createListOfTypeChecker,
	  mapOf: createMapOfTypeChecker,
	  orderedMapOf: createOrderedMapOfTypeChecker,
	  setOf: createSetOfTypeChecker,
	  orderedSetOf: createOrderedSetOfTypeChecker,
	  stackOf: createStackOfTypeChecker,
	  iterableOf: createIterableOfTypeChecker,
	  recordOf: createRecordOfTypeChecker,
	  shape: createShapeChecker,
	  contains: createShapeChecker,
	  mapContains: createMapContainsChecker,
	  // Primitive Types
	  list: createImmutableTypeChecker("List", Immutable.List.isList),
	  map: createImmutableTypeChecker("Map", Immutable.Map.isMap),
	  orderedMap: createImmutableTypeChecker("OrderedMap", Immutable.OrderedMap.isOrderedMap),
	  set: createImmutableTypeChecker("Set", Immutable.Set.isSet),
	  orderedSet: createImmutableTypeChecker("OrderedSet", Immutable.OrderedSet.isOrderedSet),
	  stack: createImmutableTypeChecker("Stack", Immutable.Stack.isStack),
	  seq: createImmutableTypeChecker("Seq", Immutable.Seq.isSeq),
	  record: createImmutableTypeChecker("Record", function (isRecord) {
	    return isRecord instanceof Immutable.Record;
	  }),
	  iterable: createImmutableTypeChecker("Iterable", Immutable.Iterable.isIterable)
	};

	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return "array";
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return "object";
	  }
	  if (propValue instanceof Immutable.Iterable) {
	    return "Immutable." + propValue.toSource().split(" ")[0];
	  }
	  return propType;
	}

	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    for (var _len = arguments.length, rest = Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
	      rest[_key - 6] = arguments[_key];
	    }

	    propFullName = propFullName || propName;
	    componentName = componentName || ANONYMOUS;
	    if (props[propName] == null) {
	      var locationName = location;
	      if (isRequired) {
	        return new Error("Required " + locationName + " `" + propFullName + "` was not specified in " + ("`" + componentName + "`."));
	      }
	    } else {
	      return validate.apply(undefined, [props, propName, componentName, location, propFullName].concat(rest));
	    }
	  }

	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);

	  return chainedCheckType;
	}

	function createImmutableTypeChecker(immutableClassName, immutableClassTypeValidator) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!immutableClassTypeValidator(propValue)) {
	      var propType = getPropType(propValue);
	      return new Error("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `" + immutableClassName + "`."));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createIterableTypeChecker(typeChecker, immutableClassName, immutableClassTypeValidator) {

	  function validate(props, propName, componentName, location, propFullName) {
	    for (var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
	      rest[_key - 5] = arguments[_key];
	    }

	    var propValue = props[propName];
	    if (!immutableClassTypeValidator(propValue)) {
	      var locationName = location;
	      var propType = getPropType(propValue);
	      return new Error("Invalid " + locationName + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an Immutable.js " + immutableClassName + "."));
	    }

	    if (typeof typeChecker !== "function") {
	      return new Error("Invalid typeChecker supplied to `" + componentName + "` " + ("for propType `" + propFullName + "`, expected a function."));
	    }

	    var propValues = propValue.toArray();
	    for (var i = 0, len = propValues.length; i < len; i++) {
	      var error = typeChecker.apply(undefined, [propValues, i, componentName, location, "" + propFullName + "[" + i + "]"].concat(rest));
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	  }
	  return createChainableTypeChecker(validate);
	}

	function createKeysTypeChecker(typeChecker) {

	  function validate(props, propName, componentName, location, propFullName) {
	    for (var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
	      rest[_key - 5] = arguments[_key];
	    }

	    var propValue = props[propName];
	    if (typeof typeChecker !== "function") {
	      return new Error("Invalid keysTypeChecker (optional second argument) supplied to `" + componentName + "` " + ("for propType `" + propFullName + "`, expected a function."));
	    }

	    var keys = propValue.keySeq().toArray();
	    for (var i = 0, len = keys.length; i < len; i++) {
	      var error = typeChecker.apply(undefined, [keys, i, componentName, location, "" + propFullName + " -> key(" + keys[i] + ")"].concat(rest));
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	  }
	  return createChainableTypeChecker(validate);
	}

	function createListOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "List", Immutable.List.isList);
	}

	function createMapOfTypeCheckerFactory(valuesTypeChecker, keysTypeChecker, immutableClassName, immutableClassTypeValidator) {
	  function validate() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return createIterableTypeChecker(valuesTypeChecker, immutableClassName, immutableClassTypeValidator).apply(undefined, args) || keysTypeChecker && createKeysTypeChecker(keysTypeChecker).apply(undefined, args);
	  }

	  return createChainableTypeChecker(validate);
	}

	function createMapOfTypeChecker(valuesTypeChecker, keysTypeChecker) {
	  return createMapOfTypeCheckerFactory(valuesTypeChecker, keysTypeChecker, "Map", Immutable.Map.isMap);
	}

	function createOrderedMapOfTypeChecker(valuesTypeChecker, keysTypeChecker) {
	  return createMapOfTypeCheckerFactory(valuesTypeChecker, keysTypeChecker, "OrderedMap", Immutable.OrderedMap.isOrderedMap);
	}

	function createSetOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "Set", Immutable.Set.isSet);
	}

	function createOrderedSetOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "OrderedSet", Immutable.OrderedSet.isOrderedSet);
	}

	function createStackOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "Stack", Immutable.Stack.isStack);
	}

	function createIterableOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "Iterable", Immutable.Iterable.isIterable);
	}

	function createRecordOfTypeChecker(recordKeys) {
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
	      rest[_key - 5] = arguments[_key];
	    }

	    var propValue = props[propName];
	    if (!(propValue instanceof Immutable.Record)) {
	      var propType = getPropType(propValue);
	      var locationName = location;
	      return new Error("Invalid " + locationName + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected an Immutable.js Record."));
	    }
	    for (var key in recordKeys) {
	      var checker = recordKeys[key];
	      if (!checker) {
	        continue;
	      }
	      var mutablePropValue = propValue.toObject();
	      var error = checker.apply(undefined, [mutablePropValue, key, componentName, location, "" + propFullName + "." + key].concat(rest));
	      if (error) {
	        return error;
	      }
	    }
	  }
	  return createChainableTypeChecker(validate);
	}

	// there is some irony in the fact that shapeTypes is a standard hash and not an immutable collection
	function createShapeTypeChecker(shapeTypes) {
	  var immutableClassName = arguments[1] === undefined ? "Iterable" : arguments[1];
	  var immutableClassTypeValidator = arguments[2] === undefined ? Immutable.Iterable.isIterable : arguments[2];

	  function validate(props, propName, componentName, location, propFullName) {
	    for (var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
	      rest[_key - 5] = arguments[_key];
	    }

	    var propValue = props[propName];
	    if (!immutableClassTypeValidator(propValue)) {
	      var propType = getPropType(propValue);
	      var locationName = location;
	      return new Error("Invalid " + locationName + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected an Immutable.js " + immutableClassName + "."));
	    }
	    var mutablePropValue = propValue.toObject();
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker.apply(undefined, [mutablePropValue, key, componentName, location, "" + propFullName + "." + key].concat(rest));
	      if (error) {
	        return error;
	      }
	    }
	  }
	  return createChainableTypeChecker(validate);
	}

	function createShapeChecker(shapeTypes) {
	  return createShapeTypeChecker(shapeTypes);
	}

	function createMapContainsChecker(shapeTypes) {
	  return createShapeTypeChecker(shapeTypes, "Map", Immutable.Map.isMap);
	}

	module.exports = ImmutablePropTypes;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.connect = exports.Provider = undefined;

	var _Provider = __webpack_require__(152);

	var _Provider2 = _interopRequireDefault(_Provider);

	var _connect = __webpack_require__(155);

	var _connect2 = _interopRequireDefault(_connect);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	exports.Provider = _Provider2["default"];
	exports.connect = _connect2["default"];

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports["default"] = undefined;

	var _react = __webpack_require__(2);

	var _storeShape = __webpack_require__(153);

	var _storeShape2 = _interopRequireDefault(_storeShape);

	var _warning = __webpack_require__(154);

	var _warning2 = _interopRequireDefault(_warning);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var didWarnAboutReceivingStore = false;
	function warnAboutReceivingStore() {
	  if (didWarnAboutReceivingStore) {
	    return;
	  }
	  didWarnAboutReceivingStore = true;

	  (0, _warning2["default"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
	}

	var Provider = function (_Component) {
	  _inherits(Provider, _Component);

	  Provider.prototype.getChildContext = function getChildContext() {
	    return { store: this.store };
	  };

	  function Provider(props, context) {
	    _classCallCheck(this, Provider);

	    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

	    _this.store = props.store;
	    return _this;
	  }

	  Provider.prototype.render = function render() {
	    var children = this.props.children;

	    return _react.Children.only(children);
	  };

	  return Provider;
	}(_react.Component);

	exports["default"] = Provider;

	if (false) {
	  Provider.prototype.componentWillReceiveProps = function (nextProps) {
	    var store = this.store;
	    var nextStore = nextProps.store;

	    if (store !== nextStore) {
	      warnAboutReceivingStore();
	    }
	  };
	}

	Provider.propTypes = {
	  store: _storeShape2["default"].isRequired,
	  children: _react.PropTypes.element.isRequired
	};
	Provider.childContextTypes = {
	  store: _storeShape2["default"].isRequired
	};

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	exports["default"] = _react.PropTypes.shape({
	  subscribe: _react.PropTypes.func.isRequired,
	  dispatch: _react.PropTypes.func.isRequired,
	  getState: _react.PropTypes.func.isRequired
	});

/***/ },
/* 154 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that you can use this stack
	    // to find the callsite that caused this warning to fire.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.__esModule = true;
	exports["default"] = connect;

	var _react = __webpack_require__(2);

	var _storeShape = __webpack_require__(153);

	var _storeShape2 = _interopRequireDefault(_storeShape);

	var _shallowEqual = __webpack_require__(156);

	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

	var _wrapActionCreators = __webpack_require__(157);

	var _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);

	var _warning = __webpack_require__(154);

	var _warning2 = _interopRequireDefault(_warning);

	var _isPlainObject = __webpack_require__(5);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	var _hoistNonReactStatics = __webpack_require__(158);

	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

	var _invariant = __webpack_require__(159);

	var _invariant2 = _interopRequireDefault(_invariant);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var defaultMapStateToProps = function defaultMapStateToProps(state) {
	  return {};
	}; // eslint-disable-line no-unused-vars
	var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
	  return { dispatch: dispatch };
	};
	var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
	  return _extends({}, parentProps, stateProps, dispatchProps);
	};

	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}

	var errorObject = { value: null };
	function tryCatch(fn, ctx) {
	  try {
	    return fn.apply(ctx);
	  } catch (e) {
	    errorObject.value = e;
	    return errorObject;
	  }
	}

	// Helps track hot reloading.
	var nextVersion = 0;

	function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
	  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

	  var shouldSubscribe = Boolean(mapStateToProps);
	  var mapState = mapStateToProps || defaultMapStateToProps;

	  var mapDispatch = undefined;
	  if (typeof mapDispatchToProps === 'function') {
	    mapDispatch = mapDispatchToProps;
	  } else if (!mapDispatchToProps) {
	    mapDispatch = defaultMapDispatchToProps;
	  } else {
	    mapDispatch = (0, _wrapActionCreators2["default"])(mapDispatchToProps);
	  }

	  var finalMergeProps = mergeProps || defaultMergeProps;
	  var _options$pure = options.pure;
	  var pure = _options$pure === undefined ? true : _options$pure;
	  var _options$withRef = options.withRef;
	  var withRef = _options$withRef === undefined ? false : _options$withRef;

	  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;

	  // Helps track hot reloading.
	  var version = nextVersion++;

	  return function wrapWithConnect(WrappedComponent) {
	    var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';

	    function checkStateShape(props, methodName) {
	      if (!(0, _isPlainObject2["default"])(props)) {
	        (0, _warning2["default"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));
	      }
	    }

	    function computeMergedProps(stateProps, dispatchProps, parentProps) {
	      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
	      if (false) {
	        checkStateShape(mergedProps, 'mergeProps');
	      }
	      return mergedProps;
	    }

	    var Connect = function (_Component) {
	      _inherits(Connect, _Component);

	      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
	        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
	      };

	      function Connect(props, context) {
	        _classCallCheck(this, Connect);

	        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

	        _this.version = version;
	        _this.store = props.store || context.store;

	        (0, _invariant2["default"])(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + connectDisplayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + connectDisplayName + '".'));

	        var storeState = _this.store.getState();
	        _this.state = { storeState: storeState };
	        _this.clearCache();
	        return _this;
	      }

	      Connect.prototype.computeStateProps = function computeStateProps(store, props) {
	        if (!this.finalMapStateToProps) {
	          return this.configureFinalMapState(store, props);
	        }

	        var state = store.getState();
	        var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);

	        if (false) {
	          checkStateShape(stateProps, 'mapStateToProps');
	        }
	        return stateProps;
	      };

	      Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {
	        var mappedState = mapState(store.getState(), props);
	        var isFactory = typeof mappedState === 'function';

	        this.finalMapStateToProps = isFactory ? mappedState : mapState;
	        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;

	        if (isFactory) {
	          return this.computeStateProps(store, props);
	        }

	        if (false) {
	          checkStateShape(mappedState, 'mapStateToProps');
	        }
	        return mappedState;
	      };

	      Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {
	        if (!this.finalMapDispatchToProps) {
	          return this.configureFinalMapDispatch(store, props);
	        }

	        var dispatch = store.dispatch;

	        var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);

	        if (false) {
	          checkStateShape(dispatchProps, 'mapDispatchToProps');
	        }
	        return dispatchProps;
	      };

	      Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {
	        var mappedDispatch = mapDispatch(store.dispatch, props);
	        var isFactory = typeof mappedDispatch === 'function';

	        this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;
	        this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;

	        if (isFactory) {
	          return this.computeDispatchProps(store, props);
	        }

	        if (false) {
	          checkStateShape(mappedDispatch, 'mapDispatchToProps');
	        }
	        return mappedDispatch;
	      };

	      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
	        var nextStateProps = this.computeStateProps(this.store, this.props);
	        if (this.stateProps && (0, _shallowEqual2["default"])(nextStateProps, this.stateProps)) {
	          return false;
	        }

	        this.stateProps = nextStateProps;
	        return true;
	      };

	      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
	        var nextDispatchProps = this.computeDispatchProps(this.store, this.props);
	        if (this.dispatchProps && (0, _shallowEqual2["default"])(nextDispatchProps, this.dispatchProps)) {
	          return false;
	        }

	        this.dispatchProps = nextDispatchProps;
	        return true;
	      };

	      Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {
	        var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
	        if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2["default"])(nextMergedProps, this.mergedProps)) {
	          return false;
	        }

	        this.mergedProps = nextMergedProps;
	        return true;
	      };

	      Connect.prototype.isSubscribed = function isSubscribed() {
	        return typeof this.unsubscribe === 'function';
	      };

	      Connect.prototype.trySubscribe = function trySubscribe() {
	        if (shouldSubscribe && !this.unsubscribe) {
	          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
	          this.handleChange();
	        }
	      };

	      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
	        if (this.unsubscribe) {
	          this.unsubscribe();
	          this.unsubscribe = null;
	        }
	      };

	      Connect.prototype.componentDidMount = function componentDidMount() {
	        this.trySubscribe();
	      };

	      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (!pure || !(0, _shallowEqual2["default"])(nextProps, this.props)) {
	          this.haveOwnPropsChanged = true;
	        }
	      };

	      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.tryUnsubscribe();
	        this.clearCache();
	      };

	      Connect.prototype.clearCache = function clearCache() {
	        this.dispatchProps = null;
	        this.stateProps = null;
	        this.mergedProps = null;
	        this.haveOwnPropsChanged = true;
	        this.hasStoreStateChanged = true;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	        this.renderedElement = null;
	        this.finalMapDispatchToProps = null;
	        this.finalMapStateToProps = null;
	      };

	      Connect.prototype.handleChange = function handleChange() {
	        if (!this.unsubscribe) {
	          return;
	        }

	        var storeState = this.store.getState();
	        var prevStoreState = this.state.storeState;
	        if (pure && prevStoreState === storeState) {
	          return;
	        }

	        if (pure && !this.doStatePropsDependOnOwnProps) {
	          var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);
	          if (!haveStatePropsChanged) {
	            return;
	          }
	          if (haveStatePropsChanged === errorObject) {
	            this.statePropsPrecalculationError = errorObject.value;
	          }
	          this.haveStatePropsBeenPrecalculated = true;
	        }

	        this.hasStoreStateChanged = true;
	        this.setState({ storeState: storeState });
	      };

	      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
	        (0, _invariant2["default"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');

	        return this.refs.wrappedInstance;
	      };

	      Connect.prototype.render = function render() {
	        var haveOwnPropsChanged = this.haveOwnPropsChanged;
	        var hasStoreStateChanged = this.hasStoreStateChanged;
	        var haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated;
	        var statePropsPrecalculationError = this.statePropsPrecalculationError;
	        var renderedElement = this.renderedElement;

	        this.haveOwnPropsChanged = false;
	        this.hasStoreStateChanged = false;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;

	        if (statePropsPrecalculationError) {
	          throw statePropsPrecalculationError;
	        }

	        var shouldUpdateStateProps = true;
	        var shouldUpdateDispatchProps = true;
	        if (pure && renderedElement) {
	          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;
	          shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;
	        }

	        var haveStatePropsChanged = false;
	        var haveDispatchPropsChanged = false;
	        if (haveStatePropsBeenPrecalculated) {
	          haveStatePropsChanged = true;
	        } else if (shouldUpdateStateProps) {
	          haveStatePropsChanged = this.updateStatePropsIfNeeded();
	        }
	        if (shouldUpdateDispatchProps) {
	          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
	        }

	        var haveMergedPropsChanged = true;
	        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
	          haveMergedPropsChanged = this.updateMergedPropsIfNeeded();
	        } else {
	          haveMergedPropsChanged = false;
	        }

	        if (!haveMergedPropsChanged && renderedElement) {
	          return renderedElement;
	        }

	        if (withRef) {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {
	            ref: 'wrappedInstance'
	          }));
	        } else {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);
	        }

	        return this.renderedElement;
	      };

	      return Connect;
	    }(_react.Component);

	    Connect.displayName = connectDisplayName;
	    Connect.WrappedComponent = WrappedComponent;
	    Connect.contextTypes = {
	      store: _storeShape2["default"]
	    };
	    Connect.propTypes = {
	      store: _storeShape2["default"]
	    };

	    if (false) {
	      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
	        if (this.version === version) {
	          return;
	        }

	        // We are hot reloading!
	        this.version = version;
	        this.trySubscribe();
	        this.clearCache();
	      };
	    }

	    return (0, _hoistNonReactStatics2["default"])(Connect, WrappedComponent);
	  };
	}

/***/ },
/* 156 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = shallowEqual;
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }

	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);

	  if (keysA.length !== keysB.length) {
	    return false;
	  }

	  // Test for A's keys different from B.
	  var hasOwn = Object.prototype.hasOwnProperty;
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }

	  return true;
	}

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports["default"] = wrapActionCreators;

	var _redux = __webpack_require__(3);

	function wrapActionCreators(actionCreators) {
	  return function (dispatch) {
	    return (0, _redux.bindActionCreators)(actionCreators, dispatch);
	  };
	}

/***/ },
/* 158 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';

	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};

	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};

	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);

	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }

	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {

	                }
	            }
	        }
	    }

	    return targetComponent;
	};


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (false) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	module.exports = invariant;


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _require = __webpack_require__(161),
	    score = _require.score;

	function getTabs(state) {
	  var tabs = state.tabs.get("tabs");
	  var filterString = getFilterString(state);

	  if (filterString === "") {
	    return tabs;
	  }

	  return tabs.filter(tab => score(tab.get("title"), filterString) + score(tab.get("url"), filterString) > 0);
	}

	function getSelectedTab(state) {
	  return state.tabs.get("selectedTab");
	}

	function getFilterString(state) {
	  return state.tabs.get("filterString");
	}

	function getConfig(state) {
	  return state.config.get("config").toJS();
	}

	module.exports = {
	  getTabs,
	  getSelectedTab,
	  getFilterString,
	  getConfig
	};

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {(function() {
	  var Query, defaultPathSeparator, filter, matcher, parseOptions, pathScorer, preparedQueryCache, scorer;

	  filter = __webpack_require__(162);

	  matcher = __webpack_require__(166);

	  scorer = __webpack_require__(163);

	  pathScorer = __webpack_require__(164);

	  Query = __webpack_require__(165);

	  preparedQueryCache = null;

	  defaultPathSeparator = (typeof process !== "undefined" && process !== null ? process.platform : void 0) === "win32" ? '\\' : '/';

	  module.exports = {
	    filter: function(candidates, query, options) {
	      if (options == null) {
	        options = {};
	      }
	      if (!((query != null ? query.length : void 0) && (candidates != null ? candidates.length : void 0))) {
	        return [];
	      }
	      options = parseOptions(options, query);
	      return filter(candidates, query, options);
	    },
	    score: function(string, query, options) {
	      if (options == null) {
	        options = {};
	      }
	      if (!((string != null ? string.length : void 0) && (query != null ? query.length : void 0))) {
	        return 0;
	      }
	      options = parseOptions(options, query);
	      if (options.usePathScoring) {
	        return pathScorer.score(string, query, options);
	      } else {
	        return scorer.score(string, query, options);
	      }
	    },
	    match: function(string, query, options) {
	      var _i, _ref, _results;
	      if (options == null) {
	        options = {};
	      }
	      if (!string) {
	        return [];
	      }
	      if (!query) {
	        return [];
	      }
	      if (string === query) {
	        return (function() {
	          _results = [];
	          for (var _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
	          return _results;
	        }).apply(this);
	      }
	      options = parseOptions(options, query);
	      return matcher.match(string, query, options);
	    },
	    wrap: function(string, query, options) {
	      if (options == null) {
	        options = {};
	      }
	      if (!string) {
	        return [];
	      }
	      if (!query) {
	        return [];
	      }
	      options = parseOptions(options, query);
	      return matcher.wrap(string, query, options);
	    },
	    prepareQuery: function(query, options) {
	      if (options == null) {
	        options = {};
	      }
	      options = parseOptions(options, query);
	      return options.preparedQuery;
	    }
	  };

	  parseOptions = function(options, query) {
	    if (options.allowErrors == null) {
	      options.allowErrors = false;
	    }
	    if (options.usePathScoring == null) {
	      options.usePathScoring = true;
	    }
	    if (options.useExtensionBonus == null) {
	      options.useExtensionBonus = false;
	    }
	    if (options.pathSeparator == null) {
	      options.pathSeparator = defaultPathSeparator;
	    }
	    if (options.optCharRegEx == null) {
	      options.optCharRegEx = null;
	    }
	    if (options.wrap == null) {
	      options.wrap = null;
	    }
	    if (options.preparedQuery == null) {
	      options.preparedQuery = preparedQueryCache && preparedQueryCache.query === query ? preparedQueryCache : (preparedQueryCache = new Query(query, options));
	    }
	    return options;
	  };

	}).call(this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(120)))

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var Query, pathScorer, pluckCandidates, scorer, sortCandidates;

	  scorer = __webpack_require__(163);

	  pathScorer = __webpack_require__(164);

	  Query = __webpack_require__(165);

	  pluckCandidates = function(a) {
	    return a.candidate;
	  };

	  sortCandidates = function(a, b) {
	    return b.score - a.score;
	  };

	  module.exports = function(candidates, query, options) {
	    var bKey, candidate, key, maxInners, maxResults, score, scoreProvider, scoredCandidates, spotLeft, string, usePathScoring, _i, _len;
	    scoredCandidates = [];
	    key = options.key, maxResults = options.maxResults, maxInners = options.maxInners, usePathScoring = options.usePathScoring;
	    spotLeft = (maxInners != null) && maxInners > 0 ? maxInners : candidates.length + 1;
	    bKey = key != null;
	    scoreProvider = usePathScoring ? pathScorer : scorer;
	    for (_i = 0, _len = candidates.length; _i < _len; _i++) {
	      candidate = candidates[_i];
	      string = bKey ? candidate[key] : candidate;
	      if (!string) {
	        continue;
	      }
	      score = scoreProvider.score(string, query, options);
	      if (score > 0) {
	        scoredCandidates.push({
	          candidate: candidate,
	          score: score
	        });
	        if (!--spotLeft) {
	          break;
	        }
	      }
	    }
	    scoredCandidates.sort(sortCandidates);
	    candidates = scoredCandidates.map(pluckCandidates);
	    if (maxResults != null) {
	      candidates = candidates.slice(0, maxResults);
	    }
	    return candidates;
	  };

	}).call(this);


/***/ },
/* 163 */
/***/ function(module, exports) {

	(function() {
	  var AcronymResult, computeScore, emptyAcronymResult, isAcronymFullWord, isMatch, isSeparator, isWordEnd, isWordStart, miss_coeff, pos_bonus, scoreAcronyms, scoreCharacter, scoreConsecutives, scoreExact, scoreExactMatch, scorePattern, scorePosition, scoreSize, tau_size, wm;

	  wm = 150;

	  pos_bonus = 20;

	  tau_size = 85;

	  miss_coeff = 0.75;

	  exports.score = function(string, query, options) {
	    var allowErrors, preparedQuery, score, string_lw;
	    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;
	    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
	      return 0;
	    }
	    string_lw = string.toLowerCase();
	    score = computeScore(string, string_lw, preparedQuery);
	    return Math.ceil(score);
	  };

	  exports.isMatch = isMatch = function(subject, query_lw, query_up) {
	    var i, j, m, n, qj_lw, qj_up, si;
	    m = subject.length;
	    n = query_lw.length;
	    if (!m || n > m) {
	      return false;
	    }
	    i = -1;
	    j = -1;
	    while (++j < n) {
	      qj_lw = query_lw.charCodeAt(j);
	      qj_up = query_up.charCodeAt(j);
	      while (++i < m) {
	        si = subject.charCodeAt(i);
	        if (si === qj_lw || si === qj_up) {
	          break;
	        }
	      }
	      if (i === m) {
	        return false;
	      }
	    }
	    return true;
	  };

	  exports.computeScore = computeScore = function(subject, subject_lw, preparedQuery) {
	    var acro, acro_score, align, csc_diag, csc_invalid, csc_row, csc_score, i, j, m, miss_budget, miss_left, mm, n, pos, query, query_lw, record_miss, score, score_diag, score_row, score_up, si_lw, start, sz;
	    query = preparedQuery.query;
	    query_lw = preparedQuery.query_lw;
	    m = subject.length;
	    n = query.length;
	    acro = scoreAcronyms(subject, subject_lw, query, query_lw);
	    acro_score = acro.score;
	    if (acro.count === n) {
	      return scoreExact(n, m, acro_score, acro.pos);
	    }
	    pos = subject_lw.indexOf(query_lw);
	    if (pos > -1) {
	      return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);
	    }
	    score_row = new Array(n);
	    csc_row = new Array(n);
	    sz = scoreSize(n, m);
	    miss_budget = Math.ceil(miss_coeff * n) + 5;
	    miss_left = miss_budget;
	    j = -1;
	    while (++j < n) {
	      score_row[j] = 0;
	      csc_row[j] = 0;
	    }
	    i = subject_lw.indexOf(query_lw[0]);
	    if (i > -1) {
	      i--;
	    }
	    mm = subject_lw.lastIndexOf(query_lw[n - 1], m);
	    if (mm > i) {
	      m = mm + 1;
	    }
	    csc_invalid = true;
	    while (++i < m) {
	      si_lw = subject_lw[i];
	      if (preparedQuery.charCodes[si_lw.charCodeAt(0)] == null) {
	        if (csc_invalid !== true) {
	          j = -1;
	          while (++j < n) {
	            csc_row[j] = 0;
	          }
	          csc_invalid = true;
	        }
	        continue;
	      }
	      score = 0;
	      score_diag = 0;
	      csc_diag = 0;
	      record_miss = true;
	      csc_invalid = false;
	      j = -1;
	      while (++j < n) {
	        score_up = score_row[j];
	        if (score_up > score) {
	          score = score_up;
	        }
	        csc_score = 0;
	        if (query_lw[j] === si_lw) {
	          start = isWordStart(i, subject, subject_lw);
	          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
	          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);
	          if (align > score) {
	            score = align;
	            miss_left = miss_budget;
	          } else {
	            if (record_miss && --miss_left <= 0) {
	              return score_row[n - 1] * sz;
	            }
	            record_miss = false;
	          }
	        }
	        score_diag = score_up;
	        csc_diag = csc_row[j];
	        csc_row[j] = csc_score;
	        score_row[j] = score;
	      }
	    }
	    score = score_row[n - 1];
	    return score * sz;
	  };

	  exports.isWordStart = isWordStart = function(pos, subject, subject_lw) {
	    var curr_s, prev_s;
	    if (pos === 0) {
	      return true;
	    }
	    curr_s = subject[pos];
	    prev_s = subject[pos - 1];
	    return isSeparator(prev_s) || (curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1]);
	  };

	  exports.isWordEnd = isWordEnd = function(pos, subject, subject_lw, len) {
	    var curr_s, next_s;
	    if (pos === len - 1) {
	      return true;
	    }
	    curr_s = subject[pos];
	    next_s = subject[pos + 1];
	    return isSeparator(next_s) || (curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1]);
	  };

	  isSeparator = function(c) {
	    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\';
	  };

	  scorePosition = function(pos) {
	    var sc;
	    if (pos < pos_bonus) {
	      sc = pos_bonus - pos;
	      return 100 + sc * sc;
	    } else {
	      return Math.max(100 + pos_bonus - pos, 0);
	    }
	  };

	  exports.scoreSize = scoreSize = function(n, m) {
	    return tau_size / (tau_size + Math.abs(m - n));
	  };

	  scoreExact = function(n, m, quality, pos) {
	    return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);
	  };

	  exports.scorePattern = scorePattern = function(count, len, sameCase, start, end) {
	    var bonus, sz;
	    sz = count;
	    bonus = 6;
	    if (sameCase === count) {
	      bonus += 2;
	    }
	    if (start) {
	      bonus += 3;
	    }
	    if (end) {
	      bonus += 1;
	    }
	    if (count === len) {
	      if (start) {
	        if (sameCase === len) {
	          sz += 2;
	        } else {
	          sz += 1;
	        }
	      }
	      if (end) {
	        bonus += 1;
	      }
	    }
	    return sameCase + sz * (sz + bonus);
	  };

	  exports.scoreCharacter = scoreCharacter = function(i, j, start, acro_score, csc_score) {
	    var posBonus;
	    posBonus = scorePosition(i);
	    if (start) {
	      return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);
	    }
	    return posBonus + wm * csc_score;
	  };

	  exports.scoreConsecutives = scoreConsecutives = function(subject, subject_lw, query, query_lw, i, j, startOfWord) {
	    var k, m, mi, n, nj, sameCase, sz;
	    m = subject.length;
	    n = query.length;
	    mi = m - i;
	    nj = n - j;
	    k = mi < nj ? mi : nj;
	    sameCase = 0;
	    sz = 0;
	    if (query[j] === subject[i]) {
	      sameCase++;
	    }
	    while (++sz < k && query_lw[++j] === subject_lw[++i]) {
	      if (query[j] === subject[i]) {
	        sameCase++;
	      }
	    }
	    if (sz === 1) {
	      return 1 + 2 * sameCase;
	    }
	    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));
	  };

	  exports.scoreExactMatch = scoreExactMatch = function(subject, subject_lw, query, query_lw, pos, n, m) {
	    var end, i, pos2, sameCase, start;
	    start = isWordStart(pos, subject, subject_lw);
	    if (!start) {
	      pos2 = subject_lw.indexOf(query_lw, pos + 1);
	      if (pos2 > -1) {
	        start = isWordStart(pos2, subject, subject_lw);
	        if (start) {
	          pos = pos2;
	        }
	      }
	    }
	    i = -1;
	    sameCase = 0;
	    while (++i < n) {
	      if (query[pos + i] === subject[i]) {
	        sameCase++;
	      }
	    }
	    end = isWordEnd(pos + n - 1, subject, subject_lw, m);
	    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);
	  };

	  AcronymResult = (function() {
	    function AcronymResult(score, pos, count) {
	      this.score = score;
	      this.pos = pos;
	      this.count = count;
	    }

	    return AcronymResult;

	  })();

	  emptyAcronymResult = new AcronymResult(0, 0.1, 0);

	  exports.scoreAcronyms = scoreAcronyms = function(subject, subject_lw, query, query_lw) {
	    var count, fullWord, i, j, m, n, qj_lw, sameCase, score, sepCount, sumPos;
	    m = subject.length;
	    n = query.length;
	    if (!(m > 1 && n > 1)) {
	      return emptyAcronymResult;
	    }
	    count = 0;
	    sepCount = 0;
	    sumPos = 0;
	    sameCase = 0;
	    i = -1;
	    j = -1;
	    while (++j < n) {
	      qj_lw = query_lw[j];
	      if (isSeparator(qj_lw)) {
	        i = subject_lw.indexOf(qj_lw, i + 1);
	        if (i > -1) {
	          sepCount++;
	          continue;
	        } else {
	          break;
	        }
	      }
	      while (++i < m) {
	        if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {
	          if (query[j] === subject[i]) {
	            sameCase++;
	          }
	          sumPos += i;
	          count++;
	          break;
	        }
	      }
	      if (i === m) {
	        break;
	      }
	    }
	    if (count < 2) {
	      return emptyAcronymResult;
	    }
	    fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;
	    score = scorePattern(count, n, sameCase, true, fullWord);
	    return new AcronymResult(score, sumPos / count, count + sepCount);
	  };

	  isAcronymFullWord = function(subject, subject_lw, query, nbAcronymInQuery) {
	    var count, i, m, n;
	    m = subject.length;
	    n = query.length;
	    count = 0;
	    if (m > 12 * n) {
	      return false;
	    }
	    i = -1;
	    while (++i < m) {
	      if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {
	        return false;
	      }
	    }
	    return true;
	  };

	}).call(this);


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var computeScore, countDir, file_coeff, getExtension, getExtensionScore, isMatch, scorePath, scoreSize, tau_depth, _ref;

	  _ref = __webpack_require__(163), isMatch = _ref.isMatch, computeScore = _ref.computeScore, scoreSize = _ref.scoreSize;

	  tau_depth = 13;

	  file_coeff = 1.2;

	  exports.score = function(string, query, options) {
	    var allowErrors, preparedQuery, score, string_lw;
	    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;
	    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
	      return 0;
	    }
	    string_lw = string.toLowerCase();
	    score = computeScore(string, string_lw, preparedQuery);
	    score = scorePath(string, string_lw, score, options);
	    return Math.ceil(score);
	  };

	  scorePath = function(subject, subject_lw, fullPathScore, options) {
	    var alpha, basePathScore, basePos, depth, end, extAdjust, fileLength, pathSeparator, preparedQuery, useExtensionBonus;
	    if (fullPathScore === 0) {
	      return 0;
	    }
	    preparedQuery = options.preparedQuery, useExtensionBonus = options.useExtensionBonus, pathSeparator = options.pathSeparator;
	    end = subject.length - 1;
	    while (subject[end] === pathSeparator) {
	      end--;
	    }
	    basePos = subject.lastIndexOf(pathSeparator, end);
	    fileLength = end - basePos;
	    extAdjust = 1.0;
	    if (useExtensionBonus) {
	      extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);
	      fullPathScore *= extAdjust;
	    }
	    if (basePos === -1) {
	      return fullPathScore;
	    }
	    depth = preparedQuery.depth;
	    while (basePos > -1 && depth-- > 0) {
	      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);
	    }
	    basePathScore = basePos === -1 ? fullPathScore : extAdjust * computeScore(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery);
	    alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));
	    return alpha * basePathScore + (1 - alpha) * fullPathScore * scoreSize(0, file_coeff * fileLength);
	  };

	  exports.countDir = countDir = function(path, end, pathSeparator) {
	    var count, i;
	    if (end < 1) {
	      return 0;
	    }
	    count = 0;
	    i = -1;
	    while (++i < end && path[i] === pathSeparator) {
	      continue;
	    }
	    while (++i < end) {
	      if (path[i] === pathSeparator) {
	        count++;
	        while (++i < end && path[i] === pathSeparator) {
	          continue;
	        }
	      }
	    }
	    return count;
	  };

	  exports.getExtension = getExtension = function(str) {
	    var pos;
	    pos = str.lastIndexOf(".");
	    if (pos < 0) {
	      return "";
	    } else {
	      return str.substr(pos + 1);
	    }
	  };

	  getExtensionScore = function(candidate, ext, startPos, endPos, maxDepth) {
	    var m, matched, n, pos;
	    if (!ext.length) {
	      return 0;
	    }
	    pos = candidate.lastIndexOf(".", endPos);
	    if (!(pos > startPos)) {
	      return 0;
	    }
	    n = ext.length;
	    m = endPos - pos;
	    if (m < n) {
	      n = m;
	      m = ext.length;
	    }
	    pos++;
	    matched = -1;
	    while (++matched < n) {
	      if (candidate[pos + matched] !== ext[matched]) {
	        break;
	      }
	    }
	    if (matched === 0 && maxDepth > 0) {
	      return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);
	    }
	    return matched / m;
	  };

	}).call(this);


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var Query, coreChars, countDir, getCharCodes, getExtension, opt_char_re, truncatedUpperCase, _ref;

	  _ref = __webpack_require__(164), countDir = _ref.countDir, getExtension = _ref.getExtension;

	  module.exports = Query = (function() {
	    function Query(query, _arg) {
	      var optCharRegEx, pathSeparator, _ref1;
	      _ref1 = _arg != null ? _arg : {}, optCharRegEx = _ref1.optCharRegEx, pathSeparator = _ref1.pathSeparator;
	      if (!(query && query.length)) {
	        return null;
	      }
	      this.query = query;
	      this.query_lw = query.toLowerCase();
	      this.core = coreChars(query, optCharRegEx);
	      this.core_lw = this.core.toLowerCase();
	      this.core_up = truncatedUpperCase(this.core);
	      this.depth = countDir(query, query.length, pathSeparator);
	      this.ext = getExtension(this.query_lw);
	      this.charCodes = getCharCodes(this.query_lw);
	    }

	    return Query;

	  })();

	  opt_char_re = /[ _\-:\/\\]/g;

	  coreChars = function(query, optCharRegEx) {
	    if (optCharRegEx == null) {
	      optCharRegEx = opt_char_re;
	    }
	    return query.replace(optCharRegEx, '');
	  };

	  truncatedUpperCase = function(str) {
	    var char, upper, _i, _len;
	    upper = "";
	    for (_i = 0, _len = str.length; _i < _len; _i++) {
	      char = str[_i];
	      upper += char.toUpperCase()[0];
	    }
	    return upper;
	  };

	  getCharCodes = function(str) {
	    var charCodes, i, len;
	    len = str.length;
	    i = -1;
	    charCodes = [];
	    while (++i < len) {
	      charCodes[str.charCodeAt(i)] = true;
	    }
	    return charCodes;
	  };

	}).call(this);


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var basenameMatch, computeMatch, isMatch, isWordStart, match, mergeMatches, scoreAcronyms, scoreCharacter, scoreConsecutives, _ref;

	  _ref = __webpack_require__(163), isMatch = _ref.isMatch, isWordStart = _ref.isWordStart, scoreConsecutives = _ref.scoreConsecutives, scoreCharacter = _ref.scoreCharacter, scoreAcronyms = _ref.scoreAcronyms;

	  exports.match = match = function(string, query, options) {
	    var allowErrors, baseMatches, matches, pathSeparator, preparedQuery, string_lw;
	    allowErrors = options.allowErrors, preparedQuery = options.preparedQuery, pathSeparator = options.pathSeparator;
	    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
	      return [];
	    }
	    string_lw = string.toLowerCase();
	    matches = computeMatch(string, string_lw, preparedQuery);
	    if (matches.length === 0) {
	      return matches;
	    }
	    if (string.indexOf(pathSeparator) > -1) {
	      baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);
	      matches = mergeMatches(matches, baseMatches);
	    }
	    return matches;
	  };

	  exports.wrap = function(string, query, options) {
	    var matchIndex, matchPos, matchPositions, output, strPos, tagClass, tagClose, tagOpen, _ref1;
	    if ((options.wrap != null)) {
	      _ref1 = options.wrap, tagClass = _ref1.tagClass, tagOpen = _ref1.tagOpen, tagClose = _ref1.tagClose;
	    }
	    if (tagClass == null) {
	      tagClass = 'highlight';
	    }
	    if (tagOpen == null) {
	      tagOpen = '<strong class="' + tagClass + '">';
	    }
	    if (tagClose == null) {
	      tagClose = '</strong>';
	    }
	    if (string === query) {
	      return tagOpen + string + tagClose;
	    }
	    matchPositions = match(string, query, options);
	    if (matchPositions.length === 0) {
	      return string;
	    }
	    output = '';
	    matchIndex = -1;
	    strPos = 0;
	    while (++matchIndex < matchPositions.length) {
	      matchPos = matchPositions[matchIndex];
	      if (matchPos > strPos) {
	        output += string.substring(strPos, matchPos);
	        strPos = matchPos;
	      }
	      while (++matchIndex < matchPositions.length) {
	        if (matchPositions[matchIndex] === matchPos + 1) {
	          matchPos++;
	        } else {
	          matchIndex--;
	          break;
	        }
	      }
	      matchPos++;
	      if (matchPos > strPos) {
	        output += tagOpen;
	        output += string.substring(strPos, matchPos);
	        output += tagClose;
	        strPos = matchPos;
	      }
	    }
	    if (strPos < string.length - 1) {
	      output += string.substring(strPos);
	    }
	    return output;
	  };

	  basenameMatch = function(subject, subject_lw, preparedQuery, pathSeparator) {
	    var basePos, depth, end;
	    end = subject.length - 1;
	    while (subject[end] === pathSeparator) {
	      end--;
	    }
	    basePos = subject.lastIndexOf(pathSeparator, end);
	    if (basePos === -1) {
	      return [];
	    }
	    depth = preparedQuery.depth;
	    while (depth-- > 0) {
	      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);
	      if (basePos === -1) {
	        return [];
	      }
	    }
	    basePos++;
	    end++;
	    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);
	  };

	  mergeMatches = function(a, b) {
	    var ai, bj, i, j, m, n, out;
	    m = a.length;
	    n = b.length;
	    if (n === 0) {
	      return a.slice();
	    }
	    if (m === 0) {
	      return b.slice();
	    }
	    i = -1;
	    j = 0;
	    bj = b[j];
	    out = [];
	    while (++i < m) {
	      ai = a[i];
	      while (bj <= ai && ++j < n) {
	        if (bj < ai) {
	          out.push(bj);
	        }
	        bj = b[j];
	      }
	      out.push(ai);
	    }
	    while (j < n) {
	      out.push(b[j++]);
	    }
	    return out;
	  };

	  computeMatch = function(subject, subject_lw, preparedQuery, offset) {
	    var DIAGONAL, LEFT, STOP, UP, acro_score, align, backtrack, csc_diag, csc_row, csc_score, i, j, m, matches, move, n, pos, query, query_lw, score, score_diag, score_row, score_up, si_lw, start, trace;
	    if (offset == null) {
	      offset = 0;
	    }
	    query = preparedQuery.query;
	    query_lw = preparedQuery.query_lw;
	    m = subject.length;
	    n = query.length;
	    acro_score = scoreAcronyms(subject, subject_lw, query, query_lw).score;
	    score_row = new Array(n);
	    csc_row = new Array(n);
	    STOP = 0;
	    UP = 1;
	    LEFT = 2;
	    DIAGONAL = 3;
	    trace = new Array(m * n);
	    pos = -1;
	    j = -1;
	    while (++j < n) {
	      score_row[j] = 0;
	      csc_row[j] = 0;
	    }
	    i = -1;
	    while (++i < m) {
	      score = 0;
	      score_up = 0;
	      csc_diag = 0;
	      si_lw = subject_lw[i];
	      j = -1;
	      while (++j < n) {
	        csc_score = 0;
	        align = 0;
	        score_diag = score_up;
	        if (query_lw[j] === si_lw) {
	          start = isWordStart(i, subject, subject_lw);
	          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
	          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);
	        }
	        score_up = score_row[j];
	        csc_diag = csc_row[j];
	        if (score > score_up) {
	          move = LEFT;
	        } else {
	          score = score_up;
	          move = UP;
	        }
	        if (align > score) {
	          score = align;
	          move = DIAGONAL;
	        } else {
	          csc_score = 0;
	        }
	        score_row[j] = score;
	        csc_row[j] = csc_score;
	        trace[++pos] = score > 0 ? move : STOP;
	      }
	    }
	    i = m - 1;
	    j = n - 1;
	    pos = i * n + j;
	    backtrack = true;
	    matches = [];
	    while (backtrack && i >= 0 && j >= 0) {
	      switch (trace[pos]) {
	        case UP:
	          i--;
	          pos -= n;
	          break;
	        case LEFT:
	          j--;
	          pos--;
	          break;
	        case DIAGONAL:
	          matches.push(i + offset);
	          j--;
	          i--;
	          pos -= n + 1;
	          break;
	        default:
	          backtrack = false;
	      }
	    }
	    matches.reverse();
	    return matches;
	  };

	}).call(this);


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(2);

	__webpack_require__(168);
	var dom = React.DOM;

	var ImPropTypes = __webpack_require__(150);

	var Tabs = React.createFactory(__webpack_require__(172));
	var Sidebar = React.createFactory(__webpack_require__(176));
	var Settings = React.createFactory(__webpack_require__(179));

	var githubUrl = "https://github.com/devtools-html/debugger.html/blob/master";

	function getTabsByClientType(tabs, clientType) {
	  return tabs.valueSeq().filter(tab => tab.get("clientType") == clientType);
	}

	function firstTimeMessage(title, urlPart) {
	  return dom.div({ className: "footer-note" }, `First time connecting to ${title}? Checkout out the `, dom.a({
	    href: `${githubUrl}/docs/getting-setup.md#starting-${urlPart}`
	  }, "docs"), ".");
	}

	var LandingPage = React.createClass({
	  propTypes: {
	    tabs: ImPropTypes.map.isRequired,
	    supportsFirefox: React.PropTypes.bool.isRequired,
	    supportsChrome: React.PropTypes.bool.isRequired,
	    title: React.PropTypes.string.isRequired,
	    filterString: React.PropTypes.string,
	    onFilterChange: React.PropTypes.func.isRequired,
	    onTabClick: React.PropTypes.func.isRequired,
	    config: React.PropTypes.object.isRequired,
	    setValue: React.PropTypes.func.isRequired
	  },

	  displayName: "LandingPage",

	  getInitialState() {
	    return {
	      selectedPane: "Firefox",
	      firefoxConnected: false,
	      chromeConnected: false
	    };
	  },

	  componentDidUpdate() {
	    if (this.refs.filterInput) {
	      this.refs.filterInput.focus();
	    }
	  },

	  onFilterChange(newFilterString) {
	    this.props.onFilterChange(newFilterString);
	  },

	  onSideBarItemClick(itemTitle) {
	    if (itemTitle !== this.state.selectedPane) {
	      this.setState({ selectedPane: itemTitle });
	    }
	  },

	  renderPanel() {
	    var _props = this.props,
	        onTabClick = _props.onTabClick,
	        config = _props.config,
	        setValue = _props.setValue;

	    var configMap = {
	      Firefox: {
	        name: "Firefox",
	        clientType: "firefox",
	        paramName: "firefox-tab",
	        docsUrlPart: "firefox"
	      },
	      Chrome: {
	        name: "Chrome",
	        clientType: "chrome",
	        paramName: "chrome-tab",
	        docsUrlPart: "chrome"
	      },
	      Node: {
	        name: "Node",
	        clientType: "node",
	        paramName: "node-tab",
	        docsUrlPart: "node"
	      },
	      Settings: {
	        name: "Settings",
	        clientType: "settings",
	        paramName: "settings-tab",
	        docsUrlPart: "settings"
	      }
	    };

	    var _configMap$state$sele = configMap[this.state.selectedPane],
	        name = _configMap$state$sele.name,
	        clientType = _configMap$state$sele.clientType,
	        paramName = _configMap$state$sele.paramName,
	        docsUrlPart = _configMap$state$sele.docsUrlPart;
	    var _props2 = this.props,
	        tabs = _props2.tabs,
	        _props2$filterString = _props2.filterString,
	        filterString = _props2$filterString === undefined ? "" : _props2$filterString;
	    var selectedPane = this.state.selectedPane;


	    var targets = getTabsByClientType(tabs, clientType);
	    var isSettingsPaneSelected = name === "Settings";

	    var launchBrowser = browser => {
	      fetch("/launch", {
	        body: JSON.stringify({ browser }),
	        headers: {
	          "Content-Type": "application/json"
	        },
	        method: "post"
	      }).then(resp => {
	        if (browser == "firefox") {
	          this.setState({ firefoxConnected: true });
	        } else {
	          this.setState({ chromeConnected: true });
	        }
	      }).catch(err => {
	        alert(`Error launching ${browser}. ${err.message}`);
	      });
	    };

	    var isConnected = name == "Firefox" ? this.state.firefoxConnected : this.state.chromeConnected;
	    var launchButton = isConnected ? null : dom.input({
	      type: "button",
	      value: `Launch ${selectedPane}`,
	      onClick: () => launchBrowser(selectedPane)
	    });
	    return dom.main({ className: "panel" }, !isSettingsPaneSelected ? dom.header({}, dom.input({
	      ref: "filterInput",
	      placeholder: "Filter tabs",
	      value: filterString,
	      autoFocus: true,
	      type: "search",
	      onChange: e => this.onFilterChange(e.target.value),
	      onKeyDown: e => {
	        if (targets.size === 1 && e.keyCode === 13) {
	          this.onTabClick(targets.first(), paramName);
	        }
	      }
	    }), launchButton) : dom.header({}, dom.h1({}, "Settings")), isSettingsPaneSelected ? Settings({ config, setValue }) : Tabs({ targets, paramName, onTabClick }), firstTimeMessage(name, docsUrlPart));
	  },

	  render() {
	    var _props3 = this.props,
	        supportsFirefox = _props3.supportsFirefox,
	        supportsChrome = _props3.supportsChrome,
	        title = _props3.title;
	    var selectedPane = this.state.selectedPane;
	    var onSideBarItemClick = this.onSideBarItemClick;

	    return dom.div({
	      className: "landing-page"
	    }, Sidebar({
	      supportsFirefox, supportsChrome, title,
	      selectedPane, onSideBarItemClick
	    }), this.renderPanel());
	  }
	});

	module.exports = LandingPage;

/***/ },
/* 168 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(2);

	__webpack_require__(173);
	var dom = React.DOM;

	var classnames = __webpack_require__(175);

	function getTabURL(tab, paramName) {
	  var tabID = tab.get("id");
	  return `/?${paramName}=${tabID}`;
	}

	var Tabs = React.createClass({
	  propTypes: {
	    targets: React.PropTypes.object.isRequired,
	    paramName: React.PropTypes.string.isRequired,
	    onTabClick: React.PropTypes.func.isRequired
	  },

	  displayName: "Tabs",

	  onTabClick(tab, paramName) {
	    this.props.onTabClick(getTabURL(tab, paramName));
	  },

	  render() {
	    var _props = this.props,
	        targets = _props.targets,
	        paramName = _props.paramName;


	    if (!targets || targets.count() == 0) {
	      return dom.div({}, "");
	    }

	    var tabClassNames = ["tab"];
	    if (targets.size === 1) {
	      tabClassNames.push("active");
	    }

	    return dom.div({ className: "tab-group" }, dom.ul({ className: "tab-list" }, targets.valueSeq().map(tab => dom.li({
	      className: classnames("tab", {
	        active: targets.size === 1
	      }),
	      key: tab.get("id"),
	      tabIndex: 0,
	      role: "link",
	      onClick: () => this.onTabClick(tab, paramName),
	      onKeyDown: e => {
	        if (e.keyCode === 13) {
	          this.onTabClick(tab, paramName);
	        }
	      }
	    }, dom.div({ className: "tab-title" }, tab.get("title")), dom.div({ className: "tab-url" }, tab.get("url"))))));
	  }

	});

	module.exports = Tabs;

/***/ },
/* 173 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 174 */,
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {
		'use strict';

		var hasOwn = {}.hasOwnProperty;

		function classNames () {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(2);

	__webpack_require__(177);
	var dom = React.DOM;

	var classnames = __webpack_require__(175);

	var Sidebar = React.createClass({

	  propTypes: {
	    supportsFirefox: React.PropTypes.bool.isRequired,
	    supportsChrome: React.PropTypes.bool.isRequired,
	    title: React.PropTypes.string.isRequired,
	    selectedPane: React.PropTypes.string.isRequired,
	    onSideBarItemClick: React.PropTypes.func.isRequired
	  },

	  displayName: "Sidebar",

	  render() {
	    var connections = [];

	    if (this.props.supportsFirefox) {
	      connections.push("Firefox");
	    }

	    if (this.props.supportsChrome) {
	      connections.push("Chrome", "Node");
	    }

	    connections.push("Settings");

	    return dom.aside({
	      className: "sidebar"
	    }, dom.h1({}, this.props.title), dom.ul({}, connections.map(title => dom.li({
	      className: classnames({
	        selected: title == this.props.selectedPane
	      }),
	      key: title,
	      tabIndex: 0,
	      role: "button",
	      onClick: () => this.props.onSideBarItemClick(title),
	      onKeyDown: e => {
	        if (e.keyCode === 13) {
	          this.props.onSideBarItemClick(title);
	        }
	      }
	    }, dom.a({}, title)))));
	  }
	});

	module.exports = Sidebar;

/***/ },
/* 177 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 178 */,
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(2);
	var dom = React.DOM;

	var _require = __webpack_require__(180),
	    showMenu = _require.showMenu,
	    buildMenu = _require.buildMenu;

	var Settings = React.createClass({
	  propTypes: {
	    config: React.PropTypes.object.isRequired,
	    setValue: React.PropTypes.func.isRequired
	  },

	  displayName: "Settings",

	  onConfigContextMenu(event, key) {
	    event.preventDefault();

	    var _props = this.props,
	        setValue = _props.setValue,
	        config = _props.config;


	    var setConfig = (path, value) => {
	      setValue(path, value);
	    };

	    var ltrMenuItem = {
	      id: "node-menu-ltr",
	      label: "ltr",
	      disabled: config[key] === "ltr",
	      click: () => setConfig(key, "ltr")
	    };

	    var rtlMenuItem = {
	      id: "node-menu-rtl",
	      label: "rtl",
	      disabled: config[key] === "rtl",
	      click: () => setConfig(key, "rtl")
	    };

	    var lightMenuItem = {
	      id: "node-menu-light",
	      label: "light",
	      disabled: config[key] === "light",
	      click: () => setConfig(key, "light")
	    };

	    var darkMenuItem = {
	      id: "node-menu-dark",
	      label: "dark",
	      disabled: config[key] === "dark",
	      click: () => setConfig(key, "dark")
	    };

	    var firebugMenuItem = {
	      id: "node-menu-firebug",
	      label: "firebug",
	      disabled: config[key] === "firebug",
	      click: () => setConfig(key, "firebug")
	    };

	    var items = {
	      "dir": [{ item: ltrMenuItem }, { item: rtlMenuItem }],
	      "theme": [{ item: lightMenuItem }, { item: darkMenuItem }, { item: firebugMenuItem }]
	    };
	    showMenu(event, buildMenu(items[key]));
	  },

	  onInputHandler(e, path) {
	    var setValue = this.props.setValue;

	    setValue(path, e.target.checked);
	  },

	  renderConfig(config) {
	    var configs = [{ name: "dir", label: "direction" }, { name: "theme", label: "theme" }
	    // Hiding hotReloading option for now. See Issue #242
	    // { name: "hotReloading", label: "hot reloading", bool: true }
	    ];

	    return dom.ul({ className: "tab-list" }, configs.map(c => {
	      return dom.li({ key: c.name, className: "tab tab-sides" }, dom.div({ className: "tab-title" }, c.label), c.bool ? dom.input({
	        type: "checkbox",
	        defaultChecked: config[c.name],
	        onChange: e => this.onInputHandler(e, c.name)
	      }, null) : dom.div({
	        className: "tab-value",
	        onClick: e => this.onConfigContextMenu(e, c.name)
	      }, config[c.name]));
	    }));
	  },

	  renderFeatures(features) {
	    return dom.ul({ className: "tab-list" }, Object.keys(features).map(key => dom.li({
	      className: "tab tab-sides",
	      key
	    }, dom.div({ className: "tab-title" }, typeof features[key] == "object" ? features[key].label : key), dom.div({ className: "tab-value" }, dom.input({
	      type: "checkbox",
	      defaultChecked: features[key].enabled,
	      onChange: e => this.onInputHandler(e, `features.${key}.enabled`)
	    })))));
	  },

	  render() {
	    var config = this.props.config;


	    return dom.div({ className: "tab-group" }, dom.h3({}, "Configurations"), this.renderConfig(config), config.features ? (dom.h3({}, "Features"), this.renderFeatures(config.features)) : null);
	  }
	});

	module.exports = Settings;

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _require = __webpack_require__(830),
	    Menu = _require.Menu,
	    MenuItem = _require.MenuItem;

	var _require2 = __webpack_require__(828),
	    isFirefoxPanel = _require2.isFirefoxPanel;

	function createPopup(doc) {
	  var popup = doc.createElement("menupopup");
	  popup.className = "landing-popup";
	  if (popup.openPopupAtScreen) {
	    return popup;
	  }

	  function preventDefault(e) {
	    e.preventDefault();
	    e.returnValue = false;
	  }

	  var mask = document.querySelector("#contextmenu-mask");
	  if (!mask) {
	    mask = doc.createElement("div");
	    mask.id = "contextmenu-mask";
	    document.body.appendChild(mask);
	  }

	  mask.onclick = () => popup.hidePopup();

	  popup.openPopupAtScreen = function (clientX, clientY) {
	    this.style.setProperty("left", `${clientX}px`);
	    this.style.setProperty("top", `${clientY}px`);
	    mask = document.querySelector("#contextmenu-mask");
	    window.onwheel = preventDefault;
	    mask.classList.add("show");
	    this.dispatchEvent(new Event("popupshown"));
	    this.popupshown;
	  };

	  popup.hidePopup = function () {
	    this.remove();
	    mask = document.querySelector("#contextmenu-mask");
	    mask.classList.remove("show");
	    window.onwheel = null;
	  };

	  return popup;
	}

	if (!isFirefoxPanel()) {
	  Menu.prototype.createPopup = createPopup;
	}

	function onShown(menu, popup) {
	  popup.childNodes.forEach((menuitem, index) => {
	    var item = menu.items[index];

	    if (!item.disabled) {
	      menuitem.onclick = () => {
	        item.click();
	        popup.hidePopup();
	      };
	    }
	  });
	}

	function showMenu(e, items) {
	  if (items.length === 0) {
	    return;
	  }

	  var menu = new Menu();
	  items.forEach(item => menu.append(new MenuItem(item)));

	  if (isFirefoxPanel()) {
	    return menu.popup(e.screenX, e.screenY, { doc: window.parent.document });
	  }

	  menu.on("open", (_, popup) => onShown(menu, popup));
	  menu.popup(e.clientX, e.clientY, { doc: document });
	}

	function buildMenu(items) {
	  return items.map(itm => {
	    var hide = typeof itm.hidden === "function" ? itm.hidden() : itm.hidden;
	    return hide ? null : itm.item;
	  }).filter(itm => itm !== null);
	}

	module.exports = {
	  showMenu,
	  buildMenu
	};

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var tabs = __webpack_require__(182);
	var config = __webpack_require__(183);

	module.exports = Object.assign({}, tabs, config);

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* global window */

	/**
	 * Redux actions for the pause state
	 * @module actions/tabs
	 */

	var constants = __webpack_require__(145);

	/**
	 * @typedef {Object} TabAction
	 * @memberof actions/tabs
	 * @static
	 * @property {number} type The type of Action
	 * @property {number} value The payload of the Action
	 */

	/**
	 * @memberof actions/tabs
	 * @static
	 * @returns {TabAction} with type constants.CLEAR_TABS and tabs as value
	 */
	function clearTabs() {
	  return {
	    type: constants.CLEAR_TABS
	  };
	}

	/**
	 * @memberof actions/tabs
	 * @static
	 * @param {Array} tabs
	 * @returns {TabAction} with type constants.ADD_TABS and tabs as value
	 */
	function newTabs(tabs) {
	  return (_ref) => {
	    var getState = _ref.getState,
	        dispatch = _ref.dispatch;

	    return dispatch({
	      type: constants.ADD_TABS,
	      value: tabs
	    });
	  };
	}

	/**
	 * @memberof actions/tabs
	 * @static
	 * @param {String} $0.id Unique ID of the tab to select
	 * @returns {TabAction}
	 */
	function selectTab(_ref2) {
	  var id = _ref2.id;

	  return {
	    type: constants.SELECT_TAB,
	    id: id
	  };
	}

	/**
	 * @memberof actions/tabs
	 * @static
	 * @param {String} value String which should be used to filter tabs
	 * @returns {TabAction} with type constants.FILTER_TABS
	 *          and filter string as value
	 */
	function filterTabs(value) {
	  return {
	    type: constants.FILTER_TABS,
	    value
	  };
	}

	module.exports = {
	  newTabs,
	  selectTab,
	  filterTabs,
	  clearTabs
	};

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var _require = __webpack_require__(828),
	    _setConfig = _require.setConfig;

	var _require2 = __webpack_require__(131),
	    updateTheme = _require2.updateTheme,
	    updateDir = _require2.updateDir;

	/**
	 * Redux actions for the pause state
	 * @module actions/config
	 */

	var constants = __webpack_require__(145);


	/**
	 * @typedef {Object} ConfigAction
	 * @memberof actions/config
	 * @static
	 * @property {number} type The type of Action
	 * @property {number} value The payload of the Action
	 */

	/**
	 * @memberof actions/config
	 * @static
	 * @param {string} path
	 * @param {string} value
	 * @returns {ConfigAction} with type constants.SET_VALUE and value
	 */
	function setValue(path, value) {
	  return (() => {
	    var _ref = _asyncToGenerator(function* (_ref2) {
	      var dispatch = _ref2.dispatch;

	      var response = yield fetch("/setconfig", {
	        method: "post",
	        headers: { "Content-Type": "application/json" },
	        body: JSON.stringify({ path, value })
	      });

	      var config = yield response.json();
	      _setConfig(config);
	      updateTheme();
	      updateDir();

	      dispatch({
	        type: constants.SET_VALUE,
	        path,
	        value
	      });
	    });

	    return function (_x) {
	      return _ref.apply(this, arguments);
	    };
	  })();
	}

	/**
	 * @memberof actions/config
	 * @static
	 * @param {string} config
	 * @returns {ConfigAction} with type constants.SET_CONFIG and config
	 */
	function setConfig(config) {
	  return {
	    type: constants.SET_CONFIG,
	    config
	  };
	}

	module.exports = {
	  setValue,
	  setConfig
	};

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _require = __webpack_require__(828),
	    isDevelopment = _require.isDevelopment,
	    isTesting = _require.isTesting;

	function debugGlobal(field, value) {
	  if (isDevelopment() || isTesting()) {
	    window[field] = value;
	  }
	}

	module.exports = {
	  debugGlobal
	};

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var _require = __webpack_require__(830),
	    sprintf = _require.sprintf;

	var _require2 = __webpack_require__(883),
	    parse = _require2.parse;

	var strings = {};

	function setBundle(bundle) {
	  bundle = parse(bundle);
	  strings = Object.assign(strings, bundle);
	}

	function getStr(key) {
	  if (!strings[key]) {
	    throw new Error(`L10N key ${key} cannot be found.`);
	  }
	  return strings[key];
	}

	function getFormatStr(name) {
	  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }

	  return sprintf.apply(undefined, [getStr(name)].concat(_toConsumableArray(args)));
	}

	function numberWithDecimals(number) {
	  var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	  // If this is an integer, don't do anything special.
	  if (number === (number | 0)) {
	    return number;
	  }
	  // If this isn't a number (and yes, `isNaN(null)` is false), return zero.
	  if (isNaN(number) || number === null) {
	    return "0";
	  }

	  var localized = number.toLocaleString();

	  // If no grouping or decimal separators are available, bail out, because
	  // padding with zeros at the end of the string won't make sense anymore.
	  if (!localized.match(/[^\d]/)) {
	    return localized;
	  }

	  return number.toLocaleString(undefined, {
	    maximumFractionDigits: decimals,
	    minimumFractionDigits: decimals
	  });
	}

	module.exports = {
	  setBundle,
	  getStr,
	  getFormatStr,
	  numberWithDecimals
	};

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var classnames = __webpack_require__(175);
	__webpack_require__(187);

	module.exports = function (className) {
	  var root = document.createElement("div");
	  root.className = classnames(className);
	  root.style.setProperty("flex", 1);
	  return root;
	};

/***/ },
/* 187 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 188 */,
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* global window */

	/**
	 * Redux store utils
	 * @module utils/create-store
	 */

	var _require = __webpack_require__(3),
	    createStore = _require.createStore,
	    applyMiddleware = _require.applyMiddleware;

	var _require2 = __webpack_require__(190),
	    waitUntilService = _require2.waitUntilService;

	var _require3 = __webpack_require__(191),
	    log = _require3.log;

	var _require4 = __webpack_require__(192),
	    history = _require4.history;

	var _require5 = __webpack_require__(193),
	    promise = _require5.promise;

	var _require6 = __webpack_require__(224),
	    thunk = _require6.thunk;

	/**
	 * @memberof utils/create-store
	 * @static
	 */


	/**
	 * This creates a dispatcher with all the standard middleware in place
	 * that all code requires. It can also be optionally configured in
	 * various ways, such as logging and recording.
	 *
	 * @param {object} opts:
	 *        - log: log all dispatched actions to console
	 *        - history: an array to store every action in. Should only be
	 *                   used in tests.
	 *        - middleware: array of middleware to be included in the redux store
	 * @memberof utils/create-store
	 * @static
	 */
	var configureStore = function () {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  var middleware = [thunk(opts.makeThunkArgs), promise,

	  // Order is important: services must go last as they always
	  // operate on "already transformed" actions. Actions going through
	  // them shouldn't have any special fields like promises, they
	  // should just be normal JSON objects.
	  waitUntilService];

	  if (opts.history) {
	    middleware.push(history(opts.history));
	  }

	  if (opts.middleware) {
	    opts.middleware.forEach(fn => middleware.push(fn));
	  }

	  if (opts.log) {
	    middleware.push(log);
	  }

	  // Hook in the redux devtools browser extension if it exists
	  var devtoolsExt = typeof window === "object" && window.devToolsExtension ? window.devToolsExtension() : f => f;

	  return applyMiddleware.apply(undefined, middleware)(devtoolsExt(createStore));
	};

	module.exports = configureStore;

/***/ },
/* 190 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * A middleware which acts like a service, because it is stateful
	 * and "long-running" in the background. It provides the ability
	 * for actions to install a function to be run once when a specific
	 * condition is met by an action coming through the system. Think of
	 * it as a thunk that blocks until the condition is met. Example:
	 *
	 * ```js
	 * const services = { WAIT_UNTIL: require('wait-service').NAME };
	 *
	 * { type: services.WAIT_UNTIL,
	 *   predicate: action => action.type === constants.ADD_ITEM,
	 *   run: (dispatch, getState, action) => {
	 *     // Do anything here. You only need to accept the arguments
	 *     // if you need them. `action` is the action that satisfied
	 *     // the predicate.
	 *   }
	 * }
	 * ```
	 */
	var NAME = exports.NAME = "@@service/waitUntil";

	function waitUntilService(_ref) {
	  var dispatch = _ref.dispatch,
	      getState = _ref.getState;

	  var pending = [];

	  function checkPending(action) {
	    var readyRequests = [];
	    var stillPending = [];

	    // Find the pending requests whose predicates are satisfied with
	    // this action. Wait to run the requests until after we update the
	    // pending queue because the request handler may synchronously
	    // dispatch again and run this service (that use case is
	    // completely valid).
	    for (var request of pending) {
	      if (request.predicate(action)) {
	        readyRequests.push(request);
	      } else {
	        stillPending.push(request);
	      }
	    }

	    pending = stillPending;
	    for (var _request of readyRequests) {
	      _request.run(dispatch, getState, action);
	    }
	  }

	  return next => action => {
	    if (action.type === NAME) {
	      pending.push(action);
	      return null;
	    }
	    var result = next(action);
	    checkPending(action);
	    return result;
	  };
	}
	exports.waitUntilService = waitUntilService;

/***/ },
/* 191 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * A middleware that logs all actions coming through the system
	 * to the console.
	 */
	function log(_ref) {
	  var dispatch = _ref.dispatch,
	      getState = _ref.getState;

	  return next => action => {
	    var actionText = JSON.stringify(action, null, 2);
	    var truncatedActionText = `${actionText.slice(0, 1000)}...`;
	    console.log(`[DISPATCH ${action.type}]`, action, truncatedActionText);
	    next(action);
	  };
	}

	exports.log = log;

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _require = __webpack_require__(828),
	    isDevelopment = _require.isDevelopment;

	/**
	 * A middleware that stores every action coming through the store in the passed
	 * in logging object. Should only be used for tests, as it collects all
	 * action information, which will cause memory bloat.
	 */
	exports.history = function () {
	  var log = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;

	    if (isDevelopment()) {
	      console.warn("Using history middleware stores all actions in state for " + "testing and devtools is not currently running in test " + "mode. Be sure this is intentional.");
	    }
	    return next => action => {
	      log.push(action);
	      next(action);
	    };
	  };
	};

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var defer = __webpack_require__(194);
	var toPairs = __webpack_require__(195);
	var fromPairs = __webpack_require__(221);

	var _require = __webpack_require__(222),
	    executeSoon = _require.executeSoon;

	var PROMISE = exports.PROMISE = "@@dispatch/promise";
	var seqIdVal = 1;

	function seqIdGen() {
	  return seqIdVal++;
	}

	function filterAction(action) {
	  return fromPairs(toPairs(action).filter(pair => pair[0] !== PROMISE));
	}

	function promiseMiddleware(_ref) {
	  var dispatch = _ref.dispatch,
	      getState = _ref.getState;

	  return next => action => {
	    if (!(PROMISE in action)) {
	      return next(action);
	    }

	    var promiseInst = action[PROMISE];
	    var seqId = seqIdGen().toString();

	    // Create a new action that doesn't have the promise field and has
	    // the `seqId` field that represents the sequence id
	    action = Object.assign(filterAction(action), { seqId });

	    dispatch(Object.assign({}, action, { status: "start" }));

	    // Return the promise so action creators can still compose if they
	    // want to.
	    var deferred = defer();
	    promiseInst.then(value => {
	      executeSoon(() => {
	        dispatch(Object.assign({}, action, {
	          status: "done",
	          value: value
	        }));
	        deferred.resolve(value);
	      });
	    }, error => {
	      executeSoon(() => {
	        dispatch(Object.assign({}, action, {
	          status: "error",
	          error: error.message || error
	        }));
	        deferred.reject(error);
	      });
	    });
	    return deferred.promise;
	  };
	}

	exports.promise = promiseMiddleware;

/***/ },
/* 194 */
/***/ function(module, exports) {

	"use strict";

	function defer() {
	  var resolve = void 0; // eslint-disable-line no-unused-vars
	  var reject = void 0; // eslint-disable-line no-unused-vars
	  var promise = new Promise(function (innerResolve, innerReject) {
	    resolve = innerResolve;
	    reject = innerReject;
	  });
	  return {
	    resolve,
	    reject,
	    promise
	  };
	}

	module.exports = defer;

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var createToPairs = __webpack_require__(196),
	    keys = __webpack_require__(205);

	/**
	 * Creates an array of own enumerable string keyed-value pairs for `object`
	 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	 * entries are returned.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias entries
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the key-value pairs.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.toPairs(new Foo);
	 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	 */
	var toPairs = createToPairs(keys);

	module.exports = toPairs;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var baseToPairs = __webpack_require__(197),
	    getTag = __webpack_require__(198),
	    mapToArray = __webpack_require__(203),
	    setToPairs = __webpack_require__(204);

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    setTag = '[object Set]';

	/**
	 * Creates a `_.toPairs` or `_.toPairsIn` function.
	 *
	 * @private
	 * @param {Function} keysFunc The function to get the keys of a given object.
	 * @returns {Function} Returns the new pairs function.
	 */
	function createToPairs(keysFunc) {
	  return function(object) {
	    var tag = getTag(object);
	    if (tag == mapTag) {
	      return mapToArray(object);
	    }
	    if (tag == setTag) {
	      return setToPairs(object);
	    }
	    return baseToPairs(object, keysFunc(object));
	  };
	}

	module.exports = createToPairs;


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(110);

	/**
	 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	 * of key-value pairs for `object` corresponding to the property names of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the key-value pairs.
	 */
	function baseToPairs(object, props) {
	  return arrayMap(props, function(key) {
	    return [key, object[key]];
	  });
	}

	module.exports = baseToPairs;


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var DataView = __webpack_require__(199),
	    Map = __webpack_require__(101),
	    Promise = __webpack_require__(200),
	    Set = __webpack_require__(201),
	    WeakMap = __webpack_require__(202),
	    baseGetTag = __webpack_require__(6),
	    toSource = __webpack_require__(87);

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	module.exports = getTag;


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(81),
	    root = __webpack_require__(8);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	module.exports = DataView;


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(81),
	    root = __webpack_require__(8);

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	module.exports = Promise;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(81),
	    root = __webpack_require__(8);

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	module.exports = Set;


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(81),
	    root = __webpack_require__(8);

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	module.exports = WeakMap;


/***/ },
/* 203 */
/***/ function(module, exports) {

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	module.exports = mapToArray;


/***/ },
/* 204 */
/***/ function(module, exports) {

	/**
	 * Converts `set` to its value-value pairs.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the value-value pairs.
	 */
	function setToPairs(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = [value, value];
	  });
	  return result;
	}

	module.exports = setToPairs;


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(206),
	    baseKeys = __webpack_require__(217),
	    isArrayLike = __webpack_require__(220);

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	module.exports = keys;


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(207),
	    isArguments = __webpack_require__(208),
	    isArray = __webpack_require__(70),
	    isBuffer = __webpack_require__(210),
	    isIndex = __webpack_require__(117),
	    isTypedArray = __webpack_require__(212);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = arrayLikeKeys;


/***/ },
/* 207 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	module.exports = baseTimes;


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsArguments = __webpack_require__(209),
	    isObjectLike = __webpack_require__(14);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	module.exports = isArguments;


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(6),
	    isObjectLike = __webpack_require__(14);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	module.exports = baseIsArguments;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(8),
	    stubFalse = __webpack_require__(211);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	module.exports = isBuffer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module)))

/***/ },
/* 211 */
/***/ function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsTypedArray = __webpack_require__(213),
	    baseUnary = __webpack_require__(215),
	    nodeUtil = __webpack_require__(216);

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	module.exports = isTypedArray;


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(6),
	    isLength = __webpack_require__(214),
	    isObjectLike = __webpack_require__(14);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	module.exports = baseIsTypedArray;


/***/ },
/* 214 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ },
/* 215 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	module.exports = baseUnary;


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(9);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module)))

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var isPrototype = __webpack_require__(218),
	    nativeKeys = __webpack_require__(219);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeys;


/***/ },
/* 218 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	module.exports = isPrototype;


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(13);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	module.exports = nativeKeys;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(83),
	    isLength = __webpack_require__(214);

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	module.exports = isArrayLike;


/***/ },
/* 221 */
/***/ function(module, exports) {

	/**
	 * The inverse of `_.toPairs`; this method returns an object composed
	 * from key-value `pairs`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} pairs The key-value pairs.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * _.fromPairs([['a', 1], ['b', 2]]);
	 * // => { 'a': 1, 'b': 2 }
	 */
	function fromPairs(pairs) {
	  var index = -1,
	      length = pairs == null ? 0 : pairs.length,
	      result = {};

	  while (++index < length) {
	    var pair = pairs[index];
	    result[pair[0]] = pair[1];
	  }
	  return result;
	}

	module.exports = fromPairs;


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var assert = __webpack_require__(223);

	function reportException(who, exception) {
	  var msg = `${who} threw an exception: `;
	  console.error(msg, exception);
	}

	function executeSoon(fn) {
	  setTimeout(fn, 0);
	}

	module.exports = { reportException, executeSoon, assert };

/***/ },
/* 223 */
/***/ function(module, exports) {

	"use strict";

	function assert(condition, message) {
	  if (!condition) {
	    throw new Error(`Assertion failure: ${message}`);
	  }
	}

	module.exports = assert;

/***/ },
/* 224 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * A middleware that allows thunks (functions) to be dispatched. If
	 * it's a thunk, it is called with an argument that contains
	 * `dispatch`, `getState`, and any additional args passed in via the
	 * middleware constructure. This allows the action to create multiple
	 * actions (most likely asynchronously).
	 */
	function thunk(makeArgs) {
	  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;

	    var args = { dispatch, getState };

	    return next => action => {
	      return typeof action === "function" ? action(makeArgs ? makeArgs(args, getState()) : args) : next(action);
	    };
	  };
	}

	exports.thunk = thunk;

/***/ },
/* 225 */,
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	// @flow

	var { PrefsHelper } = __webpack_require__(830);
	const { Services: { pref } } = __webpack_require__(830);
	const { isDevelopment } = __webpack_require__(828);

	if (isDevelopment()) {
	  pref("devtools.debugger.client-source-maps-enabled", true);
	  pref("devtools.debugger.pause-on-exceptions", false);
	  pref("devtools.debugger.ignore-caught-exceptions", false);
	  pref("devtools.debugger.call-stack-visible", false);
	  pref("devtools.debugger.scopes-visible", false);
	  pref("devtools.debugger.start-panel-collapsed", false);
	  pref("devtools.debugger.end-panel-collapsed", false);
	  pref("devtools.debugger.tabs", "[]");
	  pref("devtools.debugger.pending-selected-location", "{}");
	  pref("devtools.debugger.pending-breakpoints", "[]");
	  pref("devtools.debugger.expressions", "[]");
	}

	const prefs = new PrefsHelper("devtools", {
	  clientSourceMapsEnabled: ["Bool", "debugger.client-source-maps-enabled"],
	  pauseOnExceptions: ["Bool", "debugger.pause-on-exceptions"],
	  ignoreCaughtExceptions: ["Bool", "debugger.ignore-caught-exceptions"],
	  callStackVisible: ["Bool", "debugger.call-stack-visible"],
	  scopesVisible: ["Bool", "debugger.scopes-visible"],
	  startPanelCollapsed: ["Bool", "debugger.start-panel-collapsed"],
	  endPanelCollapsed: ["Bool", "debugger.end-panel-collapsed"],
	  tabs: ["Json", "debugger.tabs"],
	  pendingSelectedLocation: ["Json", "debugger.pending-selected-location"],
	  pendingBreakpoints: ["Json", "debugger.pending-breakpoints"],
	  expressions: ["Json", "debugger.expressions"]
	});

	module.exports = { prefs };


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var expressions = __webpack_require__(228);
	var eventListeners = __webpack_require__(231);
	var sources = __webpack_require__(232);
	var breakpoints = __webpack_require__(236);
	var asyncRequests = __webpack_require__(238);
	var pause = __webpack_require__(239);
	var ui = __webpack_require__(240);
	var coverage = __webpack_require__(241);

	module.exports = {
	  expressions: expressions.update,
	  eventListeners: eventListeners.update,
	  sources: sources.update,
	  breakpoints: breakpoints.update,
	  pause: pause.update,
	  asyncRequests,
	  ui: ui.update,
	  coverage: coverage.update
	};

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.State = undefined;
	exports.update = update;
	exports.getExpressions = getExpressions;
	exports.getVisibleExpressions = getVisibleExpressions;
	exports.getExpression = getExpression;

	var _constants = __webpack_require__(229);

	var _constants2 = _interopRequireDefault(_constants);

	var _makeRecord = __webpack_require__(230);

	var _makeRecord2 = _interopRequireDefault(_makeRecord);

	var _immutable = __webpack_require__(146);

	var _prefs = __webpack_require__(226);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var State = exports.State = (0, _makeRecord2.default)({
	  expressions: (0, _immutable.List)(restoreExpressions())
	});

	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State();
	  var action = arguments[1];

	  switch (action.type) {
	    case _constants2.default.ADD_EXPRESSION:
	      return appendToList(state, ["expressions"], {
	        input: action.input,
	        value: null,
	        updating: true,
	        visible: action.visible
	      });
	    case _constants2.default.UPDATE_EXPRESSION:
	      var key = action.expression.input;
	      return updateItemInList(state, ["expressions"], key, {
	        input: action.input,
	        value: null,
	        updating: true,
	        visible: action.visible
	      });
	    case _constants2.default.EVALUATE_EXPRESSION:
	      if (action.status === "done") {
	        return updateItemInList(state, ["expressions"], action.input, {
	          input: action.input,
	          value: action.value,
	          updating: false,
	          visible: action.visible
	        });
	      }
	      break;
	    case _constants2.default.DELETE_EXPRESSION:
	      return deleteExpression(state, action.input);
	  }

	  return state;
	}

	function restoreExpressions() {
	  var exprs = _prefs.prefs.expressions;
	  if (exprs.length == 0) {
	    return;
	  }
	  return exprs;
	}

	function storeExpressions(state) {
	  _prefs.prefs.expressions = state.getIn(["expressions"]).filter(e => e.visible).toJS();
	}

	function appendToList(state, path, value) {
	  var newState = state.updateIn(path, () => {
	    return state.getIn(path).push(value);
	  });
	  storeExpressions(newState);
	  return newState;
	}

	function updateItemInList(state, path, key, value) {
	  var newState = state.updateIn(path, () => {
	    var list = state.getIn(path);
	    var index = list.findIndex(e => e.input == key);
	    return list.update(index, () => value);
	  });
	  storeExpressions(newState);
	  return newState;
	}

	function deleteExpression(state, input) {
	  var index = getExpressions({ expressions: state }).findKey(e => e.input == input);
	  var newState = state.deleteIn(["expressions", index]);
	  storeExpressions(newState);
	  return newState;
	}

	function getExpressions(state) {
	  return state.expressions.get("expressions");
	}

	function getVisibleExpressions(state) {
	  return state.expressions.get("expressions").filter(e => e.visible);
	}

	function getExpression(state, input) {
	  return getExpressions(state).find(exp => exp.input == input);
	}

/***/ },
/* 229 */
/***/ function(module, exports) {

	"use strict";

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	exports.UPDATE_EVENT_BREAKPOINTS = "UPDATE_EVENT_BREAKPOINTS";
	exports.FETCH_EVENT_LISTENERS = "FETCH_EVENT_LISTENERS";

	exports.TOGGLE_PRETTY_PRINT = "TOGGLE_PRETTY_PRINT";
	exports.BLACKBOX = "BLACKBOX";

	exports.ADD_BREAKPOINT = "ADD_BREAKPOINT";
	exports.REMOVE_BREAKPOINT = "REMOVE_BREAKPOINT";
	exports.ENABLE_BREAKPOINT = "ENABLE_BREAKPOINT";
	exports.DISABLE_BREAKPOINT = "DISABLE_BREAKPOINT";
	exports.SET_BREAKPOINT_CONDITION = "SET_BREAKPOINT_CONDITION";
	exports.TOGGLE_BREAKPOINTS = "TOGGLE_BREAKPOINTS";

	exports.ADD_SOURCE = "ADD_SOURCE";
	exports.ADD_SOURCES = "ADD_SOURCES";
	exports.LOAD_SOURCE_TEXT = "LOAD_SOURCE_TEXT";
	exports.SELECT_SOURCE = "SELECT_SOURCE";
	exports.SELECT_SOURCE_URL = "SELECT_SOURCE_URL";
	exports.CLOSE_TAB = "CLOSE_TAB";
	exports.CLOSE_TABS = "CLOSE_TABS";
	exports.NAVIGATE = "NAVIGATE";
	exports.RELOAD = "RELOAD";

	exports.ADD_TABS = "ADD_TABS";
	exports.SELECT_TAB = "SELECT_TAB";

	exports.BREAK_ON_NEXT = "BREAK_ON_NEXT";
	exports.RESUME = "RESUME";
	exports.PAUSED = "PAUSED";
	exports.PAUSE_ON_EXCEPTIONS = "PAUSE_ON_EXCEPTIONS";
	exports.COMMAND = "COMMAND";
	exports.SELECT_FRAME = "SELECT_FRAME";
	exports.LOAD_OBJECT_PROPERTIES = "LOAD_OBJECT_PROPERTIES";
	exports.ADD_EXPRESSION = "ADD_EXPRESSION";
	exports.EVALUATE_EXPRESSION = "EVALUATE_EXPRESSION";
	exports.UPDATE_EXPRESSION = "UPDATE_EXPRESSION";
	exports.DELETE_EXPRESSION = "DELETE_EXPRESSION";

	exports.RECORD_COVERAGE = "RECORD_COVERAGE";

	exports.TOGGLE_PROJECT_SEARCH = "TOGGLE_PROJECT_SEARCH";
	exports.TOGGLE_FILE_SEARCH = "TOGGLE_FILE_SEARCH";
	exports.UPDATE_FILE_SEARCH_QUERY = "UPDATE_FILE_SEARCH_QUERY";
	exports.TOGGLE_FILE_SEARCH_MODIFIER = "TOGGLE_FILE_SEARCH_MODIFIER";
	exports.SHOW_SOURCE = "SHOW_SOURCE";
	exports.TOGGLE_PANE = "TOGGLE_PANE";

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * When Flow 0.29 is released (very soon), we can use this Record type
	 * instead of the builtin immutable.js Record type. This is better
	 * because all the fields are actually typed, unlike the builtin one.
	 * This depends on a performance fix that will go out in 0.29 though;
	 * @module utils/makeRecord
	 */

	var I = __webpack_require__(146);

	/**
	 * @memberof utils/makeRecord
	 * @static
	 */


	/**
	 * Make an immutable record type
	 *
	 * @param spec - the keys and their default values
	 * @return a state record factory function
	 * @memberof utils/makeRecord
	 * @static
	 */
	function makeRecord(spec) {
	  return I.Record(spec);
	}

	module.exports = makeRecord;

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.update = update;
	exports.getEventListeners = getEventListeners;

	var _constants = __webpack_require__(229);

	var _constants2 = _interopRequireDefault(_constants);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var initialState = {
	  activeEventNames: [],
	  listeners: [],
	  fetchingListeners: false
	}; /* This Source Code Form is subject to the terms of the Mozilla Public
	    * License, v. 2.0. If a copy of the MPL was not distributed with this
	    * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	  var action = arguments[1];
	  var emit = arguments[2];

	  switch (action.type) {
	    case _constants2.default.UPDATE_EVENT_BREAKPOINTS:
	      state.activeEventNames = action.eventNames;
	      // emit("activeEventNames", state.activeEventNames);
	      break;
	    case _constants2.default.FETCH_EVENT_LISTENERS:
	      if (action.status === "begin") {
	        state.fetchingListeners = true;
	      } else if (action.status === "done") {
	        state.fetchingListeners = false;
	        state.listeners = action.listeners;
	      }
	      break;
	    case _constants2.default.NAVIGATE:
	      return initialState;
	  }

	  return state;
	}

	function getEventListeners(state) {
	  return state.eventListeners.listeners;
	}

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * Sources reducer
	 * @module reducers/sources
	 */

	var I = __webpack_require__(146);
	var makeRecord = __webpack_require__(230);

	var _require = __webpack_require__(233),
	    getPrettySourceURL = _require.getPrettySourceURL;

	var _require2 = __webpack_require__(226),
	    prefs = _require2.prefs;

	var State = makeRecord({
	  sources: I.Map(),
	  selectedLocation: undefined,
	  pendingSelectedLocation: prefs.pendingSelectedLocation,
	  sourcesText: I.Map(),
	  tabs: I.List(restoreTabs())
	});

	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State();
	  var action = arguments[1];

	  var availableTabs = null;
	  var location = null;

	  switch (action.type) {
	    case "ADD_SOURCE":
	      {
	        var _source = action.source;
	        return state.mergeIn(["sources", action.source.id], _source);
	      }

	    case "ADD_SOURCES":
	      {
	        action.sources.forEach(source => {
	          state = state.mergeIn(["sources", source.id], source);
	        });

	        return state;
	      }

	    case "SELECT_SOURCE":
	      location = {
	        line: action.line,
	        url: action.source.url
	      };
	      prefs.pendingSelectedLocation = location;

	      var sourceUrl = action.source.url || "";
	      return state.set("selectedLocation", {
	        sourceId: action.source.id,
	        line: action.line
	      }).set("pendingSelectedLocation", location).merge({
	        tabs: updateTabList({ sources: state }, sourceUrl, action.tabIndex)
	      });

	    case "SELECT_SOURCE_URL":
	      location = {
	        url: action.url,
	        line: action.line
	      };

	      prefs.pendingSelectedLocation = location;
	      return state.set("pendingSelectedLocation", location);

	    case "CLOSE_TAB":
	      availableTabs = removeSourceFromTabList(state.tabs, action.url);

	      return state.merge({ tabs: availableTabs }).set("selectedLocation", {
	        sourceId: getNewSelectedSourceId(state, availableTabs)
	      });

	    case "CLOSE_TABS":
	      availableTabs = removeSourcesFromTabList(state.tabs, action.urls);

	      return state.merge({ tabs: availableTabs }).set("selectedLocation", {
	        sourceId: getNewSelectedSourceId(state, availableTabs)
	      });

	    case "LOAD_SOURCE_TEXT":
	      return _updateText(state, action);

	    case "BLACKBOX":
	      if (action.status === "done") {
	        return state.setIn(["sources", action.source.id, "isBlackBoxed"], action.value.isBlackBoxed);
	      }
	      break;

	    case "TOGGLE_PRETTY_PRINT":
	      return _updateText(state, action);

	    case "NAVIGATE":
	      var source = getSelectedSource({ sources: state });
	      var _url = source && source.get("url");
	      prefs.pendingSelectedLocation = { url: _url };
	      return State().set("pendingSelectedLocation", { url: _url });
	  }

	  return state;
	}

	// TODO: Action is coerced to `any` unfortunately because how we type
	// asynchronous actions is wrong. The `value` may be null for the
	// "start" and "error" states but we don't type it like that. We need
	// to rethink how we type async actions.
	function _updateText(state, action) {
	  var source = action.source;
	  var sourceText = action.value;

	  if (action.status === "start") {
	    // Merge this in, don't set it. That way the previous value is
	    // still stored here, and we can retrieve it if whatever we're
	    // doing fails.
	    return state.mergeIn(["sourcesText", source.id], {
	      loading: true
	    });
	  }

	  if (action.status === "error") {
	    return state.setIn(["sourcesText", source.id], I.Map({
	      error: action.error
	    }));
	  }

	  return state.setIn(["sourcesText", source.id], I.Map({
	    text: sourceText.text,
	    id: source.id,
	    contentType: sourceText.contentType
	  }));
	}

	function removeSourceFromTabList(tabs, url) {
	  var newTabs = tabs.filter(tab => tab != url);
	  prefs.tabs = newTabs;
	  return newTabs;
	}

	function removeSourcesFromTabList(tabs, urls) {
	  return urls.reduce((t, url) => removeSourceFromTabList(t, url), tabs);
	}

	function restoreTabs() {
	  var prefsTabs = prefs.tabs || [];
	  if (Object.keys(prefsTabs).length == 0) {
	    return;
	  }

	  return prefsTabs;
	}

	/**
	 * Adds the new source to the tab list if it is not already there
	 * @memberof reducers/sources
	 * @static
	 */
	function updateTabList(state, url, tabIndex) {
	  var tabs = state.sources.get("tabs");

	  var urlIndex = tabs.indexOf(url);
	  var includesUrl = !!tabs.find(tab => tab == url);

	  if (includesUrl) {
	    if (tabIndex != undefined) {
	      tabs = tabs.delete(urlIndex).insert(tabIndex, url);
	    }
	  } else {
	    tabs = tabs.insert(0, url);
	  }

	  prefs.tabs = tabs.toJS();
	  return tabs;
	}

	/**
	 * Gets the next tab to select when a tab closes. Heuristics:
	 * 1. if the selected tab is available, it remains selected
	 * 2. if it is gone, the next available tab to the left should be active
	 * 3. if the first tab is active and closed, select the second tab
	 *
	 * @memberof reducers/sources
	 * @static
	 */
	function getNewSelectedSourceId(state, availableTabs) {
	  var selectedLocation = state.selectedLocation;
	  if (!selectedLocation) {
	    return "";
	  }

	  var selectedTab = state.sources.find(source => source.get("id") == selectedLocation.sourceId);

	  var selectedTabUrl = selectedTab ? selectedTab.get("url") : "";

	  if (availableTabs.includes(selectedTabUrl)) {
	    var _sources = state.sources;
	    if (!_sources) {
	      return "";
	    }

	    var selectedSource = _sources.find(source => source.get("url") == selectedTabUrl);

	    if (selectedSource) {
	      return selectedSource.get("id");
	    }

	    return "";
	  }

	  var tabUrls = state.tabs.toJS();
	  var leftNeighborIndex = Math.max(tabUrls.indexOf(selectedTabUrl) - 1, 0);
	  var lastAvailbleTabIndex = availableTabs.size - 1;
	  var newSelectedTabIndex = Math.min(leftNeighborIndex, lastAvailbleTabIndex);
	  var tabSource = state.sources.find(source => source.get("url") === availableTabs.toJS()[newSelectedTabIndex]);

	  if (tabSource) {
	    return tabSource.get("id");
	  }

	  return "";
	}

	// Selectors

	// Unfortunately, it's really hard to make these functions accept just
	// the state that we care about and still type it with Flow. The
	// problem is that we want to re-export all selectors from a single
	// module for the UI, and all of those selectors should take the
	// top-level app state, so we'd have to "wrap" them to automatically
	// pick off the piece of state we're interested in. It's impossible
	// (right now) to type those wrapped functions.


	function getSource(state, id) {
	  return state.sources.sources.get(id);
	}

	function getSourceByURL(state, url) {
	  return state.sources.sources.find(source => source.get("url") == url);
	}

	function getSourceById(state, id) {
	  return state.sources.sources.find(source => source.get("id") == id);
	}

	function getSources(state) {
	  return state.sources.sources;
	}

	function getSourceText(state, id) {
	  if (id) {
	    return state.sources.sourcesText.get(id);
	  }
	}

	function getSourceTabs(state) {
	  return state.sources.tabs.filter(tab => getSourceByURL(state, tab));
	}

	function getSelectedSource(state) {
	  var selectedLocation = state.sources.selectedLocation;
	  if (!selectedLocation) {
	    return;
	  }

	  return state.sources.sources.find(source => source.get("id") == selectedLocation.sourceId);
	}

	function getSelectedLocation(state) {
	  return state.sources.selectedLocation;
	}

	function getPendingSelectedLocation(state) {
	  return state.sources.pendingSelectedLocation;
	}

	function getPrettySource(state, id) {
	  var source = getSource(state, id);
	  if (!source) {
	    return;
	  }

	  return getSourceByURL(state, getPrettySourceURL(source.get("url")));
	}

	module.exports = {
	  State,
	  update,
	  getSource,
	  getSourceByURL,
	  getSourceById,
	  getSources,
	  getSourceText,
	  getSourceTabs,
	  getSelectedSource,
	  getSelectedLocation,
	  getPendingSelectedLocation,
	  getPrettySource
	};

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * Utils for working with Source URLs
	 * @module utils/source
	 */

	var _require = __webpack_require__(234),
	    endTruncateStr = _require.endTruncateStr;

	var _require2 = __webpack_require__(235),
	    basename = _require2.basename;

	/**
	 * Trims the query part or reference identifier of a url string, if necessary.
	 *
	 * @memberof utils/source
	 * @static
	 */
	function trimUrlQuery(url) {
	  var length = url.length;
	  var q1 = url.indexOf("?");
	  var q2 = url.indexOf("&");
	  var q3 = url.indexOf("#");
	  var q = Math.min(q1 != -1 ? q1 : length, q2 != -1 ? q2 : length, q3 != -1 ? q3 : length);

	  return url.slice(0, q);
	}

	/**
	 * Returns true if the specified url and/or content type are specific to
	 * javascript files.
	 *
	 * @return boolean
	 *         True if the source is likely javascript.
	 *
	 * @memberof utils/source
	 * @static
	 */
	function isJavaScript(url) {
	  var contentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

	  return url && /\.(jsm|js)?$/.test(trimUrlQuery(url)) || contentType.includes("javascript");
	}

	/**
	 * @memberof utils/source
	 * @static
	 */
	function isPretty(source) {
	  return source.url ? /formatted$/.test(source.url) : false;
	}

	/**
	 * @memberof utils/source
	 * @static
	 */
	function getPrettySourceURL(url) {
	  return `${url}:formatted`;
	}

	/**
	 * @memberof utils/source
	 * @static
	 */
	function getRawSourceURL(url) {
	  return url.replace(/:formatted$/, "");
	}

	function getFilenameFromURL(url) {
	  url = getRawSourceURL(url || "");
	  var name = basename(url) || "(index)";
	  return endTruncateStr(name, 50);
	}

	/**
	 * Show a source url's filename.
	 * If the source does not have a url, use the source id.
	 *
	 * @memberof utils/source
	 * @static
	 */
	function getFilename(source) {
	  var url = source.url,
	      id = source.id;

	  if (!url) {
	    var sourceId = id.split("/")[1];
	    return `SOURCE${sourceId}`;
	  }

	  return getFilenameFromURL(url);
	}

	var contentTypeModeMap = {
	  "text/javascript": { name: "javascript" },
	  "text/typescript": { name: "javascript", typescript: true },
	  "text/coffeescript": "coffeescript",
	  "text/typescript-jsx": {
	    name: "jsx",
	    base: { name: "javascript", typescript: true }
	  },
	  "text/jsx": "jsx",
	  "text/x-elm": "elm",
	  "text/x-clojure": "clojure",
	  "text/wasm": { name: "text" },
	  html: { name: "htmlmixed" }
	};

	/**
	 *
	 * Returns Code Mirror mode for source content type
	 * @param contentType
	 * @return String
	 * @memberof utils/source
	 * @static
	 */

	function getMode(sourceText) {
	  var contentType = sourceText.contentType,
	      text = sourceText.text;

	  // //  or /*  */

	  if (text.match(/^\s*(\/\/ @flow|\/\* @flow \*\/)/)) {
	    return contentTypeModeMap["text/typescript"];
	  }

	  if (/script|elm|jsx|clojure|wasm/.test(contentType)) {
	    if (contentType in contentTypeModeMap) {
	      return contentTypeModeMap[contentType];
	    }

	    return contentTypeModeMap["text/javascript"];
	  }

	  // Use HTML mode for files in which the first non whitespace
	  // character is `<` regardless of extension.
	  if (text.match(/^\s*</)) {
	    return { name: "htmlmixed" };
	  }

	  return { name: "text" };
	}

	module.exports = {
	  isJavaScript,
	  isPretty,
	  getPrettySourceURL,
	  getRawSourceURL,
	  getFilename,
	  getFilenameFromURL,
	  getMode
	};

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _zip = __webpack_require__(704);

	var _zip2 = _interopRequireDefault(_zip);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	/**
	 * Utils for utils, by utils
	 * @module utils/utils
	 */

	/**
	 * @memberof utils/utils
	 * @static
	 */
	function handleError(err) {
	  console.log("ERROR: ", err);
	}

	/**
	 * @memberof utils/utils
	 * @static
	 */
	function promisify(context, method) {
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }

	  return new Promise((resolve, reject) => {
	    args.push(response => {
	      if (response.error) {
	        reject(response);
	      } else {
	        resolve(response);
	      }
	    });
	    method.apply(context, args);
	  });
	}

	/**
	 * @memberof utils/utils
	 * @static
	 */
	function endTruncateStr(str, size) {
	  if (str.length > size) {
	    return `...${str.slice(str.length - size)}`;
	  }
	  return str;
	}

	/**
	 * @memberof utils/utils
	 * @static
	 */
	function updateObj(obj, fields) {
	  return Object.assign({}, obj, fields);
	}

	/**
	 * @memberof utils/utils
	 * @static
	 */
	function throttle(func, ms) {
	  var timeout = void 0,
	      _this = void 0;
	  return function () {
	    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }

	    _this = this;
	    if (!timeout) {
	      timeout = setTimeout(() => {
	        func.apply.apply(func, [_this].concat(_toConsumableArray(args)));
	        timeout = null;
	      }, ms);
	    }
	  };
	}

	function waitForMs(ms) {
	  return new Promise(resolve => setTimeout(resolve, ms));
	}

	function filterDuplicates(list, predicate) {
	  var lastItem = list[list.length - 1];
	  var pairs = (0, _zip2.default)(list.slice(1), list.slice(0, -1));
	  return pairs.filter(predicate).map((_ref) => {
	    var _ref2 = _slicedToArray(_ref, 2),
	        prev = _ref2[0],
	        item = _ref2[1];

	    return item;
	  }).concat(lastItem);
	}

	module.exports = {
	  handleError,
	  promisify,
	  endTruncateStr,
	  updateObj,
	  throttle,
	  waitForMs,
	  filterDuplicates
	};

/***/ },
/* 235 */
/***/ function(module, exports) {

	"use strict";

	function basename(path) {
	  return path.split("/").pop();
	}

	function dirname(path) {
	  var idx = path.lastIndexOf("/");
	  return path.slice(0, idx);
	}

	function isURL(str) {
	  return str.indexOf("://") !== -1;
	}

	function isAbsolute(str) {
	  return str[0] === "/";
	}

	function join(base, dir) {
	  return `${base}/${dir}`;
	}

	module.exports = {
	  basename,
	  dirname,
	  isURL,
	  isAbsolute,
	  join
	};

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * Breakpoints reducer
	 * @module reducers/breakpoints
	 */

	var fromJS = __webpack_require__(237);

	var _require = __webpack_require__(234),
	    updateObj = _require.updateObj;

	var I = __webpack_require__(146);
	var makeRecord = __webpack_require__(230);

	var _require2 = __webpack_require__(226),
	    prefs = _require2.prefs;

	var State = makeRecord({
	  breakpoints: I.Map(),
	  pendingBreakpoints: restorePendingBreakpoints(),
	  breakpointsDisabled: false
	});

	// Return the first argument that is a string, or null if nothing is a
	// string.
	function firstString() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  for (var arg of args) {
	    if (typeof arg === "string") {
	      return arg;
	    }
	  }
	  return null;
	}

	function locationMoved(location, newLocation) {
	  return location.line !== newLocation.line || location.column != null && location.column !== newLocation.column;
	}

	function makeLocationId(location) {
	  return `${location.sourceId}:${location.line}`;
	}

	function allBreakpointsDisabled(state) {
	  return state.breakpoints.every(x => x.disabled);
	}

	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State();
	  var action = arguments[1];

	  switch (action.type) {
	    case "ADD_BREAKPOINT":
	      {
	        var newState = addBreakpoint(state, action);
	        if (newState) {
	          setPendingBreakpoints(newState);
	        }
	        return newState;
	      }

	    case "REMOVE_BREAKPOINT":
	      {
	        var _newState = removeBreakpoint(state, action);
	        setPendingBreakpoints(_newState);
	        return _newState;
	      }

	    case "TOGGLE_BREAKPOINTS":
	      {
	        if (action.status === "start") {
	          return state.set("breakpointsDisabled", action.shouldDisableBreakpoints);
	        }
	        break;
	      }

	    case "SET_BREAKPOINT_CONDITION":
	      {
	        var id = makeLocationId(action.breakpoint.location);

	        if (action.status === "start") {
	          var bp = state.breakpoints.get(id);
	          return state.setIn(["breakpoints", id], updateObj(bp, {
	            loading: true,
	            condition: action.condition
	          }));
	        } else if (action.status === "done") {
	          var _bp = state.breakpoints.get(id);
	          return state.setIn(["breakpoints", id], updateObj(_bp, {
	            id: action.value.id,
	            loading: false
	          }));
	        } else if (action.status === "error") {
	          return state.deleteIn(["breakpoints", id]);
	        }

	        break;
	      }
	  }

	  return state;
	}

	function addBreakpoint(state, action) {
	  var id = makeLocationId(action.breakpoint.location);

	  if (action.status === "start") {
	    var bp = state.breakpoints.get(id) || action.breakpoint;

	    return state.setIn(["breakpoints", id], updateObj(bp, {
	      disabled: false,
	      loading: true,
	      // We want to do an OR here, but we can't because we need
	      // empty strings to be truthy, i.e. an empty string is a valid
	      // condition.
	      condition: firstString(action.condition, bp.condition)
	    })).set("breakpointsDisabled", false);
	  }

	  if (action.status === "done") {
	    var _action$value = action.value,
	        breakpointId = _action$value.id,
	        text = _action$value.text;

	    var location = action.breakpoint.location;
	    var actualLocation = action.value.actualLocation;

	    // If the breakpoint moved, update the map

	    if (locationMoved(location, actualLocation)) {
	      state = state.deleteIn(["breakpoints", id]);

	      var movedId = makeLocationId(actualLocation);
	      var currentBp = state.breakpoints.get(movedId) || fromJS(action.breakpoint);
	      var newBp = updateObj(currentBp, { location: actualLocation });
	      state = state.setIn(["breakpoints", movedId], newBp);
	      location = actualLocation;
	    }

	    var locationId = makeLocationId(location);
	    var _bp2 = state.breakpoints.get(locationId);
	    return state.setIn(["breakpoints", locationId], updateObj(_bp2, {
	      id: breakpointId,
	      disabled: false,
	      loading: false,
	      text: text
	    }));
	  }

	  if (action.status === "error") {
	    // Remove the optimistic update
	    return state.deleteIn(["breakpoints", id]);
	  }
	}

	function removeBreakpoint(state, action) {
	  if (action.status === "done") {
	    var id = makeLocationId(action.breakpoint.location);

	    if (action.disabled) {
	      var bp = state.breakpoints.get(id);
	      var _updatedState = state.setIn(["breakpoints", id], updateObj(bp, {
	        loading: false,
	        disabled: true
	      }));

	      return _updatedState.set("breakpointsDisabled", allBreakpointsDisabled(_updatedState));
	    }

	    var updatedState = state.deleteIn(["breakpoints", id]);

	    return updatedState.set("breakpointsDisabled", allBreakpointsDisabled(updatedState));
	  }

	  return state;
	}

	function makePendingBreakpoint(bp) {
	  var _bp$location = bp.location,
	      sourceUrl = _bp$location.sourceUrl,
	      line = _bp$location.line,
	      condition = bp.condition,
	      disabled = bp.disabled;


	  var location = { sourceUrl, line };
	  return { condition, disabled, location };
	}

	function filterByNotLoading(bp) {
	  return !bp.loading;
	}

	function setPendingBreakpoints(state) {
	  prefs.pendingBreakpoints = Object.values(state.get("breakpoints").toJS()).filter(filterByNotLoading).map(makePendingBreakpoint);
	}

	function restorePendingBreakpoints() {
	  return prefs.pendingBreakpoints;
	}

	// Selectors

	function getBreakpoint(state, location) {
	  return state.breakpoints.breakpoints.get(makeLocationId(location));
	}

	function getBreakpoints(state) {
	  return state.breakpoints.breakpoints;
	}

	function getBreakpointsForSource(state, sourceId) {
	  return state.breakpoints.breakpoints.filter(bp => {
	    return bp.location.sourceId === sourceId;
	  });
	}

	function getBreakpointsDisabled(state) {
	  return state.breakpoints.get("breakpointsDisabled");
	}

	function getBreakpointsLoading(state) {
	  var breakpoints = getBreakpoints(state);
	  var isLoading = !!breakpoints.valueSeq().filter(bp => bp.loading).first();

	  return breakpoints.size > 0 && isLoading;
	}

	function getPendingBreakpoints(state) {
	  return state.breakpoints.pendingBreakpoints;
	}

	module.exports = {
	  State,
	  update,
	  makeLocationId,
	  getBreakpoint,
	  getBreakpoints,
	  getBreakpointsForSource,
	  getBreakpointsDisabled,
	  getBreakpointsLoading,
	  getPendingBreakpoints
	};

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * Immutable JS conversion utils
	 * @deprecated
	 * @module utils/fromJS
	 */

	var Immutable = __webpack_require__(146);

	/*
	  creates an immutable map, where each of the value's
	  items are transformed into their own map.

	  NOTE: we guard against `length` being a property because
	  length confuses Immutable's internal algorithm.
	*/
	function createMap(value) {
	  var hasLength = value.hasOwnProperty && value.hasOwnProperty("length");
	  var length = value.length;

	  if (hasLength) {
	    value.length = `${value.length}`;
	  }

	  var map = Immutable.Seq(value).map(fromJS).toMap();

	  if (hasLength) {
	    map = map.set("length", length);
	    value.length = length;
	  }

	  return map;
	}

	function createList(value) {
	  return Immutable.Seq(value).map(fromJS).toList();
	}

	/**
	 * When our app state is fully typed, we should be able to get rid of
	 * this function. This is only temporarily necessary to support
	 * converting typed objects to immutable.js, which usually happens in
	 * reducers.
	 *
	 * @memberof utils/fromJS
	 * @static
	 */
	function fromJS(value) {
	  if (Array.isArray(value)) {
	    return createList(value);
	  }
	  if (value && value.constructor && value.constructor.meta) {
	    // This adds support for tcomb objects which are native JS objects
	    // but are not "plain", so the above checks fail. Since they
	    // behave the same we can use the same constructors, but we need
	    // special checks for them.
	    var kind = value.constructor.meta.kind;
	    if (kind === "struct") {
	      return createMap(value);
	    } else if (kind === "list") {
	      return createList(value);
	    }
	  }

	  // If it's a primitive type, just return the value. Note `==` check
	  // for null, which is intentionally used to match either `null` or
	  // `undefined`.
	  if (value == null || typeof value !== "object") {
	    return value;
	  }

	  // Otherwise, treat it like an object. We can't reliably detect if
	  // it's a plain object because we might be objects from other JS
	  // contexts so `Object !== Object`.

	  return createMap(value);
	}

	module.exports = fromJS;

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var constants = __webpack_require__(229);
	var initialState = [];

	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	  var action = arguments[1];
	  var seqId = action.seqId;


	  if (action.type === constants.NAVIGATE) {
	    return initialState;
	  } else if (seqId) {
	    var newState = void 0;
	    if (action.status === "start") {
	      newState = [].concat(_toConsumableArray(state), [seqId]);
	    } else if (action.status === "error" || action.status === "done") {
	      newState = state.filter(id => id !== seqId);
	    }

	    return newState;
	  }

	  return state;
	}

	module.exports = update;

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var constants = __webpack_require__(229);
	var fromJS = __webpack_require__(237);
	var makeRecord = __webpack_require__(230);

	var _require = __webpack_require__(226),
	    prefs = _require.prefs;

	var I = __webpack_require__(146);

	var State = makeRecord({
	  pause: undefined,
	  isWaitingOnBreak: false,
	  frames: undefined,
	  selectedFrameId: undefined,
	  loadedObjects: I.Map(),
	  shouldPauseOnExceptions: prefs.pauseOnExceptions,
	  shouldIgnoreCaughtExceptions: prefs.ignoreCaughtExceptions,
	  debuggeeUrl: ""
	});

	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State();
	  var action = arguments[1];

	  switch (action.type) {
	    case constants.PAUSED:
	      {
	        var _selectedFrameId = action.selectedFrameId,
	            _frames = action.frames,
	            _loadedObjects = action.loadedObjects,
	            pauseInfo = action.pauseInfo;

	        pauseInfo.isInterrupted = pauseInfo.why.type === "interrupted";

	        // turn this into an object keyed by object id
	        var objectMap = {};
	        _loadedObjects.forEach(obj => {
	          objectMap[obj.value.objectId] = obj;
	        });

	        return state.merge({
	          isWaitingOnBreak: false,
	          pause: fromJS(pauseInfo),
	          selectedFrameId: _selectedFrameId,
	          frames: _frames,
	          loadedObjects: objectMap
	        });
	      }

	    case constants.RESUME:
	      return state.merge({
	        pause: null,
	        frames: null,
	        selectedFrameId: null,
	        loadedObjects: {}
	      });

	    case constants.TOGGLE_PRETTY_PRINT:
	      if (action.status == "done") {
	        var _frames2 = action.value.frames;
	        var _pause = state.get("pause");
	        if (_pause) {
	          _pause = _pause.set("frame", fromJS(_frames2[0]));
	        }

	        return state.merge({ pause: _pause, frames: _frames2 });
	      }

	      break;
	    case constants.BREAK_ON_NEXT:
	      return state.set("isWaitingOnBreak", true);

	    case constants.SELECT_FRAME:
	      return state.set("selectedFrameId", action.frame.id);

	    case constants.LOAD_OBJECT_PROPERTIES:
	      if (action.status === "start") {
	        return state.setIn(["loadedObjects", action.objectId], {});
	      }

	      if (action.status === "done") {
	        if (!action.value) {
	          return state;
	        }

	        var ownProperties = action.value.ownProperties;
	        var ownSymbols = action.value.ownSymbols || [];
	        var prototype = action.value.prototype;

	        return state.setIn(["loadedObjects", action.objectId], {
	          ownProperties,
	          prototype,
	          ownSymbols
	        });
	      }
	      break;

	    case constants.NAVIGATE:
	      return State().set("debuggeeUrl", action.url);

	    case constants.PAUSE_ON_EXCEPTIONS:
	      var _shouldPauseOnExceptions = action.shouldPauseOnExceptions,
	          _shouldIgnoreCaughtExceptions = action.shouldIgnoreCaughtExceptions;


	      prefs.pauseOnExceptions = _shouldPauseOnExceptions;
	      prefs.ignoreCaughtExceptions = _shouldIgnoreCaughtExceptions;

	      return state.merge({
	        shouldPauseOnExceptions: _shouldPauseOnExceptions,
	        shouldIgnoreCaughtExceptions: _shouldIgnoreCaughtExceptions
	      });
	  }

	  return state;
	}

	// Selectors

	// Unfortunately, it's really hard to make these functions accept just
	// the state that we care about and still type it with Flow. The
	// problem is that we want to re-export all selectors from a single
	// module for the UI, and all of those selectors should take the
	// top-level app state, so we'd have to "wrap" them to automatically
	// pick off the piece of state we're interested in. It's impossible
	// (right now) to type those wrapped functions.


	function getPause(state) {
	  return state.pause.get("pause");
	}

	function getLoadedObjects(state) {
	  return state.pause.get("loadedObjects");
	}

	function getLoadedObject(state, objectId) {
	  return getLoadedObjects(state).get(objectId);
	}

	function getObjectProperties(state, parentId) {
	  return getLoadedObjects(state).filter(obj => obj.get("parentId") == parentId);
	}

	function getIsWaitingOnBreak(state) {
	  return state.pause.get("isWaitingOnBreak");
	}

	function getShouldPauseOnExceptions(state) {
	  return state.pause.get("shouldPauseOnExceptions");
	}

	function getShouldIgnoreCaughtExceptions(state) {
	  return state.pause.get("shouldIgnoreCaughtExceptions");
	}

	function getFrames(state) {
	  return state.pause.get("frames");
	}

	function getSelectedFrame(state) {
	  var selectedFrameId = state.pause.get("selectedFrameId");
	  var frames = state.pause.get("frames");
	  if (!frames) {
	    return null;
	  }

	  return frames.find(frame => frame.get("id") == selectedFrameId).toJS();
	}

	function getDebuggeeUrl(state) {
	  return state.pause.get("debuggeeUrl");
	}

	// NOTE: currently only used for chrome
	function getChromeScopes(state) {
	  var frame = getSelectedFrame(state);
	  return frame ? frame.scopeChain : undefined;
	}

	module.exports = {
	  State,
	  update,
	  getPause,
	  getChromeScopes,
	  getLoadedObjects,
	  getLoadedObject,
	  getObjectProperties,
	  getIsWaitingOnBreak,
	  getShouldPauseOnExceptions,
	  getShouldIgnoreCaughtExceptions,
	  getFrames,
	  getSelectedFrame,
	  getDebuggeeUrl
	};

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * UI reducer
	 * @module reducers/ui
	 */

	var constants = __webpack_require__(229);
	var makeRecord = __webpack_require__(230);

	var _require = __webpack_require__(226),
	    prefs = _require.prefs;

	var State = makeRecord({
	  fileSearchOn: false,
	  fileSearchQuery: "",
	  fileSearchModifiers: makeRecord({
	    caseSensitive: true,
	    wholeWord: false,
	    regexMatch: false
	  })(),
	  projectSearchOn: false,
	  shownSource: "",
	  startPanelCollapsed: prefs.startPanelCollapsed,
	  endPanelCollapsed: prefs.endPanelCollapsed
	});

	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State();
	  var action = arguments[1];

	  switch (action.type) {
	    case constants.TOGGLE_PROJECT_SEARCH:
	      {
	        return state.set("projectSearchOn", action.value);
	      }

	    case constants.TOGGLE_FILE_SEARCH:
	      {
	        return state.set("fileSearchOn", action.value);
	      }

	    case constants.UPDATE_FILE_SEARCH_QUERY:
	      {
	        return state.set("fileSearchQuery", action.query);
	      }

	    case constants.TOGGLE_FILE_SEARCH_MODIFIER:
	      {
	        return state.setIn(["fileSearchModifiers", action.modifier], !state.getIn(["fileSearchModifiers", action.modifier]));
	      }

	    case constants.SHOW_SOURCE:
	      {
	        return state.set("shownSource", action.sourceUrl);
	      }

	    case constants.TOGGLE_PANE:
	      {
	        if (action.position == "start") {
	          prefs.startPanelCollapsed = action.paneCollapsed;
	          return state.set("startPanelCollapsed", action.paneCollapsed);
	        }

	        prefs.endPanelCollapsed = action.paneCollapsed;
	        return state.set("endPanelCollapsed", action.paneCollapsed);
	      }

	    default:
	      {
	        return state;
	      }
	  }
	}

	// NOTE: we'd like to have the app state fully typed
	// https://github.com/devtools-html/debugger.html/blob/master/src/reducers/sources.js#L179-L185

	function getSearchState(field, state) {
	  return state.ui.get(field);
	}

	function getFileSearchQueryState(state) {
	  return state.ui.get("fileSearchQuery");
	}

	function getFileSearchModifierState(state) {
	  return state.ui.get("fileSearchModifiers");
	}

	var getProjectSearchState = getSearchState.bind(null, "projectSearchOn");
	var getFileSearchState = getSearchState.bind(null, "fileSearchOn");

	function getShownSource(state) {
	  return state.ui.get("shownSource");
	}

	function getPaneCollapse(state, position) {
	  if (position == "start") {
	    return state.ui.get("startPanelCollapsed");
	  }

	  return state.ui.get("endPanelCollapsed");
	}

	module.exports = {
	  State,
	  update,
	  getProjectSearchState,
	  getFileSearchState,
	  getFileSearchQueryState,
	  getFileSearchModifierState,
	  getShownSource,
	  getPaneCollapse
	};

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * Code Coverage reducer
	 * @module reducers/coverage
	 */

	var constants = __webpack_require__(229);
	var makeRecord = __webpack_require__(230);
	var I = __webpack_require__(146);
	var fromJS = __webpack_require__(237);

	var State = makeRecord({
	  coverageOn: false,
	  hitCount: I.Map()
	});

	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State();
	  var action = arguments[1];

	  switch (action.type) {
	    case constants.RECORD_COVERAGE:
	      return state.mergeIn(["hitCount"], fromJS(action.value.coverage)).setIn(["coverageOn"], true);

	    default:
	      {
	        return state;
	      }
	  }
	}

	// NOTE: we'd like to have the app state fully typed
	// https://github.com/devtools-html/debugger.html/blob/master/src/reducers/sources.js#L179-L185


	function getHitCountForSource(state, sourceId) {
	  var hitCount = state.coverage.get("hitCount");
	  return hitCount.get(sourceId);
	}

	function getCoverageEnabled(state) {
	  return state.coverage.get("coverageOn");
	}

	module.exports = {
	  State,
	  update,
	  getHitCountForSource,
	  getCoverageEnabled
	};

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var expressions = __webpack_require__(228);
	var sources = __webpack_require__(232);
	var pause = __webpack_require__(239);
	var breakpoints = __webpack_require__(236);
	var eventListeners = __webpack_require__(231);
	var ui = __webpack_require__(240);
	var coverage = __webpack_require__(241);

	/**
	 * @param object - location
	 */

	module.exports = {
	  getSource: sources.getSource,
	  getSourceByURL: sources.getSourceByURL,
	  getSourceById: sources.getSourceById,
	  getSources: sources.getSources,
	  getSourceText: sources.getSourceText,
	  getSourceTabs: sources.getSourceTabs,
	  getSelectedSource: sources.getSelectedSource,
	  getSelectedLocation: sources.getSelectedLocation,
	  getPendingSelectedLocation: sources.getPendingSelectedLocation,
	  getPrettySource: sources.getPrettySource,

	  getBreakpoint: breakpoints.getBreakpoint,
	  getBreakpoints: breakpoints.getBreakpoints,
	  getPendingBreakpoints: breakpoints.getPendingBreakpoints,
	  getBreakpointsForSource: breakpoints.getBreakpointsForSource,
	  getBreakpointsDisabled: breakpoints.getBreakpointsDisabled,
	  getBreakpointsLoading: breakpoints.getBreakpointsLoading,

	  getPause: pause.getPause,
	  getChromeScopes: pause.getChromeScopes,
	  getLoadedObjects: pause.getLoadedObjects,
	  getLoadedObject: pause.getLoadedObject,
	  getObjectProperties: pause.getObjectProperties,
	  getIsWaitingOnBreak: pause.getIsWaitingOnBreak,
	  getShouldPauseOnExceptions: pause.getShouldPauseOnExceptions,
	  getShouldIgnoreCaughtExceptions: pause.getShouldIgnoreCaughtExceptions,
	  getFrames: pause.getFrames,
	  getSelectedFrame: pause.getSelectedFrame,
	  getDebuggeeUrl: pause.getDebuggeeUrl,

	  getHitCountForSource: coverage.getHitCountForSource,
	  getCoverageEnabled: coverage.getCoverageEnabled,

	  getEventListeners: eventListeners.getEventListeners,

	  getProjectSearchState: ui.getProjectSearchState,
	  getFileSearchState: ui.getFileSearchState,
	  getFileSearchQueryState: ui.getFileSearchQueryState,
	  getFileSearchModifierState: ui.getFileSearchModifierState,
	  getShownSource: ui.getShownSource,
	  getPaneCollapse: ui.getPaneCollapse,

	  getExpressions: expressions.getExpressions,
	  getVisibleExpressions: expressions.getVisibleExpressions,
	  getExpression: expressions.getExpression
	};

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _reactRedux = __webpack_require__(151);

	var _redux = __webpack_require__(3);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	var _devtoolsModules = __webpack_require__(830);

	__webpack_require__(323);

	__webpack_require__(325);

	__webpack_require__(327);

	__webpack_require__(331);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var shortcuts = new _devtoolsModules.KeyShortcuts({ window });

	var verticalLayoutBreakpoint = window.matchMedia("(min-width: 800px)");

	var SplitBox = (0, _react.createFactory)(__webpack_require__(910));
	var ProjectSearch = (0, _react.createFactory)(__webpack_require__(915).default);
	var Sources = (0, _react.createFactory)(__webpack_require__(388).default);
	var Editor = (0, _react.createFactory)(__webpack_require__(426).default);
	var SecondaryPanes = (0, _react.createFactory)(__webpack_require__(718).default);
	var WelcomeBox = (0, _react.createFactory)(__webpack_require__(747).default);
	var EditorTabs = (0, _react.createFactory)(__webpack_require__(750));

	class App extends _react.Component {

	  constructor(props) {
	    super(props);
	    this.state = {
	      horizontal: verticalLayoutBreakpoint.matches,
	      startPanelSize: 0,
	      endPanelSize: 0
	    };

	    this.getChildContext = this.getChildContext.bind(this);
	    this.onLayoutChange = this.onLayoutChange.bind(this);
	    this.renderEditorPane = this.renderEditorPane.bind(this);
	    this.renderVerticalLayout = this.renderVerticalLayout.bind(this);
	  }

	  getChildContext() {
	    return { shortcuts };
	  }

	  componentDidMount() {
	    verticalLayoutBreakpoint.addListener(this.onLayoutChange);
	  }

	  componentWillUnmount() {
	    verticalLayoutBreakpoint.removeListener(this.onLayoutChange);
	  }

	  onLayoutChange() {
	    this.setState({ horizontal: verticalLayoutBreakpoint.matches });
	  }

	  renderEditorPane() {
	    var _props = this.props,
	        startPanelCollapsed = _props.startPanelCollapsed,
	        endPanelCollapsed = _props.endPanelCollapsed;
	    var _state = this.state,
	        horizontal = _state.horizontal,
	        endPanelSize = _state.endPanelSize;

	    return _react.DOM.div({ className: "editor-pane" }, _react.DOM.div({ className: "editor-container" }, EditorTabs({
	      startPanelCollapsed,
	      endPanelCollapsed,
	      horizontal,
	      endPanelSize
	    }), Editor({ horizontal }), !this.props.selectedSource ? WelcomeBox({ horizontal }) : null, ProjectSearch()));
	  }

	  renderHorizontalLayout() {
	    var _props2 = this.props,
	        sources = _props2.sources,
	        startPanelCollapsed = _props2.startPanelCollapsed,
	        endPanelCollapsed = _props2.endPanelCollapsed;
	    var horizontal = this.state.horizontal;


	    var overflowX = endPanelCollapsed ? "hidden" : "auto";

	    return _react.DOM.div({ className: "debugger" }, SplitBox({
	      style: { width: "100vw" },
	      initialSize: "250px",
	      minSize: 10,
	      maxSize: "50%",
	      splitterSize: 1,
	      onResizeEnd: size => this.setState({ startPanelSize: size }),
	      startPanel: Sources({ sources, horizontal }),
	      startPanelCollapsed,
	      endPanel: SplitBox({
	        style: { overflowX },
	        initialSize: "300px",
	        minSize: 10,
	        maxSize: "80%",
	        splitterSize: 1,
	        onResizeEnd: size => this.setState({ endPanelSize: size }),
	        endPanelControl: true,
	        startPanel: this.renderEditorPane(),
	        endPanel: SecondaryPanes({ horizontal }),
	        endPanelCollapsed,
	        vert: horizontal
	      })
	    }));
	  }

	  renderVerticalLayout() {
	    var _props3 = this.props,
	        sources = _props3.sources,
	        startPanelCollapsed = _props3.startPanelCollapsed,
	        endPanelCollapsed = _props3.endPanelCollapsed;
	    var horizontal = this.state.horizontal;


	    return _react.DOM.div({ className: "debugger" }, SplitBox({
	      style: { width: "100vw" },
	      initialSize: "300px",
	      minSize: 30,
	      maxSize: "99%",
	      splitterSize: 1,
	      vert: horizontal,
	      startPanel: SplitBox({
	        style: { width: "100vw" },
	        initialSize: "250px",
	        minSize: 10,
	        maxSize: "40%",
	        splitterSize: 1,
	        startPanelCollapsed,
	        startPanel: Sources({ sources, horizontal }),
	        endPanel: this.renderEditorPane()
	      }),
	      endPanel: SecondaryPanes({ horizontal }),
	      endPanelCollapsed
	    }));
	  }

	  render() {
	    return this.state.horizontal ? this.renderHorizontalLayout() : this.renderVerticalLayout();
	  }
	}

	App.propTypes = {
	  sources: _react.PropTypes.object,
	  selectSource: _react.PropTypes.func,
	  selectedSource: _react.PropTypes.object,
	  startPanelCollapsed: _react.PropTypes.bool,
	  endPanelCollapsed: _react.PropTypes.bool
	};

	App.displayName = "App";

	App.childContextTypes = { shortcuts: _react.PropTypes.object };

	exports.default = (0, _reactRedux.connect)(state => ({
	  sources: (0, _selectors.getSources)(state),
	  selectedSource: (0, _selectors.getSelectedSource)(state),
	  startPanelCollapsed: (0, _selectors.getPaneCollapse)(state, "start"),
	  endPanelCollapsed: (0, _selectors.getPaneCollapse)(state, "end")
	}), dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(App);

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _breakpoints = __webpack_require__(245);

	var breakpoints = _interopRequireWildcard(_breakpoints);

	var _expressions = __webpack_require__(252);

	var expressions = _interopRequireWildcard(_expressions);

	var _eventListeners = __webpack_require__(253);

	var eventListeners = _interopRequireWildcard(_eventListeners);

	var _sources = __webpack_require__(254);

	var sources = _interopRequireWildcard(_sources);

	var _pause = __webpack_require__(319);

	var pause = _interopRequireWildcard(_pause);

	var _navigation = __webpack_require__(320);

	var navigation = _interopRequireWildcard(_navigation);

	var _ui = __webpack_require__(321);

	var ui = _interopRequireWildcard(_ui);

	var _coverage = __webpack_require__(322);

	var coverage = _interopRequireWildcard(_coverage);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	exports.default = Object.assign(navigation, breakpoints, expressions, eventListeners, sources, pause, ui, coverage);

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	exports.enableBreakpoint = enableBreakpoint;
	exports.addBreakpoint = addBreakpoint;
	exports.disableBreakpoint = disableBreakpoint;
	exports.removeBreakpoint = removeBreakpoint;
	exports.toggleAllBreakpoints = toggleAllBreakpoints;
	exports.setBreakpointCondition = setBreakpointCondition;

	var _constants = __webpack_require__(229);

	var _constants2 = _interopRequireDefault(_constants);

	var _promise = __webpack_require__(193);

	var _selectors = __webpack_require__(242);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * Redux actions for breakpoints
	 * @module actions/breakpoints
	 */

	function _breakpointExists(state, location) {
	  var currentBp = (0, _selectors.getBreakpoint)(state, location);
	  return currentBp && !currentBp.disabled;
	}

	function _getOrCreateBreakpoint(state, location, condition) {
	  return (0, _selectors.getBreakpoint)(state, location) || { location, condition, text: "" };
	}

	/**
	 * Enabling a breakpoint calls {@link addBreakpoint}
	 * which will reuse the existing breakpoint information that is stored.
	 *
	 * @memberof actions/breakpoints
	 * @static
	 */
	function enableBreakpoint(location) {
	  return addBreakpoint(location);
	}

	/**
	 * Add a new or enable an existing breakpoint
	 *
	 * @memberof actions/breakpoints
	 * @static
	 * @param {String} $1.condition Conditional breakpoint condition value
	 * @param {Function} $1.getTextForLine Get the text to represent the line
	 */
	function addBreakpoint(location) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      condition = _ref.condition,
	      getTextForLine = _ref.getTextForLine;

	  return (_ref2) => {
	    var dispatch = _ref2.dispatch,
	        getState = _ref2.getState,
	        client = _ref2.client,
	        sourceMaps = _ref2.sourceMaps;

	    if (_breakpointExists(getState(), location)) {
	      return Promise.resolve();
	    }

	    var bp = _getOrCreateBreakpoint(getState(), location, condition);

	    return dispatch({
	      type: _constants2.default.ADD_BREAKPOINT,
	      breakpoint: bp,
	      condition: condition,
	      [_promise.PROMISE]: _asyncToGenerator(function* () {
	        if (sourceMaps.isOriginalId(bp.location.sourceId)) {
	          var source = (0, _selectors.getSource)(getState(), bp.location.sourceId);
	          location = yield sourceMaps.getGeneratedLocation(bp.location, source.toJS());
	        }

	        var _ref4 = yield client.setBreakpoint(location, bp.condition, sourceMaps.isOriginalId(bp.location.sourceId)),
	            id = _ref4.id,
	            actualLocation = _ref4.actualLocation,
	            hitCount = _ref4.hitCount;

	        actualLocation = yield sourceMaps.getOriginalLocation(actualLocation);

	        // If this breakpoint is being re-enabled, it already has a
	        // text snippet.
	        var text = bp.text;
	        if (!text) {
	          text = getTextForLine ? getTextForLine(actualLocation.line) : "";
	        }

	        return { id, actualLocation, text, hitCount };
	      })()
	    });
	  };
	}

	/**
	 * Disable a single breakpoint
	 *
	 * @memberof actions/breakpoints
	 * @static
	 */
	function disableBreakpoint(location) {
	  return _removeOrDisableBreakpoint(location, true);
	}

	/**
	 * Remove a single breakpoint
	 *
	 * @memberof actions/breakpoints
	 * @static
	 */
	function removeBreakpoint(location) {
	  return _removeOrDisableBreakpoint(location);
	}

	function _removeOrDisableBreakpoint(location, isDisabled) {
	  return (_ref5) => {
	    var dispatch = _ref5.dispatch,
	        getState = _ref5.getState,
	        client = _ref5.client;

	    var bp = (0, _selectors.getBreakpoint)(getState(), location);
	    if (!bp) {
	      throw new Error("attempt to remove breakpoint that does not exist");
	    }
	    if (bp.loading) {
	      // TODO(jwl): make this wait until the breakpoint is saved if it
	      // is still loading
	      throw new Error("attempt to remove unsaved breakpoint");
	    }

	    var action = {
	      type: _constants2.default.REMOVE_BREAKPOINT,
	      breakpoint: bp,
	      disabled: isDisabled
	    };

	    // If the breakpoint is already disabled, we don't need to remove
	    // it from the server. We just need to dispatch an action
	    // simulating a successful server request to remove it, and it
	    // will be removed completely from the state.
	    if (!bp.disabled) {
	      return dispatch(Object.assign({}, action, {
	        [_promise.PROMISE]: client.removeBreakpoint(bp.id)
	      }));
	    }
	    return dispatch(Object.assign({}, action, { status: "done" }));
	  };
	}

	/**
	 * Toggle All Breakpoints
	 *
	 * @memberof actions/breakpoints
	 * @static
	 */
	function toggleAllBreakpoints(shouldDisableBreakpoints) {
	  return (_ref6) => {
	    var dispatch = _ref6.dispatch,
	        getState = _ref6.getState;

	    var breakpoints = (0, _selectors.getBreakpoints)(getState());
	    return dispatch({
	      type: _constants2.default.TOGGLE_BREAKPOINTS,
	      shouldDisableBreakpoints,
	      [_promise.PROMISE]: _asyncToGenerator(function* () {
	        for (var _ref8 of breakpoints) {
	          var _ref9 = _slicedToArray(_ref8, 2);

	          var breakpoint = _ref9[1];

	          if (shouldDisableBreakpoints) {
	            yield dispatch(disableBreakpoint(breakpoint.location));
	          } else {
	            yield dispatch(enableBreakpoint(breakpoint.location));
	          }
	        }
	      })()
	    });
	  };
	}

	/**
	 * Update the condition of a breakpoint.
	 *
	 * @throws {Error} "not implemented"
	 * @memberof actions/breakpoints
	 * @static
	 * @param {Location} location
	 *        @see DebuggerController.Breakpoints.addBreakpoint
	 * @param {string} condition
	 *        The condition to set on the breakpoint
	 */
	function setBreakpointCondition(location) {
	  var _ref10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      condition = _ref10.condition,
	      getTextForLine = _ref10.getTextForLine;

	  // location: Location, condition: string, { getTextForLine }) {
	  return (_ref11) => {
	    var dispatch = _ref11.dispatch,
	        getState = _ref11.getState,
	        client = _ref11.client,
	        sourceMaps = _ref11.sourceMaps;

	    var bp = (0, _selectors.getBreakpoint)(getState(), location);
	    if (!bp) {
	      return dispatch(addBreakpoint(location, { condition, getTextForLine }));
	    }

	    if (bp.loading) {
	      // TODO(jwl): when this function is called, make sure the action
	      // creator waits for the breakpoint to exist
	      throw new Error("breakpoint must be saved");
	    }

	    return dispatch({
	      type: _constants2.default.SET_BREAKPOINT_CONDITION,
	      breakpoint: bp,
	      condition: condition,
	      [_promise.PROMISE]: client.setBreakpointCondition(bp.id, location, condition, sourceMaps.isOriginalId(bp.location.sourceId))
	    });
	  };
	}

/***/ },
/* 246 */,
/* 247 */,
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
	  var crypt = __webpack_require__(249),
	      utf8 = __webpack_require__(250).utf8,
	      isBuffer = __webpack_require__(251),
	      bin = __webpack_require__(250).bin,

	  // The core
	  md5 = function (message, options) {
	    // Convert to byte array
	    if (message.constructor == String)
	      if (options && options.encoding === 'binary')
	        message = bin.stringToBytes(message);
	      else
	        message = utf8.stringToBytes(message);
	    else if (isBuffer(message))
	      message = Array.prototype.slice.call(message, 0);
	    else if (!Array.isArray(message))
	      message = message.toString();
	    // else, assume byte array already

	    var m = crypt.bytesToWords(message),
	        l = message.length * 8,
	        a =  1732584193,
	        b = -271733879,
	        c = -1732584194,
	        d =  271733878;

	    // Swap endian
	    for (var i = 0; i < m.length; i++) {
	      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
	             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
	    }

	    // Padding
	    m[l >>> 5] |= 0x80 << (l % 32);
	    m[(((l + 64) >>> 9) << 4) + 14] = l;

	    // Method shortcuts
	    var FF = md5._ff,
	        GG = md5._gg,
	        HH = md5._hh,
	        II = md5._ii;

	    for (var i = 0; i < m.length; i += 16) {

	      var aa = a,
	          bb = b,
	          cc = c,
	          dd = d;

	      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
	      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
	      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
	      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
	      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
	      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
	      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
	      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
	      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
	      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
	      c = FF(c, d, a, b, m[i+10], 17, -42063);
	      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
	      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
	      d = FF(d, a, b, c, m[i+13], 12, -40341101);
	      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
	      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

	      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
	      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
	      c = GG(c, d, a, b, m[i+11], 14,  643717713);
	      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
	      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
	      d = GG(d, a, b, c, m[i+10],  9,  38016083);
	      c = GG(c, d, a, b, m[i+15], 14, -660478335);
	      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
	      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
	      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
	      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
	      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
	      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
	      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
	      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
	      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

	      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
	      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
	      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
	      b = HH(b, c, d, a, m[i+14], 23, -35309556);
	      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
	      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
	      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
	      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
	      a = HH(a, b, c, d, m[i+13],  4,  681279174);
	      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
	      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
	      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
	      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
	      d = HH(d, a, b, c, m[i+12], 11, -421815835);
	      c = HH(c, d, a, b, m[i+15], 16,  530742520);
	      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

	      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
	      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
	      c = II(c, d, a, b, m[i+14], 15, -1416354905);
	      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
	      a = II(a, b, c, d, m[i+12],  6,  1700485571);
	      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
	      c = II(c, d, a, b, m[i+10], 15, -1051523);
	      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
	      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
	      d = II(d, a, b, c, m[i+15], 10, -30611744);
	      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
	      b = II(b, c, d, a, m[i+13], 21,  1309151649);
	      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
	      d = II(d, a, b, c, m[i+11], 10, -1120210379);
	      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
	      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

	      a = (a + aa) >>> 0;
	      b = (b + bb) >>> 0;
	      c = (c + cc) >>> 0;
	      d = (d + dd) >>> 0;
	    }

	    return crypt.endian([a, b, c, d]);
	  };

	  // Auxiliary functions
	  md5._ff  = function (a, b, c, d, x, s, t) {
	    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._gg  = function (a, b, c, d, x, s, t) {
	    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._hh  = function (a, b, c, d, x, s, t) {
	    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._ii  = function (a, b, c, d, x, s, t) {
	    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };

	  // Package private blocksize
	  md5._blocksize = 16;
	  md5._digestsize = 16;

	  module.exports = function (message, options) {
	    if (message === undefined || message === null)
	      throw new Error('Illegal argument ' + message);

	    var digestbytes = crypt.wordsToBytes(md5(message, options));
	    return options && options.asBytes ? digestbytes :
	        options && options.asString ? bin.bytesToString(digestbytes) :
	        crypt.bytesToHex(digestbytes);
	  };

	})();


/***/ },
/* 249 */
/***/ function(module, exports) {

	(function() {
	  var base64map
	      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

	  crypt = {
	    // Bit-wise rotation left
	    rotl: function(n, b) {
	      return (n << b) | (n >>> (32 - b));
	    },

	    // Bit-wise rotation right
	    rotr: function(n, b) {
	      return (n << (32 - b)) | (n >>> b);
	    },

	    // Swap big-endian to little-endian and vice versa
	    endian: function(n) {
	      // If number given, swap endian
	      if (n.constructor == Number) {
	        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
	      }

	      // Else, assume array and swap all items
	      for (var i = 0; i < n.length; i++)
	        n[i] = crypt.endian(n[i]);
	      return n;
	    },

	    // Generate an array of any length of random bytes
	    randomBytes: function(n) {
	      for (var bytes = []; n > 0; n--)
	        bytes.push(Math.floor(Math.random() * 256));
	      return bytes;
	    },

	    // Convert a byte array to big-endian 32-bit words
	    bytesToWords: function(bytes) {
	      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
	        words[b >>> 5] |= bytes[i] << (24 - b % 32);
	      return words;
	    },

	    // Convert big-endian 32-bit words to a byte array
	    wordsToBytes: function(words) {
	      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
	        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	      return bytes;
	    },

	    // Convert a byte array to a hex string
	    bytesToHex: function(bytes) {
	      for (var hex = [], i = 0; i < bytes.length; i++) {
	        hex.push((bytes[i] >>> 4).toString(16));
	        hex.push((bytes[i] & 0xF).toString(16));
	      }
	      return hex.join('');
	    },

	    // Convert a hex string to a byte array
	    hexToBytes: function(hex) {
	      for (var bytes = [], c = 0; c < hex.length; c += 2)
	        bytes.push(parseInt(hex.substr(c, 2), 16));
	      return bytes;
	    },

	    // Convert a byte array to a base-64 string
	    bytesToBase64: function(bytes) {
	      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
	        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
	        for (var j = 0; j < 4; j++)
	          if (i * 8 + j * 6 <= bytes.length * 8)
	            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
	          else
	            base64.push('=');
	      }
	      return base64.join('');
	    },

	    // Convert a base-64 string to a byte array
	    base64ToBytes: function(base64) {
	      // Remove non-base-64 characters
	      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

	      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
	          imod4 = ++i % 4) {
	        if (imod4 == 0) continue;
	        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
	            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
	            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
	      }
	      return bytes;
	    }
	  };

	  module.exports = crypt;
	})();


/***/ },
/* 250 */
/***/ function(module, exports) {

	var charenc = {
	  // UTF-8 encoding
	  utf8: {
	    // Convert a string to a byte array
	    stringToBytes: function(str) {
	      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
	    },

	    // Convert a byte array to a string
	    bytesToString: function(bytes) {
	      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
	    }
	  },

	  // Binary encoding
	  bin: {
	    // Convert a string to a byte array
	    stringToBytes: function(str) {
	      for (var bytes = [], i = 0; i < str.length; i++)
	        bytes.push(str.charCodeAt(i) & 0xFF);
	      return bytes;
	    },

	    // Convert a byte array to a string
	    bytesToString: function(bytes) {
	      for (var str = [], i = 0; i < bytes.length; i++)
	        str.push(String.fromCharCode(bytes[i]));
	      return str.join('');
	    }
	  }
	};

	module.exports = charenc;


/***/ },
/* 251 */
/***/ function(module, exports) {

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	module.exports = function (obj) {
	  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
	}

	function isBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
	}


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.addExpression = addExpression;
	exports.updateExpression = updateExpression;
	exports.deleteExpression = deleteExpression;
	exports.evaluateExpressions = evaluateExpressions;

	var _constants = __webpack_require__(229);

	var _constants2 = _interopRequireDefault(_constants);

	var _promise = __webpack_require__(193);

	var _selectors = __webpack_require__(242);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	function expressionExists(expressions, input) {
	  return !!expressions.find(e => e.input == input);
	}

	/**
	 * Add expression for debugger to watch
	 *
	 * @param {object} expression
	 * @param {number} expression.id
	 * @memberof actions/pause
	 * @static
	 */
	function addExpression(input) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$visible = _ref.visible,
	      visible = _ref$visible === undefined ? true : _ref$visible;

	  return (() => {
	    var _ref2 = _asyncToGenerator(function* (_ref3) {
	      var dispatch = _ref3.dispatch,
	          getState = _ref3.getState;

	      var expressions = (0, _selectors.getExpressions)(getState());
	      if (!input || expressionExists(expressions, input)) {
	        var expression = (0, _selectors.getExpression)(getState(), input);
	        if (!expression.visible && visible) {
	          yield dispatch(deleteExpression(expression));
	        } else {
	          return;
	        }
	      }

	      dispatch({
	        type: _constants2.default.ADD_EXPRESSION,
	        input,
	        visible
	      });

	      var selectedFrame = (0, _selectors.getSelectedFrame)(getState());
	      var selectedFrameId = selectedFrame ? selectedFrame.id : null;
	      dispatch(evaluateExpression({ input, visible }, selectedFrameId));
	    });

	    return function (_x2) {
	      return _ref2.apply(this, arguments);
	    };
	  })();
	}

	function updateExpression(input, expression) {
	  return (_ref4) => {
	    var dispatch = _ref4.dispatch,
	        getState = _ref4.getState;

	    if (!input || input == expression.input) {
	      return;
	    }

	    dispatch({
	      type: _constants2.default.UPDATE_EXPRESSION,
	      expression,
	      input: input,
	      visible: expression.visible
	    });

	    var selectedFrame = (0, _selectors.getSelectedFrame)(getState());
	    var selectedFrameId = selectedFrame ? selectedFrame.id : null;
	    dispatch(evaluateExpressions(selectedFrameId));
	  };
	}

	/**
	 *
	 * @param {object} expression
	 * @param {number} expression.id
	 * @memberof actions/pause
	 * @static
	 */
	function deleteExpression(expression) {
	  return (_ref5) => {
	    var dispatch = _ref5.dispatch;

	    dispatch({
	      type: _constants2.default.DELETE_EXPRESSION,
	      input: expression.input
	    });
	  };
	}

	/**
	 *
	 * @memberof actions/pause
	 * @param {number} selectedFrameId
	 * @static
	 */
	function evaluateExpressions(frameId) {
	  return (() => {
	    var _ref6 = _asyncToGenerator(function* (_ref7) {
	      var dispatch = _ref7.dispatch,
	          getState = _ref7.getState,
	          client = _ref7.client;

	      var expressions = (0, _selectors.getExpressions)(getState()).toJS();
	      if (!frameId) {
	        var selectedFrame = (0, _selectors.getSelectedFrame)(getState());
	        frameId = selectedFrame ? selectedFrame.id : null;
	      }
	      for (var expression of expressions) {
	        yield dispatch(evaluateExpression(expression, frameId));
	      }
	    });

	    return function (_x3) {
	      return _ref6.apply(this, arguments);
	    };
	  })();
	}

	function evaluateExpression(expression, frameId) {
	  return function (_ref8) {
	    var dispatch = _ref8.dispatch,
	        getState = _ref8.getState,
	        client = _ref8.client;

	    if (!expression.input) {
	      console.warn("Expressions should not be empty");
	      return;
	    }

	    return dispatch({
	      type: _constants2.default.EVALUATE_EXPRESSION,
	      input: expression.input,
	      visible: expression.visible,
	      [_promise.PROMISE]: client.evaluate(expression.input, { frameId })
	    });
	  };
	}

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	/**
	 * @memberof utils/utils
	 * @static
	 */
	var asPaused = (() => {
	  var _ref = _asyncToGenerator(function* (state, client, func) {
	    if (!(0, _selectors.getPause)(state)) {
	      yield client.interrupt();
	      var result = void 0;

	      try {
	        result = yield func(client);
	      } catch (e) {
	        // Try to put the debugger back in a working state by resuming
	        // it
	        yield client.resume();
	        throw e;
	      }

	      yield client.resume();
	      return result;
	    }

	    return func(client);
	  });

	  return function asPaused(_x, _x2, _x3) {
	    return _ref.apply(this, arguments);
	  };
	})();

	/**
	 * @memberof actions/event-listeners
	 * @static
	 */


	var _getEventListeners = (() => {
	  var _ref3 = _asyncToGenerator(function* (threadClient) {
	    var response = yield threadClient.eventListeners();

	    // Make sure all the listeners are sorted by the event type, since
	    // they"re not guaranteed to be clustered together.
	    response.listeners.sort(function (a, b) {
	      return a.type > b.type ? 1 : -1;
	    });

	    // Add all the listeners in the debugger view event linsteners container.
	    var fetchedDefinitions = new Map();
	    var listeners = [];
	    for (var listener of response.listeners) {
	      var definitionSite = void 0;
	      if (fetchedDefinitions.has(listener.function.actor)) {
	        definitionSite = fetchedDefinitions.get(listener.function.actor);
	      } else if (listener.function.class == "Function") {
	        definitionSite = yield _getDefinitionSite(threadClient, listener.function);
	        if (!definitionSite) {
	          // We don"t know where this listener comes from so don"t show it in
	          // the UI as breaking on it doesn"t work (bug 942899).
	          continue;
	        }

	        fetchedDefinitions.set(listener.function.actor, definitionSite);
	      }
	      listener.function.url = definitionSite;
	      listeners.push(listener);
	    }
	    fetchedDefinitions.clear();

	    return listeners;
	  });

	  return function _getEventListeners(_x4) {
	    return _ref3.apply(this, arguments);
	  };
	})();

	var _getDefinitionSite = (() => {
	  var _ref4 = _asyncToGenerator(function* (threadClient, func) {
	    var grip = threadClient.pauseGrip(func);
	    var response = void 0;

	    try {
	      response = yield grip.getDefinitionSite();
	    } catch (e) {
	      // Don't make this error fatal, it would break the entire events pane.
	      (0, _DevToolsUtils.reportException)("_getDefinitionSite", e);
	      return null;
	    }

	    return response.source.url;
	  });

	  return function _getDefinitionSite(_x5, _x6) {
	    return _ref4.apply(this, arguments);
	  };
	})();

	/**
	 * @memberof actions/event-listeners
	 * @static
	 * @param {string} eventNames
	 */


	exports.fetchEventListeners = fetchEventListeners;
	exports.updateEventBreakpoints = updateEventBreakpoints;

	var _constants = __webpack_require__(229);

	var _constants2 = _interopRequireDefault(_constants);

	var _DevToolsUtils = __webpack_require__(222);

	var _selectors = __webpack_require__(242);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /* This Source Code Form is subject to the terms of the Mozilla Public
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * License, v. 2.0. If a copy of the MPL was not distributed with this
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* global window gThreadClient setNamedTimeout services EVENTS */
	/* eslint no-shadow: 0  */

	/**
	 * Redux actions for the event listeners state
	 * @module actions/event-listeners
	 */

	// delay is in ms
	var FETCH_EVENT_LISTENERS_DELAY = 200;
	var fetchListenersTimerID = void 0;function fetchEventListeners() {
	  return (_ref2) => {
	    var dispatch = _ref2.dispatch,
	        getState = _ref2.getState,
	        client = _ref2.client;

	    // Make sure we"re not sending a batch of closely repeated requests.
	    // This can easily happen whenever new sources are fetched.
	    if (fetchListenersTimerID) {
	      clearTimeout(fetchListenersTimerID);
	    }

	    fetchListenersTimerID = setTimeout(() => {
	      // In case there is still a request of listeners going on (it
	      // takes several RDP round trips right now), make sure we wait
	      // on a currently running request
	      if (getState().eventListeners.fetchingListeners) {
	        dispatch({
	          type: services.WAIT_UNTIL,
	          predicate: action => action.type === _constants2.default.FETCH_EVENT_LISTENERS && action.status === "done",
	          run: dispatch => dispatch(fetchEventListeners())
	        });
	        return;
	      }

	      dispatch({
	        type: _constants2.default.FETCH_EVENT_LISTENERS,
	        status: "begin"
	      });

	      asPaused(getState(), client, _getEventListeners).then(listeners => {
	        dispatch({
	          type: _constants2.default.FETCH_EVENT_LISTENERS,
	          status: "done",
	          listeners: formatListeners(getState(), listeners)
	        });
	      });
	    }, FETCH_EVENT_LISTENERS_DELAY);
	  };
	}

	function formatListeners(state, listeners) {
	  return listeners.map(l => {
	    return {
	      selector: l.node.selector,
	      type: l.type,
	      sourceId: (0, _selectors.getSourceByURL)(state, l.function.location.url).get("id"),
	      line: l.function.location.line
	    };
	  });
	}

	function updateEventBreakpoints(eventNames) {
	  return dispatch => {
	    setNamedTimeout("event-breakpoints-update", 0, () => {
	      gThreadClient.pauseOnDOMEvents(eventNames, function () {
	        // Notify that event breakpoints were added/removed on the server.
	        window.emit(EVENTS.EVENT_BREAKPOINTS_UPDATED);

	        dispatch({
	          type: _constants2.default.UPDATE_EVENT_BREAKPOINTS,
	          eventNames: eventNames
	        });
	      });
	    });
	  };
	}

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	exports.newSource = newSource;
	exports.newSources = newSources;
	exports.selectSourceURL = selectSourceURL;
	exports.selectSource = selectSource;
	exports.jumpToMappedLocation = jumpToMappedLocation;
	exports.closeTab = closeTab;
	exports.closeTabs = closeTabs;
	exports.togglePrettyPrint = togglePrettyPrint;
	exports.toggleBlackBox = toggleBlackBox;
	exports.loadSourceText = loadSourceText;
	exports.getTextForSources = getTextForSources;

	var _defer = __webpack_require__(194);

	var _defer2 = _interopRequireDefault(_defer);

	var _promise = __webpack_require__(193);

	var _assert = __webpack_require__(223);

	var _assert2 = _interopRequireDefault(_assert);

	var _pause = __webpack_require__(255);

	var _breakpoints = __webpack_require__(245);

	var _prettyPrint = __webpack_require__(903);

	var _source = __webpack_require__(233);

	var _constants = __webpack_require__(229);

	var _constants2 = _interopRequireDefault(_constants);

	var _prefs = __webpack_require__(226);

	var _editor = __webpack_require__(257);

	var _selectors = __webpack_require__(242);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * Redux actions for the sources state
	 * @module actions/sources
	 */

	// If a request has been made to show this source, go ahead and
	// select it.
	function checkSelectedSource(state, dispatch, source) {
	  var pendingLocation = (0, _selectors.getPendingSelectedLocation)(state);
	  if (pendingLocation && pendingLocation.url === source.url) {
	    dispatch(selectSource(source.id, { line: pendingLocation.line }));
	  }
	}

	function checkPendingBreakpoints(state, dispatch, source) {
	  var pendingBreakpoints = (0, _selectors.getPendingBreakpoints)(state);

	  if (pendingBreakpoints) {
	    pendingBreakpoints.forEach(pendingBreakpoint => {
	      var _pendingBreakpoint$lo = pendingBreakpoint.location,
	          line = _pendingBreakpoint$lo.line,
	          sourceUrl = _pendingBreakpoint$lo.sourceUrl,
	          condition = pendingBreakpoint.condition;

	      var sameSource = sourceUrl && sourceUrl == source.url;

	      var location = { sourceId: source.id, sourceUrl, line };

	      var bp = (0, _selectors.getBreakpoint)(state, location);

	      if (sameSource && !bp) {
	        dispatch((0, _breakpoints.addBreakpoint)(location, { condition }));
	      }
	    });
	  }
	}

	/**
	 * Handler for the debugger client's unsolicited newSource notification.
	 * @memberof actions/sources
	 * @static
	 */
	function newSource(source) {
	  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;

	    if (_prefs.prefs.clientSourceMapsEnabled) {
	      dispatch(loadSourceMap(source));
	    }

	    dispatch({ type: _constants2.default.ADD_SOURCE, source });

	    checkSelectedSource(getState(), dispatch, source);
	    checkPendingBreakpoints(getState(), dispatch, source);
	  };
	}

	function newSources(sources) {
	  return (_ref2) => {
	    var dispatch = _ref2.dispatch,
	        getState = _ref2.getState;

	    sources.filter(source => !(0, _selectors.getSource)(getState(), source.id)).forEach(source => dispatch(newSource(source)));
	  };
	}

	/**
	 * @memberof actions/sources
	 * @static
	 */
	function loadSourceMap(generatedSource) {
	  return (() => {
	    var _ref3 = _asyncToGenerator(function* (_ref4) {
	      var dispatch = _ref4.dispatch,
	          getState = _ref4.getState,
	          sourceMaps = _ref4.sourceMaps;

	      var urls = yield sourceMaps.getOriginalURLs(generatedSource);
	      if (!urls) {
	        // If this source doesn't have a sourcemap, do nothing.
	        return;
	      }

	      var state = getState();
	      var originalSources = urls.map(function (originalUrl) {
	        return {
	          url: originalUrl,
	          id: sourceMaps.generatedToOriginalId(generatedSource.id, originalUrl),
	          isPrettyPrinted: false
	        };
	      });

	      dispatch({ type: _constants2.default.ADD_SOURCES, sources: originalSources });

	      originalSources.forEach(function (source) {
	        checkSelectedSource(state, dispatch, source);
	        checkPendingBreakpoints(state, dispatch, source);
	      });
	    });

	    return function (_x) {
	      return _ref3.apply(this, arguments);
	    };
	  })();
	}

	/**
	 * Deterministically select a source that has a given URL. This will
	 * work regardless of the connection status or if the source exists
	 * yet. This exists mostly for external things to interact with the
	 * debugger.
	 *
	 * @memberof actions/sources
	 * @static
	 */
	function selectSourceURL(url) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  return (_ref5) => {
	    var dispatch = _ref5.dispatch,
	        getState = _ref5.getState;

	    var source = (0, _selectors.getSourceByURL)(getState(), url);
	    if (source) {
	      dispatch(selectSource(source.get("id"), options));
	    } else {
	      dispatch({
	        type: _constants2.default.SELECT_SOURCE_URL,
	        url: url,
	        tabIndex: options.tabIndex,
	        line: options.line
	      });
	    }
	  };
	}

	/**
	 * @memberof actions/sources
	 * @static
	 */
	function selectSource(id) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  return (_ref6) => {
	    var dispatch = _ref6.dispatch,
	        getState = _ref6.getState,
	        client = _ref6.client;

	    if (!client) {
	      // No connection, do nothing. This happens when the debugger is
	      // shut down too fast and it tries to display a default source.
	      return;
	    }

	    var source = (0, _selectors.getSource)(getState(), id);

	    if (!source) {
	      return;
	    }

	    source = source.toJS();

	    // Make sure to start a request to load the source text.
	    dispatch(loadSourceText(source));

	    dispatch({ type: _constants2.default.TOGGLE_PROJECT_SEARCH, value: false });

	    dispatch({
	      type: _constants2.default.SELECT_SOURCE,
	      source: source,
	      tabIndex: options.tabIndex,
	      line: options.line
	    });
	  };
	}

	/**
	 * @memberof actions/sources
	 * @static
	 */
	function jumpToMappedLocation(sourceLocation) {
	  return (() => {
	    var _ref7 = _asyncToGenerator(function* (_ref8) {
	      var dispatch = _ref8.dispatch,
	          getState = _ref8.getState,
	          client = _ref8.client,
	          sourceMaps = _ref8.sourceMaps;

	      if (!client) {
	        return;
	      }

	      var source = (0, _selectors.getSource)(getState(), sourceLocation.sourceId);
	      var pairedLocation = void 0;
	      if (sourceMaps.isOriginalId(sourceLocation.sourceId)) {
	        pairedLocation = yield sourceMaps.getGeneratedLocation(sourceLocation, source.toJS());
	      } else {
	        pairedLocation = yield sourceMaps.getOriginalLocation(sourceLocation, source.toJS());
	      }

	      return dispatch(selectSource(pairedLocation.sourceId, { line: pairedLocation.line }));
	    });

	    return function (_x4) {
	      return _ref7.apply(this, arguments);
	    };
	  })();
	}

	/**
	 * @memberof actions/sources
	 * @static
	 */
	function closeTab(url) {
	  (0, _editor.removeDocument)(url);
	  return { type: _constants2.default.CLOSE_TAB, url };
	}

	/**
	 * @memberof actions/sources
	 * @static
	 */
	function closeTabs(urls) {
	  return (_ref9) => {
	    var dispatch = _ref9.dispatch,
	        getState = _ref9.getState,
	        client = _ref9.client;

	    urls.forEach(url => {
	      var source = (0, _selectors.getSourceByURL)(getState(), url);
	      if (source) {
	        (0, _editor.removeDocument)(source.get("id"));
	      }
	    });

	    dispatch({ type: _constants2.default.CLOSE_TABS, urls });
	  };
	}

	/**
	 * Toggle the pretty printing of a source's text. All subsequent calls to
	 * |getText| will return the pretty-toggled text. Nothing will happen for
	 * non-javascript files.
	 *
	 * @memberof actions/sources
	 * @static
	 * @param string id The source form from the RDP.
	 * @returns Promise
	 *          A promise that resolves to [aSource, prettyText] or rejects to
	 *          [aSource, error].
	 */
	function togglePrettyPrint(sourceId) {
	  return (_ref10) => {
	    var dispatch = _ref10.dispatch,
	        getState = _ref10.getState,
	        client = _ref10.client,
	        sourceMaps = _ref10.sourceMaps;

	    var source = (0, _selectors.getSource)(getState(), sourceId).toJS();
	    var sourceText = (0, _selectors.getSourceText)(getState(), sourceId);
	    if (sourceText) {
	      sourceText = sourceText.toJS();
	    }

	    if (sourceText && sourceText.loading) {
	      return {};
	    }

	    (0, _assert2.default)(sourceMaps.isGeneratedId(sourceId), "Pretty-printing only allowed on generated sources");

	    var url = (0, _source.getPrettySourceURL)(source.url);
	    var id = sourceMaps.generatedToOriginalId(source.id, url);
	    var originalSource = { url, id, isPrettyPrinted: false };
	    dispatch({ type: _constants2.default.ADD_SOURCE, source: originalSource });

	    return dispatch({
	      type: _constants2.default.TOGGLE_PRETTY_PRINT,
	      source: originalSource,
	      [_promise.PROMISE]: _asyncToGenerator(function* () {
	        var _ref12 = yield (0, _prettyPrint.prettyPrint)({
	          source,
	          sourceText,
	          url
	        }),
	            code = _ref12.code,
	            mappings = _ref12.mappings;

	        yield sourceMaps.applySourceMap(source.id, url, code, mappings);

	        var frames = (0, _selectors.getFrames)(getState());
	        if (frames) {
	          frames = yield (0, _pause.updateFrameLocations)(frames.toJS(), sourceMaps);
	        }

	        dispatch(selectSource(originalSource.id));

	        return { text: code, contentType: "text/javascript", frames };
	      })()
	    });
	  };
	}

	function toggleBlackBox(source) {
	  return (() => {
	    var _ref13 = _asyncToGenerator(function* (_ref14) {
	      var dispatch = _ref14.dispatch,
	          getState = _ref14.getState,
	          client = _ref14.client,
	          sourceMaps = _ref14.sourceMaps;
	      var isBlackBoxed = source.isBlackBoxed,
	          id = source.id;


	      return dispatch({
	        type: _constants2.default.BLACKBOX,
	        source,
	        [_promise.PROMISE]: client.blackBox(id, isBlackBoxed)
	      });
	    });

	    return function (_x5) {
	      return _ref13.apply(this, arguments);
	    };
	  })();
	}

	/**
	 * @memberof actions/sources
	 * @static
	 */
	function loadSourceText(source) {
	  return (_ref15) => {
	    var dispatch = _ref15.dispatch,
	        getState = _ref15.getState,
	        client = _ref15.client,
	        sourceMaps = _ref15.sourceMaps;

	    // Fetch the source text only once.
	    var textInfo = (0, _selectors.getSourceText)(getState(), source.id);
	    if (textInfo) {
	      // It's already loaded or is loading
	      return Promise.resolve(textInfo);
	    }

	    return dispatch({
	      type: _constants2.default.LOAD_SOURCE_TEXT,
	      source: source,
	      [_promise.PROMISE]: _asyncToGenerator(function* () {
	        if (sourceMaps.isOriginalId(source.id)) {
	          return yield sourceMaps.getOriginalSourceText(source);
	        }

	        var response = yield client.sourceContents(source.id);

	        var sourceText = {
	          id: source.id,
	          text: response.source,
	          contentType: response.contentType || "text/javascript"
	        };

	        return sourceText;
	        // Automatically pretty print if enabled and the test is
	        // detected to be "minified"
	        // if (Prefs.autoPrettyPrint &&
	        //     !source.isPrettyPrinted &&
	        //     SourceUtils.isMinified(source.id, response.source)) {
	        //   dispatch(togglePrettyPrint(source));
	        // }
	      })()
	    });
	  };
	}

	// delay is in ms
	var FETCH_SOURCE_RESPONSE_DELAY = 200;

	/**
	 * Starts fetching all the sources, silently.
	 *
	 * @memberof actions/sources
	 * @static
	 * @param array actors
	 *        The urls for the sources to fetch. If fetching a source's text
	 *        takes too long, it will be discarded.
	 * @returns {Promise}
	 *         A promise that is resolved after source texts have been fetched.
	 */
	function getTextForSources(actors) {
	  return (_ref17) => {
	    var dispatch = _ref17.dispatch,
	        getState = _ref17.getState;

	    var deferred = (0, _defer2.default)();
	    var pending = new Set(actors);

	    var fetched = [];

	    // Can't use promise.all, because if one fetch operation is rejected, then
	    // everything is considered rejected, thus no other subsequent source will
	    // be getting fetched. We don't want that. Something like Q's allSettled
	    // would work like a charm here.
	    // Try to fetch as many sources as possible.

	    var _loop = function (actor) {
	      var source = (0, _selectors.getSource)(getState(), actor);
	      dispatch(loadSourceText(source)).then((_ref26) => {
	        var text = _ref26.text,
	            contentType = _ref26.contentType;

	        onFetch([source, text, contentType]);
	      }, err => {
	        onError(source, err);
	      });
	    };

	    for (var actor of actors) {
	      _loop(actor);
	    }

	    setTimeout(onTimeout, FETCH_SOURCE_RESPONSE_DELAY);

	    /* Called if fetching a source takes too long. */
	    function onTimeout() {
	      pending = new Set();
	      maybeFinish();
	    }

	    /* Called if fetching a source finishes successfully. */
	    function onFetch(_ref18) {
	      var _ref19 = _slicedToArray(_ref18, 3),
	          aSource = _ref19[0],
	          aText = _ref19[1],
	          aContentType = _ref19[2];

	      // If fetching the source has previously timed out, discard it this time.
	      if (!pending.has(aSource.actor)) {
	        return;
	      }
	      pending.delete(aSource.actor);
	      fetched.push([aSource.actor, aText, aContentType]);
	      maybeFinish();
	    }

	    /* Called if fetching a source failed because of an error. */
	    function onError(_ref20) {
	      var _ref21 = _slicedToArray(_ref20, 2),
	          aSource = _ref21[0],
	          aError = _ref21[1];

	      pending.delete(aSource.actor);
	      maybeFinish();
	    }

	    /* Called every time something interesting
	     *  happens while fetching sources.
	     */
	    function maybeFinish() {
	      if (pending.size == 0) {
	        // Sort the fetched sources alphabetically by their url.
	        if (deferred) {
	          deferred.resolve(fetched.sort((_ref22, _ref23) => {
	            var _ref25 = _slicedToArray(_ref22, 1),
	                aFirst = _ref25[0];

	            var _ref24 = _slicedToArray(_ref23, 1),
	                aSecond = _ref24[0];

	            return aFirst > aSecond ? -1 : 1;
	          }));
	        }
	      }
	    }

	    return deferred.promise;
	  };
	}

/***/ },
/* 255 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.updateFrameLocations = updateFrameLocations;
	exports.getPauseReason = getPauseReason;
	function updateFrameLocations(frames, sourceMaps) {
	  if (!frames || frames.length == 0) {
	    return Promise.resolve(frames);
	  }

	  return Promise.all(frames.map(frame => {
	    return sourceMaps.getOriginalLocation(frame.location).then(loc => {
	      return Object.assign(frame, {
	        location: loc
	      });
	    });
	  }));
	}

	// Map protocol pause "why" reason to a valid L10N key
	// These are the known unhandled reasons:
	// "breakpointConditionThrown", "clientEvaluated"
	// "interrupted", "attached"

	var reasons = {
	  debuggerStatement: "whyPaused.debuggerStatement",
	  breakpoint: "whyPaused.breakpoint",
	  exception: "whyPaused.exception",
	  resumeLimit: "whyPaused.resumeLimit",
	  pauseOnDOMEvents: "whyPaused.pauseOnDOMEvents",
	  breakpointConditionThrown: "whyPaused.breakpointConditionThrown",

	  // V8
	  DOM: "whyPaused.breakpoint",
	  EventListener: "whyPaused.pauseOnDOMEvents",
	  XHR: "whyPaused.xhr",
	  promiseRejection: "whyPaused.promiseRejection",
	  assert: "whyPaused.assert",
	  debugCommand: "whyPaused.debugCommand",
	  other: "whyPaused.other"
	};

	function getPauseReason(pauseInfo) {
	  if (!pauseInfo) {
	    return null;
	  }

	  var reasonType = pauseInfo.getIn(["why"]).get("type");
	  if (!reasons[reasonType]) {
	    console.log("Please file an issue: reasonType=", reasonType);
	  }
	  return reasons[reasonType];
	}

/***/ },
/* 256 */,
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _expression = __webpack_require__(904);

	var expressionUtils = _interopRequireWildcard(_expression);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var _require = __webpack_require__(828),
	    isEnabled = _require.isEnabled;

	var _require2 = __webpack_require__(233),
	    isPretty = _require2.isPretty,
	    isJavaScript = _require2.isJavaScript;

	var _require3 = __webpack_require__(898),
	    isOriginalId = _require3.isOriginalId;

	var buildQuery = __webpack_require__(258);
	var sourceDocumentUtils = __webpack_require__(260);
	var getDocument = sourceDocumentUtils.getDocument;


	var sourceSearchUtils = __webpack_require__(261);
	var findNext = sourceSearchUtils.findNext,
	    findPrev = sourceSearchUtils.findPrev;

	var _require4 = __webpack_require__(965),
	    SourceEditor = _require4.SourceEditor,
	    SourceEditorUtils = _require4.SourceEditorUtils;

	function shouldShowPrettyPrint(selectedSource) {
	  if (!selectedSource) {
	    return false;
	  }

	  selectedSource = selectedSource.toJS();
	  var _isPretty = isPretty(selectedSource);
	  var _isJavaScript = isJavaScript(selectedSource.url);
	  var isOriginal = isOriginalId(selectedSource.id);
	  var hasSourceMap = selectedSource.sourceMapURL;

	  if (_isPretty || isOriginal || hasSourceMap || !_isJavaScript) {
	    return false;
	  }

	  return true;
	}

	function shouldShowFooter(selectedSource, horizontal) {
	  if (!horizontal) {
	    return true;
	  }

	  return shouldShowPrettyPrint(selectedSource);
	}

	function isTextForSource(sourceText) {
	  return !sourceText.get("loading") && !sourceText.get("error");
	}

	function breakpointAtLine(breakpoints, line) {
	  return breakpoints.find(b => {
	    return b.location.line === line + 1;
	  });
	}

	function traverseResults(e, ctx, query, dir, modifiers) {
	  e.stopPropagation();
	  e.preventDefault();

	  if (dir == "prev") {
	    findPrev(ctx, query, true, modifiers);
	  } else if (dir == "next") {
	    findNext(ctx, query, true, modifiers);
	  }
	}

	function createEditor() {
	  var gutters = ["breakpoints", "hit-markers", "CodeMirror-linenumbers"];

	  if (isEnabled("codeFolding")) {
	    gutters.push("CodeMirror-foldgutter");
	  }

	  return new SourceEditor({
	    mode: "javascript",
	    foldGutter: isEnabled("codeFolding"),
	    readOnly: true,
	    lineNumbers: true,
	    theme: "mozilla",
	    lineWrapping: false,
	    matchBrackets: true,
	    showAnnotationRuler: true,
	    gutters,
	    value: " ",
	    extraKeys: {
	      // Override code mirror keymap to avoid conflicts with split console.
	      Esc: false,
	      "Cmd-F": false,
	      "Cmd-G": false
	    }
	  });
	}

	function updateDocument(editor, selectedSource, sourceText) {
	  if (selectedSource) {
	    var sourceId = selectedSource.get("id");
	    var doc = getDocument(sourceId) || editor.createDocument();
	    editor.replaceDocument(doc);
	  } else if (sourceText) {
	    this.setText(sourceText.get("text"));
	  }
	}

	module.exports = Object.assign({}, expressionUtils, sourceDocumentUtils, sourceSearchUtils, SourceEditorUtils, {
	  createEditor,
	  shouldShowPrettyPrint,
	  shouldShowFooter,
	  buildQuery,
	  isTextForSource,
	  breakpointAtLine,
	  traverseResults,
	  updateDocument
	});

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var escapeRegExp = __webpack_require__(259);

	/**
	 * Ignore doing outline matches for less than 3 whitespaces
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function ignoreWhiteSpace(str) {
	  return (/^\s{0,2}$/.test(str) ? "(?!\\s*.*)" : str
	  );
	}

	function wholeMatch(query, wholeWord) {
	  if (query == "" || !wholeWord) {
	    return query;
	  }

	  return `\\b${query}\\b`;
	}

	function buildFlags(caseSensitive, isGlobal) {
	  if (caseSensitive && isGlobal) {
	    return "g";
	  }

	  if (!caseSensitive && isGlobal) {
	    return "gi";
	  }

	  if (!caseSensitive && !isGlobal) {
	    return "i";
	  }

	  return;
	}

	function buildQuery(originalQuery, modifiers, _ref) {
	  var _ref$isGlobal = _ref.isGlobal,
	      isGlobal = _ref$isGlobal === undefined ? false : _ref$isGlobal,
	      _ref$ignoreSpaces = _ref.ignoreSpaces,
	      ignoreSpaces = _ref$ignoreSpaces === undefined ? false : _ref$ignoreSpaces;
	  var caseSensitive = modifiers.caseSensitive,
	      regexMatch = modifiers.regexMatch,
	      wholeWord = modifiers.wholeWord;


	  if (originalQuery == "") {
	    return new RegExp(originalQuery);
	  }

	  var query = originalQuery;
	  if (ignoreSpaces) {
	    query = ignoreWhiteSpace(query);
	  }

	  if (!regexMatch) {
	    query = escapeRegExp(query);
	  }

	  query = wholeMatch(query, wholeWord);
	  var flags = buildFlags(caseSensitive, isGlobal);

	  if (flags) {
	    return new RegExp(query, flags);
	  }

	  return new RegExp(query);
	}

	module.exports = buildQuery;

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	var toString = __webpack_require__(108);

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	    reHasRegExpChar = RegExp(reRegExpChar.source);

	/**
	 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escapeRegExp('[lodash](https://lodash.com/)');
	 * // => '\[lodash\]\(https://lodash\.com/\)'
	 */
	function escapeRegExp(string) {
	  string = toString(string);
	  return (string && reHasRegExpChar.test(string))
	    ? string.replace(reRegExpChar, '\\$&')
	    : string;
	}

	module.exports = escapeRegExp;


/***/ },
/* 260 */
/***/ function(module, exports) {

	"use strict";

	var sourceDocs = {};

	function getDocument(key) {
	  return sourceDocs[key];
	}

	function setDocument(key, doc) {
	  sourceDocs[key] = doc;
	}

	function removeDocument(key) {
	  delete sourceDocs[key];
	}

	function clearDocuments() {
	  sourceDocs = {};
	}

	module.exports = {
	  getDocument,
	  setDocument,
	  removeDocument,
	  clearDocuments
	};

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var buildQuery = __webpack_require__(258);
	var findIndex = __webpack_require__(262);

	/**
	 * @memberof utils/source-search
	 * @static
	 */
	function getSearchCursor(cm, query, pos, modifiers) {
	  var regexQuery = buildQuery(query, modifiers, { isGlobal: true });
	  return cm.getSearchCursor(regexQuery, pos);
	}

	/**
	 * @memberof utils/source-search
	 * @static
	 */
	function SearchState() {
	  this.posFrom = this.posTo = this.query = null;
	  this.overlay = null;
	  this.results = [];
	  this.matchIndex = -1;
	}

	/**
	 * @memberof utils/source-search
	 * @static
	 */
	function getSearchState(cm, query, modifiers) {
	  var state = cm.state.search || (cm.state.search = new SearchState());

	  // avoid generating a cursor and iterating over the results for an empty query
	  if (query) {
	    var cursor = getSearchCursor(cm, query, null, modifiers);

	    state.results = [];
	    while (cursor.findNext()) {
	      state.results.push(cursor.pos);
	    }
	  }

	  return state;
	}

	function isWhitespace(query) {
	  return !query.match(/\S/);
	}

	/**
	 * This returns a mode object used by CoeMirror's addOverlay function
	 * to parse and style tokens in the file.
	 * The mode object contains a tokenizer function (token) which takes
	 * a character stream as input, advances it a character at a time,
	 * and returns style(s) for that token. For more details see
	 * https://codemirror.net/doc/manual.html#modeapi
	 *
	 * Also the token function code is mainly based of work done
	 * by the chrome devtools team. Thanks guys! :)
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function searchOverlay(query, modifiers) {
	  var regexQuery = buildQuery(query, modifiers, {
	    ignoreSpaces: true
	  });

	  var matchLength = null;

	  return {
	    token: function (stream) {
	      if (stream.column() === 0) {
	        matchLength = null;
	      }
	      if (matchLength !== null) {
	        if (matchLength > 2) {
	          for (var i = 0; i < matchLength - 2; ++i) {
	            stream.next();
	          }
	          matchLength = 1;
	          return "highlight";
	        }
	        stream.next();
	        matchLength = null;
	        return "highlight highlight-end";
	      }

	      var match = stream.match(regexQuery, false);
	      if (match) {
	        stream.next();
	        var len = match[0].length;
	        if (len === 1) {
	          return "highlight highlight-full";
	        }
	        matchLength = len;
	        return "highlight highlight-start";
	      }
	      while (!stream.match(regexQuery, false) && stream.peek()) {
	        stream.next();
	      }
	    }
	  };
	}

	/**
	 * @memberof utils/source-search
	 * @static
	 */
	function updateOverlay(cm, state, query, modifiers) {
	  cm.removeOverlay(state.overlay);
	  state.overlay = searchOverlay(query, modifiers);
	  cm.addOverlay(state.overlay, { opaque: false });
	}

	function updateCursor(cm, state, keepSelection) {
	  state.posTo = cm.getCursor("anchor");
	  state.posFrom = cm.getCursor("head");

	  if (!keepSelection) {
	    state.posTo = { line: 0, ch: 0 };
	    state.posFrom = { line: 0, ch: 0 };
	  }
	}

	function getMatchIndex(count, currentIndex, rev) {
	  if (!rev) {
	    if (currentIndex == count - 1) {
	      return 0;
	    }

	    return currentIndex + 1;
	  }

	  if (currentIndex == 0) {
	    return count - 1;
	  }

	  return currentIndex - 1;
	}

	/**
	 * If there's a saved search, selects the next results.
	 * Otherwise, creates a new search and selects the first
	 * result.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function doSearch(ctx, rev, query, keepSelection, modifiers) {
	  var cm = ctx.cm;

	  var matchIndex = 0;
	  cm.operation(function () {
	    if (!query || isWhitespace(query)) {
	      return;
	    }

	    var state = getSearchState(cm, query, modifiers);
	    var newQuery = state.query != query;
	    state.query = query;

	    updateOverlay(cm, state, query, modifiers);
	    updateCursor(cm, state, keepSelection);

	    var nextMatch = searchNext(ctx, rev, query, newQuery, modifiers);
	    if (nextMatch) {
	      if (state.matchIndex === -1) {
	        matchIndex = findIndex(state.results, nextMatch);
	      } else {
	        var count = state.results.length;
	        var currentIndex = state.matchIndex;
	        matchIndex = getMatchIndex(count, currentIndex, rev);
	      }

	      state.matchIndex = matchIndex;
	    }
	  });

	  return matchIndex;
	}

	function getCursorPos(newQuery, rev, state) {
	  if (newQuery) {
	    return rev ? state.posFrom : state.posTo;
	  }

	  return rev ? state.posTo : state.posFrom;
	}

	/**
	 * Selects the next result of a saved search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function searchNext(ctx, rev, query, newQuery, modifiers) {
	  var cm = ctx.cm,
	      ed = ctx.ed;

	  var nextMatch = void 0;
	  cm.operation(function () {
	    var state = getSearchState(cm, query, modifiers);
	    var pos = getCursorPos(newQuery, rev, state);
	    var cursor = getSearchCursor(cm, state.query, pos, modifiers);

	    var location = rev ? { line: cm.lastLine(), ch: null } : { line: cm.firstLine(), ch: 0 };

	    if (!cursor.find(rev)) {
	      cursor = getSearchCursor(cm, state.query, location, modifiers);
	      if (!cursor.find(rev)) {
	        return;
	      }
	    }

	    // We don't want to jump the editor
	    // when we're selecting text
	    if (!cm.state.selectingText) {
	      ed.alignLine(cursor.from().line, "center");
	      cm.setSelection(cursor.from(), cursor.to());
	    }

	    nextMatch = { from: cursor.from(), to: cursor.to() };
	  });

	  return nextMatch;
	}

	/**
	 * Remove overlay.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function removeOverlay(ctx, query, modifiers) {
	  var state = getSearchState(ctx.cm, query, modifiers);
	  ctx.cm.removeOverlay(state.overlay);

	  var _ctx$cm$getCursor = ctx.cm.getCursor(),
	      line = _ctx$cm$getCursor.line,
	      ch = _ctx$cm$getCursor.ch;

	  ctx.cm.doc.setSelection({ line, ch }, { line, ch }, { scroll: false });
	}

	/**
	 * Clears the currently saved search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function clearSearch(cm, query, modifiers) {
	  var state = getSearchState(cm, query, modifiers);

	  state.results = [];
	  state.matchIndex = -1;

	  if (!state.query) {
	    return;
	  }
	  cm.removeOverlay(state.overlay);
	  state.query = null;
	}

	/**
	 * Starts a new search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function find(ctx, query, keepSelection, modifiers) {
	  clearSearch(ctx.cm, query, modifiers);
	  return doSearch(ctx, false, query, keepSelection, modifiers);
	}

	/**
	 * Finds the next item based on the currently saved search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function findNext(ctx, query, keepSelection, modifiers) {
	  return doSearch(ctx, false, query, keepSelection, modifiers);
	}

	/**
	 * Finds the previous item based on the currently saved search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function findPrev(ctx, query, keepSelection, modifiers) {
	  return doSearch(ctx, true, query, keepSelection, modifiers);
	}

	function clearIndex(ctx, query, modifiers) {
	  var state = getSearchState(ctx.cm, query, modifiers);
	  state.matchIndex = -1;
	}

	function countMatches(query, text, modifiers) {
	  var regexQuery = buildQuery(query, modifiers, {
	    isGlobal: true
	  });
	  var match = text.match(regexQuery);
	  return match ? match.length : 0;
	}

	module.exports = {
	  buildQuery,
	  clearIndex,
	  countMatches,
	  find,
	  findNext,
	  findPrev,
	  removeOverlay,
	  getMatchIndex
	};

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	var baseFindIndex = __webpack_require__(263),
	    baseIteratee = __webpack_require__(264),
	    toInteger = __webpack_require__(302);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * This method is like `_.find` except that it returns the index of the first
	 * element `predicate` returns truthy for instead of the element itself.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {number} Returns the index of the found element, else `-1`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': false },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': true }
	 * ];
	 *
	 * _.findIndex(users, function(o) { return o.user == 'barney'; });
	 * // => 0
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findIndex(users, { 'user': 'fred', 'active': false });
	 * // => 1
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findIndex(users, ['active', false]);
	 * // => 0
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findIndex(users, 'active');
	 * // => 2
	 */
	function findIndex(array, predicate, fromIndex) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return -1;
	  }
	  var index = fromIndex == null ? 0 : toInteger(fromIndex);
	  if (index < 0) {
	    index = nativeMax(length + index, 0);
	  }
	  return baseFindIndex(array, baseIteratee(predicate, 3), index);
	}

	module.exports = findIndex;


/***/ },
/* 263 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	module.exports = baseFindIndex;


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	var baseMatches = __webpack_require__(265),
	    baseMatchesProperty = __webpack_require__(294),
	    identity = __webpack_require__(298),
	    isArray = __webpack_require__(70),
	    property = __webpack_require__(299);

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	module.exports = baseIteratee;


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsMatch = __webpack_require__(266),
	    getMatchData = __webpack_require__(291),
	    matchesStrictComparable = __webpack_require__(293);

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	module.exports = baseMatches;


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(267),
	    baseIsEqual = __webpack_require__(273);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	module.exports = baseIsMatch;


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(93),
	    stackClear = __webpack_require__(268),
	    stackDelete = __webpack_require__(269),
	    stackGet = __webpack_require__(270),
	    stackHas = __webpack_require__(271),
	    stackSet = __webpack_require__(272);

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	module.exports = Stack;


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(93);

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	module.exports = stackClear;


/***/ },
/* 269 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	module.exports = stackDelete;


/***/ },
/* 270 */
/***/ function(module, exports) {

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	module.exports = stackGet;


/***/ },
/* 271 */
/***/ function(module, exports) {

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	module.exports = stackHas;


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(93),
	    Map = __webpack_require__(101),
	    MapCache = __webpack_require__(76);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	module.exports = stackSet;


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(274),
	    isObjectLike = __webpack_require__(14);

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	module.exports = baseIsEqual;


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(267),
	    equalArrays = __webpack_require__(275),
	    equalByTag = __webpack_require__(281),
	    equalObjects = __webpack_require__(284),
	    getTag = __webpack_require__(198),
	    isArray = __webpack_require__(70),
	    isBuffer = __webpack_require__(210),
	    isTypedArray = __webpack_require__(212);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	module.exports = baseIsEqualDeep;


/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(276),
	    arraySome = __webpack_require__(279),
	    cacheHas = __webpack_require__(280);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalArrays;


/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(76),
	    setCacheAdd = __webpack_require__(277),
	    setCacheHas = __webpack_require__(278);

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	module.exports = SetCache;


/***/ },
/* 277 */
/***/ function(module, exports) {

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	module.exports = setCacheAdd;


/***/ },
/* 278 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	module.exports = setCacheHas;


/***/ },
/* 279 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arraySome;


/***/ },
/* 280 */
/***/ function(module, exports) {

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	module.exports = cacheHas;


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(7),
	    Uint8Array = __webpack_require__(282),
	    eq = __webpack_require__(97),
	    equalArrays = __webpack_require__(275),
	    mapToArray = __webpack_require__(203),
	    setToArray = __webpack_require__(283);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	module.exports = equalByTag;


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(8);

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	module.exports = Uint8Array;


/***/ },
/* 283 */
/***/ function(module, exports) {

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	module.exports = setToArray;


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var getAllKeys = __webpack_require__(285);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalObjects;


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetAllKeys = __webpack_require__(286),
	    getSymbols = __webpack_require__(288),
	    keys = __webpack_require__(205);

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	module.exports = getAllKeys;


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(287),
	    isArray = __webpack_require__(70);

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	module.exports = baseGetAllKeys;


/***/ },
/* 287 */
/***/ function(module, exports) {

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	module.exports = arrayPush;


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	var arrayFilter = __webpack_require__(289),
	    stubArray = __webpack_require__(290);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	module.exports = getSymbols;


/***/ },
/* 289 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	module.exports = arrayFilter;


/***/ },
/* 290 */
/***/ function(module, exports) {

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	module.exports = stubArray;


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	var isStrictComparable = __webpack_require__(292),
	    keys = __webpack_require__(205);

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	module.exports = getMatchData;


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(84);

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	module.exports = isStrictComparable;


/***/ },
/* 293 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	module.exports = matchesStrictComparable;


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(273),
	    get = __webpack_require__(67),
	    hasIn = __webpack_require__(295),
	    isKey = __webpack_require__(71),
	    isStrictComparable = __webpack_require__(292),
	    matchesStrictComparable = __webpack_require__(293),
	    toKey = __webpack_require__(111);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}

	module.exports = baseMatchesProperty;


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	var baseHasIn = __webpack_require__(296),
	    hasPath = __webpack_require__(297);

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	module.exports = hasIn;


/***/ },
/* 296 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	module.exports = baseHasIn;


/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(69),
	    isArguments = __webpack_require__(208),
	    isArray = __webpack_require__(70),
	    isIndex = __webpack_require__(117),
	    isLength = __webpack_require__(214),
	    toKey = __webpack_require__(111);

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	module.exports = hasPath;


/***/ },
/* 298 */
/***/ function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(300),
	    basePropertyDeep = __webpack_require__(301),
	    isKey = __webpack_require__(71),
	    toKey = __webpack_require__(111);

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	module.exports = property;


/***/ },
/* 300 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	module.exports = baseProperty;


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(68);

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	module.exports = basePropertyDeep;


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	var toFinite = __webpack_require__(303);

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	module.exports = toInteger;


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	var toNumber = __webpack_require__(304);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	module.exports = toFinite;


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(84),
	    isSymbol = __webpack_require__(72);

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	module.exports = toNumber;


/***/ },
/* 305 */,
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	// This is CodeMirror (http://codemirror.net), a code editor
	// implemented in JavaScript on top of the browser's DOM.
	//
	// You can find some technical background for some of the code below
	// at http://marijnhaverbeke.nl/blog/#cm-internals .

	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global.CodeMirror = factory());
	}(this, (function () { 'use strict';

	// Kludges for bugs and behavior differences that can't be feature
	// detected are enabled based on userAgent etc sniffing.
	var userAgent = navigator.userAgent;
	var platform = navigator.platform;

	var gecko = /gecko\/\d/i.test(userAgent);
	var ie_upto10 = /MSIE \d/.test(userAgent);
	var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
	var edge = /Edge\/(\d+)/.exec(userAgent);
	var ie = ie_upto10 || ie_11up || edge;
	var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
	var webkit = !edge && /WebKit\//.test(userAgent);
	var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
	var chrome = !edge && /Chrome\//.test(userAgent);
	var presto = /Opera\//.test(userAgent);
	var safari = /Apple Computer/.test(navigator.vendor);
	var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
	var phantom = /PhantomJS/.test(userAgent);

	var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
	var android = /Android/.test(userAgent);
	// This is woefully incomplete. Suggestions for alternative methods welcome.
	var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
	var mac = ios || /Mac/.test(platform);
	var chromeOS = /\bCrOS\b/.test(userAgent);
	var windows = /win/i.test(platform);

	var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
	if (presto_version) { presto_version = Number(presto_version[1]); }
	if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
	// Some browsers use the wrong event properties to signal cmd/ctrl on OS X
	var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
	var captureRightClick = gecko || (ie && ie_version >= 9);

	function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

	var rmClass = function(node, cls) {
	  var current = node.className;
	  var match = classTest(cls).exec(current);
	  if (match) {
	    var after = current.slice(match.index + match[0].length);
	    node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
	  }
	};

	function removeChildren(e) {
	  for (var count = e.childNodes.length; count > 0; --count)
	    { e.removeChild(e.firstChild); }
	  return e
	}

	function removeChildrenAndAdd(parent, e) {
	  return removeChildren(parent).appendChild(e)
	}

	function elt(tag, content, className, style) {
	  var e = document.createElement(tag);
	  if (className) { e.className = className; }
	  if (style) { e.style.cssText = style; }
	  if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
	  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
	  return e
	}
	// wrapper for elt, which removes the elt from the accessibility tree
	function eltP(tag, content, className, style) {
	  var e = elt(tag, content, className, style);
	  e.setAttribute("role", "presentation");
	  return e
	}

	var range;
	if (document.createRange) { range = function(node, start, end, endNode) {
	  var r = document.createRange();
	  r.setEnd(endNode || node, end);
	  r.setStart(node, start);
	  return r
	}; }
	else { range = function(node, start, end) {
	  var r = document.body.createTextRange();
	  try { r.moveToElementText(node.parentNode); }
	  catch(e) { return r }
	  r.collapse(true);
	  r.moveEnd("character", end);
	  r.moveStart("character", start);
	  return r
	}; }

	function contains(parent, child) {
	  if (child.nodeType == 3) // Android browser always returns false when child is a textnode
	    { child = child.parentNode; }
	  if (parent.contains)
	    { return parent.contains(child) }
	  do {
	    if (child.nodeType == 11) { child = child.host; }
	    if (child == parent) { return true }
	  } while (child = child.parentNode)
	}

	function activeElt() {
	  // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
	  // IE < 10 will throw when accessed while the page is loading or in an iframe.
	  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
	  var activeElement;
	  try {
	    activeElement = document.activeElement;
	  } catch(e) {
	    activeElement = document.body || null;
	  }
	  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
	    { activeElement = activeElement.shadowRoot.activeElement; }
	  return activeElement
	}

	function addClass(node, cls) {
	  var current = node.className;
	  if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
	}
	function joinClasses(a, b) {
	  var as = a.split(" ");
	  for (var i = 0; i < as.length; i++)
	    { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
	  return b
	}

	var selectInput = function(node) { node.select(); };
	if (ios) // Mobile Safari apparently has a bug where select() is broken.
	  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
	else if (ie) // Suppress mysterious IE10 errors
	  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

	function bind(f) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  return function(){return f.apply(null, args)}
	}

	function copyObj(obj, target, overwrite) {
	  if (!target) { target = {}; }
	  for (var prop in obj)
	    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
	      { target[prop] = obj[prop]; } }
	  return target
	}

	// Counts the column offset in a string, taking tabs into account.
	// Used mostly to find indentation.
	function countColumn(string, end, tabSize, startIndex, startValue) {
	  if (end == null) {
	    end = string.search(/[^\s\u00a0]/);
	    if (end == -1) { end = string.length; }
	  }
	  for (var i = startIndex || 0, n = startValue || 0;;) {
	    var nextTab = string.indexOf("\t", i);
	    if (nextTab < 0 || nextTab >= end)
	      { return n + (end - i) }
	    n += nextTab - i;
	    n += tabSize - (n % tabSize);
	    i = nextTab + 1;
	  }
	}

	var Delayed = function() {this.id = null;};
	Delayed.prototype.set = function (ms, f) {
	  clearTimeout(this.id);
	  this.id = setTimeout(f, ms);
	};

	function indexOf(array, elt) {
	  for (var i = 0; i < array.length; ++i)
	    { if (array[i] == elt) { return i } }
	  return -1
	}

	// Number of pixels added to scroller and sizer to hide scrollbar
	var scrollerGap = 30;

	// Returned or thrown by various protocols to signal 'I'm not
	// handling this'.
	var Pass = {toString: function(){return "CodeMirror.Pass"}};

	// Reused option objects for setSelection & friends
	var sel_dontScroll = {scroll: false};
	var sel_mouse = {origin: "*mouse"};
	var sel_move = {origin: "+move"};

	// The inverse of countColumn -- find the offset that corresponds to
	// a particular column.
	function findColumn(string, goal, tabSize) {
	  for (var pos = 0, col = 0;;) {
	    var nextTab = string.indexOf("\t", pos);
	    if (nextTab == -1) { nextTab = string.length; }
	    var skipped = nextTab - pos;
	    if (nextTab == string.length || col + skipped >= goal)
	      { return pos + Math.min(skipped, goal - col) }
	    col += nextTab - pos;
	    col += tabSize - (col % tabSize);
	    pos = nextTab + 1;
	    if (col >= goal) { return pos }
	  }
	}

	var spaceStrs = [""];
	function spaceStr(n) {
	  while (spaceStrs.length <= n)
	    { spaceStrs.push(lst(spaceStrs) + " "); }
	  return spaceStrs[n]
	}

	function lst(arr) { return arr[arr.length-1] }

	function map(array, f) {
	  var out = [];
	  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
	  return out
	}

	function insertSorted(array, value, score) {
	  var pos = 0, priority = score(value);
	  while (pos < array.length && score(array[pos]) <= priority) { pos++; }
	  array.splice(pos, 0, value);
	}

	function nothing() {}

	function createObj(base, props) {
	  var inst;
	  if (Object.create) {
	    inst = Object.create(base);
	  } else {
	    nothing.prototype = base;
	    inst = new nothing();
	  }
	  if (props) { copyObj(props, inst); }
	  return inst
	}

	var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
	function isWordCharBasic(ch) {
	  return /\w/.test(ch) || ch > "\x80" &&
	    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
	}
	function isWordChar(ch, helper) {
	  if (!helper) { return isWordCharBasic(ch) }
	  if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
	  return helper.test(ch)
	}

	function isEmpty(obj) {
	  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
	  return true
	}

	// Extending unicode characters. A series of a non-extending char +
	// any number of extending chars is treated as a single unit as far
	// as editing and measuring is concerned. This is not fully correct,
	// since some scripts/fonts/browsers also treat other configurations
	// of code points as a group.
	var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
	function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

	// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
	function skipExtendingChars(str, pos, dir) {
	  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
	  return pos
	}

	// Returns the value from the range [`from`; `to`] that satisfies
	// `pred` and is closest to `from`. Assumes that at least `to` satisfies `pred`.
	function findFirst(pred, from, to) {
	  for (;;) {
	    if (Math.abs(from - to) <= 1) { return pred(from) ? from : to }
	    var mid = Math.floor((from + to) / 2);
	    if (pred(mid)) { to = mid; }
	    else { from = mid; }
	  }
	}

	// The display handles the DOM integration, both for input reading
	// and content drawing. It holds references to DOM nodes and
	// display-related state.

	function Display(place, doc, input) {
	  var d = this;
	  this.input = input;

	  // Covers bottom-right square when both scrollbars are present.
	  d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
	  d.scrollbarFiller.setAttribute("cm-not-content", "true");
	  // Covers bottom of gutter when coverGutterNextToScrollbar is on
	  // and h scrollbar is present.
	  d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
	  d.gutterFiller.setAttribute("cm-not-content", "true");
	  // Will contain the actual code, positioned to cover the viewport.
	  d.lineDiv = eltP("div", null, "CodeMirror-code");
	  // Elements are added to these to represent selection and cursors.
	  d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
	  d.cursorDiv = elt("div", null, "CodeMirror-cursors");
	  // A visibility: hidden element used to find the size of things.
	  d.measure = elt("div", null, "CodeMirror-measure");
	  // When lines outside of the viewport are measured, they are drawn in this.
	  d.lineMeasure = elt("div", null, "CodeMirror-measure");
	  // Wraps everything that needs to exist inside the vertically-padded coordinate system
	  d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
	                    null, "position: relative; outline: none");
	  var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
	  // Moved around its parent to cover visible view.
	  d.mover = elt("div", [lines], null, "position: relative");
	  // Set to the height of the document, allowing scrolling.
	  d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
	  d.sizerWidth = null;
	  // Behavior of elts with overflow: auto and padding is
	  // inconsistent across browsers. This is used to ensure the
	  // scrollable area is big enough.
	  d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
	  // Will contain the gutters, if any.
	  d.gutters = elt("div", null, "CodeMirror-gutters");
	  d.lineGutter = null;
	  // Actual scrollable element.
	  d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
	  d.scroller.setAttribute("tabIndex", "-1");
	  // The element in which the editor lives.
	  d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

	  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
	  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
	  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

	  if (place) {
	    if (place.appendChild) { place.appendChild(d.wrapper); }
	    else { place(d.wrapper); }
	  }

	  // Current rendered range (may be bigger than the view window).
	  d.viewFrom = d.viewTo = doc.first;
	  d.reportedViewFrom = d.reportedViewTo = doc.first;
	  // Information about the rendered lines.
	  d.view = [];
	  d.renderedView = null;
	  // Holds info about a single rendered line when it was rendered
	  // for measurement, while not in view.
	  d.externalMeasured = null;
	  // Empty space (in pixels) above the view
	  d.viewOffset = 0;
	  d.lastWrapHeight = d.lastWrapWidth = 0;
	  d.updateLineNumbers = null;

	  d.nativeBarWidth = d.barHeight = d.barWidth = 0;
	  d.scrollbarsClipped = false;

	  // Used to only resize the line number gutter when necessary (when
	  // the amount of lines crosses a boundary that makes its width change)
	  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
	  // Set to true when a non-horizontal-scrolling line widget is
	  // added. As an optimization, line widget aligning is skipped when
	  // this is false.
	  d.alignWidgets = false;

	  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

	  // Tracks the maximum line length so that the horizontal scrollbar
	  // can be kept static when scrolling.
	  d.maxLine = null;
	  d.maxLineLength = 0;
	  d.maxLineChanged = false;

	  // Used for measuring wheel scrolling granularity
	  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

	  // True when shift is held down.
	  d.shift = false;

	  // Used to track whether anything happened since the context menu
	  // was opened.
	  d.selForContextMenu = null;

	  d.activeTouch = null;

	  input.init(d);
	}

	// Find the line object corresponding to the given line number.
	function getLine(doc, n) {
	  n -= doc.first;
	  if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
	  var chunk = doc;
	  while (!chunk.lines) {
	    for (var i = 0;; ++i) {
	      var child = chunk.children[i], sz = child.chunkSize();
	      if (n < sz) { chunk = child; break }
	      n -= sz;
	    }
	  }
	  return chunk.lines[n]
	}

	// Get the part of a document between two positions, as an array of
	// strings.
	function getBetween(doc, start, end) {
	  var out = [], n = start.line;
	  doc.iter(start.line, end.line + 1, function (line) {
	    var text = line.text;
	    if (n == end.line) { text = text.slice(0, end.ch); }
	    if (n == start.line) { text = text.slice(start.ch); }
	    out.push(text);
	    ++n;
	  });
	  return out
	}
	// Get the lines between from and to, as array of strings.
	function getLines(doc, from, to) {
	  var out = [];
	  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
	  return out
	}

	// Update the height of a line, propagating the height change
	// upwards to parent nodes.
	function updateLineHeight(line, height) {
	  var diff = height - line.height;
	  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
	}

	// Given a line object, find its line number by walking up through
	// its parent links.
	function lineNo(line) {
	  if (line.parent == null) { return null }
	  var cur = line.parent, no = indexOf(cur.lines, line);
	  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
	    for (var i = 0;; ++i) {
	      if (chunk.children[i] == cur) { break }
	      no += chunk.children[i].chunkSize();
	    }
	  }
	  return no + cur.first
	}

	// Find the line at the given vertical position, using the height
	// information in the document tree.
	function lineAtHeight(chunk, h) {
	  var n = chunk.first;
	  outer: do {
	    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
	      var child = chunk.children[i$1], ch = child.height;
	      if (h < ch) { chunk = child; continue outer }
	      h -= ch;
	      n += child.chunkSize();
	    }
	    return n
	  } while (!chunk.lines)
	  var i = 0;
	  for (; i < chunk.lines.length; ++i) {
	    var line = chunk.lines[i], lh = line.height;
	    if (h < lh) { break }
	    h -= lh;
	  }
	  return n + i
	}

	function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

	function lineNumberFor(options, i) {
	  return String(options.lineNumberFormatter(i + options.firstLineNumber))
	}

	// A Pos instance represents a position within the text.
	function Pos(line, ch, sticky) {
	  if ( sticky === void 0 ) sticky = null;

	  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
	  this.line = line;
	  this.ch = ch;
	  this.sticky = sticky;
	}

	// Compare two positions, return 0 if they are the same, a negative
	// number when a is less, and a positive number otherwise.
	function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

	function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

	function copyPos(x) {return Pos(x.line, x.ch)}
	function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
	function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

	// Most of the external API clips given positions to make sure they
	// actually exist within the document.
	function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
	function clipPos(doc, pos) {
	  if (pos.line < doc.first) { return Pos(doc.first, 0) }
	  var last = doc.first + doc.size - 1;
	  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
	  return clipToLen(pos, getLine(doc, pos.line).text.length)
	}
	function clipToLen(pos, linelen) {
	  var ch = pos.ch;
	  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
	  else if (ch < 0) { return Pos(pos.line, 0) }
	  else { return pos }
	}
	function clipPosArray(doc, array) {
	  var out = [];
	  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
	  return out
	}

	// Optimize some code when these features are not used.
	var sawReadOnlySpans = false;
	var sawCollapsedSpans = false;

	function seeReadOnlySpans() {
	  sawReadOnlySpans = true;
	}

	function seeCollapsedSpans() {
	  sawCollapsedSpans = true;
	}

	// TEXTMARKER SPANS

	function MarkedSpan(marker, from, to) {
	  this.marker = marker;
	  this.from = from; this.to = to;
	}

	// Search an array of spans for a span matching the given marker.
	function getMarkedSpanFor(spans, marker) {
	  if (spans) { for (var i = 0; i < spans.length; ++i) {
	    var span = spans[i];
	    if (span.marker == marker) { return span }
	  } }
	}
	// Remove a span from an array, returning undefined if no spans are
	// left (we don't store arrays for lines without spans).
	function removeMarkedSpan(spans, span) {
	  var r;
	  for (var i = 0; i < spans.length; ++i)
	    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
	  return r
	}
	// Add a span to a line.
	function addMarkedSpan(line, span) {
	  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
	  span.marker.attachLine(line);
	}

	// Used for the algorithm that adjusts markers for a change in the
	// document. These functions cut an array of spans at a given
	// character position, returning an array of remaining chunks (or
	// undefined if nothing remains).
	function markedSpansBefore(old, startCh, isInsert) {
	  var nw;
	  if (old) { for (var i = 0; i < old.length; ++i) {
	    var span = old[i], marker = span.marker;
	    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
	    if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
	      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
	    }
	  } }
	  return nw
	}
	function markedSpansAfter(old, endCh, isInsert) {
	  var nw;
	  if (old) { for (var i = 0; i < old.length; ++i) {
	    var span = old[i], marker = span.marker;
	    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
	    if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
	      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
	                                            span.to == null ? null : span.to - endCh));
	    }
	  } }
	  return nw
	}

	// Given a change object, compute the new set of marker spans that
	// cover the line in which the change took place. Removes spans
	// entirely within the change, reconnects spans belonging to the
	// same marker that appear on both sides of the change, and cuts off
	// spans partially within the change. Returns an array of span
	// arrays with one element for each line in (after) the change.
	function stretchSpansOverChange(doc, change) {
	  if (change.full) { return null }
	  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
	  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
	  if (!oldFirst && !oldLast) { return null }

	  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
	  // Get the spans that 'stick out' on both sides
	  var first = markedSpansBefore(oldFirst, startCh, isInsert);
	  var last = markedSpansAfter(oldLast, endCh, isInsert);

	  // Next, merge those two ends
	  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
	  if (first) {
	    // Fix up .to properties of first
	    for (var i = 0; i < first.length; ++i) {
	      var span = first[i];
	      if (span.to == null) {
	        var found = getMarkedSpanFor(last, span.marker);
	        if (!found) { span.to = startCh; }
	        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
	      }
	    }
	  }
	  if (last) {
	    // Fix up .from in last (or move them into first in case of sameLine)
	    for (var i$1 = 0; i$1 < last.length; ++i$1) {
	      var span$1 = last[i$1];
	      if (span$1.to != null) { span$1.to += offset; }
	      if (span$1.from == null) {
	        var found$1 = getMarkedSpanFor(first, span$1.marker);
	        if (!found$1) {
	          span$1.from = offset;
	          if (sameLine) { (first || (first = [])).push(span$1); }
	        }
	      } else {
	        span$1.from += offset;
	        if (sameLine) { (first || (first = [])).push(span$1); }
	      }
	    }
	  }
	  // Make sure we didn't create any zero-length spans
	  if (first) { first = clearEmptySpans(first); }
	  if (last && last != first) { last = clearEmptySpans(last); }

	  var newMarkers = [first];
	  if (!sameLine) {
	    // Fill gap with whole-line-spans
	    var gap = change.text.length - 2, gapMarkers;
	    if (gap > 0 && first)
	      { for (var i$2 = 0; i$2 < first.length; ++i$2)
	        { if (first[i$2].to == null)
	          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
	    for (var i$3 = 0; i$3 < gap; ++i$3)
	      { newMarkers.push(gapMarkers); }
	    newMarkers.push(last);
	  }
	  return newMarkers
	}

	// Remove spans that are empty and don't have a clearWhenEmpty
	// option of false.
	function clearEmptySpans(spans) {
	  for (var i = 0; i < spans.length; ++i) {
	    var span = spans[i];
	    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
	      { spans.splice(i--, 1); }
	  }
	  if (!spans.length) { return null }
	  return spans
	}

	// Used to 'clip' out readOnly ranges when making a change.
	function removeReadOnlyRanges(doc, from, to) {
	  var markers = null;
	  doc.iter(from.line, to.line + 1, function (line) {
	    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	      var mark = line.markedSpans[i].marker;
	      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
	        { (markers || (markers = [])).push(mark); }
	    } }
	  });
	  if (!markers) { return null }
	  var parts = [{from: from, to: to}];
	  for (var i = 0; i < markers.length; ++i) {
	    var mk = markers[i], m = mk.find(0);
	    for (var j = 0; j < parts.length; ++j) {
	      var p = parts[j];
	      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
	      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
	      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
	        { newParts.push({from: p.from, to: m.from}); }
	      if (dto > 0 || !mk.inclusiveRight && !dto)
	        { newParts.push({from: m.to, to: p.to}); }
	      parts.splice.apply(parts, newParts);
	      j += newParts.length - 3;
	    }
	  }
	  return parts
	}

	// Connect or disconnect spans from a line.
	function detachMarkedSpans(line) {
	  var spans = line.markedSpans;
	  if (!spans) { return }
	  for (var i = 0; i < spans.length; ++i)
	    { spans[i].marker.detachLine(line); }
	  line.markedSpans = null;
	}
	function attachMarkedSpans(line, spans) {
	  if (!spans) { return }
	  for (var i = 0; i < spans.length; ++i)
	    { spans[i].marker.attachLine(line); }
	  line.markedSpans = spans;
	}

	// Helpers used when computing which overlapping collapsed span
	// counts as the larger one.
	function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
	function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

	// Returns a number indicating which of two overlapping collapsed
	// spans is larger (and thus includes the other). Falls back to
	// comparing ids when the spans cover exactly the same range.
	function compareCollapsedMarkers(a, b) {
	  var lenDiff = a.lines.length - b.lines.length;
	  if (lenDiff != 0) { return lenDiff }
	  var aPos = a.find(), bPos = b.find();
	  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
	  if (fromCmp) { return -fromCmp }
	  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
	  if (toCmp) { return toCmp }
	  return b.id - a.id
	}

	// Find out whether a line ends or starts in a collapsed span. If
	// so, return the marker for that span.
	function collapsedSpanAtSide(line, start) {
	  var sps = sawCollapsedSpans && line.markedSpans, found;
	  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	    sp = sps[i];
	    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
	        (!found || compareCollapsedMarkers(found, sp.marker) < 0))
	      { found = sp.marker; }
	  } }
	  return found
	}
	function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
	function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

	// Test whether there exists a collapsed span that partially
	// overlaps (covers the start or end, but not both) of a new span.
	// Such overlap is not allowed.
	function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
	  var line = getLine(doc, lineNo$$1);
	  var sps = sawCollapsedSpans && line.markedSpans;
	  if (sps) { for (var i = 0; i < sps.length; ++i) {
	    var sp = sps[i];
	    if (!sp.marker.collapsed) { continue }
	    var found = sp.marker.find(0);
	    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
	    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
	    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
	    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
	        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
	      { return true }
	  } }
	}

	// A visual line is a line as drawn on the screen. Folding, for
	// example, can cause multiple logical lines to appear on the same
	// visual line. This finds the start of the visual line that the
	// given line is part of (usually that is the line itself).
	function visualLine(line) {
	  var merged;
	  while (merged = collapsedSpanAtStart(line))
	    { line = merged.find(-1, true).line; }
	  return line
	}

	function visualLineEnd(line) {
	  var merged;
	  while (merged = collapsedSpanAtEnd(line))
	    { line = merged.find(1, true).line; }
	  return line
	}

	// Returns an array of logical lines that continue the visual line
	// started by the argument, or undefined if there are no such lines.
	function visualLineContinued(line) {
	  var merged, lines;
	  while (merged = collapsedSpanAtEnd(line)) {
	    line = merged.find(1, true).line
	    ;(lines || (lines = [])).push(line);
	  }
	  return lines
	}

	// Get the line number of the start of the visual line that the
	// given line number is part of.
	function visualLineNo(doc, lineN) {
	  var line = getLine(doc, lineN), vis = visualLine(line);
	  if (line == vis) { return lineN }
	  return lineNo(vis)
	}

	// Get the line number of the start of the next visual line after
	// the given line.
	function visualLineEndNo(doc, lineN) {
	  if (lineN > doc.lastLine()) { return lineN }
	  var line = getLine(doc, lineN), merged;
	  if (!lineIsHidden(doc, line)) { return lineN }
	  while (merged = collapsedSpanAtEnd(line))
	    { line = merged.find(1, true).line; }
	  return lineNo(line) + 1
	}

	// Compute whether a line is hidden. Lines count as hidden when they
	// are part of a visual line that starts with another line, or when
	// they are entirely covered by collapsed, non-widget span.
	function lineIsHidden(doc, line) {
	  var sps = sawCollapsedSpans && line.markedSpans;
	  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	    sp = sps[i];
	    if (!sp.marker.collapsed) { continue }
	    if (sp.from == null) { return true }
	    if (sp.marker.widgetNode) { continue }
	    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
	      { return true }
	  } }
	}
	function lineIsHiddenInner(doc, line, span) {
	  if (span.to == null) {
	    var end = span.marker.find(1, true);
	    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
	  }
	  if (span.marker.inclusiveRight && span.to == line.text.length)
	    { return true }
	  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
	    sp = line.markedSpans[i];
	    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
	        (sp.to == null || sp.to != span.from) &&
	        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
	        lineIsHiddenInner(doc, line, sp)) { return true }
	  }
	}

	// Find the height above the given line.
	function heightAtLine(lineObj) {
	  lineObj = visualLine(lineObj);

	  var h = 0, chunk = lineObj.parent;
	  for (var i = 0; i < chunk.lines.length; ++i) {
	    var line = chunk.lines[i];
	    if (line == lineObj) { break }
	    else { h += line.height; }
	  }
	  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
	    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
	      var cur = p.children[i$1];
	      if (cur == chunk) { break }
	      else { h += cur.height; }
	    }
	  }
	  return h
	}

	// Compute the character length of a line, taking into account
	// collapsed ranges (see markText) that might hide parts, and join
	// other lines onto it.
	function lineLength(line) {
	  if (line.height == 0) { return 0 }
	  var len = line.text.length, merged, cur = line;
	  while (merged = collapsedSpanAtStart(cur)) {
	    var found = merged.find(0, true);
	    cur = found.from.line;
	    len += found.from.ch - found.to.ch;
	  }
	  cur = line;
	  while (merged = collapsedSpanAtEnd(cur)) {
	    var found$1 = merged.find(0, true);
	    len -= cur.text.length - found$1.from.ch;
	    cur = found$1.to.line;
	    len += cur.text.length - found$1.to.ch;
	  }
	  return len
	}

	// Find the longest line in the document.
	function findMaxLine(cm) {
	  var d = cm.display, doc = cm.doc;
	  d.maxLine = getLine(doc, doc.first);
	  d.maxLineLength = lineLength(d.maxLine);
	  d.maxLineChanged = true;
	  doc.iter(function (line) {
	    var len = lineLength(line);
	    if (len > d.maxLineLength) {
	      d.maxLineLength = len;
	      d.maxLine = line;
	    }
	  });
	}

	// BIDI HELPERS

	function iterateBidiSections(order, from, to, f) {
	  if (!order) { return f(from, to, "ltr") }
	  var found = false;
	  for (var i = 0; i < order.length; ++i) {
	    var part = order[i];
	    if (part.from < to && part.to > from || from == to && part.to == from) {
	      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
	      found = true;
	    }
	  }
	  if (!found) { f(from, to, "ltr"); }
	}

	var bidiOther = null;
	function getBidiPartAt(order, ch, sticky) {
	  var found;
	  bidiOther = null;
	  for (var i = 0; i < order.length; ++i) {
	    var cur = order[i];
	    if (cur.from < ch && cur.to > ch) { return i }
	    if (cur.to == ch) {
	      if (cur.from != cur.to && sticky == "before") { found = i; }
	      else { bidiOther = i; }
	    }
	    if (cur.from == ch) {
	      if (cur.from != cur.to && sticky != "before") { found = i; }
	      else { bidiOther = i; }
	    }
	  }
	  return found != null ? found : bidiOther
	}

	// Bidirectional ordering algorithm
	// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
	// that this (partially) implements.

	// One-char codes used for character types:
	// L (L):   Left-to-Right
	// R (R):   Right-to-Left
	// r (AL):  Right-to-Left Arabic
	// 1 (EN):  European Number
	// + (ES):  European Number Separator
	// % (ET):  European Number Terminator
	// n (AN):  Arabic Number
	// , (CS):  Common Number Separator
	// m (NSM): Non-Spacing Mark
	// b (BN):  Boundary Neutral
	// s (B):   Paragraph Separator
	// t (S):   Segment Separator
	// w (WS):  Whitespace
	// N (ON):  Other Neutrals

	// Returns null if characters are ordered as they appear
	// (left-to-right), or an array of sections ({from, to, level}
	// objects) in the order in which they occur visually.
	var bidiOrdering = (function() {
	  // Character types for codepoints 0 to 0xff
	  var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
	  // Character types for codepoints 0x600 to 0x6f9
	  var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
	  function charType(code) {
	    if (code <= 0xf7) { return lowTypes.charAt(code) }
	    else if (0x590 <= code && code <= 0x5f4) { return "R" }
	    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
	    else if (0x6ee <= code && code <= 0x8ac) { return "r" }
	    else if (0x2000 <= code && code <= 0x200b) { return "w" }
	    else if (code == 0x200c) { return "b" }
	    else { return "L" }
	  }

	  var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
	  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

	  function BidiSpan(level, from, to) {
	    this.level = level;
	    this.from = from; this.to = to;
	  }

	  return function(str, direction) {
	    var outerType = direction == "ltr" ? "L" : "R";

	    if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
	    var len = str.length, types = [];
	    for (var i = 0; i < len; ++i)
	      { types.push(charType(str.charCodeAt(i))); }

	    // W1. Examine each non-spacing mark (NSM) in the level run, and
	    // change the type of the NSM to the type of the previous
	    // character. If the NSM is at the start of the level run, it will
	    // get the type of sor.
	    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
	      var type = types[i$1];
	      if (type == "m") { types[i$1] = prev; }
	      else { prev = type; }
	    }

	    // W2. Search backwards from each instance of a European number
	    // until the first strong type (R, L, AL, or sor) is found. If an
	    // AL is found, change the type of the European number to Arabic
	    // number.
	    // W3. Change all ALs to R.
	    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
	      var type$1 = types[i$2];
	      if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
	      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
	    }

	    // W4. A single European separator between two European numbers
	    // changes to a European number. A single common separator between
	    // two numbers of the same type changes to that type.
	    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
	      var type$2 = types[i$3];
	      if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
	      else if (type$2 == "," && prev$1 == types[i$3+1] &&
	               (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
	      prev$1 = type$2;
	    }

	    // W5. A sequence of European terminators adjacent to European
	    // numbers changes to all European numbers.
	    // W6. Otherwise, separators and terminators change to Other
	    // Neutral.
	    for (var i$4 = 0; i$4 < len; ++i$4) {
	      var type$3 = types[i$4];
	      if (type$3 == ",") { types[i$4] = "N"; }
	      else if (type$3 == "%") {
	        var end = (void 0);
	        for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
	        var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
	        for (var j = i$4; j < end; ++j) { types[j] = replace; }
	        i$4 = end - 1;
	      }
	    }

	    // W7. Search backwards from each instance of a European number
	    // until the first strong type (R, L, or sor) is found. If an L is
	    // found, then change the type of the European number to L.
	    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
	      var type$4 = types[i$5];
	      if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
	      else if (isStrong.test(type$4)) { cur$1 = type$4; }
	    }

	    // N1. A sequence of neutrals takes the direction of the
	    // surrounding strong text if the text on both sides has the same
	    // direction. European and Arabic numbers act as if they were R in
	    // terms of their influence on neutrals. Start-of-level-run (sor)
	    // and end-of-level-run (eor) are used at level run boundaries.
	    // N2. Any remaining neutrals take the embedding direction.
	    for (var i$6 = 0; i$6 < len; ++i$6) {
	      if (isNeutral.test(types[i$6])) {
	        var end$1 = (void 0);
	        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
	        var before = (i$6 ? types[i$6-1] : outerType) == "L";
	        var after = (end$1 < len ? types[end$1] : outerType) == "L";
	        var replace$1 = before == after ? (before ? "L" : "R") : outerType;
	        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
	        i$6 = end$1 - 1;
	      }
	    }

	    // Here we depart from the documented algorithm, in order to avoid
	    // building up an actual levels array. Since there are only three
	    // levels (0, 1, 2) in an implementation that doesn't take
	    // explicit embedding into account, we can build up the order on
	    // the fly, without following the level-based algorithm.
	    var order = [], m;
	    for (var i$7 = 0; i$7 < len;) {
	      if (countsAsLeft.test(types[i$7])) {
	        var start = i$7;
	        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
	        order.push(new BidiSpan(0, start, i$7));
	      } else {
	        var pos = i$7, at = order.length;
	        for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
	        for (var j$2 = pos; j$2 < i$7;) {
	          if (countsAsNum.test(types[j$2])) {
	            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
	            var nstart = j$2;
	            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
	            order.splice(at, 0, new BidiSpan(2, nstart, j$2));
	            pos = j$2;
	          } else { ++j$2; }
	        }
	        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
	      }
	    }
	    if (order[0].level == 1 && (m = str.match(/^\s+/))) {
	      order[0].from = m[0].length;
	      order.unshift(new BidiSpan(0, 0, m[0].length));
	    }
	    if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
	      lst(order).to -= m[0].length;
	      order.push(new BidiSpan(0, len - m[0].length, len));
	    }

	    return direction == "rtl" ? order.reverse() : order
	  }
	})();

	// Get the bidi ordering for the given line (and cache it). Returns
	// false for lines that are fully left-to-right, and an array of
	// BidiSpan objects otherwise.
	function getOrder(line, direction) {
	  var order = line.order;
	  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
	  return order
	}

	function moveCharLogically(line, ch, dir) {
	  var target = skipExtendingChars(line.text, ch + dir, dir);
	  return target < 0 || target > line.text.length ? null : target
	}

	function moveLogically(line, start, dir) {
	  var ch = moveCharLogically(line, start.ch, dir);
	  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
	}

	function endOfLine(visually, cm, lineObj, lineNo, dir) {
	  if (visually) {
	    var order = getOrder(lineObj, cm.doc.direction);
	    if (order) {
	      var part = dir < 0 ? lst(order) : order[0];
	      var moveInStorageOrder = (dir < 0) == (part.level == 1);
	      var sticky = moveInStorageOrder ? "after" : "before";
	      var ch;
	      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
	      // it could be that the last bidi part is not on the last visual line,
	      // since visual lines contain content order-consecutive chunks.
	      // Thus, in rtl, we are looking for the first (content-order) character
	      // in the rtl chunk that is on the last line (that is, the same line
	      // as the last (content-order) character).
	      if (part.level > 0) {
	        var prep = prepareMeasureForLine(cm, lineObj);
	        ch = dir < 0 ? lineObj.text.length - 1 : 0;
	        var targetTop = measureCharPrepared(cm, prep, ch).top;
	        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
	        if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1, true); }
	      } else { ch = dir < 0 ? part.to : part.from; }
	      return new Pos(lineNo, ch, sticky)
	    }
	  }
	  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
	}

	function moveVisually(cm, line, start, dir) {
	  var bidi = getOrder(line, cm.doc.direction);
	  if (!bidi) { return moveLogically(line, start, dir) }
	  if (start.ch >= line.text.length) {
	    start.ch = line.text.length;
	    start.sticky = "before";
	  } else if (start.ch <= 0) {
	    start.ch = 0;
	    start.sticky = "after";
	  }
	  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
	  if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
	    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
	    // nothing interesting happens.
	    return moveLogically(line, start, dir)
	  }

	  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
	  var prep;
	  var getWrappedLineExtent = function (ch) {
	    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
	    prep = prep || prepareMeasureForLine(cm, line);
	    return wrappedLineExtentChar(cm, line, prep, ch)
	  };
	  var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

	  if (cm.doc.direction == "rtl" || part.level == 1) {
	    var moveInStorageOrder = (part.level == 1) == (dir < 0);
	    var ch = mv(start, moveInStorageOrder ? 1 : -1);
	    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
	      // Case 2: We move within an rtl part or in an rtl editor on the same visual line
	      var sticky = moveInStorageOrder ? "before" : "after";
	      return new Pos(start.line, ch, sticky)
	    }
	  }

	  // Case 3: Could not move within this bidi part in this visual line, so leave
	  // the current bidi part

	  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
	    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
	      ? new Pos(start.line, mv(ch, 1), "before")
	      : new Pos(start.line, ch, "after"); };

	    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
	      var part = bidi[partPos];
	      var moveInStorageOrder = (dir > 0) == (part.level != 1);
	      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
	      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
	      ch = moveInStorageOrder ? part.from : mv(part.to, -1);
	      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
	    }
	  };

	  // Case 3a: Look for other bidi parts on the same visual line
	  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
	  if (res) { return res }

	  // Case 3b: Look for other bidi parts on the next visual line
	  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
	  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
	    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
	    if (res) { return res }
	  }

	  // Case 4: Nowhere to move
	  return null
	}

	// EVENT HANDLING

	// Lightweight event framework. on/off also work on DOM nodes,
	// registering native DOM handlers.

	var noHandlers = [];

	var on = function(emitter, type, f) {
	  if (emitter.addEventListener) {
	    emitter.addEventListener(type, f, false);
	  } else if (emitter.attachEvent) {
	    emitter.attachEvent("on" + type, f);
	  } else {
	    var map$$1 = emitter._handlers || (emitter._handlers = {});
	    map$$1[type] = (map$$1[type] || noHandlers).concat(f);
	  }
	};

	function getHandlers(emitter, type) {
	  return emitter._handlers && emitter._handlers[type] || noHandlers
	}

	function off(emitter, type, f) {
	  if (emitter.removeEventListener) {
	    emitter.removeEventListener(type, f, false);
	  } else if (emitter.detachEvent) {
	    emitter.detachEvent("on" + type, f);
	  } else {
	    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
	    if (arr) {
	      var index = indexOf(arr, f);
	      if (index > -1)
	        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
	    }
	  }
	}

	function signal(emitter, type /*, values...*/) {
	  var handlers = getHandlers(emitter, type);
	  if (!handlers.length) { return }
	  var args = Array.prototype.slice.call(arguments, 2);
	  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
	}

	// The DOM events that CodeMirror handles can be overridden by
	// registering a (non-DOM) handler on the editor for the event name,
	// and preventDefault-ing the event in that handler.
	function signalDOMEvent(cm, e, override) {
	  if (typeof e == "string")
	    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
	  signal(cm, override || e.type, cm, e);
	  return e_defaultPrevented(e) || e.codemirrorIgnore
	}

	function signalCursorActivity(cm) {
	  var arr = cm._handlers && cm._handlers.cursorActivity;
	  if (!arr) { return }
	  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
	  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
	    { set.push(arr[i]); } }
	}

	function hasHandler(emitter, type) {
	  return getHandlers(emitter, type).length > 0
	}

	// Add on and off methods to a constructor's prototype, to make
	// registering events on such objects more convenient.
	function eventMixin(ctor) {
	  ctor.prototype.on = function(type, f) {on(this, type, f);};
	  ctor.prototype.off = function(type, f) {off(this, type, f);};
	}

	// Due to the fact that we still support jurassic IE versions, some
	// compatibility wrappers are needed.

	function e_preventDefault(e) {
	  if (e.preventDefault) { e.preventDefault(); }
	  else { e.returnValue = false; }
	}
	function e_stopPropagation(e) {
	  if (e.stopPropagation) { e.stopPropagation(); }
	  else { e.cancelBubble = true; }
	}
	function e_defaultPrevented(e) {
	  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
	}
	function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

	function e_target(e) {return e.target || e.srcElement}
	function e_button(e) {
	  var b = e.which;
	  if (b == null) {
	    if (e.button & 1) { b = 1; }
	    else if (e.button & 2) { b = 3; }
	    else if (e.button & 4) { b = 2; }
	  }
	  if (mac && e.ctrlKey && b == 1) { b = 3; }
	  return b
	}

	// Detect drag-and-drop
	var dragAndDrop = function() {
	  // There is *some* kind of drag-and-drop support in IE6-8, but I
	  // couldn't get it to work yet.
	  if (ie && ie_version < 9) { return false }
	  var div = elt('div');
	  return "draggable" in div || "dragDrop" in div
	}();

	var zwspSupported;
	function zeroWidthElement(measure) {
	  if (zwspSupported == null) {
	    var test = elt("span", "\u200b");
	    removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
	    if (measure.firstChild.offsetHeight != 0)
	      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
	  }
	  var node = zwspSupported ? elt("span", "\u200b") :
	    elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
	  node.setAttribute("cm-text", "");
	  return node
	}

	// Feature-detect IE's crummy client rect reporting for bidi text
	var badBidiRects;
	function hasBadBidiRects(measure) {
	  if (badBidiRects != null) { return badBidiRects }
	  var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
	  var r0 = range(txt, 0, 1).getBoundingClientRect();
	  var r1 = range(txt, 1, 2).getBoundingClientRect();
	  removeChildren(measure);
	  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
	  return badBidiRects = (r1.right - r0.right < 3)
	}

	// See if "".split is the broken IE version, if so, provide an
	// alternative way to split lines.
	var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
	  var pos = 0, result = [], l = string.length;
	  while (pos <= l) {
	    var nl = string.indexOf("\n", pos);
	    if (nl == -1) { nl = string.length; }
	    var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
	    var rt = line.indexOf("\r");
	    if (rt != -1) {
	      result.push(line.slice(0, rt));
	      pos += rt + 1;
	    } else {
	      result.push(line);
	      pos = nl + 1;
	    }
	  }
	  return result
	} : function (string) { return string.split(/\r\n?|\n/); };

	var hasSelection = window.getSelection ? function (te) {
	  try { return te.selectionStart != te.selectionEnd }
	  catch(e) { return false }
	} : function (te) {
	  var range$$1;
	  try {range$$1 = te.ownerDocument.selection.createRange();}
	  catch(e) {}
	  if (!range$$1 || range$$1.parentElement() != te) { return false }
	  return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
	};

	var hasCopyEvent = (function () {
	  var e = elt("div");
	  if ("oncopy" in e) { return true }
	  e.setAttribute("oncopy", "return;");
	  return typeof e.oncopy == "function"
	})();

	var badZoomedRects = null;
	function hasBadZoomedRects(measure) {
	  if (badZoomedRects != null) { return badZoomedRects }
	  var node = removeChildrenAndAdd(measure, elt("span", "x"));
	  var normal = node.getBoundingClientRect();
	  var fromRange = range(node, 0, 1).getBoundingClientRect();
	  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
	}

	// Known modes, by name and by MIME
	var modes = {};
	var mimeModes = {};

	// Extra arguments are stored as the mode's dependencies, which is
	// used by (legacy) mechanisms like loadmode.js to automatically
	// load a mode. (Preferred mechanism is the require/define calls.)
	function defineMode(name, mode) {
	  if (arguments.length > 2)
	    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
	  modes[name] = mode;
	}

	function defineMIME(mime, spec) {
	  mimeModes[mime] = spec;
	}

	// Given a MIME type, a {name, ...options} config object, or a name
	// string, return a mode config object.
	function resolveMode(spec) {
	  if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
	    spec = mimeModes[spec];
	  } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
	    var found = mimeModes[spec.name];
	    if (typeof found == "string") { found = {name: found}; }
	    spec = createObj(found, spec);
	    spec.name = found.name;
	  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
	    return resolveMode("application/xml")
	  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
	    return resolveMode("application/json")
	  }
	  if (typeof spec == "string") { return {name: spec} }
	  else { return spec || {name: "null"} }
	}

	// Given a mode spec (anything that resolveMode accepts), find and
	// initialize an actual mode object.
	function getMode(options, spec) {
	  spec = resolveMode(spec);
	  var mfactory = modes[spec.name];
	  if (!mfactory) { return getMode(options, "text/plain") }
	  var modeObj = mfactory(options, spec);
	  if (modeExtensions.hasOwnProperty(spec.name)) {
	    var exts = modeExtensions[spec.name];
	    for (var prop in exts) {
	      if (!exts.hasOwnProperty(prop)) { continue }
	      if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
	      modeObj[prop] = exts[prop];
	    }
	  }
	  modeObj.name = spec.name;
	  if (spec.helperType) { modeObj.helperType = spec.helperType; }
	  if (spec.modeProps) { for (var prop$1 in spec.modeProps)
	    { modeObj[prop$1] = spec.modeProps[prop$1]; } }

	  return modeObj
	}

	// This can be used to attach properties to mode objects from
	// outside the actual mode definition.
	var modeExtensions = {};
	function extendMode(mode, properties) {
	  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
	  copyObj(properties, exts);
	}

	function copyState(mode, state) {
	  if (state === true) { return state }
	  if (mode.copyState) { return mode.copyState(state) }
	  var nstate = {};
	  for (var n in state) {
	    var val = state[n];
	    if (val instanceof Array) { val = val.concat([]); }
	    nstate[n] = val;
	  }
	  return nstate
	}

	// Given a mode and a state (for that mode), find the inner mode and
	// state at the position that the state refers to.
	function innerMode(mode, state) {
	  var info;
	  while (mode.innerMode) {
	    info = mode.innerMode(state);
	    if (!info || info.mode == mode) { break }
	    state = info.state;
	    mode = info.mode;
	  }
	  return info || {mode: mode, state: state}
	}

	function startState(mode, a1, a2) {
	  return mode.startState ? mode.startState(a1, a2) : true
	}

	// STRING STREAM

	// Fed to the mode parsers, provides helper functions to make
	// parsers more succinct.

	var StringStream = function(string, tabSize) {
	  this.pos = this.start = 0;
	  this.string = string;
	  this.tabSize = tabSize || 8;
	  this.lastColumnPos = this.lastColumnValue = 0;
	  this.lineStart = 0;
	};

	StringStream.prototype.eol = function () {return this.pos >= this.string.length};
	StringStream.prototype.sol = function () {return this.pos == this.lineStart};
	StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
	StringStream.prototype.next = function () {
	  if (this.pos < this.string.length)
	    { return this.string.charAt(this.pos++) }
	};
	StringStream.prototype.eat = function (match) {
	  var ch = this.string.charAt(this.pos);
	  var ok;
	  if (typeof match == "string") { ok = ch == match; }
	  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
	  if (ok) {++this.pos; return ch}
	};
	StringStream.prototype.eatWhile = function (match) {
	  var start = this.pos;
	  while (this.eat(match)){}
	  return this.pos > start
	};
	StringStream.prototype.eatSpace = function () {
	    var this$1 = this;

	  var start = this.pos;
	  while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }
	  return this.pos > start
	};
	StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
	StringStream.prototype.skipTo = function (ch) {
	  var found = this.string.indexOf(ch, this.pos);
	  if (found > -1) {this.pos = found; return true}
	};
	StringStream.prototype.backUp = function (n) {this.pos -= n;};
	StringStream.prototype.column = function () {
	  if (this.lastColumnPos < this.start) {
	    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
	    this.lastColumnPos = this.start;
	  }
	  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	};
	StringStream.prototype.indentation = function () {
	  return countColumn(this.string, null, this.tabSize) -
	    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	};
	StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
	  if (typeof pattern == "string") {
	    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
	    var substr = this.string.substr(this.pos, pattern.length);
	    if (cased(substr) == cased(pattern)) {
	      if (consume !== false) { this.pos += pattern.length; }
	      return true
	    }
	  } else {
	    var match = this.string.slice(this.pos).match(pattern);
	    if (match && match.index > 0) { return null }
	    if (match && consume !== false) { this.pos += match[0].length; }
	    return match
	  }
	};
	StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
	StringStream.prototype.hideFirstChars = function (n, inner) {
	  this.lineStart += n;
	  try { return inner() }
	  finally { this.lineStart -= n; }
	};

	// Compute a style array (an array starting with a mode generation
	// -- for invalidation -- followed by pairs of end positions and
	// style strings), which is used to highlight the tokens on the
	// line.
	function highlightLine(cm, line, state, forceToEnd) {
	  // A styles array always starts with a number identifying the
	  // mode/overlays that it is based on (for easy invalidation).
	  var st = [cm.state.modeGen], lineClasses = {};
	  // Compute the base array of styles
	  runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },
	    lineClasses, forceToEnd);

	  // Run overlays, adjust style array.
	  var loop = function ( o ) {
	    var overlay = cm.state.overlays[o], i = 1, at = 0;
	    runMode(cm, line.text, overlay.mode, true, function (end, style) {
	      var start = i;
	      // Ensure there's a token end at the current position, and that i points at it
	      while (at < end) {
	        var i_end = st[i];
	        if (i_end > end)
	          { st.splice(i, 1, end, st[i+1], i_end); }
	        i += 2;
	        at = Math.min(end, i_end);
	      }
	      if (!style) { return }
	      if (overlay.opaque) {
	        st.splice(start, i - start, end, "overlay " + style);
	        i = start + 2;
	      } else {
	        for (; start < i; start += 2) {
	          var cur = st[start+1];
	          st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
	        }
	      }
	    }, lineClasses);
	  };

	  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

	  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
	}

	function getLineStyles(cm, line, updateFrontier) {
	  if (!line.styles || line.styles[0] != cm.state.modeGen) {
	    var state = getStateBefore(cm, lineNo(line));
	    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
	    line.stateAfter = state;
	    line.styles = result.styles;
	    if (result.classes) { line.styleClasses = result.classes; }
	    else if (line.styleClasses) { line.styleClasses = null; }
	    if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++; }
	  }
	  return line.styles
	}

	function getStateBefore(cm, n, precise) {
	  var doc = cm.doc, display = cm.display;
	  if (!doc.mode.startState) { return true }
	  var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
	  if (!state) { state = startState(doc.mode); }
	  else { state = copyState(doc.mode, state); }
	  doc.iter(pos, n, function (line) {
	    processLine(cm, line.text, state);
	    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
	    line.stateAfter = save ? copyState(doc.mode, state) : null;
	    ++pos;
	  });
	  if (precise) { doc.frontier = pos; }
	  return state
	}

	// Lightweight form of highlight -- proceed over this line and
	// update state, but don't save a style array. Used for lines that
	// aren't currently visible.
	function processLine(cm, text, state, startAt) {
	  var mode = cm.doc.mode;
	  var stream = new StringStream(text, cm.options.tabSize);
	  stream.start = stream.pos = startAt || 0;
	  if (text == "") { callBlankLine(mode, state); }
	  while (!stream.eol()) {
	    readToken(mode, stream, state);
	    stream.start = stream.pos;
	  }
	}

	function callBlankLine(mode, state) {
	  if (mode.blankLine) { return mode.blankLine(state) }
	  if (!mode.innerMode) { return }
	  var inner = innerMode(mode, state);
	  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
	}

	function readToken(mode, stream, state, inner) {
	  for (var i = 0; i < 10; i++) {
	    if (inner) { inner[0] = innerMode(mode, state).mode; }
	    var style = mode.token(stream, state);
	    if (stream.pos > stream.start) { return style }
	  }
	  throw new Error("Mode " + mode.name + " failed to advance stream.")
	}

	// Utility for getTokenAt and getLineTokens
	function takeToken(cm, pos, precise, asArray) {
	  var getObj = function (copy) { return ({
	    start: stream.start, end: stream.pos,
	    string: stream.current(),
	    type: style || null,
	    state: copy ? copyState(doc.mode, state) : state
	  }); };

	  var doc = cm.doc, mode = doc.mode, style;
	  pos = clipPos(doc, pos);
	  var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
	  var stream = new StringStream(line.text, cm.options.tabSize), tokens;
	  if (asArray) { tokens = []; }
	  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
	    stream.start = stream.pos;
	    style = readToken(mode, stream, state);
	    if (asArray) { tokens.push(getObj(true)); }
	  }
	  return asArray ? tokens : getObj()
	}

	function extractLineClasses(type, output) {
	  if (type) { for (;;) {
	    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
	    if (!lineClass) { break }
	    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
	    var prop = lineClass[1] ? "bgClass" : "textClass";
	    if (output[prop] == null)
	      { output[prop] = lineClass[2]; }
	    else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
	      { output[prop] += " " + lineClass[2]; }
	  } }
	  return type
	}

	// Run the given mode's parser over a line, calling f for each token.
	function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
	  var flattenSpans = mode.flattenSpans;
	  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
	  var curStart = 0, curStyle = null;
	  var stream = new StringStream(text, cm.options.tabSize), style;
	  var inner = cm.options.addModeClass && [null];
	  if (text == "") { extractLineClasses(callBlankLine(mode, state), lineClasses); }
	  while (!stream.eol()) {
	    if (stream.pos > cm.options.maxHighlightLength) {
	      flattenSpans = false;
	      if (forceToEnd) { processLine(cm, text, state, stream.pos); }
	      stream.pos = text.length;
	      style = null;
	    } else {
	      style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
	    }
	    if (inner) {
	      var mName = inner[0].name;
	      if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
	    }
	    if (!flattenSpans || curStyle != style) {
	      while (curStart < stream.start) {
	        curStart = Math.min(stream.start, curStart + 5000);
	        f(curStart, curStyle);
	      }
	      curStyle = style;
	    }
	    stream.start = stream.pos;
	  }
	  while (curStart < stream.pos) {
	    // Webkit seems to refuse to render text nodes longer than 57444
	    // characters, and returns inaccurate measurements in nodes
	    // starting around 5000 chars.
	    var pos = Math.min(stream.pos, curStart + 5000);
	    f(pos, curStyle);
	    curStart = pos;
	  }
	}

	// Finds the line to start with when starting a parse. Tries to
	// find a line with a stateAfter, so that it can start with a
	// valid state. If that fails, it returns the line with the
	// smallest indentation, which tends to need the least context to
	// parse correctly.
	function findStartLine(cm, n, precise) {
	  var minindent, minline, doc = cm.doc;
	  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
	  for (var search = n; search > lim; --search) {
	    if (search <= doc.first) { return doc.first }
	    var line = getLine(doc, search - 1);
	    if (line.stateAfter && (!precise || search <= doc.frontier)) { return search }
	    var indented = countColumn(line.text, null, cm.options.tabSize);
	    if (minline == null || minindent > indented) {
	      minline = search - 1;
	      minindent = indented;
	    }
	  }
	  return minline
	}

	// LINE DATA STRUCTURE

	// Line objects. These hold state related to a line, including
	// highlighting info (the styles array).
	var Line = function(text, markedSpans, estimateHeight) {
	  this.text = text;
	  attachMarkedSpans(this, markedSpans);
	  this.height = estimateHeight ? estimateHeight(this) : 1;
	};

	Line.prototype.lineNo = function () { return lineNo(this) };
	eventMixin(Line);

	// Change the content (text, markers) of a line. Automatically
	// invalidates cached information and tries to re-estimate the
	// line's height.
	function updateLine(line, text, markedSpans, estimateHeight) {
	  line.text = text;
	  if (line.stateAfter) { line.stateAfter = null; }
	  if (line.styles) { line.styles = null; }
	  if (line.order != null) { line.order = null; }
	  detachMarkedSpans(line);
	  attachMarkedSpans(line, markedSpans);
	  var estHeight = estimateHeight ? estimateHeight(line) : 1;
	  if (estHeight != line.height) { updateLineHeight(line, estHeight); }
	}

	// Detach a line from the document tree and its markers.
	function cleanUpLine(line) {
	  line.parent = null;
	  detachMarkedSpans(line);
	}

	// Convert a style as returned by a mode (either null, or a string
	// containing one or more styles) to a CSS style. This is cached,
	// and also looks for line-wide styles.
	var styleToClassCache = {};
	var styleToClassCacheWithMode = {};
	function interpretTokenStyle(style, options) {
	  if (!style || /^\s*$/.test(style)) { return null }
	  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
	  return cache[style] ||
	    (cache[style] = style.replace(/\S+/g, "cm-$&"))
	}

	// Render the DOM representation of the text of a line. Also builds
	// up a 'line map', which points at the DOM nodes that represent
	// specific stretches of text, and is used by the measuring code.
	// The returned object contains the DOM node, this map, and
	// information about line-wide styles that were set by the mode.
	function buildLineContent(cm, lineView) {
	  // The padding-right forces the element to have a 'border', which
	  // is needed on Webkit to be able to get line-level bounding
	  // rectangles for it (in measureChar).
	  var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
	  var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
	                 col: 0, pos: 0, cm: cm,
	                 trailingSpace: false,
	                 splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
	  lineView.measure = {};

	  // Iterate over the logical lines that make up this visual line.
	  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
	    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
	    builder.pos = 0;
	    builder.addToken = buildToken;
	    // Optionally wire in some hacks into the token-rendering
	    // algorithm, to deal with browser quirks.
	    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
	      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
	    builder.map = [];
	    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
	    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
	    if (line.styleClasses) {
	      if (line.styleClasses.bgClass)
	        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
	      if (line.styleClasses.textClass)
	        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
	    }

	    // Ensure at least a single node is present, for measuring.
	    if (builder.map.length == 0)
	      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

	    // Store the map and a cache object for the current logical line
	    if (i == 0) {
	      lineView.measure.map = builder.map;
	      lineView.measure.cache = {};
	    } else {
	      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
	      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
	    }
	  }

	  // See issue #2901
	  if (webkit) {
	    var last = builder.content.lastChild;
	    if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
	      { builder.content.className = "cm-tab-wrap-hack"; }
	  }

	  signal(cm, "renderLine", cm, lineView.line, builder.pre);
	  if (builder.pre.className)
	    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

	  return builder
	}

	function defaultSpecialCharPlaceholder(ch) {
	  var token = elt("span", "\u2022", "cm-invalidchar");
	  token.title = "\\u" + ch.charCodeAt(0).toString(16);
	  token.setAttribute("aria-label", token.title);
	  return token
	}

	// Build up the DOM representation for a single token, and add it to
	// the line map. Takes care to render special characters separately.
	function buildToken(builder, text, style, startStyle, endStyle, title, css) {
	  if (!text) { return }
	  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
	  var special = builder.cm.state.specialChars, mustWrap = false;
	  var content;
	  if (!special.test(text)) {
	    builder.col += text.length;
	    content = document.createTextNode(displayText);
	    builder.map.push(builder.pos, builder.pos + text.length, content);
	    if (ie && ie_version < 9) { mustWrap = true; }
	    builder.pos += text.length;
	  } else {
	    content = document.createDocumentFragment();
	    var pos = 0;
	    while (true) {
	      special.lastIndex = pos;
	      var m = special.exec(text);
	      var skipped = m ? m.index - pos : text.length - pos;
	      if (skipped) {
	        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
	        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
	        else { content.appendChild(txt); }
	        builder.map.push(builder.pos, builder.pos + skipped, txt);
	        builder.col += skipped;
	        builder.pos += skipped;
	      }
	      if (!m) { break }
	      pos += skipped + 1;
	      var txt$1 = (void 0);
	      if (m[0] == "\t") {
	        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
	        txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
	        txt$1.setAttribute("role", "presentation");
	        txt$1.setAttribute("cm-text", "\t");
	        builder.col += tabWidth;
	      } else if (m[0] == "\r" || m[0] == "\n") {
	        txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
	        txt$1.setAttribute("cm-text", m[0]);
	        builder.col += 1;
	      } else {
	        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
	        txt$1.setAttribute("cm-text", m[0]);
	        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
	        else { content.appendChild(txt$1); }
	        builder.col += 1;
	      }
	      builder.map.push(builder.pos, builder.pos + 1, txt$1);
	      builder.pos++;
	    }
	  }
	  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
	  if (style || startStyle || endStyle || mustWrap || css) {
	    var fullStyle = style || "";
	    if (startStyle) { fullStyle += startStyle; }
	    if (endStyle) { fullStyle += endStyle; }
	    var token = elt("span", [content], fullStyle, css);
	    if (title) { token.title = title; }
	    return builder.content.appendChild(token)
	  }
	  builder.content.appendChild(content);
	}

	function splitSpaces(text, trailingBefore) {
	  if (text.length > 1 && !/  /.test(text)) { return text }
	  var spaceBefore = trailingBefore, result = "";
	  for (var i = 0; i < text.length; i++) {
	    var ch = text.charAt(i);
	    if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
	      { ch = "\u00a0"; }
	    result += ch;
	    spaceBefore = ch == " ";
	  }
	  return result
	}

	// Work around nonsense dimensions being reported for stretches of
	// right-to-left text.
	function buildTokenBadBidi(inner, order) {
	  return function (builder, text, style, startStyle, endStyle, title, css) {
	    style = style ? style + " cm-force-border" : "cm-force-border";
	    var start = builder.pos, end = start + text.length;
	    for (;;) {
	      // Find the part that overlaps with the start of this text
	      var part = (void 0);
	      for (var i = 0; i < order.length; i++) {
	        part = order[i];
	        if (part.to > start && part.from <= start) { break }
	      }
	      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }
	      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
	      startStyle = null;
	      text = text.slice(part.to - start);
	      start = part.to;
	    }
	  }
	}

	function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
	  var widget = !ignoreWidget && marker.widgetNode;
	  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
	  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
	    if (!widget)
	      { widget = builder.content.appendChild(document.createElement("span")); }
	    widget.setAttribute("cm-marker", marker.id);
	  }
	  if (widget) {
	    builder.cm.display.input.setUneditable(widget);
	    builder.content.appendChild(widget);
	  }
	  builder.pos += size;
	  builder.trailingSpace = false;
	}

	// Outputs a number of spans to make up a line, taking highlighting
	// and marked text into account.
	function insertLineContent(line, builder, styles) {
	  var spans = line.markedSpans, allText = line.text, at = 0;
	  if (!spans) {
	    for (var i$1 = 1; i$1 < styles.length; i$1+=2)
	      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
	    return
	  }

	  var len = allText.length, pos = 0, i = 1, text = "", style, css;
	  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
	  for (;;) {
	    if (nextChange == pos) { // Update current marker set
	      spanStyle = spanEndStyle = spanStartStyle = title = css = "";
	      collapsed = null; nextChange = Infinity;
	      var foundBookmarks = [], endStyles = (void 0);
	      for (var j = 0; j < spans.length; ++j) {
	        var sp = spans[j], m = sp.marker;
	        if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
	          foundBookmarks.push(m);
	        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
	          if (sp.to != null && sp.to != pos && nextChange > sp.to) {
	            nextChange = sp.to;
	            spanEndStyle = "";
	          }
	          if (m.className) { spanStyle += " " + m.className; }
	          if (m.css) { css = (css ? css + ";" : "") + m.css; }
	          if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
	          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
	          if (m.title && !title) { title = m.title; }
	          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
	            { collapsed = sp; }
	        } else if (sp.from > pos && nextChange > sp.from) {
	          nextChange = sp.from;
	        }
	      }
	      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
	        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

	      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
	        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
	      if (collapsed && (collapsed.from || 0) == pos) {
	        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
	                           collapsed.marker, collapsed.from == null);
	        if (collapsed.to == null) { return }
	        if (collapsed.to == pos) { collapsed = false; }
	      }
	    }
	    if (pos >= len) { break }

	    var upto = Math.min(len, nextChange);
	    while (true) {
	      if (text) {
	        var end = pos + text.length;
	        if (!collapsed) {
	          var tokenText = end > upto ? text.slice(0, upto - pos) : text;
	          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
	                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
	        }
	        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
	        pos = end;
	        spanStartStyle = "";
	      }
	      text = allText.slice(at, at = styles[i++]);
	      style = interpretTokenStyle(styles[i++], builder.cm.options);
	    }
	  }
	}


	// These objects are used to represent the visible (currently drawn)
	// part of the document. A LineView may correspond to multiple
	// logical lines, if those are connected by collapsed ranges.
	function LineView(doc, line, lineN) {
	  // The starting line
	  this.line = line;
	  // Continuing lines, if any
	  this.rest = visualLineContinued(line);
	  // Number of logical lines in this visual line
	  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
	  this.node = this.text = null;
	  this.hidden = lineIsHidden(doc, line);
	}

	// Create a range of LineView objects for the given lines.
	function buildViewArray(cm, from, to) {
	  var array = [], nextPos;
	  for (var pos = from; pos < to; pos = nextPos) {
	    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
	    nextPos = pos + view.size;
	    array.push(view);
	  }
	  return array
	}

	var operationGroup = null;

	function pushOperation(op) {
	  if (operationGroup) {
	    operationGroup.ops.push(op);
	  } else {
	    op.ownsGroup = operationGroup = {
	      ops: [op],
	      delayedCallbacks: []
	    };
	  }
	}

	function fireCallbacksForOps(group) {
	  // Calls delayed callbacks and cursorActivity handlers until no
	  // new ones appear
	  var callbacks = group.delayedCallbacks, i = 0;
	  do {
	    for (; i < callbacks.length; i++)
	      { callbacks[i].call(null); }
	    for (var j = 0; j < group.ops.length; j++) {
	      var op = group.ops[j];
	      if (op.cursorActivityHandlers)
	        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
	          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
	    }
	  } while (i < callbacks.length)
	}

	function finishOperation(op, endCb) {
	  var group = op.ownsGroup;
	  if (!group) { return }

	  try { fireCallbacksForOps(group); }
	  finally {
	    operationGroup = null;
	    endCb(group);
	  }
	}

	var orphanDelayedCallbacks = null;

	// Often, we want to signal events at a point where we are in the
	// middle of some work, but don't want the handler to start calling
	// other methods on the editor, which might be in an inconsistent
	// state or simply not expect any other events to happen.
	// signalLater looks whether there are any handlers, and schedules
	// them to be executed when the last operation ends, or, if no
	// operation is active, when a timeout fires.
	function signalLater(emitter, type /*, values...*/) {
	  var arr = getHandlers(emitter, type);
	  if (!arr.length) { return }
	  var args = Array.prototype.slice.call(arguments, 2), list;
	  if (operationGroup) {
	    list = operationGroup.delayedCallbacks;
	  } else if (orphanDelayedCallbacks) {
	    list = orphanDelayedCallbacks;
	  } else {
	    list = orphanDelayedCallbacks = [];
	    setTimeout(fireOrphanDelayed, 0);
	  }
	  var loop = function ( i ) {
	    list.push(function () { return arr[i].apply(null, args); });
	  };

	  for (var i = 0; i < arr.length; ++i)
	    loop( i );
	}

	function fireOrphanDelayed() {
	  var delayed = orphanDelayedCallbacks;
	  orphanDelayedCallbacks = null;
	  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
	}

	// When an aspect of a line changes, a string is added to
	// lineView.changes. This updates the relevant part of the line's
	// DOM structure.
	function updateLineForChanges(cm, lineView, lineN, dims) {
	  for (var j = 0; j < lineView.changes.length; j++) {
	    var type = lineView.changes[j];
	    if (type == "text") { updateLineText(cm, lineView); }
	    else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
	    else if (type == "class") { updateLineClasses(cm, lineView); }
	    else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
	  }
	  lineView.changes = null;
	}

	// Lines with gutter elements, widgets or a background class need to
	// be wrapped, and have the extra elements added to the wrapper div
	function ensureLineWrapped(lineView) {
	  if (lineView.node == lineView.text) {
	    lineView.node = elt("div", null, null, "position: relative");
	    if (lineView.text.parentNode)
	      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
	    lineView.node.appendChild(lineView.text);
	    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
	  }
	  return lineView.node
	}

	function updateLineBackground(cm, lineView) {
	  var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
	  if (cls) { cls += " CodeMirror-linebackground"; }
	  if (lineView.background) {
	    if (cls) { lineView.background.className = cls; }
	    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
	  } else if (cls) {
	    var wrap = ensureLineWrapped(lineView);
	    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
	    cm.display.input.setUneditable(lineView.background);
	  }
	}

	// Wrapper around buildLineContent which will reuse the structure
	// in display.externalMeasured when possible.
	function getLineContent(cm, lineView) {
	  var ext = cm.display.externalMeasured;
	  if (ext && ext.line == lineView.line) {
	    cm.display.externalMeasured = null;
	    lineView.measure = ext.measure;
	    return ext.built
	  }
	  return buildLineContent(cm, lineView)
	}

	// Redraw the line's text. Interacts with the background and text
	// classes because the mode may output tokens that influence these
	// classes.
	function updateLineText(cm, lineView) {
	  var cls = lineView.text.className;
	  var built = getLineContent(cm, lineView);
	  if (lineView.text == lineView.node) { lineView.node = built.pre; }
	  lineView.text.parentNode.replaceChild(built.pre, lineView.text);
	  lineView.text = built.pre;
	  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
	    lineView.bgClass = built.bgClass;
	    lineView.textClass = built.textClass;
	    updateLineClasses(cm, lineView);
	  } else if (cls) {
	    lineView.text.className = cls;
	  }
	}

	function updateLineClasses(cm, lineView) {
	  updateLineBackground(cm, lineView);
	  if (lineView.line.wrapClass)
	    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
	  else if (lineView.node != lineView.text)
	    { lineView.node.className = ""; }
	  var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
	  lineView.text.className = textClass || "";
	}

	function updateLineGutter(cm, lineView, lineN, dims) {
	  if (lineView.gutter) {
	    lineView.node.removeChild(lineView.gutter);
	    lineView.gutter = null;
	  }
	  if (lineView.gutterBackground) {
	    lineView.node.removeChild(lineView.gutterBackground);
	    lineView.gutterBackground = null;
	  }
	  if (lineView.line.gutterClass) {
	    var wrap = ensureLineWrapped(lineView);
	    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
	                                    ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
	    cm.display.input.setUneditable(lineView.gutterBackground);
	    wrap.insertBefore(lineView.gutterBackground, lineView.text);
	  }
	  var markers = lineView.line.gutterMarkers;
	  if (cm.options.lineNumbers || markers) {
	    var wrap$1 = ensureLineWrapped(lineView);
	    var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
	    cm.display.input.setUneditable(gutterWrap);
	    wrap$1.insertBefore(gutterWrap, lineView.text);
	    if (lineView.line.gutterClass)
	      { gutterWrap.className += " " + lineView.line.gutterClass; }
	    if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
	      { lineView.lineNumber = gutterWrap.appendChild(
	        elt("div", lineNumberFor(cm.options, lineN),
	            "CodeMirror-linenumber CodeMirror-gutter-elt",
	            ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
	    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {
	      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
	      if (found)
	        { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
	                                   ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
	    } }
	  }
	}

	function updateLineWidgets(cm, lineView, dims) {
	  if (lineView.alignable) { lineView.alignable = null; }
	  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
	    next = node.nextSibling;
	    if (node.className == "CodeMirror-linewidget")
	      { lineView.node.removeChild(node); }
	  }
	  insertLineWidgets(cm, lineView, dims);
	}

	// Build a line's DOM representation from scratch
	function buildLineElement(cm, lineView, lineN, dims) {
	  var built = getLineContent(cm, lineView);
	  lineView.text = lineView.node = built.pre;
	  if (built.bgClass) { lineView.bgClass = built.bgClass; }
	  if (built.textClass) { lineView.textClass = built.textClass; }

	  updateLineClasses(cm, lineView);
	  updateLineGutter(cm, lineView, lineN, dims);
	  insertLineWidgets(cm, lineView, dims);
	  return lineView.node
	}

	// A lineView may contain multiple logical lines (when merged by
	// collapsed spans). The widgets for all of them need to be drawn.
	function insertLineWidgets(cm, lineView, dims) {
	  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
	  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
	}

	function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
	  if (!line.widgets) { return }
	  var wrap = ensureLineWrapped(lineView);
	  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
	    var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
	    if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
	    positionLineWidget(widget, node, lineView, dims);
	    cm.display.input.setUneditable(node);
	    if (allowAbove && widget.above)
	      { wrap.insertBefore(node, lineView.gutter || lineView.text); }
	    else
	      { wrap.appendChild(node); }
	    signalLater(widget, "redraw");
	  }
	}

	function positionLineWidget(widget, node, lineView, dims) {
	  if (widget.noHScroll) {
	    (lineView.alignable || (lineView.alignable = [])).push(node);
	    var width = dims.wrapperWidth;
	    node.style.left = dims.fixedPos + "px";
	    if (!widget.coverGutter) {
	      width -= dims.gutterTotalWidth;
	      node.style.paddingLeft = dims.gutterTotalWidth + "px";
	    }
	    node.style.width = width + "px";
	  }
	  if (widget.coverGutter) {
	    node.style.zIndex = 5;
	    node.style.position = "relative";
	    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
	  }
	}

	function widgetHeight(widget) {
	  if (widget.height != null) { return widget.height }
	  var cm = widget.doc.cm;
	  if (!cm) { return 0 }
	  if (!contains(document.body, widget.node)) {
	    var parentStyle = "position: relative;";
	    if (widget.coverGutter)
	      { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
	    if (widget.noHScroll)
	      { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
	    removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
	  }
	  return widget.height = widget.node.parentNode.offsetHeight
	}

	// Return true when the given mouse event happened in a widget
	function eventInWidget(display, e) {
	  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
	    if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
	        (n.parentNode == display.sizer && n != display.mover))
	      { return true }
	  }
	}

	// POSITION MEASUREMENT

	function paddingTop(display) {return display.lineSpace.offsetTop}
	function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
	function paddingH(display) {
	  if (display.cachedPaddingH) { return display.cachedPaddingH }
	  var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
	  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
	  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
	  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
	  return data
	}

	function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
	function displayWidth(cm) {
	  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
	}
	function displayHeight(cm) {
	  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
	}

	// Ensure the lineView.wrapping.heights array is populated. This is
	// an array of bottom offsets for the lines that make up a drawn
	// line. When lineWrapping is on, there might be more than one
	// height.
	function ensureLineHeights(cm, lineView, rect) {
	  var wrapping = cm.options.lineWrapping;
	  var curWidth = wrapping && displayWidth(cm);
	  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
	    var heights = lineView.measure.heights = [];
	    if (wrapping) {
	      lineView.measure.width = curWidth;
	      var rects = lineView.text.firstChild.getClientRects();
	      for (var i = 0; i < rects.length - 1; i++) {
	        var cur = rects[i], next = rects[i + 1];
	        if (Math.abs(cur.bottom - next.bottom) > 2)
	          { heights.push((cur.bottom + next.top) / 2 - rect.top); }
	      }
	    }
	    heights.push(rect.bottom - rect.top);
	  }
	}

	// Find a line map (mapping character offsets to text nodes) and a
	// measurement cache for the given line number. (A line view might
	// contain multiple lines when collapsed ranges are present.)
	function mapFromLineView(lineView, line, lineN) {
	  if (lineView.line == line)
	    { return {map: lineView.measure.map, cache: lineView.measure.cache} }
	  for (var i = 0; i < lineView.rest.length; i++)
	    { if (lineView.rest[i] == line)
	      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
	  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
	    { if (lineNo(lineView.rest[i$1]) > lineN)
	      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
	}

	// Render a line into the hidden node display.externalMeasured. Used
	// when measurement is needed for a line that's not in the viewport.
	function updateExternalMeasurement(cm, line) {
	  line = visualLine(line);
	  var lineN = lineNo(line);
	  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
	  view.lineN = lineN;
	  var built = view.built = buildLineContent(cm, view);
	  view.text = built.pre;
	  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
	  return view
	}

	// Get a {top, bottom, left, right} box (in line-local coordinates)
	// for a given character.
	function measureChar(cm, line, ch, bias) {
	  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
	}

	// Find a line view that corresponds to the given line number.
	function findViewForLine(cm, lineN) {
	  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
	    { return cm.display.view[findViewIndex(cm, lineN)] }
	  var ext = cm.display.externalMeasured;
	  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
	    { return ext }
	}

	// Measurement can be split in two steps, the set-up work that
	// applies to the whole line, and the measurement of the actual
	// character. Functions like coordsChar, that need to do a lot of
	// measurements in a row, can thus ensure that the set-up work is
	// only done once.
	function prepareMeasureForLine(cm, line) {
	  var lineN = lineNo(line);
	  var view = findViewForLine(cm, lineN);
	  if (view && !view.text) {
	    view = null;
	  } else if (view && view.changes) {
	    updateLineForChanges(cm, view, lineN, getDimensions(cm));
	    cm.curOp.forceUpdate = true;
	  }
	  if (!view)
	    { view = updateExternalMeasurement(cm, line); }

	  var info = mapFromLineView(view, line, lineN);
	  return {
	    line: line, view: view, rect: null,
	    map: info.map, cache: info.cache, before: info.before,
	    hasHeights: false
	  }
	}

	// Given a prepared measurement object, measures the position of an
	// actual character (or fetches it from the cache).
	function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
	  if (prepared.before) { ch = -1; }
	  var key = ch + (bias || ""), found;
	  if (prepared.cache.hasOwnProperty(key)) {
	    found = prepared.cache[key];
	  } else {
	    if (!prepared.rect)
	      { prepared.rect = prepared.view.text.getBoundingClientRect(); }
	    if (!prepared.hasHeights) {
	      ensureLineHeights(cm, prepared.view, prepared.rect);
	      prepared.hasHeights = true;
	    }
	    found = measureCharInner(cm, prepared, ch, bias);
	    if (!found.bogus) { prepared.cache[key] = found; }
	  }
	  return {left: found.left, right: found.right,
	          top: varHeight ? found.rtop : found.top,
	          bottom: varHeight ? found.rbottom : found.bottom}
	}

	var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

	function nodeAndOffsetInLineMap(map$$1, ch, bias) {
	  var node, start, end, collapse, mStart, mEnd;
	  // First, search the line map for the text node corresponding to,
	  // or closest to, the target character.
	  for (var i = 0; i < map$$1.length; i += 3) {
	    mStart = map$$1[i];
	    mEnd = map$$1[i + 1];
	    if (ch < mStart) {
	      start = 0; end = 1;
	      collapse = "left";
	    } else if (ch < mEnd) {
	      start = ch - mStart;
	      end = start + 1;
	    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
	      end = mEnd - mStart;
	      start = end - 1;
	      if (ch >= mEnd) { collapse = "right"; }
	    }
	    if (start != null) {
	      node = map$$1[i + 2];
	      if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
	        { collapse = bias; }
	      if (bias == "left" && start == 0)
	        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
	          node = map$$1[(i -= 3) + 2];
	          collapse = "left";
	        } }
	      if (bias == "right" && start == mEnd - mStart)
	        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
	          node = map$$1[(i += 3) + 2];
	          collapse = "right";
	        } }
	      break
	    }
	  }
	  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
	}

	function getUsefulRect(rects, bias) {
	  var rect = nullRect;
	  if (bias == "left") { for (var i = 0; i < rects.length; i++) {
	    if ((rect = rects[i]).left != rect.right) { break }
	  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
	    if ((rect = rects[i$1]).left != rect.right) { break }
	  } }
	  return rect
	}

	function measureCharInner(cm, prepared, ch, bias) {
	  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
	  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

	  var rect;
	  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
	    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
	      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
	      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
	      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
	        { rect = node.parentNode.getBoundingClientRect(); }
	      else
	        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
	      if (rect.left || rect.right || start == 0) { break }
	      end = start;
	      start = start - 1;
	      collapse = "right";
	    }
	    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
	  } else { // If it is a widget, simply get the box for the whole widget.
	    if (start > 0) { collapse = bias = "right"; }
	    var rects;
	    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
	      { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
	    else
	      { rect = node.getBoundingClientRect(); }
	  }
	  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
	    var rSpan = node.parentNode.getClientRects()[0];
	    if (rSpan)
	      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
	    else
	      { rect = nullRect; }
	  }

	  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
	  var mid = (rtop + rbot) / 2;
	  var heights = prepared.view.measure.heights;
	  var i = 0;
	  for (; i < heights.length - 1; i++)
	    { if (mid < heights[i]) { break } }
	  var top = i ? heights[i - 1] : 0, bot = heights[i];
	  var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
	                right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
	                top: top, bottom: bot};
	  if (!rect.left && !rect.right) { result.bogus = true; }
	  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

	  return result
	}

	// Work around problem with bounding client rects on ranges being
	// returned incorrectly when zoomed on IE10 and below.
	function maybeUpdateRectForZooming(measure, rect) {
	  if (!window.screen || screen.logicalXDPI == null ||
	      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
	    { return rect }
	  var scaleX = screen.logicalXDPI / screen.deviceXDPI;
	  var scaleY = screen.logicalYDPI / screen.deviceYDPI;
	  return {left: rect.left * scaleX, right: rect.right * scaleX,
	          top: rect.top * scaleY, bottom: rect.bottom * scaleY}
	}

	function clearLineMeasurementCacheFor(lineView) {
	  if (lineView.measure) {
	    lineView.measure.cache = {};
	    lineView.measure.heights = null;
	    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	      { lineView.measure.caches[i] = {}; } }
	  }
	}

	function clearLineMeasurementCache(cm) {
	  cm.display.externalMeasure = null;
	  removeChildren(cm.display.lineMeasure);
	  for (var i = 0; i < cm.display.view.length; i++)
	    { clearLineMeasurementCacheFor(cm.display.view[i]); }
	}

	function clearCaches(cm) {
	  clearLineMeasurementCache(cm);
	  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
	  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
	  cm.display.lineNumChars = null;
	}

	function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft }
	function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop }

	// Converts a {top, bottom, left, right} box from line-local
	// coordinates into another coordinate system. Context may be one of
	// "line", "div" (display.lineDiv), "local"./null (editor), "window",
	// or "page".
	function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
	  if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {
	    var size = widgetHeight(lineObj.widgets[i]);
	    rect.top += size; rect.bottom += size;
	  } } }
	  if (context == "line") { return rect }
	  if (!context) { context = "local"; }
	  var yOff = heightAtLine(lineObj);
	  if (context == "local") { yOff += paddingTop(cm.display); }
	  else { yOff -= cm.display.viewOffset; }
	  if (context == "page" || context == "window") {
	    var lOff = cm.display.lineSpace.getBoundingClientRect();
	    yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
	    var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
	    rect.left += xOff; rect.right += xOff;
	  }
	  rect.top += yOff; rect.bottom += yOff;
	  return rect
	}

	// Coverts a box from "div" coords to another coordinate system.
	// Context may be "window", "page", "div", or "local"./null.
	function fromCoordSystem(cm, coords, context) {
	  if (context == "div") { return coords }
	  var left = coords.left, top = coords.top;
	  // First move into "page" coordinate system
	  if (context == "page") {
	    left -= pageScrollX();
	    top -= pageScrollY();
	  } else if (context == "local" || !context) {
	    var localBox = cm.display.sizer.getBoundingClientRect();
	    left += localBox.left;
	    top += localBox.top;
	  }

	  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
	  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
	}

	function charCoords(cm, pos, context, lineObj, bias) {
	  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
	  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
	}

	// Returns a box for a given cursor position, which may have an
	// 'other' property containing the position of the secondary cursor
	// on a bidi boundary.
	// A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
	// and after `char - 1` in writing order of `char - 1`
	// A cursor Pos(line, char, "after") is on the same visual line as `char`
	// and before `char` in writing order of `char`
	// Examples (upper-case letters are RTL, lower-case are LTR):
	//     Pos(0, 1, ...)
	//     before   after
	// ab     a|b     a|b
	// aB     a|B     aB|
	// Ab     |Ab     A|b
	// AB     B|A     B|A
	// Every position after the last character on a line is considered to stick
	// to the last character on the line.
	function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
	  lineObj = lineObj || getLine(cm.doc, pos.line);
	  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
	  function get(ch, right) {
	    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
	    if (right) { m.left = m.right; } else { m.right = m.left; }
	    return intoCoordSystem(cm, lineObj, m, context)
	  }
	  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
	  if (ch >= lineObj.text.length) {
	    ch = lineObj.text.length;
	    sticky = "before";
	  } else if (ch <= 0) {
	    ch = 0;
	    sticky = "after";
	  }
	  if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

	  function getBidi(ch, partPos, invert) {
	    var part = order[partPos], right = (part.level % 2) != 0;
	    return get(invert ? ch - 1 : ch, right != invert)
	  }
	  var partPos = getBidiPartAt(order, ch, sticky);
	  var other = bidiOther;
	  var val = getBidi(ch, partPos, sticky == "before");
	  if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
	  return val
	}

	// Used to cheaply estimate the coordinates for a position. Used for
	// intermediate scroll updates.
	function estimateCoords(cm, pos) {
	  var left = 0;
	  pos = clipPos(cm.doc, pos);
	  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
	  var lineObj = getLine(cm.doc, pos.line);
	  var top = heightAtLine(lineObj) + paddingTop(cm.display);
	  return {left: left, right: left, top: top, bottom: top + lineObj.height}
	}

	// Positions returned by coordsChar contain some extra information.
	// xRel is the relative x position of the input coordinates compared
	// to the found position (so xRel > 0 means the coordinates are to
	// the right of the character position, for example). When outside
	// is true, that means the coordinates lie outside the line's
	// vertical range.
	function PosWithInfo(line, ch, sticky, outside, xRel) {
	  var pos = Pos(line, ch, sticky);
	  pos.xRel = xRel;
	  if (outside) { pos.outside = true; }
	  return pos
	}

	// Compute the character position closest to the given coordinates.
	// Input must be lineSpace-local ("div" coordinate system).
	function coordsChar(cm, x, y) {
	  var doc = cm.doc;
	  y += cm.display.viewOffset;
	  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }
	  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
	  if (lineN > last)
	    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }
	  if (x < 0) { x = 0; }

	  var lineObj = getLine(doc, lineN);
	  for (;;) {
	    var found = coordsCharInner(cm, lineObj, lineN, x, y);
	    var merged = collapsedSpanAtEnd(lineObj);
	    var mergedPos = merged && merged.find(0, true);
	    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
	      { lineN = lineNo(lineObj = mergedPos.to.line); }
	    else
	      { return found }
	  }
	}

	function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
	  var measure = function (ch) { return intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), "line"); };
	  var end = lineObj.text.length;
	  var begin = findFirst(function (ch) { return measure(ch - 1).bottom <= y; }, end, 0);
	  end = findFirst(function (ch) { return measure(ch).top > y; }, begin, end);
	  return {begin: begin, end: end}
	}

	function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
	  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
	  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
	}

	function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
	  y -= heightAtLine(lineObj);
	  var begin = 0, end = lineObj.text.length;
	  var preparedMeasure = prepareMeasureForLine(cm, lineObj);
	  var pos;
	  var order = getOrder(lineObj, cm.doc.direction);
	  if (order) {
	    if (cm.options.lineWrapping) {
	      var assign;
	      ((assign = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = assign.begin, end = assign.end, assign));
	    }
	    pos = new Pos(lineNo$$1, begin);
	    var beginLeft = cursorCoords(cm, pos, "line", lineObj, preparedMeasure).left;
	    var dir = beginLeft < x ? 1 : -1;
	    var prevDiff, diff = beginLeft - x, prevPos;
	    do {
	      prevDiff = diff;
	      prevPos = pos;
	      pos = moveVisually(cm, lineObj, pos, dir);
	      if (pos == null || pos.ch < begin || end <= (pos.sticky == "before" ? pos.ch - 1 : pos.ch)) {
	        pos = prevPos;
	        break
	      }
	      diff = cursorCoords(cm, pos, "line", lineObj, preparedMeasure).left - x;
	    } while ((dir < 0) != (diff < 0) && (Math.abs(diff) <= Math.abs(prevDiff)))
	    if (Math.abs(diff) > Math.abs(prevDiff)) {
	      if ((diff < 0) == (prevDiff < 0)) { throw new Error("Broke out of infinite loop in coordsCharInner") }
	      pos = prevPos;
	    }
	  } else {
	    var ch = findFirst(function (ch) {
	      var box = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), "line");
	      if (box.top > y) {
	        // For the cursor stickiness
	        end = Math.min(ch, end);
	        return true
	      }
	      else if (box.bottom <= y) { return false }
	      else if (box.left > x) { return true }
	      else if (box.right < x) { return false }
	      else { return (x - box.left < box.right - x) }
	    }, begin, end);
	    ch = skipExtendingChars(lineObj.text, ch, 1);
	    pos = new Pos(lineNo$$1, ch, ch == end ? "before" : "after");
	  }
	  var coords = cursorCoords(cm, pos, "line", lineObj, preparedMeasure);
	  if (y < coords.top || coords.bottom < y) { pos.outside = true; }
	  pos.xRel = x < coords.left ? -1 : (x > coords.right ? 1 : 0);
	  return pos
	}

	var measureText;
	// Compute the default text height.
	function textHeight(display) {
	  if (display.cachedTextHeight != null) { return display.cachedTextHeight }
	  if (measureText == null) {
	    measureText = elt("pre");
	    // Measure a bunch of lines, for browsers that compute
	    // fractional heights.
	    for (var i = 0; i < 49; ++i) {
	      measureText.appendChild(document.createTextNode("x"));
	      measureText.appendChild(elt("br"));
	    }
	    measureText.appendChild(document.createTextNode("x"));
	  }
	  removeChildrenAndAdd(display.measure, measureText);
	  var height = measureText.offsetHeight / 50;
	  if (height > 3) { display.cachedTextHeight = height; }
	  removeChildren(display.measure);
	  return height || 1
	}

	// Compute the default character width.
	function charWidth(display) {
	  if (display.cachedCharWidth != null) { return display.cachedCharWidth }
	  var anchor = elt("span", "xxxxxxxxxx");
	  var pre = elt("pre", [anchor]);
	  removeChildrenAndAdd(display.measure, pre);
	  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
	  if (width > 2) { display.cachedCharWidth = width; }
	  return width || 10
	}

	// Do a bulk-read of the DOM positions and sizes needed to draw the
	// view, so that we don't interleave reading and writing to the DOM.
	function getDimensions(cm) {
	  var d = cm.display, left = {}, width = {};
	  var gutterLeft = d.gutters.clientLeft;
	  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
	    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
	    width[cm.options.gutters[i]] = n.clientWidth;
	  }
	  return {fixedPos: compensateForHScroll(d),
	          gutterTotalWidth: d.gutters.offsetWidth,
	          gutterLeft: left,
	          gutterWidth: width,
	          wrapperWidth: d.wrapper.clientWidth}
	}

	// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
	// but using getBoundingClientRect to get a sub-pixel-accurate
	// result.
	function compensateForHScroll(display) {
	  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
	}

	// Returns a function that estimates the height of a line, to use as
	// first approximation until the line becomes visible (and is thus
	// properly measurable).
	function estimateHeight(cm) {
	  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
	  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
	  return function (line) {
	    if (lineIsHidden(cm.doc, line)) { return 0 }

	    var widgetsHeight = 0;
	    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
	      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
	    } }

	    if (wrapping)
	      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
	    else
	      { return widgetsHeight + th }
	  }
	}

	function estimateLineHeights(cm) {
	  var doc = cm.doc, est = estimateHeight(cm);
	  doc.iter(function (line) {
	    var estHeight = est(line);
	    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
	  });
	}

	// Given a mouse event, find the corresponding position. If liberal
	// is false, it checks whether a gutter or scrollbar was clicked,
	// and returns null if it was. forRect is used by rectangular
	// selections, and tries to estimate a character position even for
	// coordinates beyond the right of the text.
	function posFromMouse(cm, e, liberal, forRect) {
	  var display = cm.display;
	  if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

	  var x, y, space = display.lineSpace.getBoundingClientRect();
	  // Fails unpredictably on IE[67] when mouse is dragged around quickly.
	  try { x = e.clientX - space.left; y = e.clientY - space.top; }
	  catch (e) { return null }
	  var coords = coordsChar(cm, x, y), line;
	  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
	    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
	    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
	  }
	  return coords
	}

	// Find the view element corresponding to a given line. Return null
	// when the line isn't visible.
	function findViewIndex(cm, n) {
	  if (n >= cm.display.viewTo) { return null }
	  n -= cm.display.viewFrom;
	  if (n < 0) { return null }
	  var view = cm.display.view;
	  for (var i = 0; i < view.length; i++) {
	    n -= view[i].size;
	    if (n < 0) { return i }
	  }
	}

	function updateSelection(cm) {
	  cm.display.input.showSelection(cm.display.input.prepareSelection());
	}

	function prepareSelection(cm, primary) {
	  var doc = cm.doc, result = {};
	  var curFragment = result.cursors = document.createDocumentFragment();
	  var selFragment = result.selection = document.createDocumentFragment();

	  for (var i = 0; i < doc.sel.ranges.length; i++) {
	    if (primary === false && i == doc.sel.primIndex) { continue }
	    var range$$1 = doc.sel.ranges[i];
	    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
	    var collapsed = range$$1.empty();
	    if (collapsed || cm.options.showCursorWhenSelecting)
	      { drawSelectionCursor(cm, range$$1.head, curFragment); }
	    if (!collapsed)
	      { drawSelectionRange(cm, range$$1, selFragment); }
	  }
	  return result
	}

	// Draws a cursor for the given range
	function drawSelectionCursor(cm, head, output) {
	  var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

	  var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
	  cursor.style.left = pos.left + "px";
	  cursor.style.top = pos.top + "px";
	  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

	  if (pos.other) {
	    // Secondary cursor, shown when on a 'jump' in bi-directional text
	    var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
	    otherCursor.style.display = "";
	    otherCursor.style.left = pos.other.left + "px";
	    otherCursor.style.top = pos.other.top + "px";
	    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
	  }
	}

	// Draws the given range as a highlighted selection
	function drawSelectionRange(cm, range$$1, output) {
	  var display = cm.display, doc = cm.doc;
	  var fragment = document.createDocumentFragment();
	  var padding = paddingH(cm.display), leftSide = padding.left;
	  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

	  function add(left, top, width, bottom) {
	    if (top < 0) { top = 0; }
	    top = Math.round(top);
	    bottom = Math.round(bottom);
	    fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
	  }

	  function drawForLine(line, fromArg, toArg) {
	    var lineObj = getLine(doc, line);
	    var lineLen = lineObj.text.length;
	    var start, end;
	    function coords(ch, bias) {
	      return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
	    }

	    iterateBidiSections(getOrder(lineObj, doc.direction), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
	      var leftPos = coords(from, "left"), rightPos, left, right;
	      if (from == to) {
	        rightPos = leftPos;
	        left = right = leftPos.left;
	      } else {
	        rightPos = coords(to - 1, "right");
	        if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
	        left = leftPos.left;
	        right = rightPos.right;
	      }
	      if (fromArg == null && from == 0) { left = leftSide; }
	      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
	        add(left, leftPos.top, null, leftPos.bottom);
	        left = leftSide;
	        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top); }
	      }
	      if (toArg == null && to == lineLen) { right = rightSide; }
	      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
	        { start = leftPos; }
	      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
	        { end = rightPos; }
	      if (left < leftSide + 1) { left = leftSide; }
	      add(left, rightPos.top, right - left, rightPos.bottom);
	    });
	    return {start: start, end: end}
	  }

	  var sFrom = range$$1.from(), sTo = range$$1.to();
	  if (sFrom.line == sTo.line) {
	    drawForLine(sFrom.line, sFrom.ch, sTo.ch);
	  } else {
	    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
	    var singleVLine = visualLine(fromLine) == visualLine(toLine);
	    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
	    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
	    if (singleVLine) {
	      if (leftEnd.top < rightStart.top - 2) {
	        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
	        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
	      } else {
	        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
	      }
	    }
	    if (leftEnd.bottom < rightStart.top)
	      { add(leftSide, leftEnd.bottom, null, rightStart.top); }
	  }

	  output.appendChild(fragment);
	}

	// Cursor-blinking
	function restartBlink(cm) {
	  if (!cm.state.focused) { return }
	  var display = cm.display;
	  clearInterval(display.blinker);
	  var on = true;
	  display.cursorDiv.style.visibility = "";
	  if (cm.options.cursorBlinkRate > 0)
	    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
	      cm.options.cursorBlinkRate); }
	  else if (cm.options.cursorBlinkRate < 0)
	    { display.cursorDiv.style.visibility = "hidden"; }
	}

	function ensureFocus(cm) {
	  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
	}

	function delayBlurEvent(cm) {
	  cm.state.delayingBlurEvent = true;
	  setTimeout(function () { if (cm.state.delayingBlurEvent) {
	    cm.state.delayingBlurEvent = false;
	    onBlur(cm);
	  } }, 100);
	}

	function onFocus(cm, e) {
	  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

	  if (cm.options.readOnly == "nocursor") { return }
	  if (!cm.state.focused) {
	    signal(cm, "focus", cm, e);
	    cm.state.focused = true;
	    addClass(cm.display.wrapper, "CodeMirror-focused");
	    // This test prevents this from firing when a context
	    // menu is closed (since the input reset would kill the
	    // select-all detection hack)
	    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
	      cm.display.input.reset();
	      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
	    }
	    cm.display.input.receivedFocus();
	  }
	  restartBlink(cm);
	}
	function onBlur(cm, e) {
	  if (cm.state.delayingBlurEvent) { return }

	  if (cm.state.focused) {
	    signal(cm, "blur", cm, e);
	    cm.state.focused = false;
	    rmClass(cm.display.wrapper, "CodeMirror-focused");
	  }
	  clearInterval(cm.display.blinker);
	  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
	}

	// Re-align line numbers and gutter marks to compensate for
	// horizontal scrolling.
	function alignHorizontally(cm) {
	  var display = cm.display, view = display.view;
	  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
	  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
	  var gutterW = display.gutters.offsetWidth, left = comp + "px";
	  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
	    if (cm.options.fixedGutter) {
	      if (view[i].gutter)
	        { view[i].gutter.style.left = left; }
	      if (view[i].gutterBackground)
	        { view[i].gutterBackground.style.left = left; }
	    }
	    var align = view[i].alignable;
	    if (align) { for (var j = 0; j < align.length; j++)
	      { align[j].style.left = left; } }
	  } }
	  if (cm.options.fixedGutter)
	    { display.gutters.style.left = (comp + gutterW) + "px"; }
	}

	// Used to ensure that the line number gutter is still the right
	// size for the current document size. Returns true when an update
	// is needed.
	function maybeUpdateLineNumberWidth(cm) {
	  if (!cm.options.lineNumbers) { return false }
	  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
	  if (last.length != display.lineNumChars) {
	    var test = display.measure.appendChild(elt("div", [elt("div", last)],
	                                               "CodeMirror-linenumber CodeMirror-gutter-elt"));
	    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
	    display.lineGutter.style.width = "";
	    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
	    display.lineNumWidth = display.lineNumInnerWidth + padding;
	    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
	    display.lineGutter.style.width = display.lineNumWidth + "px";
	    updateGutterSpace(cm);
	    return true
	  }
	  return false
	}

	// Read the actual heights of the rendered lines, and update their
	// stored heights to match.
	function updateHeightsInViewport(cm) {
	  var display = cm.display;
	  var prevBottom = display.lineDiv.offsetTop;
	  for (var i = 0; i < display.view.length; i++) {
	    var cur = display.view[i], height = (void 0);
	    if (cur.hidden) { continue }
	    if (ie && ie_version < 8) {
	      var bot = cur.node.offsetTop + cur.node.offsetHeight;
	      height = bot - prevBottom;
	      prevBottom = bot;
	    } else {
	      var box = cur.node.getBoundingClientRect();
	      height = box.bottom - box.top;
	    }
	    var diff = cur.line.height - height;
	    if (height < 2) { height = textHeight(display); }
	    if (diff > .001 || diff < -.001) {
	      updateLineHeight(cur.line, height);
	      updateWidgetHeight(cur.line);
	      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
	        { updateWidgetHeight(cur.rest[j]); } }
	    }
	  }
	}

	// Read and store the height of line widgets associated with the
	// given line.
	function updateWidgetHeight(line) {
	  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)
	    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight; } }
	}

	// Compute the lines that are visible in a given viewport (defaults
	// the the current scroll position). viewport may contain top,
	// height, and ensure (see op.scrollToPos) properties.
	function visibleLines(display, doc, viewport) {
	  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
	  top = Math.floor(top - paddingTop(display));
	  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

	  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
	  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
	  // forces those lines into the viewport (if possible).
	  if (viewport && viewport.ensure) {
	    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
	    if (ensureFrom < from) {
	      from = ensureFrom;
	      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
	    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
	      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
	      to = ensureTo;
	    }
	  }
	  return {from: from, to: Math.max(to, from + 1)}
	}

	// Sync the scrollable area and scrollbars, ensure the viewport
	// covers the visible area.
	function setScrollTop(cm, val) {
	  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
	  cm.doc.scrollTop = val;
	  if (!gecko) { updateDisplaySimple(cm, {top: val}); }
	  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
	  cm.display.scrollbars.setScrollTop(val);
	  if (gecko) { updateDisplaySimple(cm); }
	  startWorker(cm, 100);
	}
	// Sync scroller and scrollbar, ensure the gutter elements are
	// aligned.
	function setScrollLeft(cm, val, isScroller) {
	  if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) { return }
	  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
	  cm.doc.scrollLeft = val;
	  alignHorizontally(cm);
	  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
	  cm.display.scrollbars.setScrollLeft(val);
	}

	// Since the delta values reported on mouse wheel events are
	// unstandardized between browsers and even browser versions, and
	// generally horribly unpredictable, this code starts by measuring
	// the scroll effect that the first few mouse wheel events have,
	// and, from that, detects the way it can convert deltas to pixel
	// offsets afterwards.
	//
	// The reason we want to know the amount a wheel event will scroll
	// is that it gives us a chance to update the display before the
	// actual scrolling happens, reducing flickering.

	var wheelSamples = 0;
	var wheelPixelsPerUnit = null;
	// Fill in a browser-detected starting value on browsers where we
	// know one. These don't have to be accurate -- the result of them
	// being wrong would just be a slight flicker on the first wheel
	// scroll (if it is large enough).
	if (ie) { wheelPixelsPerUnit = -.53; }
	else if (gecko) { wheelPixelsPerUnit = 15; }
	else if (chrome) { wheelPixelsPerUnit = -.7; }
	else if (safari) { wheelPixelsPerUnit = -1/3; }

	function wheelEventDelta(e) {
	  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
	  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
	  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
	  else if (dy == null) { dy = e.wheelDelta; }
	  return {x: dx, y: dy}
	}
	function wheelEventPixels(e) {
	  var delta = wheelEventDelta(e);
	  delta.x *= wheelPixelsPerUnit;
	  delta.y *= wheelPixelsPerUnit;
	  return delta
	}

	function onScrollWheel(cm, e) {
	  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

	  var display = cm.display, scroll = display.scroller;
	  // Quit if there's nothing to scroll here
	  var canScrollX = scroll.scrollWidth > scroll.clientWidth;
	  var canScrollY = scroll.scrollHeight > scroll.clientHeight;
	  if (!(dx && canScrollX || dy && canScrollY)) { return }

	  // Webkit browsers on OS X abort momentum scrolls when the target
	  // of the scroll event is removed from the scrollable element.
	  // This hack (see related code in patchDisplay) makes sure the
	  // element is kept around.
	  if (dy && mac && webkit) {
	    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
	      for (var i = 0; i < view.length; i++) {
	        if (view[i].node == cur) {
	          cm.display.currentWheelTarget = cur;
	          break outer
	        }
	      }
	    }
	  }

	  // On some browsers, horizontal scrolling will cause redraws to
	  // happen before the gutter has been realigned, causing it to
	  // wriggle around in a most unseemly way. When we have an
	  // estimated pixels/delta value, we just handle horizontal
	  // scrolling entirely here. It'll be slightly off from native, but
	  // better than glitching out.
	  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
	    if (dy && canScrollY)
	      { setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))); }
	    setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
	    // Only prevent default scrolling if vertical scrolling is
	    // actually possible. Otherwise, it causes vertical scroll
	    // jitter on OSX trackpads when deltaX is small and deltaY
	    // is large (issue #3579)
	    if (!dy || (dy && canScrollY))
	      { e_preventDefault(e); }
	    display.wheelStartX = null; // Abort measurement, if in progress
	    return
	  }

	  // 'Project' the visible viewport to cover the area that is being
	  // scrolled into view (if we know enough to estimate it).
	  if (dy && wheelPixelsPerUnit != null) {
	    var pixels = dy * wheelPixelsPerUnit;
	    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
	    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
	    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
	    updateDisplaySimple(cm, {top: top, bottom: bot});
	  }

	  if (wheelSamples < 20) {
	    if (display.wheelStartX == null) {
	      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
	      display.wheelDX = dx; display.wheelDY = dy;
	      setTimeout(function () {
	        if (display.wheelStartX == null) { return }
	        var movedX = scroll.scrollLeft - display.wheelStartX;
	        var movedY = scroll.scrollTop - display.wheelStartY;
	        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
	          (movedX && display.wheelDX && movedX / display.wheelDX);
	        display.wheelStartX = display.wheelStartY = null;
	        if (!sample) { return }
	        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
	        ++wheelSamples;
	      }, 200);
	    } else {
	      display.wheelDX += dx; display.wheelDY += dy;
	    }
	  }
	}

	// SCROLLBARS

	// Prepare DOM reads needed to update the scrollbars. Done in one
	// shot to minimize update/measure roundtrips.
	function measureForScrollbars(cm) {
	  var d = cm.display, gutterW = d.gutters.offsetWidth;
	  var docH = Math.round(cm.doc.height + paddingVert(cm.display));
	  return {
	    clientHeight: d.scroller.clientHeight,
	    viewHeight: d.wrapper.clientHeight,
	    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
	    viewWidth: d.wrapper.clientWidth,
	    barLeft: cm.options.fixedGutter ? gutterW : 0,
	    docHeight: docH,
	    scrollHeight: docH + scrollGap(cm) + d.barHeight,
	    nativeBarWidth: d.nativeBarWidth,
	    gutterWidth: gutterW
	  }
	}

	var NativeScrollbars = function(place, scroll, cm) {
	  this.cm = cm;
	  var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
	  var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
	  place(vert); place(horiz);

	  on(vert, "scroll", function () {
	    if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
	  });
	  on(horiz, "scroll", function () {
	    if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
	  });

	  this.checkedZeroWidth = false;
	  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
	  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
	};

	NativeScrollbars.prototype.update = function (measure) {
	  var needsH = measure.scrollWidth > measure.clientWidth + 1;
	  var needsV = measure.scrollHeight > measure.clientHeight + 1;
	  var sWidth = measure.nativeBarWidth;

	  if (needsV) {
	    this.vert.style.display = "block";
	    this.vert.style.bottom = needsH ? sWidth + "px" : "0";
	    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
	    // A bug in IE8 can cause this value to be negative, so guard it.
	    this.vert.firstChild.style.height =
	      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
	  } else {
	    this.vert.style.display = "";
	    this.vert.firstChild.style.height = "0";
	  }

	  if (needsH) {
	    this.horiz.style.display = "block";
	    this.horiz.style.right = needsV ? sWidth + "px" : "0";
	    this.horiz.style.left = measure.barLeft + "px";
	    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
	    this.horiz.firstChild.style.width =
	      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
	  } else {
	    this.horiz.style.display = "";
	    this.horiz.firstChild.style.width = "0";
	  }

	  if (!this.checkedZeroWidth && measure.clientHeight > 0) {
	    if (sWidth == 0) { this.zeroWidthHack(); }
	    this.checkedZeroWidth = true;
	  }

	  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
	};

	NativeScrollbars.prototype.setScrollLeft = function (pos) {
	  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
	  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz); }
	};

	NativeScrollbars.prototype.setScrollTop = function (pos) {
	  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
	  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert); }
	};

	NativeScrollbars.prototype.zeroWidthHack = function () {
	  var w = mac && !mac_geMountainLion ? "12px" : "18px";
	  this.horiz.style.height = this.vert.style.width = w;
	  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
	  this.disableHoriz = new Delayed;
	  this.disableVert = new Delayed;
	};

	NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay) {
	  bar.style.pointerEvents = "auto";
	  function maybeDisable() {
	    // To find out whether the scrollbar is still visible, we
	    // check whether the element under the pixel in the bottom
	    // left corner of the scrollbar box is the scrollbar box
	    // itself (when the bar is still visible) or its filler child
	    // (when the bar is hidden). If it is still visible, we keep
	    // it enabled, if it's hidden, we disable pointer events.
	    var box = bar.getBoundingClientRect();
	    var elt$$1 = document.elementFromPoint(box.left + 1, box.bottom - 1);
	    if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
	    else { delay.set(1000, maybeDisable); }
	  }
	  delay.set(1000, maybeDisable);
	};

	NativeScrollbars.prototype.clear = function () {
	  var parent = this.horiz.parentNode;
	  parent.removeChild(this.horiz);
	  parent.removeChild(this.vert);
	};

	var NullScrollbars = function () {};

	NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
	NullScrollbars.prototype.setScrollLeft = function () {};
	NullScrollbars.prototype.setScrollTop = function () {};
	NullScrollbars.prototype.clear = function () {};

	function updateScrollbars(cm, measure) {
	  if (!measure) { measure = measureForScrollbars(cm); }
	  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
	  updateScrollbarsInner(cm, measure);
	  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
	    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
	      { updateHeightsInViewport(cm); }
	    updateScrollbarsInner(cm, measureForScrollbars(cm));
	    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
	  }
	}

	// Re-synchronize the fake scrollbars with the actual size of the
	// content.
	function updateScrollbarsInner(cm, measure) {
	  var d = cm.display;
	  var sizes = d.scrollbars.update(measure);

	  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
	  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
	  d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

	  if (sizes.right && sizes.bottom) {
	    d.scrollbarFiller.style.display = "block";
	    d.scrollbarFiller.style.height = sizes.bottom + "px";
	    d.scrollbarFiller.style.width = sizes.right + "px";
	  } else { d.scrollbarFiller.style.display = ""; }
	  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
	    d.gutterFiller.style.display = "block";
	    d.gutterFiller.style.height = sizes.bottom + "px";
	    d.gutterFiller.style.width = measure.gutterWidth + "px";
	  } else { d.gutterFiller.style.display = ""; }
	}

	var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

	function initScrollbars(cm) {
	  if (cm.display.scrollbars) {
	    cm.display.scrollbars.clear();
	    if (cm.display.scrollbars.addClass)
	      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
	  }

	  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
	    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
	    // Prevent clicks in the scrollbars from killing focus
	    on(node, "mousedown", function () {
	      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
	    });
	    node.setAttribute("cm-not-content", "true");
	  }, function (pos, axis) {
	    if (axis == "horizontal") { setScrollLeft(cm, pos); }
	    else { setScrollTop(cm, pos); }
	  }, cm);
	  if (cm.display.scrollbars.addClass)
	    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
	}

	// SCROLLING THINGS INTO VIEW

	// If an editor sits on the top or bottom of the window, partially
	// scrolled out of view, this ensures that the cursor is visible.
	function maybeScrollWindow(cm, rect) {
	  if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

	  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
	  if (rect.top + box.top < 0) { doScroll = true; }
	  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
	  if (doScroll != null && !phantom) {
	    var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
	    cm.display.lineSpace.appendChild(scrollNode);
	    scrollNode.scrollIntoView(doScroll);
	    cm.display.lineSpace.removeChild(scrollNode);
	  }
	}

	// Scroll a given position into view (immediately), verifying that
	// it actually became visible (as line heights are accurately
	// measured, the position of something may 'drift' during drawing).
	function scrollPosIntoView(cm, pos, end, margin) {
	  if (margin == null) { margin = 0; }
	  var rect;
	  for (var limit = 0; limit < 5; limit++) {
	    var changed = false;
	    var coords = cursorCoords(cm, pos);
	    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
	    rect = {left: Math.min(coords.left, endCoords.left),
	            top: Math.min(coords.top, endCoords.top) - margin,
	            right: Math.max(coords.left, endCoords.left),
	            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
	    var scrollPos = calculateScrollPos(cm, rect);
	    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
	    if (scrollPos.scrollTop != null) {
	      setScrollTop(cm, scrollPos.scrollTop);
	      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
	    }
	    if (scrollPos.scrollLeft != null) {
	      setScrollLeft(cm, scrollPos.scrollLeft);
	      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
	    }
	    if (!changed) { break }
	  }
	  return rect
	}

	// Scroll a given set of coordinates into view (immediately).
	function scrollIntoView(cm, rect) {
	  var scrollPos = calculateScrollPos(cm, rect);
	  if (scrollPos.scrollTop != null) { setScrollTop(cm, scrollPos.scrollTop); }
	  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
	}

	// Calculate a new scroll position needed to scroll the given
	// rectangle into view. Returns an object with scrollTop and
	// scrollLeft properties. When these are undefined, the
	// vertical/horizontal position does not need to be adjusted.
	function calculateScrollPos(cm, rect) {
	  var display = cm.display, snapMargin = textHeight(cm.display);
	  if (rect.top < 0) { rect.top = 0; }
	  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
	  var screen = displayHeight(cm), result = {};
	  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
	  var docBottom = cm.doc.height + paddingVert(display);
	  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
	  if (rect.top < screentop) {
	    result.scrollTop = atTop ? 0 : rect.top;
	  } else if (rect.bottom > screentop + screen) {
	    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
	    if (newTop != screentop) { result.scrollTop = newTop; }
	  }

	  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
	  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
	  var tooWide = rect.right - rect.left > screenw;
	  if (tooWide) { rect.right = rect.left + screenw; }
	  if (rect.left < 10)
	    { result.scrollLeft = 0; }
	  else if (rect.left < screenleft)
	    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
	  else if (rect.right > screenw + screenleft - 3)
	    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
	  return result
	}

	// Store a relative adjustment to the scroll position in the current
	// operation (to be applied when the operation finishes).
	function addToScrollPos(cm, left, top) {
	  if (left != null || top != null) { resolveScrollToPos(cm); }
	  if (left != null)
	    { cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left; }
	  if (top != null)
	    { cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top; }
	}

	// Make sure that at the end of the operation the current cursor is
	// shown.
	function ensureCursorVisible(cm) {
	  resolveScrollToPos(cm);
	  var cur = cm.getCursor(), from = cur, to = cur;
	  if (!cm.options.lineWrapping) {
	    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
	    to = Pos(cur.line, cur.ch + 1);
	  }
	  cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin};
	}

	// When an operation has its scrollToPos property set, and another
	// scroll action is applied before the end of the operation, this
	// 'simulates' scrolling that position into view in a cheap way, so
	// that the effect of intermediate scroll commands is not ignored.
	function resolveScrollToPos(cm) {
	  var range$$1 = cm.curOp.scrollToPos;
	  if (range$$1) {
	    cm.curOp.scrollToPos = null;
	    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
	    var sPos = calculateScrollPos(cm, {
	      left: Math.min(from.left, to.left),
	      top: Math.min(from.top, to.top) - range$$1.margin,
	      right: Math.max(from.right, to.right),
	      bottom: Math.max(from.bottom, to.bottom) + range$$1.margin
	    });
	    cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
	  }
	}

	// Operations are used to wrap a series of changes to the editor
	// state in such a way that each change won't have to update the
	// cursor and display (which would be awkward, slow, and
	// error-prone). Instead, display updates are batched and then all
	// combined and executed at once.

	var nextOpId = 0;
	// Start a new operation.
	function startOperation(cm) {
	  cm.curOp = {
	    cm: cm,
	    viewChanged: false,      // Flag that indicates that lines might need to be redrawn
	    startHeight: cm.doc.height, // Used to detect need to update scrollbar
	    forceUpdate: false,      // Used to force a redraw
	    updateInput: null,       // Whether to reset the input textarea
	    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
	    changeObjs: null,        // Accumulated changes, for firing change events
	    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
	    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
	    selectionChanged: false, // Whether the selection needs to be redrawn
	    updateMaxLine: false,    // Set when the widest line needs to be determined anew
	    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
	    scrollToPos: null,       // Used to scroll to a specific position
	    focus: false,
	    id: ++nextOpId           // Unique ID
	  };
	  pushOperation(cm.curOp);
	}

	// Finish an operation, updating the display and signalling delayed events
	function endOperation(cm) {
	  var op = cm.curOp;
	  finishOperation(op, function (group) {
	    for (var i = 0; i < group.ops.length; i++)
	      { group.ops[i].cm.curOp = null; }
	    endOperations(group);
	  });
	}

	// The DOM updates done when an operation finishes are batched so
	// that the minimum number of relayouts are required.
	function endOperations(group) {
	  var ops = group.ops;
	  for (var i = 0; i < ops.length; i++) // Read DOM
	    { endOperation_R1(ops[i]); }
	  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
	    { endOperation_W1(ops[i$1]); }
	  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
	    { endOperation_R2(ops[i$2]); }
	  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
	    { endOperation_W2(ops[i$3]); }
	  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
	    { endOperation_finish(ops[i$4]); }
	}

	function endOperation_R1(op) {
	  var cm = op.cm, display = cm.display;
	  maybeClipScrollbars(cm);
	  if (op.updateMaxLine) { findMaxLine(cm); }

	  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
	    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
	                       op.scrollToPos.to.line >= display.viewTo) ||
	    display.maxLineChanged && cm.options.lineWrapping;
	  op.update = op.mustUpdate &&
	    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
	}

	function endOperation_W1(op) {
	  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
	}

	function endOperation_R2(op) {
	  var cm = op.cm, display = cm.display;
	  if (op.updatedDisplay) { updateHeightsInViewport(cm); }

	  op.barMeasure = measureForScrollbars(cm);

	  // If the max line changed since it was last measured, measure it,
	  // and ensure the document's width matches it.
	  // updateDisplay_W2 will use these properties to do the actual resizing
	  if (display.maxLineChanged && !cm.options.lineWrapping) {
	    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
	    cm.display.sizerWidth = op.adjustWidthTo;
	    op.barMeasure.scrollWidth =
	      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
	    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
	  }

	  if (op.updatedDisplay || op.selectionChanged)
	    { op.preparedSelection = display.input.prepareSelection(op.focus); }
	}

	function endOperation_W2(op) {
	  var cm = op.cm;

	  if (op.adjustWidthTo != null) {
	    cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
	    if (op.maxScrollLeft < cm.doc.scrollLeft)
	      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
	    cm.display.maxLineChanged = false;
	  }

	  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus());
	  if (op.preparedSelection)
	    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
	  if (op.updatedDisplay || op.startHeight != cm.doc.height)
	    { updateScrollbars(cm, op.barMeasure); }
	  if (op.updatedDisplay)
	    { setDocumentHeight(cm, op.barMeasure); }

	  if (op.selectionChanged) { restartBlink(cm); }

	  if (cm.state.focused && op.updateInput)
	    { cm.display.input.reset(op.typing); }
	  if (takeFocus) { ensureFocus(op.cm); }
	}

	function endOperation_finish(op) {
	  var cm = op.cm, display = cm.display, doc = cm.doc;

	  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

	  // Abort mouse wheel delta measurement, when scrolling explicitly
	  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
	    { display.wheelStartX = display.wheelStartY = null; }

	  // Propagate the scroll position to the actual DOM scroller
	  if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
	    doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
	    display.scrollbars.setScrollTop(doc.scrollTop);
	    display.scroller.scrollTop = doc.scrollTop;
	  }
	  if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
	    doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
	    display.scrollbars.setScrollLeft(doc.scrollLeft);
	    display.scroller.scrollLeft = doc.scrollLeft;
	    alignHorizontally(cm);
	  }
	  // If we need to scroll a specific position into view, do so.
	  if (op.scrollToPos) {
	    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
	                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
	    maybeScrollWindow(cm, rect);
	  }

	  // Fire events for markers that are hidden/unidden by editing or
	  // undoing
	  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
	  if (hidden) { for (var i = 0; i < hidden.length; ++i)
	    { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
	  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
	    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

	  if (display.wrapper.offsetHeight)
	    { doc.scrollTop = cm.display.scroller.scrollTop; }

	  // Fire change events, and delayed event handlers
	  if (op.changeObjs)
	    { signal(cm, "changes", cm, op.changeObjs); }
	  if (op.update)
	    { op.update.finish(); }
	}

	// Run the given function in an operation
	function runInOp(cm, f) {
	  if (cm.curOp) { return f() }
	  startOperation(cm);
	  try { return f() }
	  finally { endOperation(cm); }
	}
	// Wraps a function in an operation. Returns the wrapped function.
	function operation(cm, f) {
	  return function() {
	    if (cm.curOp) { return f.apply(cm, arguments) }
	    startOperation(cm);
	    try { return f.apply(cm, arguments) }
	    finally { endOperation(cm); }
	  }
	}
	// Used to add methods to editor and doc instances, wrapping them in
	// operations.
	function methodOp(f) {
	  return function() {
	    if (this.curOp) { return f.apply(this, arguments) }
	    startOperation(this);
	    try { return f.apply(this, arguments) }
	    finally { endOperation(this); }
	  }
	}
	function docMethodOp(f) {
	  return function() {
	    var cm = this.cm;
	    if (!cm || cm.curOp) { return f.apply(this, arguments) }
	    startOperation(cm);
	    try { return f.apply(this, arguments) }
	    finally { endOperation(cm); }
	  }
	}

	// Updates the display.view data structure for a given change to the
	// document. From and to are in pre-change coordinates. Lendiff is
	// the amount of lines added or subtracted by the change. This is
	// used for changes that span multiple lines, or change the way
	// lines are divided into visual lines. regLineChange (below)
	// registers single-line changes.
	function regChange(cm, from, to, lendiff) {
	  if (from == null) { from = cm.doc.first; }
	  if (to == null) { to = cm.doc.first + cm.doc.size; }
	  if (!lendiff) { lendiff = 0; }

	  var display = cm.display;
	  if (lendiff && to < display.viewTo &&
	      (display.updateLineNumbers == null || display.updateLineNumbers > from))
	    { display.updateLineNumbers = from; }

	  cm.curOp.viewChanged = true;

	  if (from >= display.viewTo) { // Change after
	    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
	      { resetView(cm); }
	  } else if (to <= display.viewFrom) { // Change before
	    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
	      resetView(cm);
	    } else {
	      display.viewFrom += lendiff;
	      display.viewTo += lendiff;
	    }
	  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
	    resetView(cm);
	  } else if (from <= display.viewFrom) { // Top overlap
	    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
	    if (cut) {
	      display.view = display.view.slice(cut.index);
	      display.viewFrom = cut.lineN;
	      display.viewTo += lendiff;
	    } else {
	      resetView(cm);
	    }
	  } else if (to >= display.viewTo) { // Bottom overlap
	    var cut$1 = viewCuttingPoint(cm, from, from, -1);
	    if (cut$1) {
	      display.view = display.view.slice(0, cut$1.index);
	      display.viewTo = cut$1.lineN;
	    } else {
	      resetView(cm);
	    }
	  } else { // Gap in the middle
	    var cutTop = viewCuttingPoint(cm, from, from, -1);
	    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
	    if (cutTop && cutBot) {
	      display.view = display.view.slice(0, cutTop.index)
	        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
	        .concat(display.view.slice(cutBot.index));
	      display.viewTo += lendiff;
	    } else {
	      resetView(cm);
	    }
	  }

	  var ext = display.externalMeasured;
	  if (ext) {
	    if (to < ext.lineN)
	      { ext.lineN += lendiff; }
	    else if (from < ext.lineN + ext.size)
	      { display.externalMeasured = null; }
	  }
	}

	// Register a change to a single line. Type must be one of "text",
	// "gutter", "class", "widget"
	function regLineChange(cm, line, type) {
	  cm.curOp.viewChanged = true;
	  var display = cm.display, ext = cm.display.externalMeasured;
	  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
	    { display.externalMeasured = null; }

	  if (line < display.viewFrom || line >= display.viewTo) { return }
	  var lineView = display.view[findViewIndex(cm, line)];
	  if (lineView.node == null) { return }
	  var arr = lineView.changes || (lineView.changes = []);
	  if (indexOf(arr, type) == -1) { arr.push(type); }
	}

	// Clear the view.
	function resetView(cm) {
	  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
	  cm.display.view = [];
	  cm.display.viewOffset = 0;
	}

	function viewCuttingPoint(cm, oldN, newN, dir) {
	  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
	  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
	    { return {index: index, lineN: newN} }
	  var n = cm.display.viewFrom;
	  for (var i = 0; i < index; i++)
	    { n += view[i].size; }
	  if (n != oldN) {
	    if (dir > 0) {
	      if (index == view.length - 1) { return null }
	      diff = (n + view[index].size) - oldN;
	      index++;
	    } else {
	      diff = n - oldN;
	    }
	    oldN += diff; newN += diff;
	  }
	  while (visualLineNo(cm.doc, newN) != newN) {
	    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
	    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
	    index += dir;
	  }
	  return {index: index, lineN: newN}
	}

	// Force the view to cover a given range, adding empty view element
	// or clipping off existing ones as needed.
	function adjustView(cm, from, to) {
	  var display = cm.display, view = display.view;
	  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
	    display.view = buildViewArray(cm, from, to);
	    display.viewFrom = from;
	  } else {
	    if (display.viewFrom > from)
	      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
	    else if (display.viewFrom < from)
	      { display.view = display.view.slice(findViewIndex(cm, from)); }
	    display.viewFrom = from;
	    if (display.viewTo < to)
	      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
	    else if (display.viewTo > to)
	      { display.view = display.view.slice(0, findViewIndex(cm, to)); }
	  }
	  display.viewTo = to;
	}

	// Count the number of lines in the view whose DOM representation is
	// out of date (or nonexistent).
	function countDirtyView(cm) {
	  var view = cm.display.view, dirty = 0;
	  for (var i = 0; i < view.length; i++) {
	    var lineView = view[i];
	    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
	  }
	  return dirty
	}

	// HIGHLIGHT WORKER

	function startWorker(cm, time) {
	  if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
	    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
	}

	function highlightWorker(cm) {
	  var doc = cm.doc;
	  if (doc.frontier < doc.first) { doc.frontier = doc.first; }
	  if (doc.frontier >= cm.display.viewTo) { return }
	  var end = +new Date + cm.options.workTime;
	  var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
	  var changedLines = [];

	  doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
	    if (doc.frontier >= cm.display.viewFrom) { // Visible
	      var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;
	      var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);
	      line.styles = highlighted.styles;
	      var oldCls = line.styleClasses, newCls = highlighted.classes;
	      if (newCls) { line.styleClasses = newCls; }
	      else if (oldCls) { line.styleClasses = null; }
	      var ischange = !oldStyles || oldStyles.length != line.styles.length ||
	        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
	      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
	      if (ischange) { changedLines.push(doc.frontier); }
	      line.stateAfter = tooLong ? state : copyState(doc.mode, state);
	    } else {
	      if (line.text.length <= cm.options.maxHighlightLength)
	        { processLine(cm, line.text, state); }
	      line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
	    }
	    ++doc.frontier;
	    if (+new Date > end) {
	      startWorker(cm, cm.options.workDelay);
	      return true
	    }
	  });
	  if (changedLines.length) { runInOp(cm, function () {
	    for (var i = 0; i < changedLines.length; i++)
	      { regLineChange(cm, changedLines[i], "text"); }
	  }); }
	}

	// DISPLAY DRAWING

	var DisplayUpdate = function(cm, viewport, force) {
	  var display = cm.display;

	  this.viewport = viewport;
	  // Store some values that we'll need later (but don't want to force a relayout for)
	  this.visible = visibleLines(display, cm.doc, viewport);
	  this.editorIsHidden = !display.wrapper.offsetWidth;
	  this.wrapperHeight = display.wrapper.clientHeight;
	  this.wrapperWidth = display.wrapper.clientWidth;
	  this.oldDisplayWidth = displayWidth(cm);
	  this.force = force;
	  this.dims = getDimensions(cm);
	  this.events = [];
	};

	DisplayUpdate.prototype.signal = function (emitter, type) {
	  if (hasHandler(emitter, type))
	    { this.events.push(arguments); }
	};
	DisplayUpdate.prototype.finish = function () {
	    var this$1 = this;

	  for (var i = 0; i < this.events.length; i++)
	    { signal.apply(null, this$1.events[i]); }
	};

	function maybeClipScrollbars(cm) {
	  var display = cm.display;
	  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
	    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
	    display.heightForcer.style.height = scrollGap(cm) + "px";
	    display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
	    display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
	    display.scrollbarsClipped = true;
	  }
	}

	// Does the actual updating of the line display. Bails out
	// (returning false) when there is nothing to be done and forced is
	// false.
	function updateDisplayIfNeeded(cm, update) {
	  var display = cm.display, doc = cm.doc;

	  if (update.editorIsHidden) {
	    resetView(cm);
	    return false
	  }

	  // Bail out if the visible area is already rendered and nothing changed.
	  if (!update.force &&
	      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
	      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
	      display.renderedView == display.view && countDirtyView(cm) == 0)
	    { return false }

	  if (maybeUpdateLineNumberWidth(cm)) {
	    resetView(cm);
	    update.dims = getDimensions(cm);
	  }

	  // Compute a suitable new viewport (from & to)
	  var end = doc.first + doc.size;
	  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
	  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
	  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
	  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
	  if (sawCollapsedSpans) {
	    from = visualLineNo(cm.doc, from);
	    to = visualLineEndNo(cm.doc, to);
	  }

	  var different = from != display.viewFrom || to != display.viewTo ||
	    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
	  adjustView(cm, from, to);

	  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
	  // Position the mover div to align with the current scroll position
	  cm.display.mover.style.top = display.viewOffset + "px";

	  var toUpdate = countDirtyView(cm);
	  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
	      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
	    { return false }

	  // For big changes, we hide the enclosing element during the
	  // update, since that speeds up the operations on most browsers.
	  var focused = activeElt();
	  if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
	  patchDisplay(cm, display.updateLineNumbers, update.dims);
	  if (toUpdate > 4) { display.lineDiv.style.display = ""; }
	  display.renderedView = display.view;
	  // There might have been a widget with a focused element that got
	  // hidden or updated, if so re-focus it.
	  if (focused && activeElt() != focused && focused.offsetHeight) { focused.focus(); }

	  // Prevent selection and cursors from interfering with the scroll
	  // width and height.
	  removeChildren(display.cursorDiv);
	  removeChildren(display.selectionDiv);
	  display.gutters.style.height = display.sizer.style.minHeight = 0;

	  if (different) {
	    display.lastWrapHeight = update.wrapperHeight;
	    display.lastWrapWidth = update.wrapperWidth;
	    startWorker(cm, 400);
	  }

	  display.updateLineNumbers = null;

	  return true
	}

	function postUpdateDisplay(cm, update) {
	  var viewport = update.viewport;

	  for (var first = true;; first = false) {
	    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
	      // Clip forced viewport to actual scrollable area.
	      if (viewport && viewport.top != null)
	        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
	      // Updated line heights might result in the drawn area not
	      // actually covering the viewport. Keep looping until it does.
	      update.visible = visibleLines(cm.display, cm.doc, viewport);
	      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
	        { break }
	    }
	    if (!updateDisplayIfNeeded(cm, update)) { break }
	    updateHeightsInViewport(cm);
	    var barMeasure = measureForScrollbars(cm);
	    updateSelection(cm);
	    updateScrollbars(cm, barMeasure);
	    setDocumentHeight(cm, barMeasure);
	  }

	  update.signal(cm, "update", cm);
	  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
	    update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
	    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
	  }
	}

	function updateDisplaySimple(cm, viewport) {
	  var update = new DisplayUpdate(cm, viewport);
	  if (updateDisplayIfNeeded(cm, update)) {
	    updateHeightsInViewport(cm);
	    postUpdateDisplay(cm, update);
	    var barMeasure = measureForScrollbars(cm);
	    updateSelection(cm);
	    updateScrollbars(cm, barMeasure);
	    setDocumentHeight(cm, barMeasure);
	    update.finish();
	  }
	}

	// Sync the actual display DOM structure with display.view, removing
	// nodes for lines that are no longer in view, and creating the ones
	// that are not there yet, and updating the ones that are out of
	// date.
	function patchDisplay(cm, updateNumbersFrom, dims) {
	  var display = cm.display, lineNumbers = cm.options.lineNumbers;
	  var container = display.lineDiv, cur = container.firstChild;

	  function rm(node) {
	    var next = node.nextSibling;
	    // Works around a throw-scroll bug in OS X Webkit
	    if (webkit && mac && cm.display.currentWheelTarget == node)
	      { node.style.display = "none"; }
	    else
	      { node.parentNode.removeChild(node); }
	    return next
	  }

	  var view = display.view, lineN = display.viewFrom;
	  // Loop over the elements in the view, syncing cur (the DOM nodes
	  // in display.lineDiv) with the view as we go.
	  for (var i = 0; i < view.length; i++) {
	    var lineView = view[i];
	    if (lineView.hidden) {
	    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
	      var node = buildLineElement(cm, lineView, lineN, dims);
	      container.insertBefore(node, cur);
	    } else { // Already drawn
	      while (cur != lineView.node) { cur = rm(cur); }
	      var updateNumber = lineNumbers && updateNumbersFrom != null &&
	        updateNumbersFrom <= lineN && lineView.lineNumber;
	      if (lineView.changes) {
	        if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
	        updateLineForChanges(cm, lineView, lineN, dims);
	      }
	      if (updateNumber) {
	        removeChildren(lineView.lineNumber);
	        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
	      }
	      cur = lineView.node.nextSibling;
	    }
	    lineN += lineView.size;
	  }
	  while (cur) { cur = rm(cur); }
	}

	function updateGutterSpace(cm) {
	  var width = cm.display.gutters.offsetWidth;
	  cm.display.sizer.style.marginLeft = width + "px";
	}

	function setDocumentHeight(cm, measure) {
	  cm.display.sizer.style.minHeight = measure.docHeight + "px";
	  cm.display.heightForcer.style.top = measure.docHeight + "px";
	  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
	}

	// Rebuild the gutter elements, ensure the margin to the left of the
	// code matches their width.
	function updateGutters(cm) {
	  var gutters = cm.display.gutters, specs = cm.options.gutters;
	  removeChildren(gutters);
	  var i = 0;
	  for (; i < specs.length; ++i) {
	    var gutterClass = specs[i];
	    var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
	    if (gutterClass == "CodeMirror-linenumbers") {
	      cm.display.lineGutter = gElt;
	      gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
	    }
	  }
	  gutters.style.display = i ? "" : "none";
	  updateGutterSpace(cm);
	}

	// Make sure the gutters options contains the element
	// "CodeMirror-linenumbers" when the lineNumbers option is true.
	function setGuttersForLineNumbers(options) {
	  var found = indexOf(options.gutters, "CodeMirror-linenumbers");
	  if (found == -1 && options.lineNumbers) {
	    options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
	  } else if (found > -1 && !options.lineNumbers) {
	    options.gutters = options.gutters.slice(0);
	    options.gutters.splice(found, 1);
	  }
	}

	// Selection objects are immutable. A new one is created every time
	// the selection changes. A selection is one or more non-overlapping
	// (and non-touching) ranges, sorted, and an integer that indicates
	// which one is the primary selection (the one that's scrolled into
	// view, that getCursor returns, etc).
	var Selection = function(ranges, primIndex) {
	  this.ranges = ranges;
	  this.primIndex = primIndex;
	};

	Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

	Selection.prototype.equals = function (other) {
	    var this$1 = this;

	  if (other == this) { return true }
	  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
	  for (var i = 0; i < this.ranges.length; i++) {
	    var here = this$1.ranges[i], there = other.ranges[i];
	    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
	  }
	  return true
	};

	Selection.prototype.deepCopy = function () {
	    var this$1 = this;

	  var out = [];
	  for (var i = 0; i < this.ranges.length; i++)
	    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }
	  return new Selection(out, this.primIndex)
	};

	Selection.prototype.somethingSelected = function () {
	    var this$1 = this;

	  for (var i = 0; i < this.ranges.length; i++)
	    { if (!this$1.ranges[i].empty()) { return true } }
	  return false
	};

	Selection.prototype.contains = function (pos, end) {
	    var this$1 = this;

	  if (!end) { end = pos; }
	  for (var i = 0; i < this.ranges.length; i++) {
	    var range = this$1.ranges[i];
	    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
	      { return i }
	  }
	  return -1
	};

	var Range = function(anchor, head) {
	  this.anchor = anchor; this.head = head;
	};

	Range.prototype.from = function () { return minPos(this.anchor, this.head) };
	Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
	Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

	// Take an unsorted, potentially overlapping set of ranges, and
	// build a selection out of it. 'Consumes' ranges array (modifying
	// it).
	function normalizeSelection(ranges, primIndex) {
	  var prim = ranges[primIndex];
	  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
	  primIndex = indexOf(ranges, prim);
	  for (var i = 1; i < ranges.length; i++) {
	    var cur = ranges[i], prev = ranges[i - 1];
	    if (cmp(prev.to(), cur.from()) >= 0) {
	      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
	      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
	      if (i <= primIndex) { --primIndex; }
	      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
	    }
	  }
	  return new Selection(ranges, primIndex)
	}

	function simpleSelection(anchor, head) {
	  return new Selection([new Range(anchor, head || anchor)], 0)
	}

	// Compute the position of the end of a change (its 'to' property
	// refers to the pre-change end).
	function changeEnd(change) {
	  if (!change.text) { return change.to }
	  return Pos(change.from.line + change.text.length - 1,
	             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
	}

	// Adjust a position to refer to the post-change position of the
	// same text, or the end of the change if the change covers it.
	function adjustForChange(pos, change) {
	  if (cmp(pos, change.from) < 0) { return pos }
	  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

	  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
	  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
	  return Pos(line, ch)
	}

	function computeSelAfterChange(doc, change) {
	  var out = [];
	  for (var i = 0; i < doc.sel.ranges.length; i++) {
	    var range = doc.sel.ranges[i];
	    out.push(new Range(adjustForChange(range.anchor, change),
	                       adjustForChange(range.head, change)));
	  }
	  return normalizeSelection(out, doc.sel.primIndex)
	}

	function offsetPos(pos, old, nw) {
	  if (pos.line == old.line)
	    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
	  else
	    { return Pos(nw.line + (pos.line - old.line), pos.ch) }
	}

	// Used by replaceSelections to allow moving the selection to the
	// start or around the replaced test. Hint may be "start" or "around".
	function computeReplacedSel(doc, changes, hint) {
	  var out = [];
	  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
	  for (var i = 0; i < changes.length; i++) {
	    var change = changes[i];
	    var from = offsetPos(change.from, oldPrev, newPrev);
	    var to = offsetPos(changeEnd(change), oldPrev, newPrev);
	    oldPrev = change.to;
	    newPrev = to;
	    if (hint == "around") {
	      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
	      out[i] = new Range(inv ? to : from, inv ? from : to);
	    } else {
	      out[i] = new Range(from, from);
	    }
	  }
	  return new Selection(out, doc.sel.primIndex)
	}

	// Used to get the editor into a consistent state again when options change.

	function loadMode(cm) {
	  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
	  resetModeState(cm);
	}

	function resetModeState(cm) {
	  cm.doc.iter(function (line) {
	    if (line.stateAfter) { line.stateAfter = null; }
	    if (line.styles) { line.styles = null; }
	  });
	  cm.doc.frontier = cm.doc.first;
	  startWorker(cm, 100);
	  cm.state.modeGen++;
	  if (cm.curOp) { regChange(cm); }
	}

	// DOCUMENT DATA STRUCTURE

	// By default, updates that start and end at the beginning of a line
	// are treated specially, in order to make the association of line
	// widgets and marker elements with the text behave more intuitive.
	function isWholeLineUpdate(doc, change) {
	  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
	    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
	}

	// Perform a change on the document data structure.
	function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
	  function spansFor(n) {return markedSpans ? markedSpans[n] : null}
	  function update(line, text, spans) {
	    updateLine(line, text, spans, estimateHeight$$1);
	    signalLater(line, "change", line, change);
	  }
	  function linesFor(start, end) {
	    var result = [];
	    for (var i = start; i < end; ++i)
	      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
	    return result
	  }

	  var from = change.from, to = change.to, text = change.text;
	  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
	  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

	  // Adjust the line structure
	  if (change.full) {
	    doc.insert(0, linesFor(0, text.length));
	    doc.remove(text.length, doc.size - text.length);
	  } else if (isWholeLineUpdate(doc, change)) {
	    // This is a whole-line replace. Treated specially to make
	    // sure line objects move the way they are supposed to.
	    var added = linesFor(0, text.length - 1);
	    update(lastLine, lastLine.text, lastSpans);
	    if (nlines) { doc.remove(from.line, nlines); }
	    if (added.length) { doc.insert(from.line, added); }
	  } else if (firstLine == lastLine) {
	    if (text.length == 1) {
	      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
	    } else {
	      var added$1 = linesFor(1, text.length - 1);
	      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	      doc.insert(from.line + 1, added$1);
	    }
	  } else if (text.length == 1) {
	    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
	    doc.remove(from.line + 1, nlines);
	  } else {
	    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
	    var added$2 = linesFor(1, text.length - 1);
	    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
	    doc.insert(from.line + 1, added$2);
	  }

	  signalLater(doc, "change", doc, change);
	}

	// Call f for all linked documents.
	function linkedDocs(doc, f, sharedHistOnly) {
	  function propagate(doc, skip, sharedHist) {
	    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
	      var rel = doc.linked[i];
	      if (rel.doc == skip) { continue }
	      var shared = sharedHist && rel.sharedHist;
	      if (sharedHistOnly && !shared) { continue }
	      f(rel.doc, shared);
	      propagate(rel.doc, doc, shared);
	    } }
	  }
	  propagate(doc, null, true);
	}

	// Attach a document to an editor.
	function attachDoc(cm, doc) {
	  if (doc.cm) { throw new Error("This document is already in use.") }
	  cm.doc = doc;
	  doc.cm = cm;
	  estimateLineHeights(cm);
	  loadMode(cm);
	  setDirectionClass(cm);
	  if (!cm.options.lineWrapping) { findMaxLine(cm); }
	  cm.options.mode = doc.modeOption;
	  regChange(cm);
	}

	function setDirectionClass(cm) {
	  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
	}

	function directionChanged(cm) {
	  runInOp(cm, function () {
	    setDirectionClass(cm);
	    regChange(cm);
	  });
	}

	function History(startGen) {
	  // Arrays of change events and selections. Doing something adds an
	  // event to done and clears undo. Undoing moves events from done
	  // to undone, redoing moves them in the other direction.
	  this.done = []; this.undone = [];
	  this.undoDepth = Infinity;
	  // Used to track when changes can be merged into a single undo
	  // event
	  this.lastModTime = this.lastSelTime = 0;
	  this.lastOp = this.lastSelOp = null;
	  this.lastOrigin = this.lastSelOrigin = null;
	  // Used by the isClean() method
	  this.generation = this.maxGeneration = startGen || 1;
	}

	// Create a history change event from an updateDoc-style change
	// object.
	function historyChangeFromChange(doc, change) {
	  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
	  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
	  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
	  return histChange
	}

	// Pop all selection events off the end of a history array. Stop at
	// a change event.
	function clearSelectionEvents(array) {
	  while (array.length) {
	    var last = lst(array);
	    if (last.ranges) { array.pop(); }
	    else { break }
	  }
	}

	// Find the top change event in the history. Pop off selection
	// events that are in the way.
	function lastChangeEvent(hist, force) {
	  if (force) {
	    clearSelectionEvents(hist.done);
	    return lst(hist.done)
	  } else if (hist.done.length && !lst(hist.done).ranges) {
	    return lst(hist.done)
	  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
	    hist.done.pop();
	    return lst(hist.done)
	  }
	}

	// Register a change in the history. Merges changes that are within
	// a single operation, or are close together with an origin that
	// allows merging (starting with "+") into a single event.
	function addChangeToHistory(doc, change, selAfter, opId) {
	  var hist = doc.history;
	  hist.undone.length = 0;
	  var time = +new Date, cur;
	  var last;

	  if ((hist.lastOp == opId ||
	       hist.lastOrigin == change.origin && change.origin &&
	       ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
	        change.origin.charAt(0) == "*")) &&
	      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
	    // Merge this change into the last event
	    last = lst(cur.changes);
	    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
	      // Optimized case for simple insertion -- don't want to add
	      // new changesets for every character typed
	      last.to = changeEnd(change);
	    } else {
	      // Add new sub-event
	      cur.changes.push(historyChangeFromChange(doc, change));
	    }
	  } else {
	    // Can not be merged, start a new event.
	    var before = lst(hist.done);
	    if (!before || !before.ranges)
	      { pushSelectionToHistory(doc.sel, hist.done); }
	    cur = {changes: [historyChangeFromChange(doc, change)],
	           generation: hist.generation};
	    hist.done.push(cur);
	    while (hist.done.length > hist.undoDepth) {
	      hist.done.shift();
	      if (!hist.done[0].ranges) { hist.done.shift(); }
	    }
	  }
	  hist.done.push(selAfter);
	  hist.generation = ++hist.maxGeneration;
	  hist.lastModTime = hist.lastSelTime = time;
	  hist.lastOp = hist.lastSelOp = opId;
	  hist.lastOrigin = hist.lastSelOrigin = change.origin;

	  if (!last) { signal(doc, "historyAdded"); }
	}

	function selectionEventCanBeMerged(doc, origin, prev, sel) {
	  var ch = origin.charAt(0);
	  return ch == "*" ||
	    ch == "+" &&
	    prev.ranges.length == sel.ranges.length &&
	    prev.somethingSelected() == sel.somethingSelected() &&
	    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
	}

	// Called whenever the selection changes, sets the new selection as
	// the pending selection in the history, and pushes the old pending
	// selection into the 'done' array when it was significantly
	// different (in number of selected ranges, emptiness, or time).
	function addSelectionToHistory(doc, sel, opId, options) {
	  var hist = doc.history, origin = options && options.origin;

	  // A new event is started when the previous origin does not match
	  // the current, or the origins don't allow matching. Origins
	  // starting with * are always merged, those starting with + are
	  // merged when similar and close together in time.
	  if (opId == hist.lastSelOp ||
	      (origin && hist.lastSelOrigin == origin &&
	       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
	        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
	    { hist.done[hist.done.length - 1] = sel; }
	  else
	    { pushSelectionToHistory(sel, hist.done); }

	  hist.lastSelTime = +new Date;
	  hist.lastSelOrigin = origin;
	  hist.lastSelOp = opId;
	  if (options && options.clearRedo !== false)
	    { clearSelectionEvents(hist.undone); }
	}

	function pushSelectionToHistory(sel, dest) {
	  var top = lst(dest);
	  if (!(top && top.ranges && top.equals(sel)))
	    { dest.push(sel); }
	}

	// Used to store marked span information in the history.
	function attachLocalSpans(doc, change, from, to) {
	  var existing = change["spans_" + doc.id], n = 0;
	  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
	    if (line.markedSpans)
	      { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
	    ++n;
	  });
	}

	// When un/re-doing restores text containing marked spans, those
	// that have been explicitly cleared should not be restored.
	function removeClearedSpans(spans) {
	  if (!spans) { return null }
	  var out;
	  for (var i = 0; i < spans.length; ++i) {
	    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
	    else if (out) { out.push(spans[i]); }
	  }
	  return !out ? spans : out.length ? out : null
	}

	// Retrieve and filter the old marked spans stored in a change event.
	function getOldSpans(doc, change) {
	  var found = change["spans_" + doc.id];
	  if (!found) { return null }
	  var nw = [];
	  for (var i = 0; i < change.text.length; ++i)
	    { nw.push(removeClearedSpans(found[i])); }
	  return nw
	}

	// Used for un/re-doing changes from the history. Combines the
	// result of computing the existing spans with the set of spans that
	// existed in the history (so that deleting around a span and then
	// undoing brings back the span).
	function mergeOldSpans(doc, change) {
	  var old = getOldSpans(doc, change);
	  var stretched = stretchSpansOverChange(doc, change);
	  if (!old) { return stretched }
	  if (!stretched) { return old }

	  for (var i = 0; i < old.length; ++i) {
	    var oldCur = old[i], stretchCur = stretched[i];
	    if (oldCur && stretchCur) {
	      spans: for (var j = 0; j < stretchCur.length; ++j) {
	        var span = stretchCur[j];
	        for (var k = 0; k < oldCur.length; ++k)
	          { if (oldCur[k].marker == span.marker) { continue spans } }
	        oldCur.push(span);
	      }
	    } else if (stretchCur) {
	      old[i] = stretchCur;
	    }
	  }
	  return old
	}

	// Used both to provide a JSON-safe object in .getHistory, and, when
	// detaching a document, to split the history in two
	function copyHistoryArray(events, newGroup, instantiateSel) {
	  var copy = [];
	  for (var i = 0; i < events.length; ++i) {
	    var event = events[i];
	    if (event.ranges) {
	      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
	      continue
	    }
	    var changes = event.changes, newChanges = [];
	    copy.push({changes: newChanges});
	    for (var j = 0; j < changes.length; ++j) {
	      var change = changes[j], m = (void 0);
	      newChanges.push({from: change.from, to: change.to, text: change.text});
	      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
	        if (indexOf(newGroup, Number(m[1])) > -1) {
	          lst(newChanges)[prop] = change[prop];
	          delete change[prop];
	        }
	      } } }
	    }
	  }
	  return copy
	}

	// The 'scroll' parameter given to many of these indicated whether
	// the new cursor position should be scrolled into view after
	// modifying the selection.

	// If shift is held or the extend flag is set, extends a range to
	// include a given position (and optionally a second position).
	// Otherwise, simply returns the range between the given positions.
	// Used for cursor motion and such.
	function extendRange(doc, range, head, other) {
	  if (doc.cm && doc.cm.display.shift || doc.extend) {
	    var anchor = range.anchor;
	    if (other) {
	      var posBefore = cmp(head, anchor) < 0;
	      if (posBefore != (cmp(other, anchor) < 0)) {
	        anchor = head;
	        head = other;
	      } else if (posBefore != (cmp(head, other) < 0)) {
	        head = other;
	      }
	    }
	    return new Range(anchor, head)
	  } else {
	    return new Range(other || head, head)
	  }
	}

	// Extend the primary selection range, discard the rest.
	function extendSelection(doc, head, other, options) {
	  setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
	}

	// Extend all selections (pos is an array of selections with length
	// equal the number of selections)
	function extendSelections(doc, heads, options) {
	  var out = [];
	  for (var i = 0; i < doc.sel.ranges.length; i++)
	    { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null); }
	  var newSel = normalizeSelection(out, doc.sel.primIndex);
	  setSelection(doc, newSel, options);
	}

	// Updates a single range in the selection.
	function replaceOneSelection(doc, i, range, options) {
	  var ranges = doc.sel.ranges.slice(0);
	  ranges[i] = range;
	  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
	}

	// Reset the selection to a single range.
	function setSimpleSelection(doc, anchor, head, options) {
	  setSelection(doc, simpleSelection(anchor, head), options);
	}

	// Give beforeSelectionChange handlers a change to influence a
	// selection update.
	function filterSelectionChange(doc, sel, options) {
	  var obj = {
	    ranges: sel.ranges,
	    update: function(ranges) {
	      var this$1 = this;

	      this.ranges = [];
	      for (var i = 0; i < ranges.length; i++)
	        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
	                                   clipPos(doc, ranges[i].head)); }
	    },
	    origin: options && options.origin
	  };
	  signal(doc, "beforeSelectionChange", doc, obj);
	  if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
	  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }
	  else { return sel }
	}

	function setSelectionReplaceHistory(doc, sel, options) {
	  var done = doc.history.done, last = lst(done);
	  if (last && last.ranges) {
	    done[done.length - 1] = sel;
	    setSelectionNoUndo(doc, sel, options);
	  } else {
	    setSelection(doc, sel, options);
	  }
	}

	// Set a new selection.
	function setSelection(doc, sel, options) {
	  setSelectionNoUndo(doc, sel, options);
	  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
	}

	function setSelectionNoUndo(doc, sel, options) {
	  if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
	    { sel = filterSelectionChange(doc, sel, options); }

	  var bias = options && options.bias ||
	    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
	  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

	  if (!(options && options.scroll === false) && doc.cm)
	    { ensureCursorVisible(doc.cm); }
	}

	function setSelectionInner(doc, sel) {
	  if (sel.equals(doc.sel)) { return }

	  doc.sel = sel;

	  if (doc.cm) {
	    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
	    signalCursorActivity(doc.cm);
	  }
	  signalLater(doc, "cursorActivity", doc);
	}

	// Verify that the selection does not partially select any atomic
	// marked ranges.
	function reCheckSelection(doc) {
	  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
	}

	// Return a selection that does not partially select any atomic
	// ranges.
	function skipAtomicInSelection(doc, sel, bias, mayClear) {
	  var out;
	  for (var i = 0; i < sel.ranges.length; i++) {
	    var range = sel.ranges[i];
	    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
	    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
	    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
	    if (out || newAnchor != range.anchor || newHead != range.head) {
	      if (!out) { out = sel.ranges.slice(0, i); }
	      out[i] = new Range(newAnchor, newHead);
	    }
	  }
	  return out ? normalizeSelection(out, sel.primIndex) : sel
	}

	function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
	  var line = getLine(doc, pos.line);
	  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	    var sp = line.markedSpans[i], m = sp.marker;
	    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
	        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
	      if (mayClear) {
	        signal(m, "beforeCursorEnter");
	        if (m.explicitlyCleared) {
	          if (!line.markedSpans) { break }
	          else {--i; continue}
	        }
	      }
	      if (!m.atomic) { continue }

	      if (oldPos) {
	        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
	        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
	          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
	        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
	          { return skipAtomicInner(doc, near, pos, dir, mayClear) }
	      }

	      var far = m.find(dir < 0 ? -1 : 1);
	      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
	        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
	      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
	    }
	  } }
	  return pos
	}

	// Ensure a given position is not inside an atomic range.
	function skipAtomic(doc, pos, oldPos, bias, mayClear) {
	  var dir = bias || 1;
	  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
	      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
	      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
	      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
	  if (!found) {
	    doc.cantEdit = true;
	    return Pos(doc.first, 0)
	  }
	  return found
	}

	function movePos(doc, pos, dir, line) {
	  if (dir < 0 && pos.ch == 0) {
	    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
	    else { return null }
	  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
	    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
	    else { return null }
	  } else {
	    return new Pos(pos.line, pos.ch + dir)
	  }
	}

	function selectAll(cm) {
	  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
	}

	// UPDATING

	// Allow "beforeChange" event handlers to influence a change
	function filterChange(doc, change, update) {
	  var obj = {
	    canceled: false,
	    from: change.from,
	    to: change.to,
	    text: change.text,
	    origin: change.origin,
	    cancel: function () { return obj.canceled = true; }
	  };
	  if (update) { obj.update = function (from, to, text, origin) {
	    if (from) { obj.from = clipPos(doc, from); }
	    if (to) { obj.to = clipPos(doc, to); }
	    if (text) { obj.text = text; }
	    if (origin !== undefined) { obj.origin = origin; }
	  }; }
	  signal(doc, "beforeChange", doc, obj);
	  if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

	  if (obj.canceled) { return null }
	  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
	}

	// Apply a change to a document, and add it to the document's
	// history, and propagating it to all linked documents.
	function makeChange(doc, change, ignoreReadOnly) {
	  if (doc.cm) {
	    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
	    if (doc.cm.state.suppressEdits) { return }
	  }

	  if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
	    change = filterChange(doc, change, true);
	    if (!change) { return }
	  }

	  // Possibly split or suppress the update based on the presence
	  // of read-only spans in its range.
	  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
	  if (split) {
	    for (var i = split.length - 1; i >= 0; --i)
	      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text}); }
	  } else {
	    makeChangeInner(doc, change);
	  }
	}

	function makeChangeInner(doc, change) {
	  if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
	  var selAfter = computeSelAfterChange(doc, change);
	  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

	  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
	  var rebased = [];

	  linkedDocs(doc, function (doc, sharedHist) {
	    if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	      rebaseHist(doc.history, change);
	      rebased.push(doc.history);
	    }
	    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
	  });
	}

	// Revert a change stored in a document's history.
	function makeChangeFromHistory(doc, type, allowSelectionOnly) {
	  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }

	  var hist = doc.history, event, selAfter = doc.sel;
	  var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

	  // Verify that there is a useable event (so that ctrl-z won't
	  // needlessly clear selection events)
	  var i = 0;
	  for (; i < source.length; i++) {
	    event = source[i];
	    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
	      { break }
	  }
	  if (i == source.length) { return }
	  hist.lastOrigin = hist.lastSelOrigin = null;

	  for (;;) {
	    event = source.pop();
	    if (event.ranges) {
	      pushSelectionToHistory(event, dest);
	      if (allowSelectionOnly && !event.equals(doc.sel)) {
	        setSelection(doc, event, {clearRedo: false});
	        return
	      }
	      selAfter = event;
	    }
	    else { break }
	  }

	  // Build up a reverse change object to add to the opposite history
	  // stack (redo when undoing, and vice versa).
	  var antiChanges = [];
	  pushSelectionToHistory(selAfter, dest);
	  dest.push({changes: antiChanges, generation: hist.generation});
	  hist.generation = event.generation || ++hist.maxGeneration;

	  var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

	  var loop = function ( i ) {
	    var change = event.changes[i];
	    change.origin = type;
	    if (filter && !filterChange(doc, change, false)) {
	      source.length = 0;
	      return {}
	    }

	    antiChanges.push(historyChangeFromChange(doc, change));

	    var after = i ? computeSelAfterChange(doc, change) : lst(source);
	    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
	    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
	    var rebased = [];

	    // Propagate to the linked documents
	    linkedDocs(doc, function (doc, sharedHist) {
	      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	        rebaseHist(doc.history, change);
	        rebased.push(doc.history);
	      }
	      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
	    });
	  };

	  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
	    var returned = loop( i$1 );

	    if ( returned ) return returned.v;
	  }
	}

	// Sub-views need their line numbers shifted when text is added
	// above or below them in the parent document.
	function shiftDoc(doc, distance) {
	  if (distance == 0) { return }
	  doc.first += distance;
	  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
	    Pos(range.anchor.line + distance, range.anchor.ch),
	    Pos(range.head.line + distance, range.head.ch)
	  ); }), doc.sel.primIndex);
	  if (doc.cm) {
	    regChange(doc.cm, doc.first, doc.first - distance, distance);
	    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
	      { regLineChange(doc.cm, l, "gutter"); }
	  }
	}

	// More lower-level change function, handling only a single document
	// (not linked ones).
	function makeChangeSingleDoc(doc, change, selAfter, spans) {
	  if (doc.cm && !doc.cm.curOp)
	    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

	  if (change.to.line < doc.first) {
	    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
	    return
	  }
	  if (change.from.line > doc.lastLine()) { return }

	  // Clip the change to the size of this doc
	  if (change.from.line < doc.first) {
	    var shift = change.text.length - 1 - (doc.first - change.from.line);
	    shiftDoc(doc, shift);
	    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
	              text: [lst(change.text)], origin: change.origin};
	  }
	  var last = doc.lastLine();
	  if (change.to.line > last) {
	    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
	              text: [change.text[0]], origin: change.origin};
	  }

	  change.removed = getBetween(doc, change.from, change.to);

	  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
	  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
	  else { updateDoc(doc, change, spans); }
	  setSelectionNoUndo(doc, selAfter, sel_dontScroll);
	}

	// Handle the interaction of a change to a document with the editor
	// that this document is part of.
	function makeChangeSingleDocInEditor(cm, change, spans) {
	  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

	  var recomputeMaxLength = false, checkWidthStart = from.line;
	  if (!cm.options.lineWrapping) {
	    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
	    doc.iter(checkWidthStart, to.line + 1, function (line) {
	      if (line == display.maxLine) {
	        recomputeMaxLength = true;
	        return true
	      }
	    });
	  }

	  if (doc.sel.contains(change.from, change.to) > -1)
	    { signalCursorActivity(cm); }

	  updateDoc(doc, change, spans, estimateHeight(cm));

	  if (!cm.options.lineWrapping) {
	    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
	      var len = lineLength(line);
	      if (len > display.maxLineLength) {
	        display.maxLine = line;
	        display.maxLineLength = len;
	        display.maxLineChanged = true;
	        recomputeMaxLength = false;
	      }
	    });
	    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
	  }

	  // Adjust frontier, schedule worker
	  doc.frontier = Math.min(doc.frontier, from.line);
	  startWorker(cm, 400);

	  var lendiff = change.text.length - (to.line - from.line) - 1;
	  // Remember that these lines changed, for updating the display
	  if (change.full)
	    { regChange(cm); }
	  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
	    { regLineChange(cm, from.line, "text"); }
	  else
	    { regChange(cm, from.line, to.line + 1, lendiff); }

	  var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
	  if (changeHandler || changesHandler) {
	    var obj = {
	      from: from, to: to,
	      text: change.text,
	      removed: change.removed,
	      origin: change.origin
	    };
	    if (changeHandler) { signalLater(cm, "change", cm, obj); }
	    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
	  }
	  cm.display.selForContextMenu = null;
	}

	function replaceRange(doc, code, from, to, origin) {
	  if (!to) { to = from; }
	  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
	  if (typeof code == "string") { code = doc.splitLines(code); }
	  makeChange(doc, {from: from, to: to, text: code, origin: origin});
	}

	// Rebasing/resetting history to deal with externally-sourced changes

	function rebaseHistSelSingle(pos, from, to, diff) {
	  if (to < pos.line) {
	    pos.line += diff;
	  } else if (from < pos.line) {
	    pos.line = from;
	    pos.ch = 0;
	  }
	}

	// Tries to rebase an array of history events given a change in the
	// document. If the change touches the same lines as the event, the
	// event, and everything 'behind' it, is discarded. If the change is
	// before the event, the event's positions are updated. Uses a
	// copy-on-write scheme for the positions, to avoid having to
	// reallocate them all on every rebase, but also avoid problems with
	// shared position objects being unsafely updated.
	function rebaseHistArray(array, from, to, diff) {
	  for (var i = 0; i < array.length; ++i) {
	    var sub = array[i], ok = true;
	    if (sub.ranges) {
	      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
	      for (var j = 0; j < sub.ranges.length; j++) {
	        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
	        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
	      }
	      continue
	    }
	    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
	      var cur = sub.changes[j$1];
	      if (to < cur.from.line) {
	        cur.from = Pos(cur.from.line + diff, cur.from.ch);
	        cur.to = Pos(cur.to.line + diff, cur.to.ch);
	      } else if (from <= cur.to.line) {
	        ok = false;
	        break
	      }
	    }
	    if (!ok) {
	      array.splice(0, i + 1);
	      i = 0;
	    }
	  }
	}

	function rebaseHist(hist, change) {
	  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
	  rebaseHistArray(hist.done, from, to, diff);
	  rebaseHistArray(hist.undone, from, to, diff);
	}

	// Utility for applying a change to a line by handle or number,
	// returning the number and optionally registering the line as
	// changed.
	function changeLine(doc, handle, changeType, op) {
	  var no = handle, line = handle;
	  if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
	  else { no = lineNo(handle); }
	  if (no == null) { return null }
	  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
	  return line
	}

	// The document is represented as a BTree consisting of leaves, with
	// chunk of lines in them, and branches, with up to ten leaves or
	// other branch nodes below them. The top node is always a branch
	// node, and is the document object itself (meaning it has
	// additional methods and properties).
	//
	// All nodes have parent links. The tree is used both to go from
	// line numbers to line objects, and to go from objects to numbers.
	// It also indexes by height, and is used to convert between height
	// and line object, and to find the total height of the document.
	//
	// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

	var LeafChunk = function(lines) {
	  var this$1 = this;

	  this.lines = lines;
	  this.parent = null;
	  var height = 0;
	  for (var i = 0; i < lines.length; ++i) {
	    lines[i].parent = this$1;
	    height += lines[i].height;
	  }
	  this.height = height;
	};

	LeafChunk.prototype.chunkSize = function () { return this.lines.length };

	// Remove the n lines at offset 'at'.
	LeafChunk.prototype.removeInner = function (at, n) {
	    var this$1 = this;

	  for (var i = at, e = at + n; i < e; ++i) {
	    var line = this$1.lines[i];
	    this$1.height -= line.height;
	    cleanUpLine(line);
	    signalLater(line, "delete");
	  }
	  this.lines.splice(at, n);
	};

	// Helper used to collapse a small branch into a single leaf.
	LeafChunk.prototype.collapse = function (lines) {
	  lines.push.apply(lines, this.lines);
	};

	// Insert the given array of lines at offset 'at', count them as
	// having the given height.
	LeafChunk.prototype.insertInner = function (at, lines, height) {
	    var this$1 = this;

	  this.height += height;
	  this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
	  for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }
	};

	// Used to iterate over a part of the tree.
	LeafChunk.prototype.iterN = function (at, n, op) {
	    var this$1 = this;

	  for (var e = at + n; at < e; ++at)
	    { if (op(this$1.lines[at])) { return true } }
	};

	var BranchChunk = function(children) {
	  var this$1 = this;

	  this.children = children;
	  var size = 0, height = 0;
	  for (var i = 0; i < children.length; ++i) {
	    var ch = children[i];
	    size += ch.chunkSize(); height += ch.height;
	    ch.parent = this$1;
	  }
	  this.size = size;
	  this.height = height;
	  this.parent = null;
	};

	BranchChunk.prototype.chunkSize = function () { return this.size };

	BranchChunk.prototype.removeInner = function (at, n) {
	    var this$1 = this;

	  this.size -= n;
	  for (var i = 0; i < this.children.length; ++i) {
	    var child = this$1.children[i], sz = child.chunkSize();
	    if (at < sz) {
	      var rm = Math.min(n, sz - at), oldHeight = child.height;
	      child.removeInner(at, rm);
	      this$1.height -= oldHeight - child.height;
	      if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }
	      if ((n -= rm) == 0) { break }
	      at = 0;
	    } else { at -= sz; }
	  }
	  // If the result is smaller than 25 lines, ensure that it is a
	  // single leaf node.
	  if (this.size - n < 25 &&
	      (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
	    var lines = [];
	    this.collapse(lines);
	    this.children = [new LeafChunk(lines)];
	    this.children[0].parent = this;
	  }
	};

	BranchChunk.prototype.collapse = function (lines) {
	    var this$1 = this;

	  for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }
	};

	BranchChunk.prototype.insertInner = function (at, lines, height) {
	    var this$1 = this;

	  this.size += lines.length;
	  this.height += height;
	  for (var i = 0; i < this.children.length; ++i) {
	    var child = this$1.children[i], sz = child.chunkSize();
	    if (at <= sz) {
	      child.insertInner(at, lines, height);
	      if (child.lines && child.lines.length > 50) {
	        // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
	        // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
	        var remaining = child.lines.length % 25 + 25;
	        for (var pos = remaining; pos < child.lines.length;) {
	          var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
	          child.height -= leaf.height;
	          this$1.children.splice(++i, 0, leaf);
	          leaf.parent = this$1;
	        }
	        child.lines = child.lines.slice(0, remaining);
	        this$1.maybeSpill();
	      }
	      break
	    }
	    at -= sz;
	  }
	};

	// When a node has grown, check whether it should be split.
	BranchChunk.prototype.maybeSpill = function () {
	  if (this.children.length <= 10) { return }
	  var me = this;
	  do {
	    var spilled = me.children.splice(me.children.length - 5, 5);
	    var sibling = new BranchChunk(spilled);
	    if (!me.parent) { // Become the parent node
	      var copy = new BranchChunk(me.children);
	      copy.parent = me;
	      me.children = [copy, sibling];
	      me = copy;
	   } else {
	      me.size -= sibling.size;
	      me.height -= sibling.height;
	      var myIndex = indexOf(me.parent.children, me);
	      me.parent.children.splice(myIndex + 1, 0, sibling);
	    }
	    sibling.parent = me.parent;
	  } while (me.children.length > 10)
	  me.parent.maybeSpill();
	};

	BranchChunk.prototype.iterN = function (at, n, op) {
	    var this$1 = this;

	  for (var i = 0; i < this.children.length; ++i) {
	    var child = this$1.children[i], sz = child.chunkSize();
	    if (at < sz) {
	      var used = Math.min(n, sz - at);
	      if (child.iterN(at, used, op)) { return true }
	      if ((n -= used) == 0) { break }
	      at = 0;
	    } else { at -= sz; }
	  }
	};

	// Line widgets are block elements displayed above or below a line.

	var LineWidget = function(doc, node, options) {
	  var this$1 = this;

	  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
	    { this$1[opt] = options[opt]; } } }
	  this.doc = doc;
	  this.node = node;
	};

	LineWidget.prototype.clear = function () {
	    var this$1 = this;

	  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
	  if (no == null || !ws) { return }
	  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }
	  if (!ws.length) { line.widgets = null; }
	  var height = widgetHeight(this);
	  updateLineHeight(line, Math.max(0, line.height - height));
	  if (cm) {
	    runInOp(cm, function () {
	      adjustScrollWhenAboveVisible(cm, line, -height);
	      regLineChange(cm, no, "widget");
	    });
	    signalLater(cm, "lineWidgetCleared", cm, this, no);
	  }
	};

	LineWidget.prototype.changed = function () {
	    var this$1 = this;

	  var oldH = this.height, cm = this.doc.cm, line = this.line;
	  this.height = null;
	  var diff = widgetHeight(this) - oldH;
	  if (!diff) { return }
	  updateLineHeight(line, line.height + diff);
	  if (cm) {
	    runInOp(cm, function () {
	      cm.curOp.forceUpdate = true;
	      adjustScrollWhenAboveVisible(cm, line, diff);
	      signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
	    });
	  }
	};
	eventMixin(LineWidget);

	function adjustScrollWhenAboveVisible(cm, line, diff) {
	  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
	    { addToScrollPos(cm, null, diff); }
	}

	function addLineWidget(doc, handle, node, options) {
	  var widget = new LineWidget(doc, node, options);
	  var cm = doc.cm;
	  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
	  changeLine(doc, handle, "widget", function (line) {
	    var widgets = line.widgets || (line.widgets = []);
	    if (widget.insertAt == null) { widgets.push(widget); }
	    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
	    widget.line = line;
	    if (cm && !lineIsHidden(doc, line)) {
	      var aboveVisible = heightAtLine(line) < doc.scrollTop;
	      updateLineHeight(line, line.height + widgetHeight(widget));
	      if (aboveVisible) { addToScrollPos(cm, null, widget.height); }
	      cm.curOp.forceUpdate = true;
	    }
	    return true
	  });
	  signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
	  return widget
	}

	// TEXTMARKERS

	// Created with markText and setBookmark methods. A TextMarker is a
	// handle that can be used to clear or find a marked position in the
	// document. Line objects hold arrays (markedSpans) containing
	// {from, to, marker} object pointing to such marker objects, and
	// indicating that such a marker is present on that line. Multiple
	// lines may point to the same marker when it spans across lines.
	// The spans will have null for their from/to properties when the
	// marker continues beyond the start/end of the line. Markers have
	// links back to the lines they currently touch.

	// Collapsed markers have unique ids, in order to be able to order
	// them, which is needed for uniquely determining an outer marker
	// when they overlap (they may nest, but not partially overlap).
	var nextMarkerId = 0;

	var TextMarker = function(doc, type) {
	  this.lines = [];
	  this.type = type;
	  this.doc = doc;
	  this.id = ++nextMarkerId;
	};

	// Clear the marker.
	TextMarker.prototype.clear = function () {
	    var this$1 = this;

	  if (this.explicitlyCleared) { return }
	  var cm = this.doc.cm, withOp = cm && !cm.curOp;
	  if (withOp) { startOperation(cm); }
	  if (hasHandler(this, "clear")) {
	    var found = this.find();
	    if (found) { signalLater(this, "clear", found.from, found.to); }
	  }
	  var min = null, max = null;
	  for (var i = 0; i < this.lines.length; ++i) {
	    var line = this$1.lines[i];
	    var span = getMarkedSpanFor(line.markedSpans, this$1);
	    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text"); }
	    else if (cm) {
	      if (span.to != null) { max = lineNo(line); }
	      if (span.from != null) { min = lineNo(line); }
	    }
	    line.markedSpans = removeMarkedSpan(line.markedSpans, span);
	    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
	      { updateLineHeight(line, textHeight(cm.display)); }
	  }
	  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
	    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
	    if (len > cm.display.maxLineLength) {
	      cm.display.maxLine = visual;
	      cm.display.maxLineLength = len;
	      cm.display.maxLineChanged = true;
	    }
	  } }

	  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
	  this.lines.length = 0;
	  this.explicitlyCleared = true;
	  if (this.atomic && this.doc.cantEdit) {
	    this.doc.cantEdit = false;
	    if (cm) { reCheckSelection(cm.doc); }
	  }
	  if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
	  if (withOp) { endOperation(cm); }
	  if (this.parent) { this.parent.clear(); }
	};

	// Find the position of the marker in the document. Returns a {from,
	// to} object by default. Side can be passed to get a specific side
	// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
	// Pos objects returned contain a line object, rather than a line
	// number (used to prevent looking up the same line twice).
	TextMarker.prototype.find = function (side, lineObj) {
	    var this$1 = this;

	  if (side == null && this.type == "bookmark") { side = 1; }
	  var from, to;
	  for (var i = 0; i < this.lines.length; ++i) {
	    var line = this$1.lines[i];
	    var span = getMarkedSpanFor(line.markedSpans, this$1);
	    if (span.from != null) {
	      from = Pos(lineObj ? line : lineNo(line), span.from);
	      if (side == -1) { return from }
	    }
	    if (span.to != null) {
	      to = Pos(lineObj ? line : lineNo(line), span.to);
	      if (side == 1) { return to }
	    }
	  }
	  return from && {from: from, to: to}
	};

	// Signals that the marker's widget changed, and surrounding layout
	// should be recomputed.
	TextMarker.prototype.changed = function () {
	    var this$1 = this;

	  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
	  if (!pos || !cm) { return }
	  runInOp(cm, function () {
	    var line = pos.line, lineN = lineNo(pos.line);
	    var view = findViewForLine(cm, lineN);
	    if (view) {
	      clearLineMeasurementCacheFor(view);
	      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
	    }
	    cm.curOp.updateMaxLine = true;
	    if (!lineIsHidden(widget.doc, line) && widget.height != null) {
	      var oldHeight = widget.height;
	      widget.height = null;
	      var dHeight = widgetHeight(widget) - oldHeight;
	      if (dHeight)
	        { updateLineHeight(line, line.height + dHeight); }
	    }
	    signalLater(cm, "markerChanged", cm, this$1);
	  });
	};

	TextMarker.prototype.attachLine = function (line) {
	  if (!this.lines.length && this.doc.cm) {
	    var op = this.doc.cm.curOp;
	    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
	      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
	  }
	  this.lines.push(line);
	};

	TextMarker.prototype.detachLine = function (line) {
	  this.lines.splice(indexOf(this.lines, line), 1);
	  if (!this.lines.length && this.doc.cm) {
	    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
	  }
	};
	eventMixin(TextMarker);

	// Create a marker, wire it up to the right lines, and
	function markText(doc, from, to, options, type) {
	  // Shared markers (across linked documents) are handled separately
	  // (markTextShared will call out to this again, once per
	  // document).
	  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
	  // Ensure we are in an operation.
	  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

	  var marker = new TextMarker(doc, type), diff = cmp(from, to);
	  if (options) { copyObj(options, marker, false); }
	  // Don't connect empty markers unless clearWhenEmpty is false
	  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
	    { return marker }
	  if (marker.replacedWith) {
	    // Showing up as a widget implies collapsed (widget replaces text)
	    marker.collapsed = true;
	    marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
	    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
	    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
	  }
	  if (marker.collapsed) {
	    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
	        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
	      { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
	    seeCollapsedSpans();
	  }

	  if (marker.addToHistory)
	    { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

	  var curLine = from.line, cm = doc.cm, updateMaxLine;
	  doc.iter(curLine, to.line + 1, function (line) {
	    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
	      { updateMaxLine = true; }
	    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
	    addMarkedSpan(line, new MarkedSpan(marker,
	                                       curLine == from.line ? from.ch : null,
	                                       curLine == to.line ? to.ch : null));
	    ++curLine;
	  });
	  // lineIsHidden depends on the presence of the spans, so needs a second pass
	  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
	    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
	  }); }

	  if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

	  if (marker.readOnly) {
	    seeReadOnlySpans();
	    if (doc.history.done.length || doc.history.undone.length)
	      { doc.clearHistory(); }
	  }
	  if (marker.collapsed) {
	    marker.id = ++nextMarkerId;
	    marker.atomic = true;
	  }
	  if (cm) {
	    // Sync editor state
	    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
	    if (marker.collapsed)
	      { regChange(cm, from.line, to.line + 1); }
	    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
	      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
	    if (marker.atomic) { reCheckSelection(cm.doc); }
	    signalLater(cm, "markerAdded", cm, marker);
	  }
	  return marker
	}

	// SHARED TEXTMARKERS

	// A shared marker spans multiple linked documents. It is
	// implemented as a meta-marker-object controlling multiple normal
	// markers.
	var SharedTextMarker = function(markers, primary) {
	  var this$1 = this;

	  this.markers = markers;
	  this.primary = primary;
	  for (var i = 0; i < markers.length; ++i)
	    { markers[i].parent = this$1; }
	};

	SharedTextMarker.prototype.clear = function () {
	    var this$1 = this;

	  if (this.explicitlyCleared) { return }
	  this.explicitlyCleared = true;
	  for (var i = 0; i < this.markers.length; ++i)
	    { this$1.markers[i].clear(); }
	  signalLater(this, "clear");
	};

	SharedTextMarker.prototype.find = function (side, lineObj) {
	  return this.primary.find(side, lineObj)
	};
	eventMixin(SharedTextMarker);

	function markTextShared(doc, from, to, options, type) {
	  options = copyObj(options);
	  options.shared = false;
	  var markers = [markText(doc, from, to, options, type)], primary = markers[0];
	  var widget = options.widgetNode;
	  linkedDocs(doc, function (doc) {
	    if (widget) { options.widgetNode = widget.cloneNode(true); }
	    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
	    for (var i = 0; i < doc.linked.length; ++i)
	      { if (doc.linked[i].isParent) { return } }
	    primary = lst(markers);
	  });
	  return new SharedTextMarker(markers, primary)
	}

	function findSharedMarkers(doc) {
	  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
	}

	function copySharedMarkers(doc, markers) {
	  for (var i = 0; i < markers.length; i++) {
	    var marker = markers[i], pos = marker.find();
	    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
	    if (cmp(mFrom, mTo)) {
	      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
	      marker.markers.push(subMark);
	      subMark.parent = marker;
	    }
	  }
	}

	function detachSharedMarkers(markers) {
	  var loop = function ( i ) {
	    var marker = markers[i], linked = [marker.primary.doc];
	    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
	    for (var j = 0; j < marker.markers.length; j++) {
	      var subMarker = marker.markers[j];
	      if (indexOf(linked, subMarker.doc) == -1) {
	        subMarker.parent = null;
	        marker.markers.splice(j--, 1);
	      }
	    }
	  };

	  for (var i = 0; i < markers.length; i++) loop( i );
	}

	var nextDocId = 0;
	var Doc = function(text, mode, firstLine, lineSep, direction) {
	  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
	  if (firstLine == null) { firstLine = 0; }

	  BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
	  this.first = firstLine;
	  this.scrollTop = this.scrollLeft = 0;
	  this.cantEdit = false;
	  this.cleanGeneration = 1;
	  this.frontier = firstLine;
	  var start = Pos(firstLine, 0);
	  this.sel = simpleSelection(start);
	  this.history = new History(null);
	  this.id = ++nextDocId;
	  this.modeOption = mode;
	  this.lineSep = lineSep;
	  this.direction = (direction == "rtl") ? "rtl" : "ltr";
	  this.extend = false;

	  if (typeof text == "string") { text = this.splitLines(text); }
	  updateDoc(this, {from: start, to: start, text: text});
	  setSelection(this, simpleSelection(start), sel_dontScroll);
	};

	Doc.prototype = createObj(BranchChunk.prototype, {
	  constructor: Doc,
	  // Iterate over the document. Supports two forms -- with only one
	  // argument, it calls that for each line in the document. With
	  // three, it iterates over the range given by the first two (with
	  // the second being non-inclusive).
	  iter: function(from, to, op) {
	    if (op) { this.iterN(from - this.first, to - from, op); }
	    else { this.iterN(this.first, this.first + this.size, from); }
	  },

	  // Non-public interface for adding and removing lines.
	  insert: function(at, lines) {
	    var height = 0;
	    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
	    this.insertInner(at - this.first, lines, height);
	  },
	  remove: function(at, n) { this.removeInner(at - this.first, n); },

	  // From here, the methods are part of the public interface. Most
	  // are also available from CodeMirror (editor) instances.

	  getValue: function(lineSep) {
	    var lines = getLines(this, this.first, this.first + this.size);
	    if (lineSep === false) { return lines }
	    return lines.join(lineSep || this.lineSeparator())
	  },
	  setValue: docMethodOp(function(code) {
	    var top = Pos(this.first, 0), last = this.first + this.size - 1;
	    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
	                      text: this.splitLines(code), origin: "setValue", full: true}, true);
	    setSelection(this, simpleSelection(top));
	  }),
	  replaceRange: function(code, from, to, origin) {
	    from = clipPos(this, from);
	    to = to ? clipPos(this, to) : from;
	    replaceRange(this, code, from, to, origin);
	  },
	  getRange: function(from, to, lineSep) {
	    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
	    if (lineSep === false) { return lines }
	    return lines.join(lineSep || this.lineSeparator())
	  },

	  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

	  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
	  getLineNumber: function(line) {return lineNo(line)},

	  getLineHandleVisualStart: function(line) {
	    if (typeof line == "number") { line = getLine(this, line); }
	    return visualLine(line)
	  },

	  lineCount: function() {return this.size},
	  firstLine: function() {return this.first},
	  lastLine: function() {return this.first + this.size - 1},

	  clipPos: function(pos) {return clipPos(this, pos)},

	  getCursor: function(start) {
	    var range$$1 = this.sel.primary(), pos;
	    if (start == null || start == "head") { pos = range$$1.head; }
	    else if (start == "anchor") { pos = range$$1.anchor; }
	    else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
	    else { pos = range$$1.from(); }
	    return pos
	  },
	  listSelections: function() { return this.sel.ranges },
	  somethingSelected: function() {return this.sel.somethingSelected()},

	  setCursor: docMethodOp(function(line, ch, options) {
	    setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
	  }),
	  setSelection: docMethodOp(function(anchor, head, options) {
	    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
	  }),
	  extendSelection: docMethodOp(function(head, other, options) {
	    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
	  }),
	  extendSelections: docMethodOp(function(heads, options) {
	    extendSelections(this, clipPosArray(this, heads), options);
	  }),
	  extendSelectionsBy: docMethodOp(function(f, options) {
	    var heads = map(this.sel.ranges, f);
	    extendSelections(this, clipPosArray(this, heads), options);
	  }),
	  setSelections: docMethodOp(function(ranges, primary, options) {
	    var this$1 = this;

	    if (!ranges.length) { return }
	    var out = [];
	    for (var i = 0; i < ranges.length; i++)
	      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
	                         clipPos(this$1, ranges[i].head)); }
	    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
	    setSelection(this, normalizeSelection(out, primary), options);
	  }),
	  addSelection: docMethodOp(function(anchor, head, options) {
	    var ranges = this.sel.ranges.slice(0);
	    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
	    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
	  }),

	  getSelection: function(lineSep) {
	    var this$1 = this;

	    var ranges = this.sel.ranges, lines;
	    for (var i = 0; i < ranges.length; i++) {
	      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
	      lines = lines ? lines.concat(sel) : sel;
	    }
	    if (lineSep === false) { return lines }
	    else { return lines.join(lineSep || this.lineSeparator()) }
	  },
	  getSelections: function(lineSep) {
	    var this$1 = this;

	    var parts = [], ranges = this.sel.ranges;
	    for (var i = 0; i < ranges.length; i++) {
	      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
	      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }
	      parts[i] = sel;
	    }
	    return parts
	  },
	  replaceSelection: function(code, collapse, origin) {
	    var dup = [];
	    for (var i = 0; i < this.sel.ranges.length; i++)
	      { dup[i] = code; }
	    this.replaceSelections(dup, collapse, origin || "+input");
	  },
	  replaceSelections: docMethodOp(function(code, collapse, origin) {
	    var this$1 = this;

	    var changes = [], sel = this.sel;
	    for (var i = 0; i < sel.ranges.length; i++) {
	      var range$$1 = sel.ranges[i];
	      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};
	    }
	    var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
	    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
	      { makeChange(this$1, changes[i$1]); }
	    if (newSel) { setSelectionReplaceHistory(this, newSel); }
	    else if (this.cm) { ensureCursorVisible(this.cm); }
	  }),
	  undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
	  redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
	  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
	  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

	  setExtending: function(val) {this.extend = val;},
	  getExtending: function() {return this.extend},

	  historySize: function() {
	    var hist = this.history, done = 0, undone = 0;
	    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
	    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
	    return {undo: done, redo: undone}
	  },
	  clearHistory: function() {this.history = new History(this.history.maxGeneration);},

	  markClean: function() {
	    this.cleanGeneration = this.changeGeneration(true);
	  },
	  changeGeneration: function(forceSplit) {
	    if (forceSplit)
	      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
	    return this.history.generation
	  },
	  isClean: function (gen) {
	    return this.history.generation == (gen || this.cleanGeneration)
	  },

	  getHistory: function() {
	    return {done: copyHistoryArray(this.history.done),
	            undone: copyHistoryArray(this.history.undone)}
	  },
	  setHistory: function(histData) {
	    var hist = this.history = new History(this.history.maxGeneration);
	    hist.done = copyHistoryArray(histData.done.slice(0), null, true);
	    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
	  },

	  setGutterMarker: docMethodOp(function(line, gutterID, value) {
	    return changeLine(this, line, "gutter", function (line) {
	      var markers = line.gutterMarkers || (line.gutterMarkers = {});
	      markers[gutterID] = value;
	      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
	      return true
	    })
	  }),

	  clearGutter: docMethodOp(function(gutterID) {
	    var this$1 = this;

	    this.iter(function (line) {
	      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
	        changeLine(this$1, line, "gutter", function () {
	          line.gutterMarkers[gutterID] = null;
	          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
	          return true
	        });
	      }
	    });
	  }),

	  lineInfo: function(line) {
	    var n;
	    if (typeof line == "number") {
	      if (!isLine(this, line)) { return null }
	      n = line;
	      line = getLine(this, line);
	      if (!line) { return null }
	    } else {
	      n = lineNo(line);
	      if (n == null) { return null }
	    }
	    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
	            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
	            widgets: line.widgets}
	  },

	  addLineClass: docMethodOp(function(handle, where, cls) {
	    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	      var prop = where == "text" ? "textClass"
	               : where == "background" ? "bgClass"
	               : where == "gutter" ? "gutterClass" : "wrapClass";
	      if (!line[prop]) { line[prop] = cls; }
	      else if (classTest(cls).test(line[prop])) { return false }
	      else { line[prop] += " " + cls; }
	      return true
	    })
	  }),
	  removeLineClass: docMethodOp(function(handle, where, cls) {
	    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	      var prop = where == "text" ? "textClass"
	               : where == "background" ? "bgClass"
	               : where == "gutter" ? "gutterClass" : "wrapClass";
	      var cur = line[prop];
	      if (!cur) { return false }
	      else if (cls == null) { line[prop] = null; }
	      else {
	        var found = cur.match(classTest(cls));
	        if (!found) { return false }
	        var end = found.index + found[0].length;
	        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
	      }
	      return true
	    })
	  }),

	  addLineWidget: docMethodOp(function(handle, node, options) {
	    return addLineWidget(this, handle, node, options)
	  }),
	  removeLineWidget: function(widget) { widget.clear(); },

	  markText: function(from, to, options) {
	    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
	  },
	  setBookmark: function(pos, options) {
	    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
	                    insertLeft: options && options.insertLeft,
	                    clearWhenEmpty: false, shared: options && options.shared,
	                    handleMouseEvents: options && options.handleMouseEvents};
	    pos = clipPos(this, pos);
	    return markText(this, pos, pos, realOpts, "bookmark")
	  },
	  findMarksAt: function(pos) {
	    pos = clipPos(this, pos);
	    var markers = [], spans = getLine(this, pos.line).markedSpans;
	    if (spans) { for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if ((span.from == null || span.from <= pos.ch) &&
	          (span.to == null || span.to >= pos.ch))
	        { markers.push(span.marker.parent || span.marker); }
	    } }
	    return markers
	  },
	  findMarks: function(from, to, filter) {
	    from = clipPos(this, from); to = clipPos(this, to);
	    var found = [], lineNo$$1 = from.line;
	    this.iter(from.line, to.line + 1, function (line) {
	      var spans = line.markedSpans;
	      if (spans) { for (var i = 0; i < spans.length; i++) {
	        var span = spans[i];
	        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
	              span.from == null && lineNo$$1 != from.line ||
	              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
	            (!filter || filter(span.marker)))
	          { found.push(span.marker.parent || span.marker); }
	      } }
	      ++lineNo$$1;
	    });
	    return found
	  },
	  getAllMarks: function() {
	    var markers = [];
	    this.iter(function (line) {
	      var sps = line.markedSpans;
	      if (sps) { for (var i = 0; i < sps.length; ++i)
	        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
	    });
	    return markers
	  },

	  posFromIndex: function(off) {
	    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
	    this.iter(function (line) {
	      var sz = line.text.length + sepSize;
	      if (sz > off) { ch = off; return true }
	      off -= sz;
	      ++lineNo$$1;
	    });
	    return clipPos(this, Pos(lineNo$$1, ch))
	  },
	  indexFromPos: function (coords) {
	    coords = clipPos(this, coords);
	    var index = coords.ch;
	    if (coords.line < this.first || coords.ch < 0) { return 0 }
	    var sepSize = this.lineSeparator().length;
	    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
	      index += line.text.length + sepSize;
	    });
	    return index
	  },

	  copy: function(copyHistory) {
	    var doc = new Doc(getLines(this, this.first, this.first + this.size),
	                      this.modeOption, this.first, this.lineSep, this.direction);
	    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
	    doc.sel = this.sel;
	    doc.extend = false;
	    if (copyHistory) {
	      doc.history.undoDepth = this.history.undoDepth;
	      doc.setHistory(this.getHistory());
	    }
	    return doc
	  },

	  linkedDoc: function(options) {
	    if (!options) { options = {}; }
	    var from = this.first, to = this.first + this.size;
	    if (options.from != null && options.from > from) { from = options.from; }
	    if (options.to != null && options.to < to) { to = options.to; }
	    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
	    if (options.sharedHist) { copy.history = this.history
	    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
	    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
	    copySharedMarkers(copy, findSharedMarkers(this));
	    return copy
	  },
	  unlinkDoc: function(other) {
	    var this$1 = this;

	    if (other instanceof CodeMirror$1) { other = other.doc; }
	    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
	      var link = this$1.linked[i];
	      if (link.doc != other) { continue }
	      this$1.linked.splice(i, 1);
	      other.unlinkDoc(this$1);
	      detachSharedMarkers(findSharedMarkers(this$1));
	      break
	    } }
	    // If the histories were shared, split them again
	    if (other.history == this.history) {
	      var splitIds = [other.id];
	      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
	      other.history = new History(null);
	      other.history.done = copyHistoryArray(this.history.done, splitIds);
	      other.history.undone = copyHistoryArray(this.history.undone, splitIds);
	    }
	  },
	  iterLinkedDocs: function(f) {linkedDocs(this, f);},

	  getMode: function() {return this.mode},
	  getEditor: function() {return this.cm},

	  splitLines: function(str) {
	    if (this.lineSep) { return str.split(this.lineSep) }
	    return splitLinesAuto(str)
	  },
	  lineSeparator: function() { return this.lineSep || "\n" },

	  setDirection: docMethodOp(function (dir) {
	    if (dir != "rtl") { dir = "ltr"; }
	    if (dir == this.direction) { return }
	    this.direction = dir;
	    this.iter(function (line) { return line.order = null; });
	    if (this.cm) { directionChanged(this.cm); }
	  })
	});

	// Public alias.
	Doc.prototype.eachLine = Doc.prototype.iter;

	// Kludge to work around strange IE behavior where it'll sometimes
	// re-fire a series of drag-related events right after the drop (#1551)
	var lastDrop = 0;

	function onDrop(e) {
	  var cm = this;
	  clearDragCursor(cm);
	  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
	    { return }
	  e_preventDefault(e);
	  if (ie) { lastDrop = +new Date; }
	  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
	  if (!pos || cm.isReadOnly()) { return }
	  // Might be a file drop, in which case we simply extract the text
	  // and insert it.
	  if (files && files.length && window.FileReader && window.File) {
	    var n = files.length, text = Array(n), read = 0;
	    var loadFile = function (file, i) {
	      if (cm.options.allowDropFileTypes &&
	          indexOf(cm.options.allowDropFileTypes, file.type) == -1)
	        { return }

	      var reader = new FileReader;
	      reader.onload = operation(cm, function () {
	        var content = reader.result;
	        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
	        text[i] = content;
	        if (++read == n) {
	          pos = clipPos(cm.doc, pos);
	          var change = {from: pos, to: pos,
	                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
	                        origin: "paste"};
	          makeChange(cm.doc, change);
	          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
	        }
	      });
	      reader.readAsText(file);
	    };
	    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
	  } else { // Normal drop
	    // Don't do a replace if the drop happened inside of the selected text.
	    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
	      cm.state.draggingText(e);
	      // Ensure the editor is re-focused
	      setTimeout(function () { return cm.display.input.focus(); }, 20);
	      return
	    }
	    try {
	      var text$1 = e.dataTransfer.getData("Text");
	      if (text$1) {
	        var selected;
	        if (cm.state.draggingText && !cm.state.draggingText.copy)
	          { selected = cm.listSelections(); }
	        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
	        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
	          { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
	        cm.replaceSelection(text$1, "around", "paste");
	        cm.display.input.focus();
	      }
	    }
	    catch(e){}
	  }
	}

	function onDragStart(cm, e) {
	  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
	  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

	  e.dataTransfer.setData("Text", cm.getSelection());
	  e.dataTransfer.effectAllowed = "copyMove";

	  // Use dummy image instead of default browsers image.
	  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
	  if (e.dataTransfer.setDragImage && !safari) {
	    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
	    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
	    if (presto) {
	      img.width = img.height = 1;
	      cm.display.wrapper.appendChild(img);
	      // Force a relayout, or Opera won't use our image for some obscure reason
	      img._top = img.offsetTop;
	    }
	    e.dataTransfer.setDragImage(img, 0, 0);
	    if (presto) { img.parentNode.removeChild(img); }
	  }
	}

	function onDragOver(cm, e) {
	  var pos = posFromMouse(cm, e);
	  if (!pos) { return }
	  var frag = document.createDocumentFragment();
	  drawSelectionCursor(cm, pos, frag);
	  if (!cm.display.dragCursor) {
	    cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
	    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
	  }
	  removeChildrenAndAdd(cm.display.dragCursor, frag);
	}

	function clearDragCursor(cm) {
	  if (cm.display.dragCursor) {
	    cm.display.lineSpace.removeChild(cm.display.dragCursor);
	    cm.display.dragCursor = null;
	  }
	}

	// These must be handled carefully, because naively registering a
	// handler for each editor will cause the editors to never be
	// garbage collected.

	function forEachCodeMirror(f) {
	  if (!document.body.getElementsByClassName) { return }
	  var byClass = document.body.getElementsByClassName("CodeMirror");
	  for (var i = 0; i < byClass.length; i++) {
	    var cm = byClass[i].CodeMirror;
	    if (cm) { f(cm); }
	  }
	}

	var globalsRegistered = false;
	function ensureGlobalHandlers() {
	  if (globalsRegistered) { return }
	  registerGlobalHandlers();
	  globalsRegistered = true;
	}
	function registerGlobalHandlers() {
	  // When the window resizes, we need to refresh active editors.
	  var resizeTimer;
	  on(window, "resize", function () {
	    if (resizeTimer == null) { resizeTimer = setTimeout(function () {
	      resizeTimer = null;
	      forEachCodeMirror(onResize);
	    }, 100); }
	  });
	  // When the window loses focus, we want to show the editor as blurred
	  on(window, "blur", function () { return forEachCodeMirror(onBlur); });
	}
	// Called when the window resizes
	function onResize(cm) {
	  var d = cm.display;
	  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
	    { return }
	  // Might be a text scaling operation, clear size caches.
	  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
	  d.scrollbarsClipped = false;
	  cm.setSize();
	}

	var keyNames = {
	  3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
	  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
	  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
	  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
	  106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
	  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
	  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
	  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
	};

	// Number keys
	for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
	// Alphabetic keys
	for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
	// Function keys
	for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

	var keyMap = {};

	keyMap.basic = {
	  "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
	  "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
	  "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
	  "Tab": "defaultTab", "Shift-Tab": "indentAuto",
	  "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
	  "Esc": "singleSelection"
	};
	// Note that the save and find-related commands aren't defined by
	// default. User code or addons can define them. Unknown commands
	// are simply ignored.
	keyMap.pcDefault = {
	  "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
	  "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
	  "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
	  "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
	  "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
	  "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
	  "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
	  fallthrough: "basic"
	};
	// Very basic readline/emacs-style bindings, which are standard on Mac.
	keyMap.emacsy = {
	  "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
	  "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
	  "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
	  "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
	  "Ctrl-O": "openLine"
	};
	keyMap.macDefault = {
	  "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
	  "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
	  "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
	  "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
	  "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
	  "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
	  "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
	  fallthrough: ["basic", "emacsy"]
	};
	keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

	// KEYMAP DISPATCH

	function normalizeKeyName(name) {
	  var parts = name.split(/-(?!$)/);
	  name = parts[parts.length - 1];
	  var alt, ctrl, shift, cmd;
	  for (var i = 0; i < parts.length - 1; i++) {
	    var mod = parts[i];
	    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
	    else if (/^a(lt)?$/i.test(mod)) { alt = true; }
	    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
	    else if (/^s(hift)?$/i.test(mod)) { shift = true; }
	    else { throw new Error("Unrecognized modifier name: " + mod) }
	  }
	  if (alt) { name = "Alt-" + name; }
	  if (ctrl) { name = "Ctrl-" + name; }
	  if (cmd) { name = "Cmd-" + name; }
	  if (shift) { name = "Shift-" + name; }
	  return name
	}

	// This is a kludge to keep keymaps mostly working as raw objects
	// (backwards compatibility) while at the same time support features
	// like normalization and multi-stroke key bindings. It compiles a
	// new normalized keymap, and then updates the old object to reflect
	// this.
	function normalizeKeyMap(keymap) {
	  var copy = {};
	  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
	    var value = keymap[keyname];
	    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
	    if (value == "...") { delete keymap[keyname]; continue }

	    var keys = map(keyname.split(" "), normalizeKeyName);
	    for (var i = 0; i < keys.length; i++) {
	      var val = (void 0), name = (void 0);
	      if (i == keys.length - 1) {
	        name = keys.join(" ");
	        val = value;
	      } else {
	        name = keys.slice(0, i + 1).join(" ");
	        val = "...";
	      }
	      var prev = copy[name];
	      if (!prev) { copy[name] = val; }
	      else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
	    }
	    delete keymap[keyname];
	  } }
	  for (var prop in copy) { keymap[prop] = copy[prop]; }
	  return keymap
	}

	function lookupKey(key, map$$1, handle, context) {
	  map$$1 = getKeyMap(map$$1);
	  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
	  if (found === false) { return "nothing" }
	  if (found === "...") { return "multi" }
	  if (found != null && handle(found)) { return "handled" }

	  if (map$$1.fallthrough) {
	    if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
	      { return lookupKey(key, map$$1.fallthrough, handle, context) }
	    for (var i = 0; i < map$$1.fallthrough.length; i++) {
	      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
	      if (result) { return result }
	    }
	  }
	}

	// Modifier key presses don't count as 'real' key presses for the
	// purpose of keymap fallthrough.
	function isModifierKey(value) {
	  var name = typeof value == "string" ? value : keyNames[value.keyCode];
	  return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
	}

	// Look up the name of a key as indicated by an event object.
	function keyName(event, noShift) {
	  if (presto && event.keyCode == 34 && event["char"]) { return false }
	  var base = keyNames[event.keyCode], name = base;
	  if (name == null || event.altGraphKey) { return false }
	  if (event.altKey && base != "Alt") { name = "Alt-" + name; }
	  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
	  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
	  if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
	  return name
	}

	function getKeyMap(val) {
	  return typeof val == "string" ? keyMap[val] : val
	}

	// Helper for deleting text near the selection(s), used to implement
	// backspace, delete, and similar functionality.
	function deleteNearSelection(cm, compute) {
	  var ranges = cm.doc.sel.ranges, kill = [];
	  // Build up a set of ranges to kill first, merging overlapping
	  // ranges.
	  for (var i = 0; i < ranges.length; i++) {
	    var toKill = compute(ranges[i]);
	    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
	      var replaced = kill.pop();
	      if (cmp(replaced.from, toKill.from) < 0) {
	        toKill.from = replaced.from;
	        break
	      }
	    }
	    kill.push(toKill);
	  }
	  // Next, remove those actual ranges.
	  runInOp(cm, function () {
	    for (var i = kill.length - 1; i >= 0; i--)
	      { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
	    ensureCursorVisible(cm);
	  });
	}

	// Commands are parameter-less actions that can be performed on an
	// editor, mostly used for keybindings.
	var commands = {
	  selectAll: selectAll,
	  singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
	  killLine: function (cm) { return deleteNearSelection(cm, function (range) {
	    if (range.empty()) {
	      var len = getLine(cm.doc, range.head.line).text.length;
	      if (range.head.ch == len && range.head.line < cm.lastLine())
	        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
	      else
	        { return {from: range.head, to: Pos(range.head.line, len)} }
	    } else {
	      return {from: range.from(), to: range.to()}
	    }
	  }); },
	  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	    from: Pos(range.from().line, 0),
	    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
	  }); }); },
	  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	    from: Pos(range.from().line, 0), to: range.from()
	  }); }); },
	  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5;
	    var leftPos = cm.coordsChar({left: 0, top: top}, "div");
	    return {from: leftPos, to: range.from()}
	  }); },
	  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5;
	    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
	    return {from: range.from(), to: rightPos }
	  }); },
	  undo: function (cm) { return cm.undo(); },
	  redo: function (cm) { return cm.redo(); },
	  undoSelection: function (cm) { return cm.undoSelection(); },
	  redoSelection: function (cm) { return cm.redoSelection(); },
	  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
	  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
	  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
	    {origin: "+move", bias: 1}
	  ); },
	  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
	    {origin: "+move", bias: 1}
	  ); },
	  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
	    {origin: "+move", bias: -1}
	  ); },
	  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5;
	    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
	  }, sel_move); },
	  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5;
	    return cm.coordsChar({left: 0, top: top}, "div")
	  }, sel_move); },
	  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5;
	    var pos = cm.coordsChar({left: 0, top: top}, "div");
	    if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
	    return pos
	  }, sel_move); },
	  goLineUp: function (cm) { return cm.moveV(-1, "line"); },
	  goLineDown: function (cm) { return cm.moveV(1, "line"); },
	  goPageUp: function (cm) { return cm.moveV(-1, "page"); },
	  goPageDown: function (cm) { return cm.moveV(1, "page"); },
	  goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
	  goCharRight: function (cm) { return cm.moveH(1, "char"); },
	  goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
	  goColumnRight: function (cm) { return cm.moveH(1, "column"); },
	  goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
	  goGroupRight: function (cm) { return cm.moveH(1, "group"); },
	  goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
	  goWordRight: function (cm) { return cm.moveH(1, "word"); },
	  delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
	  delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
	  delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
	  delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
	  delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
	  delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
	  indentAuto: function (cm) { return cm.indentSelection("smart"); },
	  indentMore: function (cm) { return cm.indentSelection("add"); },
	  indentLess: function (cm) { return cm.indentSelection("subtract"); },
	  insertTab: function (cm) { return cm.replaceSelection("\t"); },
	  insertSoftTab: function (cm) {
	    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
	    for (var i = 0; i < ranges.length; i++) {
	      var pos = ranges[i].from();
	      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
	      spaces.push(spaceStr(tabSize - col % tabSize));
	    }
	    cm.replaceSelections(spaces);
	  },
	  defaultTab: function (cm) {
	    if (cm.somethingSelected()) { cm.indentSelection("add"); }
	    else { cm.execCommand("insertTab"); }
	  },
	  // Swap the two chars left and right of each selection's head.
	  // Move cursor behind the two swapped characters afterwards.
	  //
	  // Doesn't consider line feeds a character.
	  // Doesn't scan more than one line above to find a character.
	  // Doesn't do anything on an empty line.
	  // Doesn't do anything with non-empty selections.
	  transposeChars: function (cm) { return runInOp(cm, function () {
	    var ranges = cm.listSelections(), newSel = [];
	    for (var i = 0; i < ranges.length; i++) {
	      if (!ranges[i].empty()) { continue }
	      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
	      if (line) {
	        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
	        if (cur.ch > 0) {
	          cur = new Pos(cur.line, cur.ch + 1);
	          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
	                          Pos(cur.line, cur.ch - 2), cur, "+transpose");
	        } else if (cur.line > cm.doc.first) {
	          var prev = getLine(cm.doc, cur.line - 1).text;
	          if (prev) {
	            cur = new Pos(cur.line, 1);
	            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
	                            prev.charAt(prev.length - 1),
	                            Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
	          }
	        }
	      }
	      newSel.push(new Range(cur, cur));
	    }
	    cm.setSelections(newSel);
	  }); },
	  newlineAndIndent: function (cm) { return runInOp(cm, function () {
	    var sels = cm.listSelections();
	    for (var i = sels.length - 1; i >= 0; i--)
	      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
	    sels = cm.listSelections();
	    for (var i$1 = 0; i$1 < sels.length; i$1++)
	      { cm.indentLine(sels[i$1].from().line, null, true); }
	    ensureCursorVisible(cm);
	  }); },
	  openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
	  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
	};


	function lineStart(cm, lineN) {
	  var line = getLine(cm.doc, lineN);
	  var visual = visualLine(line);
	  if (visual != line) { lineN = lineNo(visual); }
	  return endOfLine(true, cm, visual, lineN, 1)
	}
	function lineEnd(cm, lineN) {
	  var line = getLine(cm.doc, lineN);
	  var visual = visualLineEnd(line);
	  if (visual != line) { lineN = lineNo(visual); }
	  return endOfLine(true, cm, line, lineN, -1)
	}
	function lineStartSmart(cm, pos) {
	  var start = lineStart(cm, pos.line);
	  var line = getLine(cm.doc, start.line);
	  var order = getOrder(line, cm.doc.direction);
	  if (!order || order[0].level == 0) {
	    var firstNonWS = Math.max(0, line.text.search(/\S/));
	    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
	    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
	  }
	  return start
	}

	// Run a handler that was bound to a key.
	function doHandleBinding(cm, bound, dropShift) {
	  if (typeof bound == "string") {
	    bound = commands[bound];
	    if (!bound) { return false }
	  }
	  // Ensure previous input has been read, so that the handler sees a
	  // consistent view of the document
	  cm.display.input.ensurePolled();
	  var prevShift = cm.display.shift, done = false;
	  try {
	    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
	    if (dropShift) { cm.display.shift = false; }
	    done = bound(cm) != Pass;
	  } finally {
	    cm.display.shift = prevShift;
	    cm.state.suppressEdits = false;
	  }
	  return done
	}

	function lookupKeyForEditor(cm, name, handle) {
	  for (var i = 0; i < cm.state.keyMaps.length; i++) {
	    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
	    if (result) { return result }
	  }
	  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
	    || lookupKey(name, cm.options.keyMap, handle, cm)
	}

	var stopSeq = new Delayed;
	function dispatchKey(cm, name, e, handle) {
	  var seq = cm.state.keySeq;
	  if (seq) {
	    if (isModifierKey(name)) { return "handled" }
	    stopSeq.set(50, function () {
	      if (cm.state.keySeq == seq) {
	        cm.state.keySeq = null;
	        cm.display.input.reset();
	      }
	    });
	    name = seq + " " + name;
	  }
	  var result = lookupKeyForEditor(cm, name, handle);

	  if (result == "multi")
	    { cm.state.keySeq = name; }
	  if (result == "handled")
	    { signalLater(cm, "keyHandled", cm, name, e); }

	  if (result == "handled" || result == "multi") {
	    e_preventDefault(e);
	    restartBlink(cm);
	  }

	  if (seq && !result && /\'$/.test(name)) {
	    e_preventDefault(e);
	    return true
	  }
	  return !!result
	}

	// Handle a key from the keydown event.
	function handleKeyBinding(cm, e) {
	  var name = keyName(e, true);
	  if (!name) { return false }

	  if (e.shiftKey && !cm.state.keySeq) {
	    // First try to resolve full name (including 'Shift-'). Failing
	    // that, see if there is a cursor-motion command (starting with
	    // 'go') bound to the keyname without 'Shift-'.
	    return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
	        || dispatchKey(cm, name, e, function (b) {
	             if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
	               { return doHandleBinding(cm, b) }
	           })
	  } else {
	    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
	  }
	}

	// Handle a key from the keypress event
	function handleCharBinding(cm, e, ch) {
	  return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
	}

	var lastStoppedKey = null;
	function onKeyDown(e) {
	  var cm = this;
	  cm.curOp.focus = activeElt();
	  if (signalDOMEvent(cm, e)) { return }
	  // IE does strange things with escape.
	  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
	  var code = e.keyCode;
	  cm.display.shift = code == 16 || e.shiftKey;
	  var handled = handleKeyBinding(cm, e);
	  if (presto) {
	    lastStoppedKey = handled ? code : null;
	    // Opera has no cut event... we try to at least catch the key combo
	    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
	      { cm.replaceSelection("", null, "cut"); }
	  }

	  // Turn mouse into crosshair when Alt is held on Mac.
	  if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
	    { showCrossHair(cm); }
	}

	function showCrossHair(cm) {
	  var lineDiv = cm.display.lineDiv;
	  addClass(lineDiv, "CodeMirror-crosshair");

	  function up(e) {
	    if (e.keyCode == 18 || !e.altKey) {
	      rmClass(lineDiv, "CodeMirror-crosshair");
	      off(document, "keyup", up);
	      off(document, "mouseover", up);
	    }
	  }
	  on(document, "keyup", up);
	  on(document, "mouseover", up);
	}

	function onKeyUp(e) {
	  if (e.keyCode == 16) { this.doc.sel.shift = false; }
	  signalDOMEvent(this, e);
	}

	function onKeyPress(e) {
	  var cm = this;
	  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
	  var keyCode = e.keyCode, charCode = e.charCode;
	  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
	  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
	  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
	  // Some browsers fire keypress events for backspace
	  if (ch == "\x08") { return }
	  if (handleCharBinding(cm, e, ch)) { return }
	  cm.display.input.onKeyPress(e);
	}

	// A mouse down can be a single click, double click, triple click,
	// start of selection drag, start of text drag, new cursor
	// (ctrl-click), rectangle drag (alt-drag), or xwin
	// middle-click-paste. Or it might be a click on something we should
	// not interfere with, such as a scrollbar or widget.
	function onMouseDown(e) {
	  var cm = this, display = cm.display;
	  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
	  display.input.ensurePolled();
	  display.shift = e.shiftKey;

	  if (eventInWidget(display, e)) {
	    if (!webkit) {
	      // Briefly turn off draggability, to allow widgets to do
	      // normal dragging things.
	      display.scroller.draggable = false;
	      setTimeout(function () { return display.scroller.draggable = true; }, 100);
	    }
	    return
	  }
	  if (clickInGutter(cm, e)) { return }
	  var start = posFromMouse(cm, e);
	  window.focus();

	  switch (e_button(e)) {
	  case 1:
	    // #3261: make sure, that we're not starting a second selection
	    if (cm.state.selectingText)
	      { cm.state.selectingText(e); }
	    else if (start)
	      { leftButtonDown(cm, e, start); }
	    else if (e_target(e) == display.scroller)
	      { e_preventDefault(e); }
	    break
	  case 2:
	    if (webkit) { cm.state.lastMiddleDown = +new Date; }
	    if (start) { extendSelection(cm.doc, start); }
	    setTimeout(function () { return display.input.focus(); }, 20);
	    e_preventDefault(e);
	    break
	  case 3:
	    if (captureRightClick) { onContextMenu(cm, e); }
	    else { delayBlurEvent(cm); }
	    break
	  }
	}

	var lastClick;
	var lastDoubleClick;
	function leftButtonDown(cm, e, start) {
	  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
	  else { cm.curOp.focus = activeElt(); }

	  var now = +new Date, type;
	  if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
	    type = "triple";
	  } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
	    type = "double";
	    lastDoubleClick = {time: now, pos: start};
	  } else {
	    type = "single";
	    lastClick = {time: now, pos: start};
	  }

	  var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
	  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
	      type == "single" && (contained = sel.contains(start)) > -1 &&
	      (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&
	      (cmp(contained.to(), start) > 0 || start.xRel < 0))
	    { leftButtonStartDrag(cm, e, start, modifier); }
	  else
	    { leftButtonSelect(cm, e, start, type, modifier); }
	}

	// Start a text drag. When it ends, see if any dragging actually
	// happen, and treat as a click if it didn't.
	function leftButtonStartDrag(cm, e, start, modifier) {
	  var display = cm.display, startTime = +new Date;
	  var dragEnd = operation(cm, function (e2) {
	    if (webkit) { display.scroller.draggable = false; }
	    cm.state.draggingText = false;
	    off(document, "mouseup", dragEnd);
	    off(display.scroller, "drop", dragEnd);
	    if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
	      e_preventDefault(e2);
	      if (!modifier && +new Date - 200 < startTime)
	        { extendSelection(cm.doc, start); }
	      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
	      if (webkit || ie && ie_version == 9)
	        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }
	      else
	        { display.input.focus(); }
	    }
	  });
	  // Let the drag handler handle this.
	  if (webkit) { display.scroller.draggable = true; }
	  cm.state.draggingText = dragEnd;
	  dragEnd.copy = mac ? e.altKey : e.ctrlKey;
	  // IE's approach to draggable
	  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
	  on(document, "mouseup", dragEnd);
	  on(display.scroller, "drop", dragEnd);
	}

	// Normal selection, as opposed to text dragging.
	function leftButtonSelect(cm, e, start, type, addNew) {
	  var display = cm.display, doc = cm.doc;
	  e_preventDefault(e);

	  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
	  if (addNew && !e.shiftKey) {
	    ourIndex = doc.sel.contains(start);
	    if (ourIndex > -1)
	      { ourRange = ranges[ourIndex]; }
	    else
	      { ourRange = new Range(start, start); }
	  } else {
	    ourRange = doc.sel.primary();
	    ourIndex = doc.sel.primIndex;
	  }

	  if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {
	    type = "rect";
	    if (!addNew) { ourRange = new Range(start, start); }
	    start = posFromMouse(cm, e, true, true);
	    ourIndex = -1;
	  } else if (type == "double") {
	    var word = cm.findWordAt(start);
	    if (cm.display.shift || doc.extend)
	      { ourRange = extendRange(doc, ourRange, word.anchor, word.head); }
	    else
	      { ourRange = word; }
	  } else if (type == "triple") {
	    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
	    if (cm.display.shift || doc.extend)
	      { ourRange = extendRange(doc, ourRange, line.anchor, line.head); }
	    else
	      { ourRange = line; }
	  } else {
	    ourRange = extendRange(doc, ourRange, start);
	  }

	  if (!addNew) {
	    ourIndex = 0;
	    setSelection(doc, new Selection([ourRange], 0), sel_mouse);
	    startSel = doc.sel;
	  } else if (ourIndex == -1) {
	    ourIndex = ranges.length;
	    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
	                 {scroll: false, origin: "*mouse"});
	  } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
	    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
	                 {scroll: false, origin: "*mouse"});
	    startSel = doc.sel;
	  } else {
	    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
	  }

	  var lastPos = start;
	  function extendTo(pos) {
	    if (cmp(lastPos, pos) == 0) { return }
	    lastPos = pos;

	    if (type == "rect") {
	      var ranges = [], tabSize = cm.options.tabSize;
	      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
	      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
	      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
	      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
	           line <= end; line++) {
	        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
	        if (left == right)
	          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
	        else if (text.length > leftPos)
	          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
	      }
	      if (!ranges.length) { ranges.push(new Range(start, start)); }
	      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
	                   {origin: "*mouse", scroll: false});
	      cm.scrollIntoView(pos);
	    } else {
	      var oldRange = ourRange;
	      var anchor = oldRange.anchor, head = pos;
	      if (type != "single") {
	        var range$$1;
	        if (type == "double")
	          { range$$1 = cm.findWordAt(pos); }
	        else
	          { range$$1 = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))); }
	        if (cmp(range$$1.anchor, anchor) > 0) {
	          head = range$$1.head;
	          anchor = minPos(oldRange.from(), range$$1.anchor);
	        } else {
	          head = range$$1.anchor;
	          anchor = maxPos(oldRange.to(), range$$1.head);
	        }
	      }
	      var ranges$1 = startSel.ranges.slice(0);
	      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head);
	      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
	    }
	  }

	  var editorSize = display.wrapper.getBoundingClientRect();
	  // Used to ensure timeout re-tries don't fire when another extend
	  // happened in the meantime (clearTimeout isn't reliable -- at
	  // least on Chrome, the timeouts still happen even when cleared,
	  // if the clear happens after their scheduled firing time).
	  var counter = 0;

	  function extend(e) {
	    var curCount = ++counter;
	    var cur = posFromMouse(cm, e, true, type == "rect");
	    if (!cur) { return }
	    if (cmp(cur, lastPos) != 0) {
	      cm.curOp.focus = activeElt();
	      extendTo(cur);
	      var visible = visibleLines(display, doc);
	      if (cur.line >= visible.to || cur.line < visible.from)
	        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
	    } else {
	      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
	      if (outside) { setTimeout(operation(cm, function () {
	        if (counter != curCount) { return }
	        display.scroller.scrollTop += outside;
	        extend(e);
	      }), 50); }
	    }
	  }

	  function done(e) {
	    cm.state.selectingText = false;
	    counter = Infinity;
	    e_preventDefault(e);
	    display.input.focus();
	    off(document, "mousemove", move);
	    off(document, "mouseup", up);
	    doc.history.lastSelOrigin = null;
	  }

	  var move = operation(cm, function (e) {
	    if (!e_button(e)) { done(e); }
	    else { extend(e); }
	  });
	  var up = operation(cm, done);
	  cm.state.selectingText = up;
	  on(document, "mousemove", move);
	  on(document, "mouseup", up);
	}


	// Determines whether an event happened in the gutter, and fires the
	// handlers for the corresponding event.
	function gutterEvent(cm, e, type, prevent) {
	  var mX, mY;
	  try { mX = e.clientX; mY = e.clientY; }
	  catch(e) { return false }
	  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
	  if (prevent) { e_preventDefault(e); }

	  var display = cm.display;
	  var lineBox = display.lineDiv.getBoundingClientRect();

	  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
	  mY -= lineBox.top - display.viewOffset;

	  for (var i = 0; i < cm.options.gutters.length; ++i) {
	    var g = display.gutters.childNodes[i];
	    if (g && g.getBoundingClientRect().right >= mX) {
	      var line = lineAtHeight(cm.doc, mY);
	      var gutter = cm.options.gutters[i];
	      signal(cm, type, cm, line, gutter, e);
	      return e_defaultPrevented(e)
	    }
	  }
	}

	function clickInGutter(cm, e) {
	  return gutterEvent(cm, e, "gutterClick", true)
	}

	// CONTEXT MENU HANDLING

	// To make the context menu work, we need to briefly unhide the
	// textarea (making it as unobtrusive as possible) to let the
	// right-click take effect on it.
	function onContextMenu(cm, e) {
	  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
	  if (signalDOMEvent(cm, e, "contextmenu")) { return }
	  cm.display.input.onContextMenu(e);
	}

	function contextMenuInGutter(cm, e) {
	  if (!hasHandler(cm, "gutterContextMenu")) { return false }
	  return gutterEvent(cm, e, "gutterContextMenu", false)
	}

	function themeChanged(cm) {
	  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
	    cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
	  clearCaches(cm);
	}

	var Init = {toString: function(){return "CodeMirror.Init"}};

	var defaults = {};
	var optionHandlers = {};

	function defineOptions(CodeMirror) {
	  var optionHandlers = CodeMirror.optionHandlers;

	  function option(name, deflt, handle, notOnInit) {
	    CodeMirror.defaults[name] = deflt;
	    if (handle) { optionHandlers[name] =
	      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
	  }

	  CodeMirror.defineOption = option;

	  // Passed to option handlers when there is no old value.
	  CodeMirror.Init = Init;

	  // These two are, on init, called from the constructor because they
	  // have to be initialized before the editor can start at all.
	  option("value", "", function (cm, val) { return cm.setValue(val); }, true);
	  option("mode", null, function (cm, val) {
	    cm.doc.modeOption = val;
	    loadMode(cm);
	  }, true);

	  option("indentUnit", 2, loadMode, true);
	  option("indentWithTabs", false);
	  option("smartIndent", true);
	  option("tabSize", 4, function (cm) {
	    resetModeState(cm);
	    clearCaches(cm);
	    regChange(cm);
	  }, true);
	  option("lineSeparator", null, function (cm, val) {
	    cm.doc.lineSep = val;
	    if (!val) { return }
	    var newBreaks = [], lineNo = cm.doc.first;
	    cm.doc.iter(function (line) {
	      for (var pos = 0;;) {
	        var found = line.text.indexOf(val, pos);
	        if (found == -1) { break }
	        pos = found + val.length;
	        newBreaks.push(Pos(lineNo, found));
	      }
	      lineNo++;
	    });
	    for (var i = newBreaks.length - 1; i >= 0; i--)
	      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
	  });
	  option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
	    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
	    if (old != Init) { cm.refresh(); }
	  });
	  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
	  option("electricChars", true);
	  option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
	    throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
	  }, true);
	  option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
	  option("rtlMoveVisually", !windows);
	  option("wholeLineUpdateBefore", true);

	  option("theme", "default", function (cm) {
	    themeChanged(cm);
	    guttersChanged(cm);
	  }, true);
	  option("keyMap", "default", function (cm, val, old) {
	    var next = getKeyMap(val);
	    var prev = old != Init && getKeyMap(old);
	    if (prev && prev.detach) { prev.detach(cm, next); }
	    if (next.attach) { next.attach(cm, prev || null); }
	  });
	  option("extraKeys", null);

	  option("lineWrapping", false, wrappingChanged, true);
	  option("gutters", [], function (cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("fixedGutter", true, function (cm, val) {
	    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
	    cm.refresh();
	  }, true);
	  option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
	  option("scrollbarStyle", "native", function (cm) {
	    initScrollbars(cm);
	    updateScrollbars(cm);
	    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
	    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
	  }, true);
	  option("lineNumbers", false, function (cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("firstLineNumber", 1, guttersChanged, true);
	  option("lineNumberFormatter", function (integer) { return integer; }, guttersChanged, true);
	  option("showCursorWhenSelecting", false, updateSelection, true);

	  option("resetSelectionOnContextMenu", true);
	  option("lineWiseCopyCut", true);

	  option("readOnly", false, function (cm, val) {
	    if (val == "nocursor") {
	      onBlur(cm);
	      cm.display.input.blur();
	      cm.display.disabled = true;
	    } else {
	      cm.display.disabled = false;
	    }
	    cm.display.input.readOnlyChanged(val);
	  });
	  option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
	  option("dragDrop", true, dragDropChanged);
	  option("allowDropFileTypes", null);

	  option("cursorBlinkRate", 530);
	  option("cursorScrollMargin", 0);
	  option("cursorHeight", 1, updateSelection, true);
	  option("singleCursorHeightPerLine", true, updateSelection, true);
	  option("workTime", 100);
	  option("workDelay", 100);
	  option("flattenSpans", true, resetModeState, true);
	  option("addModeClass", false, resetModeState, true);
	  option("pollInterval", 100);
	  option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
	  option("historyEventDelay", 1250);
	  option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
	  option("maxHighlightLength", 10000, resetModeState, true);
	  option("moveInputWithCursor", true, function (cm, val) {
	    if (!val) { cm.display.input.resetPosition(); }
	  });

	  option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
	  option("autofocus", null);
	  option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
	}

	function guttersChanged(cm) {
	  updateGutters(cm);
	  regChange(cm);
	  alignHorizontally(cm);
	}

	function dragDropChanged(cm, value, old) {
	  var wasOn = old && old != Init;
	  if (!value != !wasOn) {
	    var funcs = cm.display.dragFunctions;
	    var toggle = value ? on : off;
	    toggle(cm.display.scroller, "dragstart", funcs.start);
	    toggle(cm.display.scroller, "dragenter", funcs.enter);
	    toggle(cm.display.scroller, "dragover", funcs.over);
	    toggle(cm.display.scroller, "dragleave", funcs.leave);
	    toggle(cm.display.scroller, "drop", funcs.drop);
	  }
	}

	function wrappingChanged(cm) {
	  if (cm.options.lineWrapping) {
	    addClass(cm.display.wrapper, "CodeMirror-wrap");
	    cm.display.sizer.style.minWidth = "";
	    cm.display.sizerWidth = null;
	  } else {
	    rmClass(cm.display.wrapper, "CodeMirror-wrap");
	    findMaxLine(cm);
	  }
	  estimateLineHeights(cm);
	  regChange(cm);
	  clearCaches(cm);
	  setTimeout(function () { return updateScrollbars(cm); }, 100);
	}

	// A CodeMirror instance represents an editor. This is the object
	// that user code is usually dealing with.

	function CodeMirror$1(place, options) {
	  var this$1 = this;

	  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }

	  this.options = options = options ? copyObj(options) : {};
	  // Determine effective options based on given values and defaults.
	  copyObj(defaults, options, false);
	  setGuttersForLineNumbers(options);

	  var doc = options.value;
	  if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
	  this.doc = doc;

	  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);
	  var display = this.display = new Display(place, doc, input);
	  display.wrapper.CodeMirror = this;
	  updateGutters(this);
	  themeChanged(this);
	  if (options.lineWrapping)
	    { this.display.wrapper.className += " CodeMirror-wrap"; }
	  initScrollbars(this);

	  this.state = {
	    keyMaps: [],  // stores maps added by addKeyMap
	    overlays: [], // highlighting overlays, as added by addOverlay
	    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
	    overwrite: false,
	    delayingBlurEvent: false,
	    focused: false,
	    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
	    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
	    selectingText: false,
	    draggingText: false,
	    highlight: new Delayed(), // stores highlight worker timeout
	    keySeq: null,  // Unfinished key sequence
	    specialChars: null
	  };

	  if (options.autofocus && !mobile) { display.input.focus(); }

	  // Override magic textarea content restore that IE sometimes does
	  // on our hidden textarea on reload
	  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

	  registerEventHandlers(this);
	  ensureGlobalHandlers();

	  startOperation(this);
	  this.curOp.forceUpdate = true;
	  attachDoc(this, doc);

	  if ((options.autofocus && !mobile) || this.hasFocus())
	    { setTimeout(bind(onFocus, this), 20); }
	  else
	    { onBlur(this); }

	  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
	    { optionHandlers[opt](this$1, options[opt], Init); } }
	  maybeUpdateLineNumberWidth(this);
	  if (options.finishInit) { options.finishInit(this); }
	  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }
	  endOperation(this);
	  // Suppress optimizelegibility in Webkit, since it breaks text
	  // measuring on line wrapping boundaries.
	  if (webkit && options.lineWrapping &&
	      getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
	    { display.lineDiv.style.textRendering = "auto"; }
	}

	// The default configuration options.
	CodeMirror$1.defaults = defaults;
	// Functions to run when options are changed.
	CodeMirror$1.optionHandlers = optionHandlers;

	// Attach the necessary event handlers when initializing the editor
	function registerEventHandlers(cm) {
	  var d = cm.display;
	  on(d.scroller, "mousedown", operation(cm, onMouseDown));
	  // Older IE's will not fire a second mousedown for a double click
	  if (ie && ie_version < 11)
	    { on(d.scroller, "dblclick", operation(cm, function (e) {
	      if (signalDOMEvent(cm, e)) { return }
	      var pos = posFromMouse(cm, e);
	      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
	      e_preventDefault(e);
	      var word = cm.findWordAt(pos);
	      extendSelection(cm.doc, word.anchor, word.head);
	    })); }
	  else
	    { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
	  // Some browsers fire contextmenu *after* opening the menu, at
	  // which point we can't mess with it anymore. Context menu is
	  // handled in onMouseDown for these browsers.
	  if (!captureRightClick) { on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); }); }

	  // Used to suppress mouse event handling when a touch happens
	  var touchFinished, prevTouch = {end: 0};
	  function finishTouch() {
	    if (d.activeTouch) {
	      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
	      prevTouch = d.activeTouch;
	      prevTouch.end = +new Date;
	    }
	  }
	  function isMouseLikeTouchEvent(e) {
	    if (e.touches.length != 1) { return false }
	    var touch = e.touches[0];
	    return touch.radiusX <= 1 && touch.radiusY <= 1
	  }
	  function farAway(touch, other) {
	    if (other.left == null) { return true }
	    var dx = other.left - touch.left, dy = other.top - touch.top;
	    return dx * dx + dy * dy > 20 * 20
	  }
	  on(d.scroller, "touchstart", function (e) {
	    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
	      d.input.ensurePolled();
	      clearTimeout(touchFinished);
	      var now = +new Date;
	      d.activeTouch = {start: now, moved: false,
	                       prev: now - prevTouch.end <= 300 ? prevTouch : null};
	      if (e.touches.length == 1) {
	        d.activeTouch.left = e.touches[0].pageX;
	        d.activeTouch.top = e.touches[0].pageY;
	      }
	    }
	  });
	  on(d.scroller, "touchmove", function () {
	    if (d.activeTouch) { d.activeTouch.moved = true; }
	  });
	  on(d.scroller, "touchend", function (e) {
	    var touch = d.activeTouch;
	    if (touch && !eventInWidget(d, e) && touch.left != null &&
	        !touch.moved && new Date - touch.start < 300) {
	      var pos = cm.coordsChar(d.activeTouch, "page"), range;
	      if (!touch.prev || farAway(touch, touch.prev)) // Single tap
	        { range = new Range(pos, pos); }
	      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
	        { range = cm.findWordAt(pos); }
	      else // Triple tap
	        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
	      cm.setSelection(range.anchor, range.head);
	      cm.focus();
	      e_preventDefault(e);
	    }
	    finishTouch();
	  });
	  on(d.scroller, "touchcancel", finishTouch);

	  // Sync scrolling between fake scrollbars and real scrollable
	  // area, ensure viewport is updated when scrolling.
	  on(d.scroller, "scroll", function () {
	    if (d.scroller.clientHeight) {
	      setScrollTop(cm, d.scroller.scrollTop);
	      setScrollLeft(cm, d.scroller.scrollLeft, true);
	      signal(cm, "scroll", cm);
	    }
	  });

	  // Listen to wheel events in order to try and update the viewport on time.
	  on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
	  on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

	  // Prevent wrapper from ever scrolling
	  on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

	  d.dragFunctions = {
	    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
	    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
	    start: function (e) { return onDragStart(cm, e); },
	    drop: operation(cm, onDrop),
	    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
	  };

	  var inp = d.input.getField();
	  on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
	  on(inp, "keydown", operation(cm, onKeyDown));
	  on(inp, "keypress", operation(cm, onKeyPress));
	  on(inp, "focus", function (e) { return onFocus(cm, e); });
	  on(inp, "blur", function (e) { return onBlur(cm, e); });
	}

	var initHooks = [];
	CodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };

	// Indent the given line. The how parameter can be "smart",
	// "add"/null, "subtract", or "prev". When aggressive is false
	// (typically set to true for forced single-line indents), empty
	// lines are not indented, and places where the mode returns Pass
	// are left alone.
	function indentLine(cm, n, how, aggressive) {
	  var doc = cm.doc, state;
	  if (how == null) { how = "add"; }
	  if (how == "smart") {
	    // Fall back to "prev" when the mode doesn't have an indentation
	    // method.
	    if (!doc.mode.indent) { how = "prev"; }
	    else { state = getStateBefore(cm, n); }
	  }

	  var tabSize = cm.options.tabSize;
	  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
	  if (line.stateAfter) { line.stateAfter = null; }
	  var curSpaceString = line.text.match(/^\s*/)[0], indentation;
	  if (!aggressive && !/\S/.test(line.text)) {
	    indentation = 0;
	    how = "not";
	  } else if (how == "smart") {
	    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
	    if (indentation == Pass || indentation > 150) {
	      if (!aggressive) { return }
	      how = "prev";
	    }
	  }
	  if (how == "prev") {
	    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
	    else { indentation = 0; }
	  } else if (how == "add") {
	    indentation = curSpace + cm.options.indentUnit;
	  } else if (how == "subtract") {
	    indentation = curSpace - cm.options.indentUnit;
	  } else if (typeof how == "number") {
	    indentation = curSpace + how;
	  }
	  indentation = Math.max(0, indentation);

	  var indentString = "", pos = 0;
	  if (cm.options.indentWithTabs)
	    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
	  if (pos < indentation) { indentString += spaceStr(indentation - pos); }

	  if (indentString != curSpaceString) {
	    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
	    line.stateAfter = null;
	    return true
	  } else {
	    // Ensure that, if the cursor was in the whitespace at the start
	    // of the line, it is moved to the end of that space.
	    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
	      var range = doc.sel.ranges[i$1];
	      if (range.head.line == n && range.head.ch < curSpaceString.length) {
	        var pos$1 = Pos(n, curSpaceString.length);
	        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
	        break
	      }
	    }
	  }
	}

	// This will be set to a {lineWise: bool, text: [string]} object, so
	// that, when pasting, we know what kind of selections the copied
	// text was made out of.
	var lastCopied = null;

	function setLastCopied(newLastCopied) {
	  lastCopied = newLastCopied;
	}

	function applyTextInput(cm, inserted, deleted, sel, origin) {
	  var doc = cm.doc;
	  cm.display.shift = false;
	  if (!sel) { sel = doc.sel; }

	  var paste = cm.state.pasteIncoming || origin == "paste";
	  var textLines = splitLinesAuto(inserted), multiPaste = null;
	  // When pasing N lines into N selections, insert one line per selection
	  if (paste && sel.ranges.length > 1) {
	    if (lastCopied && lastCopied.text.join("\n") == inserted) {
	      if (sel.ranges.length % lastCopied.text.length == 0) {
	        multiPaste = [];
	        for (var i = 0; i < lastCopied.text.length; i++)
	          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
	      }
	    } else if (textLines.length == sel.ranges.length) {
	      multiPaste = map(textLines, function (l) { return [l]; });
	    }
	  }

	  var updateInput;
	  // Normal behavior is to insert the new text into every selection
	  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
	    var range$$1 = sel.ranges[i$1];
	    var from = range$$1.from(), to = range$$1.to();
	    if (range$$1.empty()) {
	      if (deleted && deleted > 0) // Handle deletion
	        { from = Pos(from.line, from.ch - deleted); }
	      else if (cm.state.overwrite && !paste) // Handle overwrite
	        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
	      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
	        { from = to = Pos(from.line, 0); }
	    }
	    updateInput = cm.curOp.updateInput;
	    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
	                       origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
	    makeChange(cm.doc, changeEvent);
	    signalLater(cm, "inputRead", cm, changeEvent);
	  }
	  if (inserted && !paste)
	    { triggerElectric(cm, inserted); }

	  ensureCursorVisible(cm);
	  cm.curOp.updateInput = updateInput;
	  cm.curOp.typing = true;
	  cm.state.pasteIncoming = cm.state.cutIncoming = false;
	}

	function handlePaste(e, cm) {
	  var pasted = e.clipboardData && e.clipboardData.getData("Text");
	  if (pasted) {
	    e.preventDefault();
	    if (!cm.isReadOnly() && !cm.options.disableInput)
	      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
	    return true
	  }
	}

	function triggerElectric(cm, inserted) {
	  // When an 'electric' character is inserted, immediately trigger a reindent
	  if (!cm.options.electricChars || !cm.options.smartIndent) { return }
	  var sel = cm.doc.sel;

	  for (var i = sel.ranges.length - 1; i >= 0; i--) {
	    var range$$1 = sel.ranges[i];
	    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
	    var mode = cm.getModeAt(range$$1.head);
	    var indented = false;
	    if (mode.electricChars) {
	      for (var j = 0; j < mode.electricChars.length; j++)
	        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
	          indented = indentLine(cm, range$$1.head.line, "smart");
	          break
	        } }
	    } else if (mode.electricInput) {
	      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
	        { indented = indentLine(cm, range$$1.head.line, "smart"); }
	    }
	    if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
	  }
	}

	function copyableRanges(cm) {
	  var text = [], ranges = [];
	  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
	    var line = cm.doc.sel.ranges[i].head.line;
	    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
	    ranges.push(lineRange);
	    text.push(cm.getRange(lineRange.anchor, lineRange.head));
	  }
	  return {text: text, ranges: ranges}
	}

	function disableBrowserMagic(field, spellcheck) {
	  field.setAttribute("autocorrect", "off");
	  field.setAttribute("autocapitalize", "off");
	  field.setAttribute("spellcheck", !!spellcheck);
	}

	function hiddenTextarea() {
	  var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
	  var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
	  // The textarea is kept positioned near the cursor to prevent the
	  // fact that it'll be scrolled into view on input from scrolling
	  // our fake cursor out of view. On webkit, when wrap=off, paste is
	  // very slow. So make the area wide instead.
	  if (webkit) { te.style.width = "1000px"; }
	  else { te.setAttribute("wrap", "off"); }
	  // If border: 0; -- iOS fails to open keyboard (issue #1287)
	  if (ios) { te.style.border = "1px solid black"; }
	  disableBrowserMagic(te);
	  return div
	}

	// The publicly visible API. Note that methodOp(f) means
	// 'wrap f in an operation, performed on its `this` parameter'.

	// This is not the complete set of editor methods. Most of the
	// methods defined on the Doc type are also injected into
	// CodeMirror.prototype, for backwards compatibility and
	// convenience.

	var addEditorMethods = function(CodeMirror) {
	  var optionHandlers = CodeMirror.optionHandlers;

	  var helpers = CodeMirror.helpers = {};

	  CodeMirror.prototype = {
	    constructor: CodeMirror,
	    focus: function(){window.focus(); this.display.input.focus();},

	    setOption: function(option, value) {
	      var options = this.options, old = options[option];
	      if (options[option] == value && option != "mode") { return }
	      options[option] = value;
	      if (optionHandlers.hasOwnProperty(option))
	        { operation(this, optionHandlers[option])(this, value, old); }
	      signal(this, "optionChange", this, option);
	    },

	    getOption: function(option) {return this.options[option]},
	    getDoc: function() {return this.doc},

	    addKeyMap: function(map$$1, bottom) {
	      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
	    },
	    removeKeyMap: function(map$$1) {
	      var maps = this.state.keyMaps;
	      for (var i = 0; i < maps.length; ++i)
	        { if (maps[i] == map$$1 || maps[i].name == map$$1) {
	          maps.splice(i, 1);
	          return true
	        } }
	    },

	    addOverlay: methodOp(function(spec, options) {
	      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
	      if (mode.startState) { throw new Error("Overlays may not be stateful.") }
	      insertSorted(this.state.overlays,
	                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,
	                    priority: (options && options.priority) || 0},
	                   function (overlay) { return overlay.priority; });
	      this.state.modeGen++;
	      regChange(this);
	    }),
	    removeOverlay: methodOp(function(spec) {
	      var this$1 = this;

	      var overlays = this.state.overlays;
	      for (var i = 0; i < overlays.length; ++i) {
	        var cur = overlays[i].modeSpec;
	        if (cur == spec || typeof spec == "string" && cur.name == spec) {
	          overlays.splice(i, 1);
	          this$1.state.modeGen++;
	          regChange(this$1);
	          return
	        }
	      }
	    }),

	    indentLine: methodOp(function(n, dir, aggressive) {
	      if (typeof dir != "string" && typeof dir != "number") {
	        if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
	        else { dir = dir ? "add" : "subtract"; }
	      }
	      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
	    }),
	    indentSelection: methodOp(function(how) {
	      var this$1 = this;

	      var ranges = this.doc.sel.ranges, end = -1;
	      for (var i = 0; i < ranges.length; i++) {
	        var range$$1 = ranges[i];
	        if (!range$$1.empty()) {
	          var from = range$$1.from(), to = range$$1.to();
	          var start = Math.max(end, from.line);
	          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
	          for (var j = start; j < end; ++j)
	            { indentLine(this$1, j, how); }
	          var newRanges = this$1.doc.sel.ranges;
	          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
	            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
	        } else if (range$$1.head.line > end) {
	          indentLine(this$1, range$$1.head.line, how, true);
	          end = range$$1.head.line;
	          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }
	        }
	      }
	    }),

	    // Fetch the parser token for a given character. Useful for hacks
	    // that want to inspect the mode state (say, for completion).
	    getTokenAt: function(pos, precise) {
	      return takeToken(this, pos, precise)
	    },

	    getLineTokens: function(line, precise) {
	      return takeToken(this, Pos(line), precise, true)
	    },

	    getTokenTypeAt: function(pos) {
	      pos = clipPos(this.doc, pos);
	      var styles = getLineStyles(this, getLine(this.doc, pos.line));
	      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
	      var type;
	      if (ch == 0) { type = styles[2]; }
	      else { for (;;) {
	        var mid = (before + after) >> 1;
	        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
	        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
	        else { type = styles[mid * 2 + 2]; break }
	      } }
	      var cut = type ? type.indexOf("overlay ") : -1;
	      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
	    },

	    getModeAt: function(pos) {
	      var mode = this.doc.mode;
	      if (!mode.innerMode) { return mode }
	      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
	    },

	    getHelper: function(pos, type) {
	      return this.getHelpers(pos, type)[0]
	    },

	    getHelpers: function(pos, type) {
	      var this$1 = this;

	      var found = [];
	      if (!helpers.hasOwnProperty(type)) { return found }
	      var help = helpers[type], mode = this.getModeAt(pos);
	      if (typeof mode[type] == "string") {
	        if (help[mode[type]]) { found.push(help[mode[type]]); }
	      } else if (mode[type]) {
	        for (var i = 0; i < mode[type].length; i++) {
	          var val = help[mode[type][i]];
	          if (val) { found.push(val); }
	        }
	      } else if (mode.helperType && help[mode.helperType]) {
	        found.push(help[mode.helperType]);
	      } else if (help[mode.name]) {
	        found.push(help[mode.name]);
	      }
	      for (var i$1 = 0; i$1 < help._global.length; i$1++) {
	        var cur = help._global[i$1];
	        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
	          { found.push(cur.val); }
	      }
	      return found
	    },

	    getStateAfter: function(line, precise) {
	      var doc = this.doc;
	      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
	      return getStateBefore(this, line + 1, precise)
	    },

	    cursorCoords: function(start, mode) {
	      var pos, range$$1 = this.doc.sel.primary();
	      if (start == null) { pos = range$$1.head; }
	      else if (typeof start == "object") { pos = clipPos(this.doc, start); }
	      else { pos = start ? range$$1.from() : range$$1.to(); }
	      return cursorCoords(this, pos, mode || "page")
	    },

	    charCoords: function(pos, mode) {
	      return charCoords(this, clipPos(this.doc, pos), mode || "page")
	    },

	    coordsChar: function(coords, mode) {
	      coords = fromCoordSystem(this, coords, mode || "page");
	      return coordsChar(this, coords.left, coords.top)
	    },

	    lineAtHeight: function(height, mode) {
	      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
	      return lineAtHeight(this.doc, height + this.display.viewOffset)
	    },
	    heightAtLine: function(line, mode, includeWidgets) {
	      var end = false, lineObj;
	      if (typeof line == "number") {
	        var last = this.doc.first + this.doc.size - 1;
	        if (line < this.doc.first) { line = this.doc.first; }
	        else if (line > last) { line = last; end = true; }
	        lineObj = getLine(this.doc, line);
	      } else {
	        lineObj = line;
	      }
	      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
	        (end ? this.doc.height - heightAtLine(lineObj) : 0)
	    },

	    defaultTextHeight: function() { return textHeight(this.display) },
	    defaultCharWidth: function() { return charWidth(this.display) },

	    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

	    addWidget: function(pos, node, scroll, vert, horiz) {
	      var display = this.display;
	      pos = cursorCoords(this, clipPos(this.doc, pos));
	      var top = pos.bottom, left = pos.left;
	      node.style.position = "absolute";
	      node.setAttribute("cm-ignore-events", "true");
	      this.display.input.setUneditable(node);
	      display.sizer.appendChild(node);
	      if (vert == "over") {
	        top = pos.top;
	      } else if (vert == "above" || vert == "near") {
	        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
	        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
	        // Default to positioning above (if specified and possible); otherwise default to positioning below
	        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
	          { top = pos.top - node.offsetHeight; }
	        else if (pos.bottom + node.offsetHeight <= vspace)
	          { top = pos.bottom; }
	        if (left + node.offsetWidth > hspace)
	          { left = hspace - node.offsetWidth; }
	      }
	      node.style.top = top + "px";
	      node.style.left = node.style.right = "";
	      if (horiz == "right") {
	        left = display.sizer.clientWidth - node.offsetWidth;
	        node.style.right = "0px";
	      } else {
	        if (horiz == "left") { left = 0; }
	        else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
	        node.style.left = left + "px";
	      }
	      if (scroll)
	        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
	    },

	    triggerOnKeyDown: methodOp(onKeyDown),
	    triggerOnKeyPress: methodOp(onKeyPress),
	    triggerOnKeyUp: onKeyUp,

	    execCommand: function(cmd) {
	      if (commands.hasOwnProperty(cmd))
	        { return commands[cmd].call(null, this) }
	    },

	    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

	    findPosH: function(from, amount, unit, visually) {
	      var this$1 = this;

	      var dir = 1;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      var cur = clipPos(this.doc, from);
	      for (var i = 0; i < amount; ++i) {
	        cur = findPosH(this$1.doc, cur, dir, unit, visually);
	        if (cur.hitSide) { break }
	      }
	      return cur
	    },

	    moveH: methodOp(function(dir, unit) {
	      var this$1 = this;

	      this.extendSelectionsBy(function (range$$1) {
	        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
	          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
	        else
	          { return dir < 0 ? range$$1.from() : range$$1.to() }
	      }, sel_move);
	    }),

	    deleteH: methodOp(function(dir, unit) {
	      var sel = this.doc.sel, doc = this.doc;
	      if (sel.somethingSelected())
	        { doc.replaceSelection("", null, "+delete"); }
	      else
	        { deleteNearSelection(this, function (range$$1) {
	          var other = findPosH(doc, range$$1.head, dir, unit, false);
	          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
	        }); }
	    }),

	    findPosV: function(from, amount, unit, goalColumn) {
	      var this$1 = this;

	      var dir = 1, x = goalColumn;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      var cur = clipPos(this.doc, from);
	      for (var i = 0; i < amount; ++i) {
	        var coords = cursorCoords(this$1, cur, "div");
	        if (x == null) { x = coords.left; }
	        else { coords.left = x; }
	        cur = findPosV(this$1, coords, dir, unit);
	        if (cur.hitSide) { break }
	      }
	      return cur
	    },

	    moveV: methodOp(function(dir, unit) {
	      var this$1 = this;

	      var doc = this.doc, goals = [];
	      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
	      doc.extendSelectionsBy(function (range$$1) {
	        if (collapse)
	          { return dir < 0 ? range$$1.from() : range$$1.to() }
	        var headPos = cursorCoords(this$1, range$$1.head, "div");
	        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
	        goals.push(headPos.left);
	        var pos = findPosV(this$1, headPos, dir, unit);
	        if (unit == "page" && range$$1 == doc.sel.primary())
	          { addToScrollPos(this$1, null, charCoords(this$1, pos, "div").top - headPos.top); }
	        return pos
	      }, sel_move);
	      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
	        { doc.sel.ranges[i].goalColumn = goals[i]; } }
	    }),

	    // Find the word at the given position (as returned by coordsChar).
	    findWordAt: function(pos) {
	      var doc = this.doc, line = getLine(doc, pos.line).text;
	      var start = pos.ch, end = pos.ch;
	      if (line) {
	        var helper = this.getHelper(pos, "wordChars");
	        if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
	        var startChar = line.charAt(start);
	        var check = isWordChar(startChar, helper)
	          ? function (ch) { return isWordChar(ch, helper); }
	          : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
	          : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
	        while (start > 0 && check(line.charAt(start - 1))) { --start; }
	        while (end < line.length && check(line.charAt(end))) { ++end; }
	      }
	      return new Range(Pos(pos.line, start), Pos(pos.line, end))
	    },

	    toggleOverwrite: function(value) {
	      if (value != null && value == this.state.overwrite) { return }
	      if (this.state.overwrite = !this.state.overwrite)
	        { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
	      else
	        { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

	      signal(this, "overwriteToggle", this, this.state.overwrite);
	    },
	    hasFocus: function() { return this.display.input.getField() == activeElt() },
	    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

	    scrollTo: methodOp(function(x, y) {
	      if (x != null || y != null) { resolveScrollToPos(this); }
	      if (x != null) { this.curOp.scrollLeft = x; }
	      if (y != null) { this.curOp.scrollTop = y; }
	    }),
	    getScrollInfo: function() {
	      var scroller = this.display.scroller;
	      return {left: scroller.scrollLeft, top: scroller.scrollTop,
	              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
	              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
	              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
	    },

	    scrollIntoView: methodOp(function(range$$1, margin) {
	      if (range$$1 == null) {
	        range$$1 = {from: this.doc.sel.primary().head, to: null};
	        if (margin == null) { margin = this.options.cursorScrollMargin; }
	      } else if (typeof range$$1 == "number") {
	        range$$1 = {from: Pos(range$$1, 0), to: null};
	      } else if (range$$1.from == null) {
	        range$$1 = {from: range$$1, to: null};
	      }
	      if (!range$$1.to) { range$$1.to = range$$1.from; }
	      range$$1.margin = margin || 0;

	      if (range$$1.from.line != null) {
	        resolveScrollToPos(this);
	        this.curOp.scrollToPos = range$$1;
	      } else {
	        var sPos = calculateScrollPos(this, {
	          left: Math.min(range$$1.from.left, range$$1.to.left),
	          top: Math.min(range$$1.from.top, range$$1.to.top) - range$$1.margin,
	          right: Math.max(range$$1.from.right, range$$1.to.right),
	          bottom: Math.max(range$$1.from.bottom, range$$1.to.bottom) + range$$1.margin
	        });
	        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
	      }
	    }),

	    setSize: methodOp(function(width, height) {
	      var this$1 = this;

	      var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
	      if (width != null) { this.display.wrapper.style.width = interpret(width); }
	      if (height != null) { this.display.wrapper.style.height = interpret(height); }
	      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
	      var lineNo$$1 = this.display.viewFrom;
	      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
	        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
	          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
	        ++lineNo$$1;
	      });
	      this.curOp.forceUpdate = true;
	      signal(this, "refresh", this);
	    }),

	    operation: function(f){return runInOp(this, f)},

	    refresh: methodOp(function() {
	      var oldHeight = this.display.cachedTextHeight;
	      regChange(this);
	      this.curOp.forceUpdate = true;
	      clearCaches(this);
	      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
	      updateGutterSpace(this);
	      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
	        { estimateLineHeights(this); }
	      signal(this, "refresh", this);
	    }),

	    swapDoc: methodOp(function(doc) {
	      var old = this.doc;
	      old.cm = null;
	      attachDoc(this, doc);
	      clearCaches(this);
	      this.display.input.reset();
	      this.scrollTo(doc.scrollLeft, doc.scrollTop);
	      this.curOp.forceScroll = true;
	      signalLater(this, "swapDoc", this, old);
	      return old
	    }),

	    getInputField: function(){return this.display.input.getField()},
	    getWrapperElement: function(){return this.display.wrapper},
	    getScrollerElement: function(){return this.display.scroller},
	    getGutterElement: function(){return this.display.gutters}
	  };
	  eventMixin(CodeMirror);

	  CodeMirror.registerHelper = function(type, name, value) {
	    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
	    helpers[type][name] = value;
	  };
	  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
	    CodeMirror.registerHelper(type, name, value);
	    helpers[type]._global.push({pred: predicate, val: value});
	  };
	};

	// Used for horizontal relative motion. Dir is -1 or 1 (left or
	// right), unit can be "char", "column" (like char, but doesn't
	// cross line boundaries), "word" (across next word), or "group" (to
	// the start of next group of word or non-word-non-whitespace
	// chars). The visually param controls whether, in right-to-left
	// text, direction 1 means to move towards the next index in the
	// string, or towards the character to the right of the current
	// position. The resulting position will have a hitSide=true
	// property if it reached the end of the document.
	function findPosH(doc, pos, dir, unit, visually) {
	  var oldPos = pos;
	  var origDir = dir;
	  var lineObj = getLine(doc, pos.line);
	  function findNextLine() {
	    var l = pos.line + dir;
	    if (l < doc.first || l >= doc.first + doc.size) { return false }
	    pos = new Pos(l, pos.ch, pos.sticky);
	    return lineObj = getLine(doc, l)
	  }
	  function moveOnce(boundToLine) {
	    var next;
	    if (visually) {
	      next = moveVisually(doc.cm, lineObj, pos, dir);
	    } else {
	      next = moveLogically(lineObj, pos, dir);
	    }
	    if (next == null) {
	      if (!boundToLine && findNextLine())
	        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
	      else
	        { return false }
	    } else {
	      pos = next;
	    }
	    return true
	  }

	  if (unit == "char") {
	    moveOnce();
	  } else if (unit == "column") {
	    moveOnce(true);
	  } else if (unit == "word" || unit == "group") {
	    var sawType = null, group = unit == "group";
	    var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
	    for (var first = true;; first = false) {
	      if (dir < 0 && !moveOnce(!first)) { break }
	      var cur = lineObj.text.charAt(pos.ch) || "\n";
	      var type = isWordChar(cur, helper) ? "w"
	        : group && cur == "\n" ? "n"
	        : !group || /\s/.test(cur) ? null
	        : "p";
	      if (group && !first && !type) { type = "s"; }
	      if (sawType && sawType != type) {
	        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
	        break
	      }

	      if (type) { sawType = type; }
	      if (dir > 0 && !moveOnce(!first)) { break }
	    }
	  }
	  var result = skipAtomic(doc, pos, oldPos, origDir, true);
	  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
	  return result
	}

	// For relative vertical movement. Dir may be -1 or 1. Unit can be
	// "page" or "line". The resulting position will have a hitSide=true
	// property if it reached the end of the document.
	function findPosV(cm, pos, dir, unit) {
	  var doc = cm.doc, x = pos.left, y;
	  if (unit == "page") {
	    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
	    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
	    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

	  } else if (unit == "line") {
	    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
	  }
	  var target;
	  for (;;) {
	    target = coordsChar(cm, x, y);
	    if (!target.outside) { break }
	    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
	    y += dir * 5;
	  }
	  return target
	}

	// CONTENTEDITABLE INPUT STYLE

	var ContentEditableInput = function(cm) {
	  this.cm = cm;
	  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
	  this.polling = new Delayed();
	  this.composing = null;
	  this.gracePeriod = false;
	  this.readDOMTimeout = null;
	};

	ContentEditableInput.prototype.init = function (display) {
	    var this$1 = this;

	  var input = this, cm = input.cm;
	  var div = input.div = display.lineDiv;
	  disableBrowserMagic(div, cm.options.spellcheck);

	  on(div, "paste", function (e) {
	    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
	    // IE doesn't fire input events, so we schedule a read for the pasted content in this way
	    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
	  });

	  on(div, "compositionstart", function (e) {
	    this$1.composing = {data: e.data, done: false};
	  });
	  on(div, "compositionupdate", function (e) {
	    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
	  });
	  on(div, "compositionend", function (e) {
	    if (this$1.composing) {
	      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
	      this$1.composing.done = true;
	    }
	  });

	  on(div, "touchstart", function () { return input.forceCompositionEnd(); });

	  on(div, "input", function () {
	    if (!this$1.composing) { this$1.readFromDOMSoon(); }
	  });

	  function onCopyCut(e) {
	    if (signalDOMEvent(cm, e)) { return }
	    if (cm.somethingSelected()) {
	      setLastCopied({lineWise: false, text: cm.getSelections()});
	      if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
	    } else if (!cm.options.lineWiseCopyCut) {
	      return
	    } else {
	      var ranges = copyableRanges(cm);
	      setLastCopied({lineWise: true, text: ranges.text});
	      if (e.type == "cut") {
	        cm.operation(function () {
	          cm.setSelections(ranges.ranges, 0, sel_dontScroll);
	          cm.replaceSelection("", null, "cut");
	        });
	      }
	    }
	    if (e.clipboardData) {
	      e.clipboardData.clearData();
	      var content = lastCopied.text.join("\n");
	      // iOS exposes the clipboard API, but seems to discard content inserted into it
	      e.clipboardData.setData("Text", content);
	      if (e.clipboardData.getData("Text") == content) {
	        e.preventDefault();
	        return
	      }
	    }
	    // Old-fashioned briefly-focus-a-textarea hack
	    var kludge = hiddenTextarea(), te = kludge.firstChild;
	    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
	    te.value = lastCopied.text.join("\n");
	    var hadFocus = document.activeElement;
	    selectInput(te);
	    setTimeout(function () {
	      cm.display.lineSpace.removeChild(kludge);
	      hadFocus.focus();
	      if (hadFocus == div) { input.showPrimarySelection(); }
	    }, 50);
	  }
	  on(div, "copy", onCopyCut);
	  on(div, "cut", onCopyCut);
	};

	ContentEditableInput.prototype.prepareSelection = function () {
	  var result = prepareSelection(this.cm, false);
	  result.focus = this.cm.state.focused;
	  return result
	};

	ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
	  if (!info || !this.cm.display.view.length) { return }
	  if (info.focus || takeFocus) { this.showPrimarySelection(); }
	  this.showMultipleSelections(info);
	};

	ContentEditableInput.prototype.showPrimarySelection = function () {
	  var sel = window.getSelection(), prim = this.cm.doc.sel.primary();
	  var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
	  var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
	  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
	      cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
	      cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
	    { return }

	  var start = posToDOM(this.cm, prim.from());
	  var end = posToDOM(this.cm, prim.to());
	  if (!start && !end) {
	    sel.removeAllRanges();
	    return
	  }

	  var view = this.cm.display.view;
	  var old = sel.rangeCount && sel.getRangeAt(0);
	  if (!start) {
	    start = {node: view[0].measure.map[2], offset: 0};
	  } else if (!end) { // FIXME dangerously hacky
	    var measure = view[view.length - 1].measure;
	    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
	    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
	  }

	  var rng;
	  try { rng = range(start.node, start.offset, end.offset, end.node); }
	  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
	  if (rng) {
	    if (!gecko && this.cm.state.focused) {
	      sel.collapse(start.node, start.offset);
	      if (!rng.collapsed) {
	        sel.removeAllRanges();
	        sel.addRange(rng);
	      }
	    } else {
	      sel.removeAllRanges();
	      sel.addRange(rng);
	    }
	    if (old && sel.anchorNode == null) { sel.addRange(old); }
	    else if (gecko) { this.startGracePeriod(); }
	  }
	  this.rememberSelection();
	};

	ContentEditableInput.prototype.startGracePeriod = function () {
	    var this$1 = this;

	  clearTimeout(this.gracePeriod);
	  this.gracePeriod = setTimeout(function () {
	    this$1.gracePeriod = false;
	    if (this$1.selectionChanged())
	      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
	  }, 20);
	};

	ContentEditableInput.prototype.showMultipleSelections = function (info) {
	  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
	  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
	};

	ContentEditableInput.prototype.rememberSelection = function () {
	  var sel = window.getSelection();
	  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
	  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
	};

	ContentEditableInput.prototype.selectionInEditor = function () {
	  var sel = window.getSelection();
	  if (!sel.rangeCount) { return false }
	  var node = sel.getRangeAt(0).commonAncestorContainer;
	  return contains(this.div, node)
	};

	ContentEditableInput.prototype.focus = function () {
	  if (this.cm.options.readOnly != "nocursor") {
	    if (!this.selectionInEditor())
	      { this.showSelection(this.prepareSelection(), true); }
	    this.div.focus();
	  }
	};
	ContentEditableInput.prototype.blur = function () { this.div.blur(); };
	ContentEditableInput.prototype.getField = function () { return this.div };

	ContentEditableInput.prototype.supportsTouch = function () { return true };

	ContentEditableInput.prototype.receivedFocus = function () {
	  var input = this;
	  if (this.selectionInEditor())
	    { this.pollSelection(); }
	  else
	    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

	  function poll() {
	    if (input.cm.state.focused) {
	      input.pollSelection();
	      input.polling.set(input.cm.options.pollInterval, poll);
	    }
	  }
	  this.polling.set(this.cm.options.pollInterval, poll);
	};

	ContentEditableInput.prototype.selectionChanged = function () {
	  var sel = window.getSelection();
	  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
	    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
	};

	ContentEditableInput.prototype.pollSelection = function () {
	  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
	  var sel = window.getSelection(), cm = this.cm;
	  // On Android Chrome (version 56, at least), backspacing into an
	  // uneditable block element will put the cursor in that element,
	  // and then, because it's not editable, hide the virtual keyboard.
	  // Because Android doesn't allow us to actually detect backspace
	  // presses in a sane way, this code checks for when that happens
	  // and simulates a backspace press in this case.
	  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {
	    this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
	    this.blur();
	    this.focus();
	    return
	  }
	  if (this.composing) { return }
	  this.rememberSelection();
	  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	  var head = domToPos(cm, sel.focusNode, sel.focusOffset);
	  if (anchor && head) { runInOp(cm, function () {
	    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
	    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
	  }); }
	};

	ContentEditableInput.prototype.pollContent = function () {
	  if (this.readDOMTimeout != null) {
	    clearTimeout(this.readDOMTimeout);
	    this.readDOMTimeout = null;
	  }

	  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
	  var from = sel.from(), to = sel.to();
	  if (from.ch == 0 && from.line > cm.firstLine())
	    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
	  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
	    { to = Pos(to.line + 1, 0); }
	  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

	  var fromIndex, fromLine, fromNode;
	  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
	    fromLine = lineNo(display.view[0].line);
	    fromNode = display.view[0].node;
	  } else {
	    fromLine = lineNo(display.view[fromIndex].line);
	    fromNode = display.view[fromIndex - 1].node.nextSibling;
	  }
	  var toIndex = findViewIndex(cm, to.line);
	  var toLine, toNode;
	  if (toIndex == display.view.length - 1) {
	    toLine = display.viewTo - 1;
	    toNode = display.lineDiv.lastChild;
	  } else {
	    toLine = lineNo(display.view[toIndex + 1].line) - 1;
	    toNode = display.view[toIndex + 1].node.previousSibling;
	  }

	  if (!fromNode) { return false }
	  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
	  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
	  while (newText.length > 1 && oldText.length > 1) {
	    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
	    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
	    else { break }
	  }

	  var cutFront = 0, cutEnd = 0;
	  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
	  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
	    { ++cutFront; }
	  var newBot = lst(newText), oldBot = lst(oldText);
	  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
	                           oldBot.length - (oldText.length == 1 ? cutFront : 0));
	  while (cutEnd < maxCutEnd &&
	         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
	    { ++cutEnd; }
	  // Try to move start of change to start of selection if ambiguous
	  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
	    while (cutFront && cutFront > from.ch &&
	           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
	      cutFront--;
	      cutEnd++;
	    }
	  }

	  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
	  newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

	  var chFrom = Pos(fromLine, cutFront);
	  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
	  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
	    replaceRange(cm.doc, newText, chFrom, chTo, "+input");
	    return true
	  }
	};

	ContentEditableInput.prototype.ensurePolled = function () {
	  this.forceCompositionEnd();
	};
	ContentEditableInput.prototype.reset = function () {
	  this.forceCompositionEnd();
	};
	ContentEditableInput.prototype.forceCompositionEnd = function () {
	  if (!this.composing) { return }
	  clearTimeout(this.readDOMTimeout);
	  this.composing = null;
	  this.updateFromDOM();
	  this.div.blur();
	  this.div.focus();
	};
	ContentEditableInput.prototype.readFromDOMSoon = function () {
	    var this$1 = this;

	  if (this.readDOMTimeout != null) { return }
	  this.readDOMTimeout = setTimeout(function () {
	    this$1.readDOMTimeout = null;
	    if (this$1.composing) {
	      if (this$1.composing.done) { this$1.composing = null; }
	      else { return }
	    }
	    this$1.updateFromDOM();
	  }, 80);
	};

	ContentEditableInput.prototype.updateFromDOM = function () {
	    var this$1 = this;

	  if (this.cm.isReadOnly() || !this.pollContent())
	    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
	};

	ContentEditableInput.prototype.setUneditable = function (node) {
	  node.contentEditable = "false";
	};

	ContentEditableInput.prototype.onKeyPress = function (e) {
	  if (e.charCode == 0) { return }
	  e.preventDefault();
	  if (!this.cm.isReadOnly())
	    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
	};

	ContentEditableInput.prototype.readOnlyChanged = function (val) {
	  this.div.contentEditable = String(val != "nocursor");
	};

	ContentEditableInput.prototype.onContextMenu = function () {};
	ContentEditableInput.prototype.resetPosition = function () {};

	ContentEditableInput.prototype.needsContentAttribute = true;

	function posToDOM(cm, pos) {
	  var view = findViewForLine(cm, pos.line);
	  if (!view || view.hidden) { return null }
	  var line = getLine(cm.doc, pos.line);
	  var info = mapFromLineView(view, line, pos.line);

	  var order = getOrder(line, cm.doc.direction), side = "left";
	  if (order) {
	    var partPos = getBidiPartAt(order, pos.ch);
	    side = partPos % 2 ? "right" : "left";
	  }
	  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
	  result.offset = result.collapse == "right" ? result.end : result.start;
	  return result
	}

	function isInGutter(node) {
	  for (var scan = node; scan; scan = scan.parentNode)
	    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
	  return false
	}

	function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

	function domTextBetween(cm, from, to, fromLine, toLine) {
	  var text = "", closing = false, lineSep = cm.doc.lineSeparator();
	  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
	  function close() {
	    if (closing) {
	      text += lineSep;
	      closing = false;
	    }
	  }
	  function addText(str) {
	    if (str) {
	      close();
	      text += str;
	    }
	  }
	  function walk(node) {
	    if (node.nodeType == 1) {
	      var cmText = node.getAttribute("cm-text");
	      if (cmText != null) {
	        addText(cmText || node.textContent.replace(/\u200b/g, ""));
	        return
	      }
	      var markerID = node.getAttribute("cm-marker"), range$$1;
	      if (markerID) {
	        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
	        if (found.length && (range$$1 = found[0].find()))
	          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
	        return
	      }
	      if (node.getAttribute("contenteditable") == "false") { return }
	      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);
	      if (isBlock) { close(); }
	      for (var i = 0; i < node.childNodes.length; i++)
	        { walk(node.childNodes[i]); }
	      if (isBlock) { closing = true; }
	    } else if (node.nodeType == 3) {
	      addText(node.nodeValue);
	    }
	  }
	  for (;;) {
	    walk(from);
	    if (from == to) { break }
	    from = from.nextSibling;
	  }
	  return text
	}

	function domToPos(cm, node, offset) {
	  var lineNode;
	  if (node == cm.display.lineDiv) {
	    lineNode = cm.display.lineDiv.childNodes[offset];
	    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
	    node = null; offset = 0;
	  } else {
	    for (lineNode = node;; lineNode = lineNode.parentNode) {
	      if (!lineNode || lineNode == cm.display.lineDiv) { return null }
	      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
	    }
	  }
	  for (var i = 0; i < cm.display.view.length; i++) {
	    var lineView = cm.display.view[i];
	    if (lineView.node == lineNode)
	      { return locateNodeInLineView(lineView, node, offset) }
	  }
	}

	function locateNodeInLineView(lineView, node, offset) {
	  var wrapper = lineView.text.firstChild, bad = false;
	  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
	  if (node == wrapper) {
	    bad = true;
	    node = wrapper.childNodes[offset];
	    offset = 0;
	    if (!node) {
	      var line = lineView.rest ? lst(lineView.rest) : lineView.line;
	      return badPos(Pos(lineNo(line), line.text.length), bad)
	    }
	  }

	  var textNode = node.nodeType == 3 ? node : null, topNode = node;
	  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
	    textNode = node.firstChild;
	    if (offset) { offset = textNode.nodeValue.length; }
	  }
	  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
	  var measure = lineView.measure, maps = measure.maps;

	  function find(textNode, topNode, offset) {
	    for (var i = -1; i < (maps ? maps.length : 0); i++) {
	      var map$$1 = i < 0 ? measure.map : maps[i];
	      for (var j = 0; j < map$$1.length; j += 3) {
	        var curNode = map$$1[j + 2];
	        if (curNode == textNode || curNode == topNode) {
	          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
	          var ch = map$$1[j] + offset;
	          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
	          return Pos(line, ch)
	        }
	      }
	    }
	  }
	  var found = find(textNode, topNode, offset);
	  if (found) { return badPos(found, bad) }

	  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
	  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
	    found = find(after, after.firstChild, 0);
	    if (found)
	      { return badPos(Pos(found.line, found.ch - dist), bad) }
	    else
	      { dist += after.textContent.length; }
	  }
	  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
	    found = find(before, before.firstChild, -1);
	    if (found)
	      { return badPos(Pos(found.line, found.ch + dist$1), bad) }
	    else
	      { dist$1 += before.textContent.length; }
	  }
	}

	// TEXTAREA INPUT STYLE

	var TextareaInput = function(cm) {
	  this.cm = cm;
	  // See input.poll and input.reset
	  this.prevInput = "";

	  // Flag that indicates whether we expect input to appear real soon
	  // now (after some event like 'keypress' or 'input') and are
	  // polling intensively.
	  this.pollingFast = false;
	  // Self-resetting timeout for the poller
	  this.polling = new Delayed();
	  // Tracks when input.reset has punted to just putting a short
	  // string into the textarea instead of the full selection.
	  this.inaccurateSelection = false;
	  // Used to work around IE issue with selection being forgotten when focus moves away from textarea
	  this.hasSelection = false;
	  this.composing = null;
	};

	TextareaInput.prototype.init = function (display) {
	    var this$1 = this;

	  var input = this, cm = this.cm;

	  // Wraps and hides input textarea
	  var div = this.wrapper = hiddenTextarea();
	  // The semihidden textarea that is focused when the editor is
	  // focused, and receives input.
	  var te = this.textarea = div.firstChild;
	  display.wrapper.insertBefore(div, display.wrapper.firstChild);

	  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
	  if (ios) { te.style.width = "0px"; }

	  on(te, "input", function () {
	    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
	    input.poll();
	  });

	  on(te, "paste", function (e) {
	    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

	    cm.state.pasteIncoming = true;
	    input.fastPoll();
	  });

	  function prepareCopyCut(e) {
	    if (signalDOMEvent(cm, e)) { return }
	    if (cm.somethingSelected()) {
	      setLastCopied({lineWise: false, text: cm.getSelections()});
	      if (input.inaccurateSelection) {
	        input.prevInput = "";
	        input.inaccurateSelection = false;
	        te.value = lastCopied.text.join("\n");
	        selectInput(te);
	      }
	    } else if (!cm.options.lineWiseCopyCut) {
	      return
	    } else {
	      var ranges = copyableRanges(cm);
	      setLastCopied({lineWise: true, text: ranges.text});
	      if (e.type == "cut") {
	        cm.setSelections(ranges.ranges, null, sel_dontScroll);
	      } else {
	        input.prevInput = "";
	        te.value = ranges.text.join("\n");
	        selectInput(te);
	      }
	    }
	    if (e.type == "cut") { cm.state.cutIncoming = true; }
	  }
	  on(te, "cut", prepareCopyCut);
	  on(te, "copy", prepareCopyCut);

	  on(display.scroller, "paste", function (e) {
	    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
	    cm.state.pasteIncoming = true;
	    input.focus();
	  });

	  // Prevent normal selection in the editor (we handle our own)
	  on(display.lineSpace, "selectstart", function (e) {
	    if (!eventInWidget(display, e)) { e_preventDefault(e); }
	  });

	  on(te, "compositionstart", function () {
	    var start = cm.getCursor("from");
	    if (input.composing) { input.composing.range.clear(); }
	    input.composing = {
	      start: start,
	      range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
	    };
	  });
	  on(te, "compositionend", function () {
	    if (input.composing) {
	      input.poll();
	      input.composing.range.clear();
	      input.composing = null;
	    }
	  });
	};

	TextareaInput.prototype.prepareSelection = function () {
	  // Redraw the selection and/or cursor
	  var cm = this.cm, display = cm.display, doc = cm.doc;
	  var result = prepareSelection(cm);

	  // Move the hidden textarea near the cursor to prevent scrolling artifacts
	  if (cm.options.moveInputWithCursor) {
	    var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
	    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
	    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
	                                        headPos.top + lineOff.top - wrapOff.top));
	    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
	                                         headPos.left + lineOff.left - wrapOff.left));
	  }

	  return result
	};

	TextareaInput.prototype.showSelection = function (drawn) {
	  var cm = this.cm, display = cm.display;
	  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
	  removeChildrenAndAdd(display.selectionDiv, drawn.selection);
	  if (drawn.teTop != null) {
	    this.wrapper.style.top = drawn.teTop + "px";
	    this.wrapper.style.left = drawn.teLeft + "px";
	  }
	};

	// Reset the input to correspond to the selection (or to be empty,
	// when not typing and nothing is selected)
	TextareaInput.prototype.reset = function (typing) {
	  if (this.contextMenuPending) { return }
	  var minimal, selected, cm = this.cm, doc = cm.doc;
	  if (cm.somethingSelected()) {
	    this.prevInput = "";
	    var range$$1 = doc.sel.primary();
	    minimal = hasCopyEvent &&
	      (range$$1.to().line - range$$1.from().line > 100 || (selected = cm.getSelection()).length > 1000);
	    var content = minimal ? "-" : selected || cm.getSelection();
	    this.textarea.value = content;
	    if (cm.state.focused) { selectInput(this.textarea); }
	    if (ie && ie_version >= 9) { this.hasSelection = content; }
	  } else if (!typing) {
	    this.prevInput = this.textarea.value = "";
	    if (ie && ie_version >= 9) { this.hasSelection = null; }
	  }
	  this.inaccurateSelection = minimal;
	};

	TextareaInput.prototype.getField = function () { return this.textarea };

	TextareaInput.prototype.supportsTouch = function () { return false };

	TextareaInput.prototype.focus = function () {
	  if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
	    try { this.textarea.focus(); }
	    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
	  }
	};

	TextareaInput.prototype.blur = function () { this.textarea.blur(); };

	TextareaInput.prototype.resetPosition = function () {
	  this.wrapper.style.top = this.wrapper.style.left = 0;
	};

	TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

	// Poll for input changes, using the normal rate of polling. This
	// runs as long as the editor is focused.
	TextareaInput.prototype.slowPoll = function () {
	    var this$1 = this;

	  if (this.pollingFast) { return }
	  this.polling.set(this.cm.options.pollInterval, function () {
	    this$1.poll();
	    if (this$1.cm.state.focused) { this$1.slowPoll(); }
	  });
	};

	// When an event has just come in that is likely to add or change
	// something in the input textarea, we poll faster, to ensure that
	// the change appears on the screen quickly.
	TextareaInput.prototype.fastPoll = function () {
	  var missed = false, input = this;
	  input.pollingFast = true;
	  function p() {
	    var changed = input.poll();
	    if (!changed && !missed) {missed = true; input.polling.set(60, p);}
	    else {input.pollingFast = false; input.slowPoll();}
	  }
	  input.polling.set(20, p);
	};

	// Read input from the textarea, and update the document to match.
	// When something is selected, it is present in the textarea, and
	// selected (unless it is huge, in which case a placeholder is
	// used). When nothing is selected, the cursor sits after previously
	// seen text (can be empty), which is stored in prevInput (we must
	// not reset the textarea when typing, because that breaks IME).
	TextareaInput.prototype.poll = function () {
	    var this$1 = this;

	  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
	  // Since this is called a *lot*, try to bail out as cheaply as
	  // possible when it is clear that nothing happened. hasSelection
	  // will be the case when there is a lot of text in the textarea,
	  // in which case reading its value would be expensive.
	  if (this.contextMenuPending || !cm.state.focused ||
	      (hasSelection(input) && !prevInput && !this.composing) ||
	      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
	    { return false }

	  var text = input.value;
	  // If nothing changed, bail.
	  if (text == prevInput && !cm.somethingSelected()) { return false }
	  // Work around nonsensical selection resetting in IE9/10, and
	  // inexplicable appearance of private area unicode characters on
	  // some key combos in Mac (#2689).
	  if (ie && ie_version >= 9 && this.hasSelection === text ||
	      mac && /[\uf700-\uf7ff]/.test(text)) {
	    cm.display.input.reset();
	    return false
	  }

	  if (cm.doc.sel == cm.display.selForContextMenu) {
	    var first = text.charCodeAt(0);
	    if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
	    if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
	  }
	  // Find the part of the input that is actually new
	  var same = 0, l = Math.min(prevInput.length, text.length);
	  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

	  runInOp(cm, function () {
	    applyTextInput(cm, text.slice(same), prevInput.length - same,
	                   null, this$1.composing ? "*compose" : null);

	    // Don't leave long text in the textarea, since it makes further polling slow
	    if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
	    else { this$1.prevInput = text; }

	    if (this$1.composing) {
	      this$1.composing.range.clear();
	      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
	                                         {className: "CodeMirror-composing"});
	    }
	  });
	  return true
	};

	TextareaInput.prototype.ensurePolled = function () {
	  if (this.pollingFast && this.poll()) { this.pollingFast = false; }
	};

	TextareaInput.prototype.onKeyPress = function () {
	  if (ie && ie_version >= 9) { this.hasSelection = null; }
	  this.fastPoll();
	};

	TextareaInput.prototype.onContextMenu = function (e) {
	  var input = this, cm = input.cm, display = cm.display, te = input.textarea;
	  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
	  if (!pos || presto) { return } // Opera is difficult.

	  // Reset the current text selection only if the click is done outside of the selection
	  // and 'resetSelectionOnContextMenu' option is true.
	  var reset = cm.options.resetSelectionOnContextMenu;
	  if (reset && cm.doc.sel.contains(pos) == -1)
	    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

	  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
	  input.wrapper.style.cssText = "position: absolute";
	  var wrapperBox = input.wrapper.getBoundingClientRect();
	  te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
	  var oldScrollY;
	  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
	  display.input.focus();
	  if (webkit) { window.scrollTo(null, oldScrollY); }
	  display.input.reset();
	  // Adds "Select all" to context menu in FF
	  if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
	  input.contextMenuPending = true;
	  display.selForContextMenu = cm.doc.sel;
	  clearTimeout(display.detectingSelectAll);

	  // Select-all will be greyed out if there's nothing to select, so
	  // this adds a zero-width space so that we can later check whether
	  // it got selected.
	  function prepareSelectAllHack() {
	    if (te.selectionStart != null) {
	      var selected = cm.somethingSelected();
	      var extval = "\u200b" + (selected ? te.value : "");
	      te.value = "\u21da"; // Used to catch context-menu undo
	      te.value = extval;
	      input.prevInput = selected ? "" : "\u200b";
	      te.selectionStart = 1; te.selectionEnd = extval.length;
	      // Re-set this, in case some other handler touched the
	      // selection in the meantime.
	      display.selForContextMenu = cm.doc.sel;
	    }
	  }
	  function rehide() {
	    input.contextMenuPending = false;
	    input.wrapper.style.cssText = oldWrapperCSS;
	    te.style.cssText = oldCSS;
	    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

	    // Try to detect the user choosing select-all
	    if (te.selectionStart != null) {
	      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
	      var i = 0, poll = function () {
	        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
	            te.selectionEnd > 0 && input.prevInput == "\u200b") {
	          operation(cm, selectAll)(cm);
	        } else if (i++ < 10) {
	          display.detectingSelectAll = setTimeout(poll, 500);
	        } else {
	          display.selForContextMenu = null;
	          display.input.reset();
	        }
	      };
	      display.detectingSelectAll = setTimeout(poll, 200);
	    }
	  }

	  if (ie && ie_version >= 9) { prepareSelectAllHack(); }
	  if (captureRightClick) {
	    e_stop(e);
	    var mouseup = function () {
	      off(window, "mouseup", mouseup);
	      setTimeout(rehide, 20);
	    };
	    on(window, "mouseup", mouseup);
	  } else {
	    setTimeout(rehide, 50);
	  }
	};

	TextareaInput.prototype.readOnlyChanged = function (val) {
	  if (!val) { this.reset(); }
	};

	TextareaInput.prototype.setUneditable = function () {};

	TextareaInput.prototype.needsContentAttribute = false;

	function fromTextArea(textarea, options) {
	  options = options ? copyObj(options) : {};
	  options.value = textarea.value;
	  if (!options.tabindex && textarea.tabIndex)
	    { options.tabindex = textarea.tabIndex; }
	  if (!options.placeholder && textarea.placeholder)
	    { options.placeholder = textarea.placeholder; }
	  // Set autofocus to true if this textarea is focused, or if it has
	  // autofocus and no other element is focused.
	  if (options.autofocus == null) {
	    var hasFocus = activeElt();
	    options.autofocus = hasFocus == textarea ||
	      textarea.getAttribute("autofocus") != null && hasFocus == document.body;
	  }

	  function save() {textarea.value = cm.getValue();}

	  var realSubmit;
	  if (textarea.form) {
	    on(textarea.form, "submit", save);
	    // Deplorable hack to make the submit method do the right thing.
	    if (!options.leaveSubmitMethodAlone) {
	      var form = textarea.form;
	      realSubmit = form.submit;
	      try {
	        var wrappedSubmit = form.submit = function () {
	          save();
	          form.submit = realSubmit;
	          form.submit();
	          form.submit = wrappedSubmit;
	        };
	      } catch(e) {}
	    }
	  }

	  options.finishInit = function (cm) {
	    cm.save = save;
	    cm.getTextArea = function () { return textarea; };
	    cm.toTextArea = function () {
	      cm.toTextArea = isNaN; // Prevent this from being ran twice
	      save();
	      textarea.parentNode.removeChild(cm.getWrapperElement());
	      textarea.style.display = "";
	      if (textarea.form) {
	        off(textarea.form, "submit", save);
	        if (typeof textarea.form.submit == "function")
	          { textarea.form.submit = realSubmit; }
	      }
	    };
	  };

	  textarea.style.display = "none";
	  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
	    options);
	  return cm
	}

	function addLegacyProps(CodeMirror) {
	  CodeMirror.off = off;
	  CodeMirror.on = on;
	  CodeMirror.wheelEventPixels = wheelEventPixels;
	  CodeMirror.Doc = Doc;
	  CodeMirror.splitLines = splitLinesAuto;
	  CodeMirror.countColumn = countColumn;
	  CodeMirror.findColumn = findColumn;
	  CodeMirror.isWordChar = isWordCharBasic;
	  CodeMirror.Pass = Pass;
	  CodeMirror.signal = signal;
	  CodeMirror.Line = Line;
	  CodeMirror.changeEnd = changeEnd;
	  CodeMirror.scrollbarModel = scrollbarModel;
	  CodeMirror.Pos = Pos;
	  CodeMirror.cmpPos = cmp;
	  CodeMirror.modes = modes;
	  CodeMirror.mimeModes = mimeModes;
	  CodeMirror.resolveMode = resolveMode;
	  CodeMirror.getMode = getMode;
	  CodeMirror.modeExtensions = modeExtensions;
	  CodeMirror.extendMode = extendMode;
	  CodeMirror.copyState = copyState;
	  CodeMirror.startState = startState;
	  CodeMirror.innerMode = innerMode;
	  CodeMirror.commands = commands;
	  CodeMirror.keyMap = keyMap;
	  CodeMirror.keyName = keyName;
	  CodeMirror.isModifierKey = isModifierKey;
	  CodeMirror.lookupKey = lookupKey;
	  CodeMirror.normalizeKeyMap = normalizeKeyMap;
	  CodeMirror.StringStream = StringStream;
	  CodeMirror.SharedTextMarker = SharedTextMarker;
	  CodeMirror.TextMarker = TextMarker;
	  CodeMirror.LineWidget = LineWidget;
	  CodeMirror.e_preventDefault = e_preventDefault;
	  CodeMirror.e_stopPropagation = e_stopPropagation;
	  CodeMirror.e_stop = e_stop;
	  CodeMirror.addClass = addClass;
	  CodeMirror.contains = contains;
	  CodeMirror.rmClass = rmClass;
	  CodeMirror.keyNames = keyNames;
	}

	// EDITOR CONSTRUCTOR

	defineOptions(CodeMirror$1);

	addEditorMethods(CodeMirror$1);

	// Set up methods on CodeMirror's prototype to redirect to the editor's document.
	var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
	for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
	  { CodeMirror$1.prototype[prop] = (function(method) {
	    return function() {return method.apply(this.doc, arguments)}
	  })(Doc.prototype[prop]); } }

	eventMixin(Doc);

	// INPUT HANDLING

	CodeMirror$1.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

	// MODE DEFINITION AND QUERYING

	// Extra arguments are stored as the mode's dependencies, which is
	// used by (legacy) mechanisms like loadmode.js to automatically
	// load a mode. (Preferred mechanism is the require/define calls.)
	CodeMirror$1.defineMode = function(name/*, mode, …*/) {
	  if (!CodeMirror$1.defaults.mode && name != "null") { CodeMirror$1.defaults.mode = name; }
	  defineMode.apply(this, arguments);
	};

	CodeMirror$1.defineMIME = defineMIME;

	// Minimal default mode.
	CodeMirror$1.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
	CodeMirror$1.defineMIME("text/plain", "null");

	// EXTENSIONS

	CodeMirror$1.defineExtension = function (name, func) {
	  CodeMirror$1.prototype[name] = func;
	};
	CodeMirror$1.defineDocExtension = function (name, func) {
	  Doc.prototype[name] = func;
	};

	CodeMirror$1.fromTextArea = fromTextArea;

	addLegacyProps(CodeMirror$1);

	CodeMirror$1.version = "5.25.0";

	return CodeMirror$1;

	})));


/***/ },
/* 307 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 308 */,
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(306));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";

	function expressionAllowed(stream, state, backUp) {
	  return /^(?:operator|sof|keyword c|case|new|export|default|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
	    (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
	}

	CodeMirror.defineMode("javascript", function(config, parserConfig) {
	  var indentUnit = config.indentUnit;
	  var statementIndent = parserConfig.statementIndent;
	  var jsonldMode = parserConfig.jsonld;
	  var jsonMode = parserConfig.json || jsonldMode;
	  var isTS = parserConfig.typescript;
	  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

	  // Tokenizer

	  var keywords = function(){
	    function kw(type) {return {type: type, style: "keyword"};}
	    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
	    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

	    var jsKeywords = {
	      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
	      "return": C, "break": C, "continue": C, "new": kw("new"), "delete": C, "throw": C, "debugger": C,
	      "var": kw("var"), "const": kw("var"), "let": kw("var"),
	      "function": kw("function"), "catch": kw("catch"),
	      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
	      "in": operator, "typeof": operator, "instanceof": operator,
	      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
	      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
	      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
	      "await": C, "async": kw("async")
	    };

	    // Extend the 'normal' keywords with the TypeScript language extensions
	    if (isTS) {
	      var type = {type: "variable", style: "variable-3"};
	      var tsKeywords = {
	        // object-like things
	        "interface": kw("class"),
	        "implements": C,
	        "namespace": C,
	        "module": kw("module"),
	        "enum": kw("module"),
	        "type": kw("type"),

	        // scope modifiers
	        "public": kw("modifier"),
	        "private": kw("modifier"),
	        "protected": kw("modifier"),
	        "abstract": kw("modifier"),

	        // operators
	        "as": operator,

	        // types
	        "string": type, "number": type, "boolean": type, "any": type
	      };

	      for (var attr in tsKeywords) {
	        jsKeywords[attr] = tsKeywords[attr];
	      }
	    }

	    return jsKeywords;
	  }();

	  var isOperatorChar = /[+\-*&%=<>!?|~^]/;
	  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

	  function readRegexp(stream) {
	    var escaped = false, next, inSet = false;
	    while ((next = stream.next()) != null) {
	      if (!escaped) {
	        if (next == "/" && !inSet) return;
	        if (next == "[") inSet = true;
	        else if (inSet && next == "]") inSet = false;
	      }
	      escaped = !escaped && next == "\\";
	    }
	  }

	  // Used as scratch variables to communicate multiple values without
	  // consing up tons of objects.
	  var type, content;
	  function ret(tp, style, cont) {
	    type = tp; content = cont;
	    return style;
	  }
	  function tokenBase(stream, state) {
	    var ch = stream.next();
	    if (ch == '"' || ch == "'") {
	      state.tokenize = tokenString(ch);
	      return state.tokenize(stream, state);
	    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
	      return ret("number", "number");
	    } else if (ch == "." && stream.match("..")) {
	      return ret("spread", "meta");
	    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
	      return ret(ch);
	    } else if (ch == "=" && stream.eat(">")) {
	      return ret("=>", "operator");
	    } else if (ch == "0" && stream.eat(/x/i)) {
	      stream.eatWhile(/[\da-f]/i);
	      return ret("number", "number");
	    } else if (ch == "0" && stream.eat(/o/i)) {
	      stream.eatWhile(/[0-7]/i);
	      return ret("number", "number");
	    } else if (ch == "0" && stream.eat(/b/i)) {
	      stream.eatWhile(/[01]/i);
	      return ret("number", "number");
	    } else if (/\d/.test(ch)) {
	      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
	      return ret("number", "number");
	    } else if (ch == "/") {
	      if (stream.eat("*")) {
	        state.tokenize = tokenComment;
	        return tokenComment(stream, state);
	      } else if (stream.eat("/")) {
	        stream.skipToEnd();
	        return ret("comment", "comment");
	      } else if (expressionAllowed(stream, state, 1)) {
	        readRegexp(stream);
	        stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
	        return ret("regexp", "string-2");
	      } else {
	        stream.eatWhile(isOperatorChar);
	        return ret("operator", "operator", stream.current());
	      }
	    } else if (ch == "`") {
	      state.tokenize = tokenQuasi;
	      return tokenQuasi(stream, state);
	    } else if (ch == "#") {
	      stream.skipToEnd();
	      return ret("error", "error");
	    } else if (isOperatorChar.test(ch)) {
	      if (ch != ">" || !state.lexical || state.lexical.type != ">")
	        stream.eatWhile(isOperatorChar);
	      return ret("operator", "operator", stream.current());
	    } else if (wordRE.test(ch)) {
	      stream.eatWhile(wordRE);
	      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
	      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
	                     ret("variable", "variable", word);
	    }
	  }

	  function tokenString(quote) {
	    return function(stream, state) {
	      var escaped = false, next;
	      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
	        state.tokenize = tokenBase;
	        return ret("jsonld-keyword", "meta");
	      }
	      while ((next = stream.next()) != null) {
	        if (next == quote && !escaped) break;
	        escaped = !escaped && next == "\\";
	      }
	      if (!escaped) state.tokenize = tokenBase;
	      return ret("string", "string");
	    };
	  }

	  function tokenComment(stream, state) {
	    var maybeEnd = false, ch;
	    while (ch = stream.next()) {
	      if (ch == "/" && maybeEnd) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      maybeEnd = (ch == "*");
	    }
	    return ret("comment", "comment");
	  }

	  function tokenQuasi(stream, state) {
	    var escaped = false, next;
	    while ((next = stream.next()) != null) {
	      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      escaped = !escaped && next == "\\";
	    }
	    return ret("quasi", "string-2", stream.current());
	  }

	  var brackets = "([{}])";
	  // This is a crude lookahead trick to try and notice that we're
	  // parsing the argument patterns for a fat-arrow function before we
	  // actually hit the arrow token. It only works if the arrow is on
	  // the same line as the arguments and there's no strange noise
	  // (comments) in between. Fallback is to only notice when we hit the
	  // arrow, and not declare the arguments as locals for the arrow
	  // body.
	  function findFatArrow(stream, state) {
	    if (state.fatArrowAt) state.fatArrowAt = null;
	    var arrow = stream.string.indexOf("=>", stream.start);
	    if (arrow < 0) return;

	    if (isTS) { // Try to skip TypeScript return type declarations after the arguments
	      var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow))
	      if (m) arrow = m.index
	    }

	    var depth = 0, sawSomething = false;
	    for (var pos = arrow - 1; pos >= 0; --pos) {
	      var ch = stream.string.charAt(pos);
	      var bracket = brackets.indexOf(ch);
	      if (bracket >= 0 && bracket < 3) {
	        if (!depth) { ++pos; break; }
	        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
	      } else if (bracket >= 3 && bracket < 6) {
	        ++depth;
	      } else if (wordRE.test(ch)) {
	        sawSomething = true;
	      } else if (/["'\/]/.test(ch)) {
	        return;
	      } else if (sawSomething && !depth) {
	        ++pos;
	        break;
	      }
	    }
	    if (sawSomething && !depth) state.fatArrowAt = pos;
	  }

	  // Parser

	  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

	  function JSLexical(indented, column, type, align, prev, info) {
	    this.indented = indented;
	    this.column = column;
	    this.type = type;
	    this.prev = prev;
	    this.info = info;
	    if (align != null) this.align = align;
	  }

	  function inScope(state, varname) {
	    for (var v = state.localVars; v; v = v.next)
	      if (v.name == varname) return true;
	    for (var cx = state.context; cx; cx = cx.prev) {
	      for (var v = cx.vars; v; v = v.next)
	        if (v.name == varname) return true;
	    }
	  }

	  function parseJS(state, style, type, content, stream) {
	    var cc = state.cc;
	    // Communicate our context to the combinators.
	    // (Less wasteful than consing up a hundred closures on every call.)
	    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

	    if (!state.lexical.hasOwnProperty("align"))
	      state.lexical.align = true;

	    while(true) {
	      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
	      if (combinator(type, content)) {
	        while(cc.length && cc[cc.length - 1].lex)
	          cc.pop()();
	        if (cx.marked) return cx.marked;
	        if (type == "variable" && inScope(state, content)) return "variable-2";
	        return style;
	      }
	    }
	  }

	  // Combinator utils

	  var cx = {state: null, column: null, marked: null, cc: null};
	  function pass() {
	    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
	  }
	  function cont() {
	    pass.apply(null, arguments);
	    return true;
	  }
	  function register(varname) {
	    function inList(list) {
	      for (var v = list; v; v = v.next)
	        if (v.name == varname) return true;
	      return false;
	    }
	    var state = cx.state;
	    cx.marked = "def";
	    if (state.context) {
	      if (inList(state.localVars)) return;
	      state.localVars = {name: varname, next: state.localVars};
	    } else {
	      if (inList(state.globalVars)) return;
	      if (parserConfig.globalVars)
	        state.globalVars = {name: varname, next: state.globalVars};
	    }
	  }

	  // Combinators

	  var defaultVars = {name: "this", next: {name: "arguments"}};
	  function pushcontext() {
	    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
	    cx.state.localVars = defaultVars;
	  }
	  function popcontext() {
	    cx.state.localVars = cx.state.context.vars;
	    cx.state.context = cx.state.context.prev;
	  }
	  function pushlex(type, info) {
	    var result = function() {
	      var state = cx.state, indent = state.indented;
	      if (state.lexical.type == "stat") indent = state.lexical.indented;
	      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
	        indent = outer.indented;
	      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
	    };
	    result.lex = true;
	    return result;
	  }
	  function poplex() {
	    var state = cx.state;
	    if (state.lexical.prev) {
	      if (state.lexical.type == ")")
	        state.indented = state.lexical.indented;
	      state.lexical = state.lexical.prev;
	    }
	  }
	  poplex.lex = true;

	  function expect(wanted) {
	    function exp(type) {
	      if (type == wanted) return cont();
	      else if (wanted == ";") return pass();
	      else return cont(exp);
	    };
	    return exp;
	  }

	  function statement(type, value) {
	    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
	    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
	    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
	    if (type == "{") return cont(pushlex("}"), block, poplex);
	    if (type == ";") return cont();
	    if (type == "if") {
	      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
	        cx.state.cc.pop()();
	      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
	    }
	    if (type == "function") return cont(functiondef);
	    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
	    if (type == "variable") return cont(pushlex("stat"), maybelabel);
	    if (type == "switch") return cont(pushlex("form"), parenExpr, pushlex("}", "switch"), expect("{"),
	                                      block, poplex, poplex);
	    if (type == "case") return cont(expression, expect(":"));
	    if (type == "default") return cont(expect(":"));
	    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
	                                     statement, poplex, popcontext);
	    if (type == "class") return cont(pushlex("form"), className, poplex);
	    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
	    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
	    if (type == "module") return cont(pushlex("form"), pattern, pushlex("}"), expect("{"), block, poplex, poplex)
	    if (type == "type") return cont(typeexpr, expect("operator"), typeexpr, expect(";"));
	    if (type == "async") return cont(statement)
	    return pass(pushlex("stat"), expression, expect(";"), poplex);
	  }
	  function expression(type) {
	    return expressionInner(type, false);
	  }
	  function expressionNoComma(type) {
	    return expressionInner(type, true);
	  }
	  function parenExpr(type) {
	    if (type != "(") return pass()
	    return cont(pushlex(")"), expression, expect(")"), poplex)
	  }
	  function expressionInner(type, noComma) {
	    if (cx.state.fatArrowAt == cx.stream.start) {
	      var body = noComma ? arrowBodyNoComma : arrowBody;
	      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
	      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
	    }

	    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
	    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
	    if (type == "function") return cont(functiondef, maybeop);
	    if (type == "class") return cont(pushlex("form"), classExpression, poplex);
	    if (type == "keyword c" || type == "async") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
	    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
	    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
	    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
	    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
	    if (type == "quasi") return pass(quasi, maybeop);
	    if (type == "new") return cont(maybeTarget(noComma));
	    return cont();
	  }
	  function maybeexpression(type) {
	    if (type.match(/[;\}\)\],]/)) return pass();
	    return pass(expression);
	  }
	  function maybeexpressionNoComma(type) {
	    if (type.match(/[;\}\)\],]/)) return pass();
	    return pass(expressionNoComma);
	  }

	  function maybeoperatorComma(type, value) {
	    if (type == ",") return cont(expression);
	    return maybeoperatorNoComma(type, value, false);
	  }
	  function maybeoperatorNoComma(type, value, noComma) {
	    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
	    var expr = noComma == false ? expression : expressionNoComma;
	    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
	    if (type == "operator") {
	      if (/\+\+|--/.test(value)) return cont(me);
	      if (value == "?") return cont(expression, expect(":"), expr);
	      return cont(expr);
	    }
	    if (type == "quasi") { return pass(quasi, me); }
	    if (type == ";") return;
	    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
	    if (type == ".") return cont(property, me);
	    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
	  }
	  function quasi(type, value) {
	    if (type != "quasi") return pass();
	    if (value.slice(value.length - 2) != "${") return cont(quasi);
	    return cont(expression, continueQuasi);
	  }
	  function continueQuasi(type) {
	    if (type == "}") {
	      cx.marked = "string-2";
	      cx.state.tokenize = tokenQuasi;
	      return cont(quasi);
	    }
	  }
	  function arrowBody(type) {
	    findFatArrow(cx.stream, cx.state);
	    return pass(type == "{" ? statement : expression);
	  }
	  function arrowBodyNoComma(type) {
	    findFatArrow(cx.stream, cx.state);
	    return pass(type == "{" ? statement : expressionNoComma);
	  }
	  function maybeTarget(noComma) {
	    return function(type) {
	      if (type == ".") return cont(noComma ? targetNoComma : target);
	      else return pass(noComma ? expressionNoComma : expression);
	    };
	  }
	  function target(_, value) {
	    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
	  }
	  function targetNoComma(_, value) {
	    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
	  }
	  function maybelabel(type) {
	    if (type == ":") return cont(poplex, statement);
	    return pass(maybeoperatorComma, expect(";"), poplex);
	  }
	  function property(type) {
	    if (type == "variable") {cx.marked = "property"; return cont();}
	  }
	  function objprop(type, value) {
	    if (type == "async") {
	      cx.marked = "property";
	      return cont(objprop);
	    } else if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property";
	      if (value == "get" || value == "set") return cont(getterSetter);
	      return cont(afterprop);
	    } else if (type == "number" || type == "string") {
	      cx.marked = jsonldMode ? "property" : (cx.style + " property");
	      return cont(afterprop);
	    } else if (type == "jsonld-keyword") {
	      return cont(afterprop);
	    } else if (type == "modifier") {
	      return cont(objprop)
	    } else if (type == "[") {
	      return cont(expression, expect("]"), afterprop);
	    } else if (type == "spread") {
	      return cont(expression);
	    } else if (type == ":") {
	      return pass(afterprop)
	    }
	  }
	  function getterSetter(type) {
	    if (type != "variable") return pass(afterprop);
	    cx.marked = "property";
	    return cont(functiondef);
	  }
	  function afterprop(type) {
	    if (type == ":") return cont(expressionNoComma);
	    if (type == "(") return pass(functiondef);
	  }
	  function commasep(what, end, sep) {
	    function proceed(type, value) {
	      if (sep ? sep.indexOf(type) > -1 : type == ",") {
	        var lex = cx.state.lexical;
	        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
	        return cont(function(type, value) {
	          if (type == end || value == end) return pass()
	          return pass(what)
	        }, proceed);
	      }
	      if (type == end || value == end) return cont();
	      return cont(expect(end));
	    }
	    return function(type, value) {
	      if (type == end || value == end) return cont();
	      return pass(what, proceed);
	    };
	  }
	  function contCommasep(what, end, info) {
	    for (var i = 3; i < arguments.length; i++)
	      cx.cc.push(arguments[i]);
	    return cont(pushlex(end, info), commasep(what, end), poplex);
	  }
	  function block(type) {
	    if (type == "}") return cont();
	    return pass(statement, block);
	  }
	  function maybetype(type, value) {
	    if (isTS) {
	      if (type == ":") return cont(typeexpr);
	      if (value == "?") return cont(maybetype);
	    }
	  }
	  function typeexpr(type) {
	    if (type == "variable") {cx.marked = "variable-3"; return cont(afterType);}
	    if (type == "string" || type == "number" || type == "atom") return cont(afterType);
	    if (type == "{") return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex)
	    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType)
	  }
	  function maybeReturnType(type) {
	    if (type == "=>") return cont(typeexpr)
	  }
	  function typeprop(type, value) {
	    if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property"
	      return cont(typeprop)
	    } else if (value == "?") {
	      return cont(typeprop)
	    } else if (type == ":") {
	      return cont(typeexpr)
	    }
	  }
	  function typearg(type) {
	    if (type == "variable") return cont(typearg)
	    else if (type == ":") return cont(typeexpr)
	  }
	  function afterType(type, value) {
	    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
	    if (value == "|" || type == ".") return cont(typeexpr)
	    if (type == "[") return cont(expect("]"), afterType)
	  }
	  function vardef() {
	    return pass(pattern, maybetype, maybeAssign, vardefCont);
	  }
	  function pattern(type, value) {
	    if (type == "modifier") return cont(pattern)
	    if (type == "variable") { register(value); return cont(); }
	    if (type == "spread") return cont(pattern);
	    if (type == "[") return contCommasep(pattern, "]");
	    if (type == "{") return contCommasep(proppattern, "}");
	  }
	  function proppattern(type, value) {
	    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
	      register(value);
	      return cont(maybeAssign);
	    }
	    if (type == "variable") cx.marked = "property";
	    if (type == "spread") return cont(pattern);
	    if (type == "}") return pass();
	    return cont(expect(":"), pattern, maybeAssign);
	  }
	  function maybeAssign(_type, value) {
	    if (value == "=") return cont(expressionNoComma);
	  }
	  function vardefCont(type) {
	    if (type == ",") return cont(vardef);
	  }
	  function maybeelse(type, value) {
	    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
	  }
	  function forspec(type) {
	    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
	  }
	  function forspec1(type) {
	    if (type == "var") return cont(vardef, expect(";"), forspec2);
	    if (type == ";") return cont(forspec2);
	    if (type == "variable") return cont(formaybeinof);
	    return pass(expression, expect(";"), forspec2);
	  }
	  function formaybeinof(_type, value) {
	    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
	    return cont(maybeoperatorComma, forspec2);
	  }
	  function forspec2(type, value) {
	    if (type == ";") return cont(forspec3);
	    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
	    return pass(expression, expect(";"), forspec3);
	  }
	  function forspec3(type) {
	    if (type != ")") cont(expression);
	  }
	  function functiondef(type, value) {
	    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
	    if (type == "variable") {register(value); return cont(functiondef);}
	    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, maybetype, statement, popcontext);
	  }
	  function funarg(type) {
	    if (type == "spread") return cont(funarg);
	    return pass(pattern, maybetype, maybeAssign);
	  }
	  function classExpression(type, value) {
	    // Class expressions may have an optional name.
	    if (type == "variable") return className(type, value);
	    return classNameAfter(type, value);
	  }
	  function className(type, value) {
	    if (type == "variable") {register(value); return cont(classNameAfter);}
	  }
	  function classNameAfter(type, value) {
	    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, classNameAfter)
	    if (value == "extends" || value == "implements" || (isTS && type == ","))
	      return cont(isTS ? typeexpr : expression, classNameAfter);
	    if (type == "{") return cont(pushlex("}"), classBody, poplex);
	  }
	  function classBody(type, value) {
	    if (type == "variable" || cx.style == "keyword") {
	      if ((value == "async" || value == "static" || value == "get" || value == "set" ||
	           (isTS && (value == "public" || value == "private" || value == "protected" || value == "readonly" || value == "abstract"))) &&
	          cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
	        cx.marked = "keyword";
	        return cont(classBody);
	      }
	      cx.marked = "property";
	      return cont(isTS ? classfield : functiondef, classBody);
	    }
	    if (type == "[")
	      return cont(expression, expect("]"), isTS ? classfield : functiondef, classBody)
	    if (value == "*") {
	      cx.marked = "keyword";
	      return cont(classBody);
	    }
	    if (type == ";") return cont(classBody);
	    if (type == "}") return cont();
	  }
	  function classfield(type, value) {
	    if (value == "?") return cont(classfield)
	    if (type == ":") return cont(typeexpr, maybeAssign)
	    if (value == "=") return cont(expressionNoComma)
	    return pass(functiondef)
	  }
	  function afterExport(type, value) {
	    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
	    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
	    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
	    return pass(statement);
	  }
	  function exportField(type, value) {
	    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
	    if (type == "variable") return pass(expressionNoComma, exportField);
	  }
	  function afterImport(type) {
	    if (type == "string") return cont();
	    return pass(importSpec, maybeMoreImports, maybeFrom);
	  }
	  function importSpec(type, value) {
	    if (type == "{") return contCommasep(importSpec, "}");
	    if (type == "variable") register(value);
	    if (value == "*") cx.marked = "keyword";
	    return cont(maybeAs);
	  }
	  function maybeMoreImports(type) {
	    if (type == ",") return cont(importSpec, maybeMoreImports)
	  }
	  function maybeAs(_type, value) {
	    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
	  }
	  function maybeFrom(_type, value) {
	    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
	  }
	  function arrayLiteral(type) {
	    if (type == "]") return cont();
	    return pass(commasep(expressionNoComma, "]"));
	  }

	  function isContinuedStatement(state, textAfter) {
	    return state.lastType == "operator" || state.lastType == "," ||
	      isOperatorChar.test(textAfter.charAt(0)) ||
	      /[,.]/.test(textAfter.charAt(0));
	  }

	  // Interface

	  return {
	    startState: function(basecolumn) {
	      var state = {
	        tokenize: tokenBase,
	        lastType: "sof",
	        cc: [],
	        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
	        localVars: parserConfig.localVars,
	        context: parserConfig.localVars && {vars: parserConfig.localVars},
	        indented: basecolumn || 0
	      };
	      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
	        state.globalVars = parserConfig.globalVars;
	      return state;
	    },

	    token: function(stream, state) {
	      if (stream.sol()) {
	        if (!state.lexical.hasOwnProperty("align"))
	          state.lexical.align = false;
	        state.indented = stream.indentation();
	        findFatArrow(stream, state);
	      }
	      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
	      var style = state.tokenize(stream, state);
	      if (type == "comment") return style;
	      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
	      return parseJS(state, style, type, content, stream);
	    },

	    indent: function(state, textAfter) {
	      if (state.tokenize == tokenComment) return CodeMirror.Pass;
	      if (state.tokenize != tokenBase) return 0;
	      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top
	      // Kludge to prevent 'maybelse' from blocking lexical scope pops
	      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
	        var c = state.cc[i];
	        if (c == poplex) lexical = lexical.prev;
	        else if (c != maybeelse) break;
	      }
	      while ((lexical.type == "stat" || lexical.type == "form") &&
	             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
	                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
	                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
	        lexical = lexical.prev;
	      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
	        lexical = lexical.prev;
	      var type = lexical.type, closing = firstChar == type;

	      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
	      else if (type == "form" && firstChar == "{") return lexical.indented;
	      else if (type == "form") return lexical.indented + indentUnit;
	      else if (type == "stat")
	        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
	      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
	        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
	      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
	      else return lexical.indented + (closing ? 0 : indentUnit);
	    },

	    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
	    blockCommentStart: jsonMode ? null : "/*",
	    blockCommentEnd: jsonMode ? null : "*/",
	    lineComment: jsonMode ? null : "//",
	    fold: "brace",
	    closeBrackets: "()[]{}''\"\"``",

	    helperType: jsonMode ? "json" : "javascript",
	    jsonldMode: jsonldMode,
	    jsonMode: jsonMode,

	    expressionAllowed: expressionAllowed,
	    skipExpression: function(state) {
	      var top = state.cc[state.cc.length - 1]
	      if (top == expression || top == expressionNoComma) state.cc.pop()
	    }
	  };
	});

	CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

	CodeMirror.defineMIME("text/javascript", "javascript");
	CodeMirror.defineMIME("text/ecmascript", "javascript");
	CodeMirror.defineMIME("application/javascript", "javascript");
	CodeMirror.defineMIME("application/x-javascript", "javascript");
	CodeMirror.defineMIME("application/ecmascript", "javascript");
	CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
	CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
	CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
	CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
	CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

	});


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(306), __webpack_require__(311), __webpack_require__(309), __webpack_require__(312));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";

	  var defaultTags = {
	    script: [
	      ["lang", /(javascript|babel)/i, "javascript"],
	      ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
	      ["type", /./, "text/plain"],
	      [null, null, "javascript"]
	    ],
	    style:  [
	      ["lang", /^css$/i, "css"],
	      ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
	      ["type", /./, "text/plain"],
	      [null, null, "css"]
	    ]
	  };

	  function maybeBackup(stream, pat, style) {
	    var cur = stream.current(), close = cur.search(pat);
	    if (close > -1) {
	      stream.backUp(cur.length - close);
	    } else if (cur.match(/<\/?$/)) {
	      stream.backUp(cur.length);
	      if (!stream.match(pat, false)) stream.match(cur);
	    }
	    return style;
	  }

	  var attrRegexpCache = {};
	  function getAttrRegexp(attr) {
	    var regexp = attrRegexpCache[attr];
	    if (regexp) return regexp;
	    return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
	  }

	  function getAttrValue(text, attr) {
	    var match = text.match(getAttrRegexp(attr))
	    return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
	  }

	  function getTagRegexp(tagName, anchored) {
	    return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
	  }

	  function addTags(from, to) {
	    for (var tag in from) {
	      var dest = to[tag] || (to[tag] = []);
	      var source = from[tag];
	      for (var i = source.length - 1; i >= 0; i--)
	        dest.unshift(source[i])
	    }
	  }

	  function findMatchingMode(tagInfo, tagText) {
	    for (var i = 0; i < tagInfo.length; i++) {
	      var spec = tagInfo[i];
	      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
	    }
	  }

	  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
	    var htmlMode = CodeMirror.getMode(config, {
	      name: "xml",
	      htmlMode: true,
	      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
	      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
	    });

	    var tags = {};
	    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
	    addTags(defaultTags, tags);
	    if (configTags) addTags(configTags, tags);
	    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
	      tags.script.unshift(["type", configScript[i].matches, configScript[i].mode])

	    function html(stream, state) {
	      var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName
	      if (tag && !/[<>\s\/]/.test(stream.current()) &&
	          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&
	          tags.hasOwnProperty(tagName)) {
	        state.inTag = tagName + " "
	      } else if (state.inTag && tag && />$/.test(stream.current())) {
	        var inTag = /^([\S]+) (.*)/.exec(state.inTag)
	        state.inTag = null
	        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2])
	        var mode = CodeMirror.getMode(config, modeSpec)
	        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
	        state.token = function (stream, state) {
	          if (stream.match(endTagA, false)) {
	            state.token = html;
	            state.localState = state.localMode = null;
	            return null;
	          }
	          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
	        };
	        state.localMode = mode;
	        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, ""));
	      } else if (state.inTag) {
	        state.inTag += stream.current()
	        if (stream.eol()) state.inTag += " "
	      }
	      return style;
	    };

	    return {
	      startState: function () {
	        var state = CodeMirror.startState(htmlMode);
	        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
	      },

	      copyState: function (state) {
	        var local;
	        if (state.localState) {
	          local = CodeMirror.copyState(state.localMode, state.localState);
	        }
	        return {token: state.token, inTag: state.inTag,
	                localMode: state.localMode, localState: local,
	                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
	      },

	      token: function (stream, state) {
	        return state.token(stream, state);
	      },

	      indent: function (state, textAfter) {
	        if (!state.localMode || /^\s*<\//.test(textAfter))
	          return htmlMode.indent(state.htmlState, textAfter);
	        else if (state.localMode.indent)
	          return state.localMode.indent(state.localState, textAfter);
	        else
	          return CodeMirror.Pass;
	      },

	      innerMode: function (state) {
	        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
	      }
	    };
	  }, "xml", "javascript", "css");

	  CodeMirror.defineMIME("text/html", "htmlmixed");
	});


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(306));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";

	var htmlConfig = {
	  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
	                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
	                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
	                    'track': true, 'wbr': true, 'menuitem': true},
	  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
	                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
	                     'th': true, 'tr': true},
	  contextGrabbers: {
	    'dd': {'dd': true, 'dt': true},
	    'dt': {'dd': true, 'dt': true},
	    'li': {'li': true},
	    'option': {'option': true, 'optgroup': true},
	    'optgroup': {'optgroup': true},
	    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
	          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
	          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
	          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
	          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
	    'rp': {'rp': true, 'rt': true},
	    'rt': {'rp': true, 'rt': true},
	    'tbody': {'tbody': true, 'tfoot': true},
	    'td': {'td': true, 'th': true},
	    'tfoot': {'tbody': true},
	    'th': {'td': true, 'th': true},
	    'thead': {'tbody': true, 'tfoot': true},
	    'tr': {'tr': true}
	  },
	  doNotIndent: {"pre": true},
	  allowUnquoted: true,
	  allowMissing: true,
	  caseFold: true
	}

	var xmlConfig = {
	  autoSelfClosers: {},
	  implicitlyClosed: {},
	  contextGrabbers: {},
	  doNotIndent: {},
	  allowUnquoted: false,
	  allowMissing: false,
	  caseFold: false
	}

	CodeMirror.defineMode("xml", function(editorConf, config_) {
	  var indentUnit = editorConf.indentUnit
	  var config = {}
	  var defaults = config_.htmlMode ? htmlConfig : xmlConfig
	  for (var prop in defaults) config[prop] = defaults[prop]
	  for (var prop in config_) config[prop] = config_[prop]

	  // Return variables for tokenizers
	  var type, setStyle;

	  function inText(stream, state) {
	    function chain(parser) {
	      state.tokenize = parser;
	      return parser(stream, state);
	    }

	    var ch = stream.next();
	    if (ch == "<") {
	      if (stream.eat("!")) {
	        if (stream.eat("[")) {
	          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
	          else return null;
	        } else if (stream.match("--")) {
	          return chain(inBlock("comment", "-->"));
	        } else if (stream.match("DOCTYPE", true, true)) {
	          stream.eatWhile(/[\w\._\-]/);
	          return chain(doctype(1));
	        } else {
	          return null;
	        }
	      } else if (stream.eat("?")) {
	        stream.eatWhile(/[\w\._\-]/);
	        state.tokenize = inBlock("meta", "?>");
	        return "meta";
	      } else {
	        type = stream.eat("/") ? "closeTag" : "openTag";
	        state.tokenize = inTag;
	        return "tag bracket";
	      }
	    } else if (ch == "&") {
	      var ok;
	      if (stream.eat("#")) {
	        if (stream.eat("x")) {
	          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
	        } else {
	          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
	        }
	      } else {
	        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
	      }
	      return ok ? "atom" : "error";
	    } else {
	      stream.eatWhile(/[^&<]/);
	      return null;
	    }
	  }
	  inText.isInText = true;

	  function inTag(stream, state) {
	    var ch = stream.next();
	    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
	      state.tokenize = inText;
	      type = ch == ">" ? "endTag" : "selfcloseTag";
	      return "tag bracket";
	    } else if (ch == "=") {
	      type = "equals";
	      return null;
	    } else if (ch == "<") {
	      state.tokenize = inText;
	      state.state = baseState;
	      state.tagName = state.tagStart = null;
	      var next = state.tokenize(stream, state);
	      return next ? next + " tag error" : "tag error";
	    } else if (/[\'\"]/.test(ch)) {
	      state.tokenize = inAttribute(ch);
	      state.stringStartCol = stream.column();
	      return state.tokenize(stream, state);
	    } else {
	      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
	      return "word";
	    }
	  }

	  function inAttribute(quote) {
	    var closure = function(stream, state) {
	      while (!stream.eol()) {
	        if (stream.next() == quote) {
	          state.tokenize = inTag;
	          break;
	        }
	      }
	      return "string";
	    };
	    closure.isInAttribute = true;
	    return closure;
	  }

	  function inBlock(style, terminator) {
	    return function(stream, state) {
	      while (!stream.eol()) {
	        if (stream.match(terminator)) {
	          state.tokenize = inText;
	          break;
	        }
	        stream.next();
	      }
	      return style;
	    };
	  }
	  function doctype(depth) {
	    return function(stream, state) {
	      var ch;
	      while ((ch = stream.next()) != null) {
	        if (ch == "<") {
	          state.tokenize = doctype(depth + 1);
	          return state.tokenize(stream, state);
	        } else if (ch == ">") {
	          if (depth == 1) {
	            state.tokenize = inText;
	            break;
	          } else {
	            state.tokenize = doctype(depth - 1);
	            return state.tokenize(stream, state);
	          }
	        }
	      }
	      return "meta";
	    };
	  }

	  function Context(state, tagName, startOfLine) {
	    this.prev = state.context;
	    this.tagName = tagName;
	    this.indent = state.indented;
	    this.startOfLine = startOfLine;
	    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
	      this.noIndent = true;
	  }
	  function popContext(state) {
	    if (state.context) state.context = state.context.prev;
	  }
	  function maybePopContext(state, nextTagName) {
	    var parentTagName;
	    while (true) {
	      if (!state.context) {
	        return;
	      }
	      parentTagName = state.context.tagName;
	      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
	          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
	        return;
	      }
	      popContext(state);
	    }
	  }

	  function baseState(type, stream, state) {
	    if (type == "openTag") {
	      state.tagStart = stream.column();
	      return tagNameState;
	    } else if (type == "closeTag") {
	      return closeTagNameState;
	    } else {
	      return baseState;
	    }
	  }
	  function tagNameState(type, stream, state) {
	    if (type == "word") {
	      state.tagName = stream.current();
	      setStyle = "tag";
	      return attrState;
	    } else {
	      setStyle = "error";
	      return tagNameState;
	    }
	  }
	  function closeTagNameState(type, stream, state) {
	    if (type == "word") {
	      var tagName = stream.current();
	      if (state.context && state.context.tagName != tagName &&
	          config.implicitlyClosed.hasOwnProperty(state.context.tagName))
	        popContext(state);
	      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
	        setStyle = "tag";
	        return closeState;
	      } else {
	        setStyle = "tag error";
	        return closeStateErr;
	      }
	    } else {
	      setStyle = "error";
	      return closeStateErr;
	    }
	  }

	  function closeState(type, _stream, state) {
	    if (type != "endTag") {
	      setStyle = "error";
	      return closeState;
	    }
	    popContext(state);
	    return baseState;
	  }
	  function closeStateErr(type, stream, state) {
	    setStyle = "error";
	    return closeState(type, stream, state);
	  }

	  function attrState(type, _stream, state) {
	    if (type == "word") {
	      setStyle = "attribute";
	      return attrEqState;
	    } else if (type == "endTag" || type == "selfcloseTag") {
	      var tagName = state.tagName, tagStart = state.tagStart;
	      state.tagName = state.tagStart = null;
	      if (type == "selfcloseTag" ||
	          config.autoSelfClosers.hasOwnProperty(tagName)) {
	        maybePopContext(state, tagName);
	      } else {
	        maybePopContext(state, tagName);
	        state.context = new Context(state, tagName, tagStart == state.indented);
	      }
	      return baseState;
	    }
	    setStyle = "error";
	    return attrState;
	  }
	  function attrEqState(type, stream, state) {
	    if (type == "equals") return attrValueState;
	    if (!config.allowMissing) setStyle = "error";
	    return attrState(type, stream, state);
	  }
	  function attrValueState(type, stream, state) {
	    if (type == "string") return attrContinuedState;
	    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
	    setStyle = "error";
	    return attrState(type, stream, state);
	  }
	  function attrContinuedState(type, stream, state) {
	    if (type == "string") return attrContinuedState;
	    return attrState(type, stream, state);
	  }

	  return {
	    startState: function(baseIndent) {
	      var state = {tokenize: inText,
	                   state: baseState,
	                   indented: baseIndent || 0,
	                   tagName: null, tagStart: null,
	                   context: null}
	      if (baseIndent != null) state.baseIndent = baseIndent
	      return state
	    },

	    token: function(stream, state) {
	      if (!state.tagName && stream.sol())
	        state.indented = stream.indentation();

	      if (stream.eatSpace()) return null;
	      type = null;
	      var style = state.tokenize(stream, state);
	      if ((style || type) && style != "comment") {
	        setStyle = null;
	        state.state = state.state(type || style, stream, state);
	        if (setStyle)
	          style = setStyle == "error" ? style + " error" : setStyle;
	      }
	      return style;
	    },

	    indent: function(state, textAfter, fullLine) {
	      var context = state.context;
	      // Indent multi-line strings (e.g. css).
	      if (state.tokenize.isInAttribute) {
	        if (state.tagStart == state.indented)
	          return state.stringStartCol + 1;
	        else
	          return state.indented + indentUnit;
	      }
	      if (context && context.noIndent) return CodeMirror.Pass;
	      if (state.tokenize != inTag && state.tokenize != inText)
	        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
	      // Indent the starts of attribute names.
	      if (state.tagName) {
	        if (config.multilineTagIndentPastTag !== false)
	          return state.tagStart + state.tagName.length + 2;
	        else
	          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
	      }
	      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
	      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
	      if (tagAfter && tagAfter[1]) { // Closing tag spotted
	        while (context) {
	          if (context.tagName == tagAfter[2]) {
	            context = context.prev;
	            break;
	          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
	            context = context.prev;
	          } else {
	            break;
	          }
	        }
	      } else if (tagAfter) { // Opening tag spotted
	        while (context) {
	          var grabbers = config.contextGrabbers[context.tagName];
	          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
	            context = context.prev;
	          else
	            break;
	        }
	      }
	      while (context && context.prev && !context.startOfLine)
	        context = context.prev;
	      if (context) return context.indent + indentUnit;
	      else return state.baseIndent || 0;
	    },

	    electricInput: /<\/[\s\w:]+>$/,
	    blockCommentStart: "<!--",
	    blockCommentEnd: "-->",

	    configuration: config.htmlMode ? "html" : "xml",
	    helperType: config.htmlMode ? "html" : "xml",

	    skipAttribute: function(state) {
	      if (state.state == attrValueState)
	        state.state = attrState
	    }
	  };
	});

	CodeMirror.defineMIME("text/xml", "xml");
	CodeMirror.defineMIME("application/xml", "xml");
	if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
	  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

	});


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(306));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";

	CodeMirror.defineMode("css", function(config, parserConfig) {
	  var inline = parserConfig.inline
	  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

	  var indentUnit = config.indentUnit,
	      tokenHooks = parserConfig.tokenHooks,
	      documentTypes = parserConfig.documentTypes || {},
	      mediaTypes = parserConfig.mediaTypes || {},
	      mediaFeatures = parserConfig.mediaFeatures || {},
	      mediaValueKeywords = parserConfig.mediaValueKeywords || {},
	      propertyKeywords = parserConfig.propertyKeywords || {},
	      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
	      fontProperties = parserConfig.fontProperties || {},
	      counterDescriptors = parserConfig.counterDescriptors || {},
	      colorKeywords = parserConfig.colorKeywords || {},
	      valueKeywords = parserConfig.valueKeywords || {},
	      allowNested = parserConfig.allowNested,
	      lineComment = parserConfig.lineComment,
	      supportsAtComponent = parserConfig.supportsAtComponent === true;

	  var type, override;
	  function ret(style, tp) { type = tp; return style; }

	  // Tokenizers

	  function tokenBase(stream, state) {
	    var ch = stream.next();
	    if (tokenHooks[ch]) {
	      var result = tokenHooks[ch](stream, state);
	      if (result !== false) return result;
	    }
	    if (ch == "@") {
	      stream.eatWhile(/[\w\\\-]/);
	      return ret("def", stream.current());
	    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
	      return ret(null, "compare");
	    } else if (ch == "\"" || ch == "'") {
	      state.tokenize = tokenString(ch);
	      return state.tokenize(stream, state);
	    } else if (ch == "#") {
	      stream.eatWhile(/[\w\\\-]/);
	      return ret("atom", "hash");
	    } else if (ch == "!") {
	      stream.match(/^\s*\w*/);
	      return ret("keyword", "important");
	    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
	      stream.eatWhile(/[\w.%]/);
	      return ret("number", "unit");
	    } else if (ch === "-") {
	      if (/[\d.]/.test(stream.peek())) {
	        stream.eatWhile(/[\w.%]/);
	        return ret("number", "unit");
	      } else if (stream.match(/^-[\w\\\-]+/)) {
	        stream.eatWhile(/[\w\\\-]/);
	        if (stream.match(/^\s*:/, false))
	          return ret("variable-2", "variable-definition");
	        return ret("variable-2", "variable");
	      } else if (stream.match(/^\w+-/)) {
	        return ret("meta", "meta");
	      }
	    } else if (/[,+>*\/]/.test(ch)) {
	      return ret(null, "select-op");
	    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
	      return ret("qualifier", "qualifier");
	    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
	      return ret(null, ch);
	    } else if ((ch == "u" && stream.match(/rl(-prefix)?\(/)) ||
	               (ch == "d" && stream.match("omain(")) ||
	               (ch == "r" && stream.match("egexp("))) {
	      stream.backUp(1);
	      state.tokenize = tokenParenthesized;
	      return ret("property", "word");
	    } else if (/[\w\\\-]/.test(ch)) {
	      stream.eatWhile(/[\w\\\-]/);
	      return ret("property", "word");
	    } else {
	      return ret(null, null);
	    }
	  }

	  function tokenString(quote) {
	    return function(stream, state) {
	      var escaped = false, ch;
	      while ((ch = stream.next()) != null) {
	        if (ch == quote && !escaped) {
	          if (quote == ")") stream.backUp(1);
	          break;
	        }
	        escaped = !escaped && ch == "\\";
	      }
	      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
	      return ret("string", "string");
	    };
	  }

	  function tokenParenthesized(stream, state) {
	    stream.next(); // Must be '('
	    if (!stream.match(/\s*[\"\')]/, false))
	      state.tokenize = tokenString(")");
	    else
	      state.tokenize = null;
	    return ret(null, "(");
	  }

	  // Context management

	  function Context(type, indent, prev) {
	    this.type = type;
	    this.indent = indent;
	    this.prev = prev;
	  }

	  function pushContext(state, stream, type, indent) {
	    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
	    return type;
	  }

	  function popContext(state) {
	    if (state.context.prev)
	      state.context = state.context.prev;
	    return state.context.type;
	  }

	  function pass(type, stream, state) {
	    return states[state.context.type](type, stream, state);
	  }
	  function popAndPass(type, stream, state, n) {
	    for (var i = n || 1; i > 0; i--)
	      state.context = state.context.prev;
	    return pass(type, stream, state);
	  }

	  // Parser

	  function wordAsValue(stream) {
	    var word = stream.current().toLowerCase();
	    if (valueKeywords.hasOwnProperty(word))
	      override = "atom";
	    else if (colorKeywords.hasOwnProperty(word))
	      override = "keyword";
	    else
	      override = "variable";
	  }

	  var states = {};

	  states.top = function(type, stream, state) {
	    if (type == "{") {
	      return pushContext(state, stream, "block");
	    } else if (type == "}" && state.context.prev) {
	      return popContext(state);
	    } else if (supportsAtComponent && /@component/.test(type)) {
	      return pushContext(state, stream, "atComponentBlock");
	    } else if (/^@(-moz-)?document$/.test(type)) {
	      return pushContext(state, stream, "documentTypes");
	    } else if (/^@(media|supports|(-moz-)?document|import)$/.test(type)) {
	      return pushContext(state, stream, "atBlock");
	    } else if (/^@(font-face|counter-style)/.test(type)) {
	      state.stateArg = type;
	      return "restricted_atBlock_before";
	    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {
	      return "keyframes";
	    } else if (type && type.charAt(0) == "@") {
	      return pushContext(state, stream, "at");
	    } else if (type == "hash") {
	      override = "builtin";
	    } else if (type == "word") {
	      override = "tag";
	    } else if (type == "variable-definition") {
	      return "maybeprop";
	    } else if (type == "interpolation") {
	      return pushContext(state, stream, "interpolation");
	    } else if (type == ":") {
	      return "pseudo";
	    } else if (allowNested && type == "(") {
	      return pushContext(state, stream, "parens");
	    }
	    return state.context.type;
	  };

	  states.block = function(type, stream, state) {
	    if (type == "word") {
	      var word = stream.current().toLowerCase();
	      if (propertyKeywords.hasOwnProperty(word)) {
	        override = "property";
	        return "maybeprop";
	      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
	        override = "string-2";
	        return "maybeprop";
	      } else if (allowNested) {
	        override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
	        return "block";
	      } else {
	        override += " error";
	        return "maybeprop";
	      }
	    } else if (type == "meta") {
	      return "block";
	    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
	      override = "error";
	      return "block";
	    } else {
	      return states.top(type, stream, state);
	    }
	  };

	  states.maybeprop = function(type, stream, state) {
	    if (type == ":") return pushContext(state, stream, "prop");
	    return pass(type, stream, state);
	  };

	  states.prop = function(type, stream, state) {
	    if (type == ";") return popContext(state);
	    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
	    if (type == "}" || type == "{") return popAndPass(type, stream, state);
	    if (type == "(") return pushContext(state, stream, "parens");

	    if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
	      override += " error";
	    } else if (type == "word") {
	      wordAsValue(stream);
	    } else if (type == "interpolation") {
	      return pushContext(state, stream, "interpolation");
	    }
	    return "prop";
	  };

	  states.propBlock = function(type, _stream, state) {
	    if (type == "}") return popContext(state);
	    if (type == "word") { override = "property"; return "maybeprop"; }
	    return state.context.type;
	  };

	  states.parens = function(type, stream, state) {
	    if (type == "{" || type == "}") return popAndPass(type, stream, state);
	    if (type == ")") return popContext(state);
	    if (type == "(") return pushContext(state, stream, "parens");
	    if (type == "interpolation") return pushContext(state, stream, "interpolation");
	    if (type == "word") wordAsValue(stream);
	    return "parens";
	  };

	  states.pseudo = function(type, stream, state) {
	    if (type == "meta") return "pseudo";

	    if (type == "word") {
	      override = "variable-3";
	      return state.context.type;
	    }
	    return pass(type, stream, state);
	  };

	  states.documentTypes = function(type, stream, state) {
	    if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
	      override = "tag";
	      return state.context.type;
	    } else {
	      return states.atBlock(type, stream, state);
	    }
	  };

	  states.atBlock = function(type, stream, state) {
	    if (type == "(") return pushContext(state, stream, "atBlock_parens");
	    if (type == "}" || type == ";") return popAndPass(type, stream, state);
	    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

	    if (type == "interpolation") return pushContext(state, stream, "interpolation");

	    if (type == "word") {
	      var word = stream.current().toLowerCase();
	      if (word == "only" || word == "not" || word == "and" || word == "or")
	        override = "keyword";
	      else if (mediaTypes.hasOwnProperty(word))
	        override = "attribute";
	      else if (mediaFeatures.hasOwnProperty(word))
	        override = "property";
	      else if (mediaValueKeywords.hasOwnProperty(word))
	        override = "keyword";
	      else if (propertyKeywords.hasOwnProperty(word))
	        override = "property";
	      else if (nonStandardPropertyKeywords.hasOwnProperty(word))
	        override = "string-2";
	      else if (valueKeywords.hasOwnProperty(word))
	        override = "atom";
	      else if (colorKeywords.hasOwnProperty(word))
	        override = "keyword";
	      else
	        override = "error";
	    }
	    return state.context.type;
	  };

	  states.atComponentBlock = function(type, stream, state) {
	    if (type == "}")
	      return popAndPass(type, stream, state);
	    if (type == "{")
	      return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
	    if (type == "word")
	      override = "error";
	    return state.context.type;
	  };

	  states.atBlock_parens = function(type, stream, state) {
	    if (type == ")") return popContext(state);
	    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
	    return states.atBlock(type, stream, state);
	  };

	  states.restricted_atBlock_before = function(type, stream, state) {
	    if (type == "{")
	      return pushContext(state, stream, "restricted_atBlock");
	    if (type == "word" && state.stateArg == "@counter-style") {
	      override = "variable";
	      return "restricted_atBlock_before";
	    }
	    return pass(type, stream, state);
	  };

	  states.restricted_atBlock = function(type, stream, state) {
	    if (type == "}") {
	      state.stateArg = null;
	      return popContext(state);
	    }
	    if (type == "word") {
	      if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||
	          (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))
	        override = "error";
	      else
	        override = "property";
	      return "maybeprop";
	    }
	    return "restricted_atBlock";
	  };

	  states.keyframes = function(type, stream, state) {
	    if (type == "word") { override = "variable"; return "keyframes"; }
	    if (type == "{") return pushContext(state, stream, "top");
	    return pass(type, stream, state);
	  };

	  states.at = function(type, stream, state) {
	    if (type == ";") return popContext(state);
	    if (type == "{" || type == "}") return popAndPass(type, stream, state);
	    if (type == "word") override = "tag";
	    else if (type == "hash") override = "builtin";
	    return "at";
	  };

	  states.interpolation = function(type, stream, state) {
	    if (type == "}") return popContext(state);
	    if (type == "{" || type == ";") return popAndPass(type, stream, state);
	    if (type == "word") override = "variable";
	    else if (type != "variable" && type != "(" && type != ")") override = "error";
	    return "interpolation";
	  };

	  return {
	    startState: function(base) {
	      return {tokenize: null,
	              state: inline ? "block" : "top",
	              stateArg: null,
	              context: new Context(inline ? "block" : "top", base || 0, null)};
	    },

	    token: function(stream, state) {
	      if (!state.tokenize && stream.eatSpace()) return null;
	      var style = (state.tokenize || tokenBase)(stream, state);
	      if (style && typeof style == "object") {
	        type = style[1];
	        style = style[0];
	      }
	      override = style;
	      state.state = states[state.state](type, stream, state);
	      return override;
	    },

	    indent: function(state, textAfter) {
	      var cx = state.context, ch = textAfter && textAfter.charAt(0);
	      var indent = cx.indent;
	      if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
	      if (cx.prev) {
	        if (ch == "}" && (cx.type == "block" || cx.type == "top" ||
	                          cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
	          // Resume indentation from parent context.
	          cx = cx.prev;
	          indent = cx.indent;
	        } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
	            ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
	          // Dedent relative to current context.
	          indent = Math.max(0, cx.indent - indentUnit);
	          cx = cx.prev;
	        }
	      }
	      return indent;
	    },

	    electricChars: "}",
	    blockCommentStart: "/*",
	    blockCommentEnd: "*/",
	    lineComment: lineComment,
	    fold: "brace"
	  };
	});

	  function keySet(array) {
	    var keys = {};
	    for (var i = 0; i < array.length; ++i) {
	      keys[array[i].toLowerCase()] = true;
	    }
	    return keys;
	  }

	  var documentTypes_ = [
	    "domain", "regexp", "url", "url-prefix"
	  ], documentTypes = keySet(documentTypes_);

	  var mediaTypes_ = [
	    "all", "aural", "braille", "handheld", "print", "projection", "screen",
	    "tty", "tv", "embossed"
	  ], mediaTypes = keySet(mediaTypes_);

	  var mediaFeatures_ = [
	    "width", "min-width", "max-width", "height", "min-height", "max-height",
	    "device-width", "min-device-width", "max-device-width", "device-height",
	    "min-device-height", "max-device-height", "aspect-ratio",
	    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
	    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
	    "max-color", "color-index", "min-color-index", "max-color-index",
	    "monochrome", "min-monochrome", "max-monochrome", "resolution",
	    "min-resolution", "max-resolution", "scan", "grid", "orientation",
	    "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",
	    "pointer", "any-pointer", "hover", "any-hover"
	  ], mediaFeatures = keySet(mediaFeatures_);

	  var mediaValueKeywords_ = [
	    "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",
	    "interlace", "progressive"
	  ], mediaValueKeywords = keySet(mediaValueKeywords_);

	  var propertyKeywords_ = [
	    "align-content", "align-items", "align-self", "alignment-adjust",
	    "alignment-baseline", "anchor-point", "animation", "animation-delay",
	    "animation-direction", "animation-duration", "animation-fill-mode",
	    "animation-iteration-count", "animation-name", "animation-play-state",
	    "animation-timing-function", "appearance", "azimuth", "backface-visibility",
	    "background", "background-attachment", "background-blend-mode", "background-clip",
	    "background-color", "background-image", "background-origin", "background-position",
	    "background-repeat", "background-size", "baseline-shift", "binding",
	    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
	    "bookmark-target", "border", "border-bottom", "border-bottom-color",
	    "border-bottom-left-radius", "border-bottom-right-radius",
	    "border-bottom-style", "border-bottom-width", "border-collapse",
	    "border-color", "border-image", "border-image-outset",
	    "border-image-repeat", "border-image-slice", "border-image-source",
	    "border-image-width", "border-left", "border-left-color",
	    "border-left-style", "border-left-width", "border-radius", "border-right",
	    "border-right-color", "border-right-style", "border-right-width",
	    "border-spacing", "border-style", "border-top", "border-top-color",
	    "border-top-left-radius", "border-top-right-radius", "border-top-style",
	    "border-top-width", "border-width", "bottom", "box-decoration-break",
	    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
	    "caption-side", "clear", "clip", "color", "color-profile", "column-count",
	    "column-fill", "column-gap", "column-rule", "column-rule-color",
	    "column-rule-style", "column-rule-width", "column-span", "column-width",
	    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
	    "cue-after", "cue-before", "cursor", "direction", "display",
	    "dominant-baseline", "drop-initial-after-adjust",
	    "drop-initial-after-align", "drop-initial-before-adjust",
	    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
	    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
	    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
	    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",
	    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",
	    "font-stretch", "font-style", "font-synthesis", "font-variant",
	    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
	    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
	    "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow",
	    "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap",
	    "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap",
	    "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns",
	    "grid-template-rows", "hanging-punctuation", "height", "hyphens",
	    "icon", "image-orientation", "image-rendering", "image-resolution",
	    "inline-box-align", "justify-content", "left", "letter-spacing",
	    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
	    "line-stacking-shift", "line-stacking-strategy", "list-style",
	    "list-style-image", "list-style-position", "list-style-type", "margin",
	    "margin-bottom", "margin-left", "margin-right", "margin-top",
	    "marks", "marquee-direction", "marquee-loop",
	    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
	    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
	    "nav-left", "nav-right", "nav-up", "object-fit", "object-position",
	    "opacity", "order", "orphans", "outline",
	    "outline-color", "outline-offset", "outline-style", "outline-width",
	    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
	    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
	    "page", "page-break-after", "page-break-before", "page-break-inside",
	    "page-policy", "pause", "pause-after", "pause-before", "perspective",
	    "perspective-origin", "pitch", "pitch-range", "play-during", "position",
	    "presentation-level", "punctuation-trim", "quotes", "region-break-after",
	    "region-break-before", "region-break-inside", "region-fragment",
	    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",
	    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",
	    "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin",
	    "shape-outside", "size", "speak", "speak-as", "speak-header",
	    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
	    "tab-size", "table-layout", "target", "target-name", "target-new",
	    "target-position", "text-align", "text-align-last", "text-decoration",
	    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
	    "text-decoration-style", "text-emphasis", "text-emphasis-color",
	    "text-emphasis-position", "text-emphasis-style", "text-height",
	    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",
	    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",
	    "text-wrap", "top", "transform", "transform-origin", "transform-style",
	    "transition", "transition-delay", "transition-duration",
	    "transition-property", "transition-timing-function", "unicode-bidi",
	    "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration",
	    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
	    "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break",
	    "word-spacing", "word-wrap", "z-index",
	    // SVG-specific
	    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
	    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
	    "color-interpolation", "color-interpolation-filters",
	    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
	    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
	    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
	    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
	    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
	    "glyph-orientation-vertical", "text-anchor", "writing-mode"
	  ], propertyKeywords = keySet(propertyKeywords_);

	  var nonStandardPropertyKeywords_ = [
	    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
	    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
	    "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside",
	    "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button",
	    "searchfield-results-decoration", "zoom"
	  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);

	  var fontProperties_ = [
	    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",
	    "font-stretch", "font-weight", "font-style"
	  ], fontProperties = keySet(fontProperties_);

	  var counterDescriptors_ = [
	    "additive-symbols", "fallback", "negative", "pad", "prefix", "range",
	    "speak-as", "suffix", "symbols", "system"
	  ], counterDescriptors = keySet(counterDescriptors_);

	  var colorKeywords_ = [
	    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
	    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
	    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
	    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
	    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
	    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
	    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
	    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
	    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
	    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
	    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
	    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
	    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
	    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
	    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
	    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
	    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
	    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
	    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
	    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
	    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
	    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
	    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
	    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
	    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
	    "whitesmoke", "yellow", "yellowgreen"
	  ], colorKeywords = keySet(colorKeywords_);

	  var valueKeywords_ = [
	    "above", "absolute", "activeborder", "additive", "activecaption", "afar",
	    "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",
	    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
	    "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page",
	    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
	    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
	    "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",
	    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",
	    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
	    "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",
	    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
	    "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",
	    "compact", "condensed", "contain", "content", "contents",
	    "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop",
	    "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
	    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",
	    "destination-in", "destination-out", "destination-over", "devanagari", "difference",
	    "disc", "discard", "disclosure-closed", "disclosure-open", "document",
	    "dot-dash", "dot-dot-dash",
	    "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
	    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
	    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
	    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
	    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
	    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
	    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
	    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",
	    "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",
	    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",
	    "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove",
	    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",
	    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
	    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",
	    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
	    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
	    "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",
	    "italic", "japanese-formal", "japanese-informal", "justify", "kannada",
	    "katakana", "katakana-iroha", "keep-all", "khmer",
	    "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",
	    "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",
	    "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",
	    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
	    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
	    "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d",
	    "media-controls-background", "media-current-time-display",
	    "media-fullscreen-button", "media-mute-button", "media-play-button",
	    "media-return-to-realtime-button", "media-rewind-button",
	    "media-seek-back-button", "media-seek-forward-button", "media-slider",
	    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
	    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
	    "menu", "menulist", "menulist-button", "menulist-text",
	    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
	    "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize",
	    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
	    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
	    "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",
	    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
	    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
	    "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter",
	    "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",
	    "progress", "push-button", "radial-gradient", "radio", "read-only",
	    "read-write", "read-write-plaintext-only", "rectangle", "region",
	    "relative", "repeat", "repeating-linear-gradient",
	    "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
	    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",
	    "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",
	    "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",
	    "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",
	    "searchfield-cancel-button", "searchfield-decoration",
	    "searchfield-results-button", "searchfield-results-decoration",
	    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
	    "simp-chinese-formal", "simp-chinese-informal", "single",
	    "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
	    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
	    "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",
	    "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "spell-out", "square",
	    "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub",
	    "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table",
	    "table-caption", "table-cell", "table-column", "table-column-group",
	    "table-footer-group", "table-header-group", "table-row", "table-row-group",
	    "tamil",
	    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
	    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
	    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
	    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
	    "trad-chinese-formal", "trad-chinese-informal", "transform",
	    "translate", "translate3d", "translateX", "translateY", "translateZ",
	    "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up",
	    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
	    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
	    "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
	    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
	    "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",
	    "xx-large", "xx-small"
	  ], valueKeywords = keySet(valueKeywords_);

	  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)
	    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)
	    .concat(valueKeywords_);
	  CodeMirror.registerHelper("hintWords", "css", allWords);

	  function tokenCComment(stream, state) {
	    var maybeEnd = false, ch;
	    while ((ch = stream.next()) != null) {
	      if (maybeEnd && ch == "/") {
	        state.tokenize = null;
	        break;
	      }
	      maybeEnd = (ch == "*");
	    }
	    return ["comment", "comment"];
	  }

	  CodeMirror.defineMIME("text/css", {
	    documentTypes: documentTypes,
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    mediaValueKeywords: mediaValueKeywords,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    fontProperties: fontProperties,
	    counterDescriptors: counterDescriptors,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (!stream.eat("*")) return false;
	        state.tokenize = tokenCComment;
	        return tokenCComment(stream, state);
	      }
	    },
	    name: "css"
	  });

	  CodeMirror.defineMIME("text/x-scss", {
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    mediaValueKeywords: mediaValueKeywords,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    fontProperties: fontProperties,
	    allowNested: true,
	    lineComment: "//",
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (stream.eat("/")) {
	          stream.skipToEnd();
	          return ["comment", "comment"];
	        } else if (stream.eat("*")) {
	          state.tokenize = tokenCComment;
	          return tokenCComment(stream, state);
	        } else {
	          return ["operator", "operator"];
	        }
	      },
	      ":": function(stream) {
	        if (stream.match(/\s*\{/))
	          return [null, "{"];
	        return false;
	      },
	      "$": function(stream) {
	        stream.match(/^[\w-]+/);
	        if (stream.match(/^\s*:/, false))
	          return ["variable-2", "variable-definition"];
	        return ["variable-2", "variable"];
	      },
	      "#": function(stream) {
	        if (!stream.eat("{")) return false;
	        return [null, "interpolation"];
	      }
	    },
	    name: "css",
	    helperType: "scss"
	  });

	  CodeMirror.defineMIME("text/x-less", {
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    mediaValueKeywords: mediaValueKeywords,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    fontProperties: fontProperties,
	    allowNested: true,
	    lineComment: "//",
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (stream.eat("/")) {
	          stream.skipToEnd();
	          return ["comment", "comment"];
	        } else if (stream.eat("*")) {
	          state.tokenize = tokenCComment;
	          return tokenCComment(stream, state);
	        } else {
	          return ["operator", "operator"];
	        }
	      },
	      "@": function(stream) {
	        if (stream.eat("{")) return [null, "interpolation"];
	        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/, false)) return false;
	        stream.eatWhile(/[\w\\\-]/);
	        if (stream.match(/^\s*:/, false))
	          return ["variable-2", "variable-definition"];
	        return ["variable-2", "variable"];
	      },
	      "&": function() {
	        return ["atom", "atom"];
	      }
	    },
	    name: "css",
	    helperType: "less"
	  });

	  CodeMirror.defineMIME("text/x-gss", {
	    documentTypes: documentTypes,
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    fontProperties: fontProperties,
	    counterDescriptors: counterDescriptors,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    supportsAtComponent: true,
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (!stream.eat("*")) return false;
	        state.tokenize = tokenCComment;
	        return tokenCComment(stream, state);
	      }
	    },
	    name: "css",
	    helperType: "gss"
	  });

	});


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	/**
	 * Link to the project's GitHub page:
	 * https://github.com/pickhardt/coffeescript-codemirror-mode
	 */
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(306));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";

	CodeMirror.defineMode("coffeescript", function(conf, parserConf) {
	  var ERRORCLASS = "error";

	  function wordRegexp(words) {
	    return new RegExp("^((" + words.join(")|(") + "))\\b");
	  }

	  var operators = /^(?:->|=>|\+[+=]?|-[\-=]?|\*[\*=]?|\/[\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\|=?|\^=?|\~|!|\?|(or|and|\|\||&&|\?)=)/;
	  var delimiters = /^(?:[()\[\]{},:`=;]|\.\.?\.?)/;
	  var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;
	  var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;

	  var wordOperators = wordRegexp(["and", "or", "not",
	                                  "is", "isnt", "in",
	                                  "instanceof", "typeof"]);
	  var indentKeywords = ["for", "while", "loop", "if", "unless", "else",
	                        "switch", "try", "catch", "finally", "class"];
	  var commonKeywords = ["break", "by", "continue", "debugger", "delete",
	                        "do", "in", "of", "new", "return", "then",
	                        "this", "@", "throw", "when", "until", "extends"];

	  var keywords = wordRegexp(indentKeywords.concat(commonKeywords));

	  indentKeywords = wordRegexp(indentKeywords);


	  var stringPrefixes = /^('{3}|\"{3}|['\"])/;
	  var regexPrefixes = /^(\/{3}|\/)/;
	  var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];
	  var constants = wordRegexp(commonConstants);

	  // Tokenizers
	  function tokenBase(stream, state) {
	    // Handle scope changes
	    if (stream.sol()) {
	      if (state.scope.align === null) state.scope.align = false;
	      var scopeOffset = state.scope.offset;
	      if (stream.eatSpace()) {
	        var lineOffset = stream.indentation();
	        if (lineOffset > scopeOffset && state.scope.type == "coffee") {
	          return "indent";
	        } else if (lineOffset < scopeOffset) {
	          return "dedent";
	        }
	        return null;
	      } else {
	        if (scopeOffset > 0) {
	          dedent(stream, state);
	        }
	      }
	    }
	    if (stream.eatSpace()) {
	      return null;
	    }

	    var ch = stream.peek();

	    // Handle docco title comment (single line)
	    if (stream.match("####")) {
	      stream.skipToEnd();
	      return "comment";
	    }

	    // Handle multi line comments
	    if (stream.match("###")) {
	      state.tokenize = longComment;
	      return state.tokenize(stream, state);
	    }

	    // Single line comment
	    if (ch === "#") {
	      stream.skipToEnd();
	      return "comment";
	    }

	    // Handle number literals
	    if (stream.match(/^-?[0-9\.]/, false)) {
	      var floatLiteral = false;
	      // Floats
	      if (stream.match(/^-?\d*\.\d+(e[\+\-]?\d+)?/i)) {
	        floatLiteral = true;
	      }
	      if (stream.match(/^-?\d+\.\d*/)) {
	        floatLiteral = true;
	      }
	      if (stream.match(/^-?\.\d+/)) {
	        floatLiteral = true;
	      }

	      if (floatLiteral) {
	        // prevent from getting extra . on 1..
	        if (stream.peek() == "."){
	          stream.backUp(1);
	        }
	        return "number";
	      }
	      // Integers
	      var intLiteral = false;
	      // Hex
	      if (stream.match(/^-?0x[0-9a-f]+/i)) {
	        intLiteral = true;
	      }
	      // Decimal
	      if (stream.match(/^-?[1-9]\d*(e[\+\-]?\d+)?/)) {
	        intLiteral = true;
	      }
	      // Zero by itself with no other piece of number.
	      if (stream.match(/^-?0(?![\dx])/i)) {
	        intLiteral = true;
	      }
	      if (intLiteral) {
	        return "number";
	      }
	    }

	    // Handle strings
	    if (stream.match(stringPrefixes)) {
	      state.tokenize = tokenFactory(stream.current(), false, "string");
	      return state.tokenize(stream, state);
	    }
	    // Handle regex literals
	    if (stream.match(regexPrefixes)) {
	      if (stream.current() != "/" || stream.match(/^.*\//, false)) { // prevent highlight of division
	        state.tokenize = tokenFactory(stream.current(), true, "string-2");
	        return state.tokenize(stream, state);
	      } else {
	        stream.backUp(1);
	      }
	    }



	    // Handle operators and delimiters
	    if (stream.match(operators) || stream.match(wordOperators)) {
	      return "operator";
	    }
	    if (stream.match(delimiters)) {
	      return "punctuation";
	    }

	    if (stream.match(constants)) {
	      return "atom";
	    }

	    if (stream.match(atProp) || state.prop && stream.match(identifiers)) {
	      return "property";
	    }

	    if (stream.match(keywords)) {
	      return "keyword";
	    }

	    if (stream.match(identifiers)) {
	      return "variable";
	    }

	    // Handle non-detected items
	    stream.next();
	    return ERRORCLASS;
	  }

	  function tokenFactory(delimiter, singleline, outclass) {
	    return function(stream, state) {
	      while (!stream.eol()) {
	        stream.eatWhile(/[^'"\/\\]/);
	        if (stream.eat("\\")) {
	          stream.next();
	          if (singleline && stream.eol()) {
	            return outclass;
	          }
	        } else if (stream.match(delimiter)) {
	          state.tokenize = tokenBase;
	          return outclass;
	        } else {
	          stream.eat(/['"\/]/);
	        }
	      }
	      if (singleline) {
	        if (parserConf.singleLineStringErrors) {
	          outclass = ERRORCLASS;
	        } else {
	          state.tokenize = tokenBase;
	        }
	      }
	      return outclass;
	    };
	  }

	  function longComment(stream, state) {
	    while (!stream.eol()) {
	      stream.eatWhile(/[^#]/);
	      if (stream.match("###")) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      stream.eatWhile("#");
	    }
	    return "comment";
	  }

	  function indent(stream, state, type) {
	    type = type || "coffee";
	    var offset = 0, align = false, alignOffset = null;
	    for (var scope = state.scope; scope; scope = scope.prev) {
	      if (scope.type === "coffee" || scope.type == "}") {
	        offset = scope.offset + conf.indentUnit;
	        break;
	      }
	    }
	    if (type !== "coffee") {
	      align = null;
	      alignOffset = stream.column() + stream.current().length;
	    } else if (state.scope.align) {
	      state.scope.align = false;
	    }
	    state.scope = {
	      offset: offset,
	      type: type,
	      prev: state.scope,
	      align: align,
	      alignOffset: alignOffset
	    };
	  }

	  function dedent(stream, state) {
	    if (!state.scope.prev) return;
	    if (state.scope.type === "coffee") {
	      var _indent = stream.indentation();
	      var matched = false;
	      for (var scope = state.scope; scope; scope = scope.prev) {
	        if (_indent === scope.offset) {
	          matched = true;
	          break;
	        }
	      }
	      if (!matched) {
	        return true;
	      }
	      while (state.scope.prev && state.scope.offset !== _indent) {
	        state.scope = state.scope.prev;
	      }
	      return false;
	    } else {
	      state.scope = state.scope.prev;
	      return false;
	    }
	  }

	  function tokenLexer(stream, state) {
	    var style = state.tokenize(stream, state);
	    var current = stream.current();

	    // Handle scope changes.
	    if (current === "return") {
	      state.dedent = true;
	    }
	    if (((current === "->" || current === "=>") && stream.eol())
	        || style === "indent") {
	      indent(stream, state);
	    }
	    var delimiter_index = "[({".indexOf(current);
	    if (delimiter_index !== -1) {
	      indent(stream, state, "])}".slice(delimiter_index, delimiter_index+1));
	    }
	    if (indentKeywords.exec(current)){
	      indent(stream, state);
	    }
	    if (current == "then"){
	      dedent(stream, state);
	    }


	    if (style === "dedent") {
	      if (dedent(stream, state)) {
	        return ERRORCLASS;
	      }
	    }
	    delimiter_index = "])}".indexOf(current);
	    if (delimiter_index !== -1) {
	      while (state.scope.type == "coffee" && state.scope.prev)
	        state.scope = state.scope.prev;
	      if (state.scope.type == current)
	        state.scope = state.scope.prev;
	    }
	    if (state.dedent && stream.eol()) {
	      if (state.scope.type == "coffee" && state.scope.prev)
	        state.scope = state.scope.prev;
	      state.dedent = false;
	    }

	    return style;
	  }

	  var external = {
	    startState: function(basecolumn) {
	      return {
	        tokenize: tokenBase,
	        scope: {offset:basecolumn || 0, type:"coffee", prev: null, align: false},
	        prop: false,
	        dedent: 0
	      };
	    },

	    token: function(stream, state) {
	      var fillAlign = state.scope.align === null && state.scope;
	      if (fillAlign && stream.sol()) fillAlign.align = false;

	      var style = tokenLexer(stream, state);
	      if (style && style != "comment") {
	        if (fillAlign) fillAlign.align = true;
	        state.prop = style == "punctuation" && stream.current() == "."
	      }

	      return style;
	    },

	    indent: function(state, text) {
	      if (state.tokenize != tokenBase) return 0;
	      var scope = state.scope;
	      var closer = text && "])}".indexOf(text.charAt(0)) > -1;
	      if (closer) while (scope.type == "coffee" && scope.prev) scope = scope.prev;
	      var closes = closer && scope.type === text.charAt(0);
	      if (scope.align)
	        return scope.alignOffset - (closes ? 1 : 0);
	      else
	        return (closes ? scope.prev : scope).offset;
	    },

	    lineComment: "#",
	    fold: "indent"
	  };
	  return external;
	});

	CodeMirror.defineMIME("text/x-coffeescript", "coffeescript");
	CodeMirror.defineMIME("text/coffeescript", "coffeescript");

	});


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(306), __webpack_require__(311), __webpack_require__(309))
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript"], mod)
	  else // Plain browser env
	    mod(CodeMirror)
	})(function(CodeMirror) {
	  "use strict"

	  // Depth means the amount of open braces in JS context, in XML
	  // context 0 means not in tag, 1 means in tag, and 2 means in tag
	  // and js block comment.
	  function Context(state, mode, depth, prev) {
	    this.state = state; this.mode = mode; this.depth = depth; this.prev = prev
	  }

	  function copyContext(context) {
	    return new Context(CodeMirror.copyState(context.mode, context.state),
	                       context.mode,
	                       context.depth,
	                       context.prev && copyContext(context.prev))
	  }

	  CodeMirror.defineMode("jsx", function(config, modeConfig) {
	    var xmlMode = CodeMirror.getMode(config, {name: "xml", allowMissing: true, multilineTagIndentPastTag: false})
	    var jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || "javascript")

	    function flatXMLIndent(state) {
	      var tagName = state.tagName
	      state.tagName = null
	      var result = xmlMode.indent(state, "")
	      state.tagName = tagName
	      return result
	    }

	    function token(stream, state) {
	      if (state.context.mode == xmlMode)
	        return xmlToken(stream, state, state.context)
	      else
	        return jsToken(stream, state, state.context)
	    }

	    function xmlToken(stream, state, cx) {
	      if (cx.depth == 2) { // Inside a JS /* */ comment
	        if (stream.match(/^.*?\*\//)) cx.depth = 1
	        else stream.skipToEnd()
	        return "comment"
	      }

	      if (stream.peek() == "{") {
	        xmlMode.skipAttribute(cx.state)

	        var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context
	        // If JS starts on same line as tag
	        if (xmlContext && stream.match(/^[^>]*>\s*$/, false)) {
	          while (xmlContext.prev && !xmlContext.startOfLine)
	            xmlContext = xmlContext.prev
	          // If tag starts the line, use XML indentation level
	          if (xmlContext.startOfLine) indent -= config.indentUnit
	          // Else use JS indentation level
	          else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented
	        // Else if inside of tag
	        } else if (cx.depth == 1) {
	          indent += config.indentUnit
	        }

	        state.context = new Context(CodeMirror.startState(jsMode, indent),
	                                    jsMode, 0, state.context)
	        return null
	      }

	      if (cx.depth == 1) { // Inside of tag
	        if (stream.peek() == "<") { // Tag inside of tag
	          xmlMode.skipAttribute(cx.state)
	          state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)),
	                                      xmlMode, 0, state.context)
	          return null
	        } else if (stream.match("//")) {
	          stream.skipToEnd()
	          return "comment"
	        } else if (stream.match("/*")) {
	          cx.depth = 2
	          return token(stream, state)
	        }
	      }

	      var style = xmlMode.token(stream, cx.state), cur = stream.current(), stop
	      if (/\btag\b/.test(style)) {
	        if (/>$/.test(cur)) {
	          if (cx.state.context) cx.depth = 0
	          else state.context = state.context.prev
	        } else if (/^</.test(cur)) {
	          cx.depth = 1
	        }
	      } else if (!style && (stop = cur.indexOf("{")) > -1) {
	        stream.backUp(cur.length - stop)
	      }
	      return style
	    }

	    function jsToken(stream, state, cx) {
	      if (stream.peek() == "<" && jsMode.expressionAllowed(stream, cx.state)) {
	        jsMode.skipExpression(cx.state)
	        state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, "")),
	                                    xmlMode, 0, state.context)
	        return null
	      }

	      var style = jsMode.token(stream, cx.state)
	      if (!style && cx.depth != null) {
	        var cur = stream.current()
	        if (cur == "{") {
	          cx.depth++
	        } else if (cur == "}") {
	          if (--cx.depth == 0) state.context = state.context.prev
	        }
	      }
	      return style
	    }

	    return {
	      startState: function() {
	        return {context: new Context(CodeMirror.startState(jsMode), jsMode)}
	      },

	      copyState: function(state) {
	        return {context: copyContext(state.context)}
	      },

	      token: token,

	      indent: function(state, textAfter, fullLine) {
	        return state.context.mode.indent(state.context.state, textAfter, fullLine)
	      },

	      innerMode: function(state) {
	        return state.context
	      }
	    }
	  }, "xml", "javascript")

	  CodeMirror.defineMIME("text/jsx", "jsx")
	  CodeMirror.defineMIME("text/typescript-jsx", {name: "jsx", base: {name: "javascript", typescript: true}})
	});


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(306));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";

	  CodeMirror.defineMode("elm", function() {

	    function switchState(source, setState, f) {
	      setState(f);
	      return f(source, setState);
	    }

	    // These should all be Unicode extended, as per the Haskell 2010 report
	    var smallRE = /[a-z_]/;
	    var largeRE = /[A-Z]/;
	    var digitRE = /[0-9]/;
	    var hexitRE = /[0-9A-Fa-f]/;
	    var octitRE = /[0-7]/;
	    var idRE = /[a-z_A-Z0-9\']/;
	    var symbolRE = /[-!#$%&*+.\/<=>?@\\^|~:\u03BB\u2192]/;
	    var specialRE = /[(),;[\]`{}]/;
	    var whiteCharRE = /[ \t\v\f]/; // newlines are handled in tokenizer

	    function normal() {
	      return function (source, setState) {
	        if (source.eatWhile(whiteCharRE)) {
	          return null;
	        }

	        var ch = source.next();
	        if (specialRE.test(ch)) {
	          if (ch == '{' && source.eat('-')) {
	            var t = "comment";
	            if (source.eat('#')) t = "meta";
	            return switchState(source, setState, ncomment(t, 1));
	          }
	          return null;
	        }

	        if (ch == '\'') {
	          if (source.eat('\\'))
	            source.next();  // should handle other escapes here
	          else
	            source.next();

	          if (source.eat('\''))
	            return "string";
	          return "error";
	        }

	        if (ch == '"') {
	          return switchState(source, setState, stringLiteral);
	        }

	        if (largeRE.test(ch)) {
	          source.eatWhile(idRE);
	          if (source.eat('.'))
	            return "qualifier";
	          return "variable-2";
	        }

	        if (smallRE.test(ch)) {
	          var isDef = source.pos === 1;
	          source.eatWhile(idRE);
	          return isDef ? "variable-3" : "variable";
	        }

	        if (digitRE.test(ch)) {
	          if (ch == '0') {
	            if (source.eat(/[xX]/)) {
	              source.eatWhile(hexitRE); // should require at least 1
	              return "integer";
	            }
	            if (source.eat(/[oO]/)) {
	              source.eatWhile(octitRE); // should require at least 1
	              return "number";
	            }
	          }
	          source.eatWhile(digitRE);
	          var t = "number";
	          if (source.eat('.')) {
	            t = "number";
	            source.eatWhile(digitRE); // should require at least 1
	          }
	          if (source.eat(/[eE]/)) {
	            t = "number";
	            source.eat(/[-+]/);
	            source.eatWhile(digitRE); // should require at least 1
	          }
	          return t;
	        }

	        if (symbolRE.test(ch)) {
	          if (ch == '-' && source.eat(/-/)) {
	            source.eatWhile(/-/);
	            if (!source.eat(symbolRE)) {
	              source.skipToEnd();
	              return "comment";
	            }
	          }
	          source.eatWhile(symbolRE);
	          return "builtin";
	        }

	        return "error";
	      }
	    }

	    function ncomment(type, nest) {
	      if (nest == 0) {
	        return normal();
	      }
	      return function(source, setState) {
	        var currNest = nest;
	        while (!source.eol()) {
	          var ch = source.next();
	          if (ch == '{' && source.eat('-')) {
	            ++currNest;
	          } else if (ch == '-' && source.eat('}')) {
	            --currNest;
	            if (currNest == 0) {
	              setState(normal());
	              return type;
	            }
	          }
	        }
	        setState(ncomment(type, currNest));
	        return type;
	      }
	    }

	    function stringLiteral(source, setState) {
	      while (!source.eol()) {
	        var ch = source.next();
	        if (ch == '"') {
	          setState(normal());
	          return "string";
	        }
	        if (ch == '\\') {
	          if (source.eol() || source.eat(whiteCharRE)) {
	            setState(stringGap);
	            return "string";
	          }
	          if (!source.eat('&')) source.next(); // should handle other escapes here
	        }
	      }
	      setState(normal());
	      return "error";
	    }

	    function stringGap(source, setState) {
	      if (source.eat('\\')) {
	        return switchState(source, setState, stringLiteral);
	      }
	      source.next();
	      setState(normal());
	      return "error";
	    }


	    var wellKnownWords = (function() {
	      var wkw = {};

	      var keywords = [
	        "case", "of", "as",
	        "if", "then", "else",
	        "let", "in",
	        "infix", "infixl", "infixr",
	        "type", "alias",
	        "input", "output", "foreign", "loopback",
	        "module", "where", "import", "exposing",
	        "_", "..", "|", ":", "=", "\\", "\"", "->", "<-"
	      ];

	      for (var i = keywords.length; i--;)
	        wkw[keywords[i]] = "keyword";

	      return wkw;
	    })();



	    return {
	      startState: function ()  { return { f: normal() }; },
	      copyState:  function (s) { return { f: s.f }; },

	      token: function(stream, state) {
	        var t = state.f(stream, function(s) { state.f = s; });
	        var w = stream.current();
	        return (wellKnownWords.hasOwnProperty(w)) ? wellKnownWords[w] : t;
	      }
	    };

	  });

	  CodeMirror.defineMIME("text/x-elm", "elm");
	});


/***/ },
/* 316 */,
/* 317 */,
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(306));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	  var Pos = CodeMirror.Pos;

	  function SearchCursor(doc, query, pos, caseFold) {
	    this.atOccurrence = false; this.doc = doc;
	    if (caseFold == null && typeof query == "string") caseFold = false;

	    pos = pos ? doc.clipPos(pos) : Pos(0, 0);
	    this.pos = {from: pos, to: pos};

	    // The matches method is filled in based on the type of query.
	    // It takes a position and a direction, and returns an object
	    // describing the next occurrence of the query, or null if no
	    // more matches were found.
	    if (typeof query != "string") { // Regexp match
	      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? "ig" : "g");
	      this.matches = function(reverse, pos) {
	        if (reverse) {
	          query.lastIndex = 0;
	          var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;
	          for (;;) {
	            query.lastIndex = cutOff;
	            var newMatch = query.exec(line);
	            if (!newMatch) break;
	            match = newMatch;
	            start = match.index;
	            cutOff = match.index + (match[0].length || 1);
	            if (cutOff == line.length) break;
	          }
	          var matchLen = (match && match[0].length) || 0;
	          if (!matchLen) {
	            if (start == 0 && line.length == 0) {match = undefined;}
	            else if (start != doc.getLine(pos.line).length) {
	              matchLen++;
	            }
	          }
	        } else {
	          query.lastIndex = pos.ch;
	          var line = doc.getLine(pos.line), match = query.exec(line);
	          var matchLen = (match && match[0].length) || 0;
	          var start = match && match.index;
	          if (start + matchLen != line.length && !matchLen) matchLen = 1;
	        }
	        if (match && matchLen)
	          return {from: Pos(pos.line, start),
	                  to: Pos(pos.line, start + matchLen),
	                  match: match};
	      };
	    } else { // String query
	      var origQuery = query;
	      if (caseFold) query = query.toLowerCase();
	      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};
	      var target = query.split("\n");
	      // Different methods for single-line and multi-line queries
	      if (target.length == 1) {
	        if (!query.length) {
	          // Empty string would match anything and never progress, so
	          // we define it to match nothing instead.
	          this.matches = function() {};
	        } else {
	          this.matches = function(reverse, pos) {
	            if (reverse) {
	              var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);
	              var match = line.lastIndexOf(query);
	              if (match > -1) {
	                match = adjustPos(orig, line, match);
	                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};
	              }
	             } else {
	               var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);
	               var match = line.indexOf(query);
	               if (match > -1) {
	                 match = adjustPos(orig, line, match) + pos.ch;
	                 return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};
	               }
	            }
	          };
	        }
	      } else {
	        var origTarget = origQuery.split("\n");
	        this.matches = function(reverse, pos) {
	          var last = target.length - 1;
	          if (reverse) {
	            if (pos.line - (target.length - 1) < doc.firstLine()) return;
	            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;
	            var to = Pos(pos.line, origTarget[last].length);
	            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln)
	              if (target[i] != fold(doc.getLine(ln))) return;
	            var line = doc.getLine(ln), cut = line.length - origTarget[0].length;
	            if (fold(line.slice(cut)) != target[0]) return;
	            return {from: Pos(ln, cut), to: to};
	          } else {
	            if (pos.line + (target.length - 1) > doc.lastLine()) return;
	            var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;
	            if (fold(line.slice(cut)) != target[0]) return;
	            var from = Pos(pos.line, cut);
	            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln)
	              if (target[i] != fold(doc.getLine(ln))) return;
	            if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;
	            return {from: from, to: Pos(ln, origTarget[last].length)};
	          }
	        };
	      }
	    }
	  }

	  SearchCursor.prototype = {
	    findNext: function() {return this.find(false);},
	    findPrevious: function() {return this.find(true);},

	    find: function(reverse) {
	      var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);
	      function savePosAndFail(line) {
	        var pos = Pos(line, 0);
	        self.pos = {from: pos, to: pos};
	        self.atOccurrence = false;
	        return false;
	      }

	      for (;;) {
	        if (this.pos = this.matches(reverse, pos)) {
	          this.atOccurrence = true;
	          return this.pos.match || true;
	        }
	        if (reverse) {
	          if (!pos.line) return savePosAndFail(0);
	          pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);
	        }
	        else {
	          var maxLine = this.doc.lineCount();
	          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);
	          pos = Pos(pos.line + 1, 0);
	        }
	      }
	    },

	    from: function() {if (this.atOccurrence) return this.pos.from;},
	    to: function() {if (this.atOccurrence) return this.pos.to;},

	    replace: function(newText, origin) {
	      if (!this.atOccurrence) return;
	      var lines = CodeMirror.splitLines(newText);
	      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
	      this.pos.to = Pos(this.pos.from.line + lines.length - 1,
	                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
	    }
	  };

	  // Maps a position in a case-folded line back to a position in the original line
	  // (compensating for codepoints increasing in number during folding)
	  function adjustPos(orig, folded, pos) {
	    if (orig.length == folded.length) return pos;
	    for (var pos1 = Math.min(pos, orig.length);;) {
	      var len1 = orig.slice(0, pos1).toLowerCase().length;
	      if (len1 < pos) ++pos1;
	      else if (len1 > pos) --pos1;
	      else return pos1;
	    }
	  }

	  CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {
	    return new SearchCursor(this.doc, query, pos, caseFold);
	  });
	  CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
	    return new SearchCursor(this, query, pos, caseFold);
	  });

	  CodeMirror.defineExtension("selectMatches", function(query, caseFold) {
	    var ranges = [];
	    var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);
	    while (cur.findNext()) {
	      if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break;
	      ranges.push({anchor: cur.from(), head: cur.to()});
	    }
	    if (ranges.length)
	      this.setSelections(ranges, 0);
	  });
	});


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.resumed = resumed;
	exports.paused = paused;
	exports.pauseOnExceptions = pauseOnExceptions;
	exports.command = command;
	exports.stepIn = stepIn;
	exports.stepOver = stepOver;
	exports.stepOut = stepOut;
	exports.resume = resume;
	exports.breakOnNext = breakOnNext;
	exports.selectFrame = selectFrame;
	exports.loadObjectProperties = loadObjectProperties;

	var _constants = __webpack_require__(229);

	var _constants2 = _interopRequireDefault(_constants);

	var _sources = __webpack_require__(254);

	var _promise = __webpack_require__(193);

	var _selectors = __webpack_require__(242);

	var _pause = __webpack_require__(255);

	var _expressions = __webpack_require__(252);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	/**
	 * Redux actions for the pause state
	 * @module actions/pause
	 */

	/**
	 * Debugger has just resumed
	 *
	 * @memberof actions/pause
	 * @static
	 */
	function resumed() {
	  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        client = _ref.client;

	    // dispatch(evaluateExpressions(null));

	    return dispatch({
	      type: _constants2.default.RESUME,
	      value: undefined
	    });
	  };
	}

	/**
	 * Debugger has just paused
	 *
	 * @param {object} pauseInfo
	 * @memberof actions/pause
	 * @static
	 */
	function paused(pauseInfo) {
	  return (() => {
	    var _ref2 = _asyncToGenerator(function* (_ref3) {
	      var dispatch = _ref3.dispatch,
	          getState = _ref3.getState,
	          client = _ref3.client,
	          sourceMaps = _ref3.sourceMaps;
	      var frames = pauseInfo.frames,
	          why = pauseInfo.why,
	          loadedObjects = pauseInfo.loadedObjects;

	      frames = yield (0, _pause.updateFrameLocations)(frames, sourceMaps);
	      var frame = frames[0];

	      dispatch({
	        type: _constants2.default.PAUSED,
	        pauseInfo: { why, frame },
	        frames: frames,
	        selectedFrameId: frame.id,
	        loadedObjects: loadedObjects || []
	      });

	      dispatch((0, _expressions.evaluateExpressions)(frame.id));

	      dispatch((0, _sources.selectSource)(frame.location.sourceId, { line: frame.location.line }));
	    });

	    return function (_x) {
	      return _ref2.apply(this, arguments);
	    };
	  })();
	}

	/**
	 *
	 * @memberof actions/pause
	 * @static
	 */
	function pauseOnExceptions(shouldPauseOnExceptions, shouldIgnoreCaughtExceptions) {
	  return (_ref4) => {
	    var dispatch = _ref4.dispatch,
	        client = _ref4.client;

	    dispatch({
	      type: _constants2.default.PAUSE_ON_EXCEPTIONS,
	      shouldPauseOnExceptions,
	      shouldIgnoreCaughtExceptions,
	      [_promise.PROMISE]: client.pauseOnExceptions(shouldPauseOnExceptions, shouldIgnoreCaughtExceptions)
	    });
	  };
	}

	/**
	 * Debugger commands like stepOver, stepIn, stepUp
	 *
	 * @param string $0.type
	 * @memberof actions/pause
	 * @static
	 */
	function command(_ref5) {
	  var type = _ref5.type;

	  return (_ref6) => {
	    var dispatch = _ref6.dispatch,
	        client = _ref6.client;

	    // execute debugger thread command e.g. stepIn, stepOver
	    client[type]();

	    return dispatch({
	      type: _constants2.default.COMMAND,
	      value: undefined
	    });
	  };
	}

	/**
	 * StepIn
	 * @memberof actions/pause
	 * @static
	 * @returns {Function} {@link command}
	 */
	function stepIn() {
	  return (_ref7) => {
	    var dispatch = _ref7.dispatch,
	        getState = _ref7.getState;

	    if ((0, _selectors.getPause)(getState())) {
	      return dispatch(command({ type: "stepIn" }));
	    }
	  };
	}

	/**
	 * stepOver
	 * @memberof actions/pause
	 * @static
	 * @returns {Function} {@link command}
	 */
	function stepOver() {
	  return (_ref8) => {
	    var dispatch = _ref8.dispatch,
	        getState = _ref8.getState;

	    if ((0, _selectors.getPause)(getState())) {
	      return dispatch(command({ type: "stepOver" }));
	    }
	  };
	}

	/**
	 * stepOut
	 * @memberof actions/pause
	 * @static
	 * @returns {Function} {@link command}
	 */
	function stepOut() {
	  return (_ref9) => {
	    var dispatch = _ref9.dispatch,
	        getState = _ref9.getState;

	    if ((0, _selectors.getPause)(getState())) {
	      return dispatch(command({ type: "stepOut" }));
	    }
	  };
	}

	/**
	 * resume
	 * @memberof actions/pause
	 * @static
	 * @returns {Function} {@link command}
	 */
	function resume() {
	  return (_ref10) => {
	    var dispatch = _ref10.dispatch,
	        getState = _ref10.getState;

	    if ((0, _selectors.getPause)(getState())) {
	      return dispatch(command({ type: "resume" }));
	    }
	  };
	}

	/**
	 * Debugger breakOnNext command.
	 * It's different from the comand action because we also want to
	 * highlight the pause icon.
	 *
	 * @memberof actions/pause
	 * @static
	 */
	function breakOnNext() {
	  return (_ref11) => {
	    var dispatch = _ref11.dispatch,
	        client = _ref11.client;

	    client.breakOnNext();

	    return dispatch({
	      type: _constants2.default.BREAK_ON_NEXT,
	      value: true
	    });
	  };
	}

	/**
	 * @memberof actions/pause
	 * @static
	 */
	function selectFrame(frame) {
	  return (_ref12) => {
	    var dispatch = _ref12.dispatch;

	    dispatch((0, _expressions.evaluateExpressions)(frame.id));
	    dispatch((0, _sources.selectSource)(frame.location.sourceId, { line: frame.location.line }));
	    dispatch({
	      type: _constants2.default.SELECT_FRAME,
	      frame
	    });
	  };
	}

	/**
	 * @memberof actions/pause
	 * @static
	 */
	function loadObjectProperties(object) {
	  return (_ref13) => {
	    var dispatch = _ref13.dispatch,
	        client = _ref13.client,
	        getState = _ref13.getState;

	    var objectId = object.actor || object.objectId;

	    if ((0, _selectors.getLoadedObject)(getState(), objectId)) {
	      return;
	    }

	    dispatch({
	      type: _constants2.default.LOAD_OBJECT_PROPERTIES,
	      objectId,
	      [_promise.PROMISE]: client.getProperties(object)
	    });
	  };
	}

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.willNavigate = willNavigate;
	exports.navigated = navigated;

	var _constants = __webpack_require__(229);

	var _constants2 = _interopRequireDefault(_constants);

	var _editor = __webpack_require__(257);

	var _sources = __webpack_require__(232);

	var _utils = __webpack_require__(234);

	var _sources2 = __webpack_require__(254);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	/**
	 * Redux actions for the navigation state
	 * @module actions/navigation
	 */

	/**
	 * @memberof actions/navigation
	 * @static
	 */
	function willNavigate(_, event) {
	  return (() => {
	    var _ref = _asyncToGenerator(function* (_ref2) {
	      var dispatch = _ref2.dispatch,
	          getState = _ref2.getState,
	          client = _ref2.client,
	          sourceMaps = _ref2.sourceMaps;

	      yield sourceMaps.clearSourceMaps();
	      (0, _editor.clearDocuments)();

	      dispatch({
	        type: _constants2.default.NAVIGATE,
	        url: event.url
	      });
	    });

	    return function (_x) {
	      return _ref.apply(this, arguments);
	    };
	  })();
	}

	/**
	 * @memberof actions/navigation
	 * @static
	 */
	function navigated() {
	  return (() => {
	    var _ref3 = _asyncToGenerator(function* (_ref4) {
	      var dispatch = _ref4.dispatch,
	          getState = _ref4.getState,
	          client = _ref4.client;

	      yield (0, _utils.waitForMs)(100);
	      if ((0, _sources.getSources)(getState()).size == 0) {
	        var sources = yield client.fetchSources();
	        dispatch((0, _sources2.newSources)(sources));
	      }
	    });

	    return function (_x2) {
	      return _ref3.apply(this, arguments);
	    };
	  })();
	}

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.toggleProjectSearch = toggleProjectSearch;
	exports.toggleFileSearch = toggleFileSearch;
	exports.setFileSearchQuery = setFileSearchQuery;
	exports.toggleFileSearchModifier = toggleFileSearchModifier;
	exports.showSource = showSource;
	exports.togglePaneCollapse = togglePaneCollapse;

	var _constants = __webpack_require__(229);

	var _constants2 = _interopRequireDefault(_constants);

	var _selectors = __webpack_require__(242);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function toggleProjectSearch(toggleValue) {
	  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;

	    if (toggleValue != null) {
	      dispatch({
	        type: _constants2.default.TOGGLE_PROJECT_SEARCH,
	        value: toggleValue
	      });
	    } else {
	      dispatch({
	        type: _constants2.default.TOGGLE_PROJECT_SEARCH,
	        value: !(0, _selectors.getProjectSearchState)(getState())
	      });
	    }
	  };
	}

	function toggleFileSearch(toggleValue) {
	  return (_ref2) => {
	    var dispatch = _ref2.dispatch,
	        getState = _ref2.getState;

	    if (toggleValue != null) {
	      dispatch({
	        type: _constants2.default.TOGGLE_FILE_SEARCH,
	        value: toggleValue
	      });
	    } else {
	      dispatch({
	        type: _constants2.default.TOGGLE_FILE_SEARCH,
	        value: !(0, _selectors.getFileSearchState)(getState())
	      });
	    }
	  };
	}

	function setFileSearchQuery(query) {
	  return {
	    type: _constants2.default.UPDATE_FILE_SEARCH_QUERY,
	    query
	  };
	}

	function toggleFileSearchModifier(modifier) {
	  return { type: _constants2.default.TOGGLE_FILE_SEARCH_MODIFIER, modifier };
	}

	function showSource(sourceId) {
	  return (_ref3) => {
	    var dispatch = _ref3.dispatch,
	        getState = _ref3.getState;

	    var source = (0, _selectors.getSource)(getState(), sourceId);
	    dispatch({
	      type: _constants2.default.SHOW_SOURCE,
	      sourceUrl: source.get("url")
	    });
	  };
	}

	function togglePaneCollapse(position, paneCollapsed) {
	  return {
	    type: _constants2.default.TOGGLE_PANE,
	    position,
	    paneCollapsed
	  };
	}

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.recordCoverage = recordCoverage;

	var _constants = __webpack_require__(229);

	var _constants2 = _interopRequireDefault(_constants);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	function recordCoverage() {
	  return (() => {
	    var _ref = _asyncToGenerator(function* (_ref2) {
	      var dispatch = _ref2.dispatch,
	          getState = _ref2.getState,
	          client = _ref2.client;

	      var _ref3 = yield client.recordCoverage(),
	          coverage = _ref3.coverage;

	      return dispatch({
	        type: _constants2.default.RECORD_COVERAGE,
	        value: { coverage }
	      });
	    });

	    return function (_x) {
	      return _ref.apply(this, arguments);
	    };
	  })();
	}

/***/ },
/* 323 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 324 */,
/* 325 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 326 */,
/* 327 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 332 */,
/* 333 */,
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var punycode = __webpack_require__(916);
	var util = __webpack_require__(336);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // Special case for a simple path URL
	    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(337);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && util.isObject(url) && url instanceof Url) return url;

	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!util.isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  // Copy chrome, IE, opera backslash-handling behavior.
	  // Back slashes before the query string get converted to forward slashes
	  // See: https://code.google.com/p/chromium/issues/detail?id=25916
	  var queryIndex = url.indexOf('?'),
	      splitter =
	          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
	      uSplit = url.split(splitter),
	      slashRegex = /\\/g;
	  uSplit[0] = uSplit[0].replace(slashRegex, '/');
	  url = uSplit.join(splitter);

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.path = rest;
	      this.href = rest;
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	        if (parseQueryString) {
	          this.query = querystring.parse(this.search.substr(1));
	        } else {
	          this.query = this.search.substr(1);
	        }
	      } else if (parseQueryString) {
	        this.search = '';
	        this.query = {};
	      }
	      return this;
	    }
	  }

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a punycoded representation of "domain".
	      // It only converts parts of the domain name that
	      // have non-ASCII characters, i.e. it doesn't matter if
	      // you call it with a domain that already is ASCII-only.
	      this.hostname = punycode.toASCII(this.hostname);
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      if (rest.indexOf(ae) === -1)
	        continue;
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }


	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (util.isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query &&
	      util.isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function(relative) {
	  if (util.isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  var tkeys = Object.keys(this);
	  for (var tk = 0; tk < tkeys.length; tk++) {
	    var tkey = tkeys[tk];
	    result[tkey] = this[tkey];
	  }

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    var rkeys = Object.keys(relative);
	    for (var rk = 0; rk < rkeys.length; rk++) {
	      var rkey = rkeys[rk];
	      if (rkey !== 'protocol')
	        result[rkey] = relative[rkey];
	    }

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      var keys = Object.keys(relative);
	      for (var v = 0; v < keys.length; v++) {
	        var k = keys[v];
	        result[k] = relative[k];
	      }
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!util.isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especially happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host || srcPath.length > 1) &&
	      (last === '.' || last === '..') || last === '');

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last === '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especially happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};


/***/ },
/* 335 */,
/* 336 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	  isString: function(arg) {
	    return typeof(arg) === 'string';
	  },
	  isObject: function(arg) {
	    return typeof(arg) === 'object' && arg !== null;
	  },
	  isNull: function(arg) {
	    return arg === null;
	  },
	  isNullOrUndefined: function(arg) {
	    return arg == null;
	  }
	};


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(338);
	exports.encode = exports.stringify = __webpack_require__(339);


/***/ },
/* 338 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ },
/* 339 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 340 */,
/* 341 */,
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _fuzzaldrinPlus = __webpack_require__(161);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _resultList = __webpack_require__(343);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	__webpack_require__(386);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _require = __webpack_require__(22),
	    findDOMNode = _require.findDOMNode;

	var SearchInput = (0, _react.createFactory)(__webpack_require__(377).default);
	var ResultList = (0, _react.createFactory)(__webpack_require__(383).default);

	class Autocomplete extends _react.Component {

	  constructor(props) {
	    super(props);

	    this.onKeyDown = this.onKeyDown.bind(this);
	    this.state = {
	      inputValue: props.inputValue,
	      selectedIndex: 0,
	      focused: false
	    };
	  }

	  componentDidMount() {
	    var endOfInput = this.state.inputValue.length;
	    var node = findDOMNode(this);
	    if (node instanceof HTMLElement) {
	      var searchInput = node.querySelector("input");
	      if (searchInput instanceof HTMLInputElement) {
	        searchInput.focus();
	        searchInput.setSelectionRange(endOfInput, endOfInput);
	      }
	    }
	  }

	  componentDidUpdate() {
	    if (this.refs.resultList && this.refs.resultList.refs) {
	      (0, _resultList.scrollList)(this.refs.resultList.refs, this.state.selectedIndex);
	    }
	  }

	  getSearchResults() {
	    var inputValue = this.state.inputValue;

	    if (inputValue == "") {
	      return [];
	    }
	    return (0, _fuzzaldrinPlus.filter)(this.props.items, this.state.inputValue, {
	      key: "value"
	    });
	  }

	  onKeyDown(e) {
	    var searchResults = this.getSearchResults(),
	        resultCount = searchResults.length;

	    if (e.key === "ArrowUp") {
	      var _selectedIndex = Math.max(0, this.state.selectedIndex - 1);
	      this.setState({ selectedIndex: _selectedIndex });
	      if (this.props.onSelectedItem) {
	        this.props.onSelectedItem(searchResults[_selectedIndex]);
	      }
	      e.preventDefault();
	    } else if (e.key === "ArrowDown") {
	      var _selectedIndex2 = Math.min(resultCount - 1, this.state.selectedIndex + 1);
	      this.setState({ selectedIndex: _selectedIndex2 });
	      if (this.props.onSelectedItem) {
	        this.props.onSelectedItem(searchResults[_selectedIndex2]);
	      }
	      e.preventDefault();
	    } else if (e.key === "Enter") {
	      if (searchResults.length) {
	        this.props.selectItem(searchResults[this.state.selectedIndex]);
	      } else {
	        this.props.close(this.state.inputValue);
	      }
	      e.preventDefault();
	    } else if (e.key === "Tab") {
	      this.props.close(this.state.inputValue);
	      e.preventDefault();
	    }
	  }

	  renderResults(results) {
	    var size = this.props.size;


	    if (results.length) {
	      return ResultList({
	        items: results,
	        selected: this.state.selectedIndex,
	        selectItem: this.props.selectItem,
	        close: this.props.close,
	        size,
	        ref: "resultList"
	      });
	    } else if (this.state.inputValue && !results.length) {
	      return _react.DOM.div({ className: "no-result-msg" }, (0, _Svg2.default)("sad-face"), L10N.getFormatStr("sourceSearch.noResults", this.state.inputValue));
	    }
	  }

	  render() {
	    var focused = this.state.focused;
	    var size = this.props.size;

	    var searchResults = this.getSearchResults();
	    var summaryMsg = L10N.getFormatStr("sourceSearch.resultsSummary1", searchResults.length);
	    return _react.DOM.div({ className: (0, _classnames2.default)("autocomplete", { focused }) }, SearchInput({
	      query: this.state.inputValue,
	      count: searchResults.length,
	      placeholder: this.props.placeholder,
	      size,
	      summaryMsg,
	      onChange: e => this.setState({
	        inputValue: e.target.value,
	        selectedIndex: 0
	      }),
	      onFocus: () => this.setState({ focused: true }),
	      onBlur: () => this.setState({ focused: false }),
	      onKeyDown: this.onKeyDown,
	      handleClose: this.props.close
	    }), this.renderResults(searchResults));
	  }
	}

	exports.default = Autocomplete;
	Autocomplete.propTypes = {
	  selectItem: _react.PropTypes.func.isRequired,
	  onSelectedItem: _react.PropTypes.func,
	  items: _react.PropTypes.array,
	  close: _react.PropTypes.func.isRequired,
	  inputValue: _react.PropTypes.string.isRequired,
	  placeholder: _react.PropTypes.string,
	  size: _react.PropTypes.string
	};

	Autocomplete.displayName = "Autocomplete";

	Autocomplete.defaultProps = {
	  size: ""
	};

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _require = __webpack_require__(828),
	    isFirefox = _require.isFirefox;

	function scrollList(resultList, index) {
	  var resultEl = resultList[index];

	  if (isFirefox()) {
	    resultEl.scrollIntoView({ block: "end", behavior: "smooth" });
	  } else {
	    chromeScrollList(resultEl, index);
	  }
	}

	function chromeScrollList(elem, index) {
	  var resultsEl = elem.parentNode;
	  if (!resultsEl || resultsEl.children.length === 0) {
	    return;
	  }

	  var resultsHeight = resultsEl.clientHeight;
	  var itemHeight = resultsEl.children[0].clientHeight;
	  var numVisible = resultsHeight / itemHeight;
	  var positionsToScroll = index - numVisible + 1;
	  var itemOffset = resultsHeight % itemHeight;
	  var scroll = positionsToScroll * (itemHeight + 2) + itemOffset;

	  resultsEl.scrollTop = Math.max(0, scroll);
	}

	function handleKeyDown(e) {
	  var searchResults = this.getSearchResults(),
	      resultCount = searchResults.length;

	  if (e.key === "ArrowUp") {
	    var selectedIndex = Math.max(0, this.state.selectedIndex - 1);
	    this.setState({ selectedIndex });
	    if (this.props.onSelectedItem) {
	      this.props.onSelectedItem(searchResults[selectedIndex]);
	    }
	    e.preventDefault();
	  } else if (e.key === "ArrowDown") {
	    var _selectedIndex = Math.min(resultCount - 1, this.state.selectedIndex + 1);
	    this.setState({ selectedIndex: _selectedIndex });
	    if (this.props.onSelectedItem) {
	      this.props.onSelectedItem(searchResults[_selectedIndex]);
	    }
	    e.preventDefault();
	  } else if (e.key === "Enter") {
	    if (searchResults.length) {
	      this.props.selectItem(searchResults[this.state.selectedIndex]);
	    } else {
	      this.props.close(this.state.inputValue);
	    }
	    e.preventDefault();
	  } else if (e.key === "Tab") {
	    this.props.close(this.state.inputValue);
	    e.preventDefault();
	  }
	}

	module.exports = {
	  scrollList,
	  handleKeyDown
	};

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Svg = __webpack_require__(345);

	var _Svg2 = _interopRequireDefault(_Svg);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	__webpack_require__(375);
	/**
	 * This file maps the SVG React Components in the assets/images directory.
	 */

	exports.default = _Svg2.default;

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(2);
	var InlineSVG = __webpack_require__(346);

	var svg = {
	  "angle-brackets": __webpack_require__(347),
	  arrow: __webpack_require__(348),
	  blackBox: __webpack_require__(349),
	  breakpoint: __webpack_require__(350),
	  "case-match": __webpack_require__(351),
	  close: __webpack_require__(352),
	  domain: __webpack_require__(353),
	  file: __webpack_require__(354),
	  folder: __webpack_require__(355),
	  globe: __webpack_require__(356),
	  "magnifying-glass": __webpack_require__(357),
	  "arrow-up": __webpack_require__(919),
	  "arrow-down": __webpack_require__(920),
	  pause: __webpack_require__(358),
	  "pause-exceptions": __webpack_require__(359),
	  plus: __webpack_require__(360),
	  prettyPrint: __webpack_require__(361),
	  react: __webpack_require__(970),
	  "regex-match": __webpack_require__(362),
	  resume: __webpack_require__(363),
	  settings: __webpack_require__(364),
	  stepIn: __webpack_require__(365),
	  stepOut: __webpack_require__(366),
	  stepOver: __webpack_require__(367),
	  subSettings: __webpack_require__(368),
	  toggleBreakpoints: __webpack_require__(369),
	  togglePanes: __webpack_require__(370),
	  "whole-word-match": __webpack_require__(371),
	  worker: __webpack_require__(372),
	  "sad-face": __webpack_require__(373),
	  refresh: __webpack_require__(374)
	};

	module.exports = function (name, props) {
	  // eslint-disable-line
	  if (!svg[name]) {
	    throw new Error("Unknown SVG: " + name);
	  }
	  var className = name;
	  if (props && props.className) {
	    className = `${name} ${props.className}`;
	  }
	  if (name === "subSettings") {
	    className = "";
	  }
	  props = Object.assign({}, props, { className, src: svg[name] });
	  return React.createElement(InlineSVG, props);
	};

/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var DOMParser = typeof window !== 'undefined' && window.DOMParser;
	var process = process || {};
	process.env = process.env || {};
	var parserAvailable = typeof DOMParser !== 'undefined' && DOMParser.prototype != null && DOMParser.prototype.parseFromString != null;

	function isParsable(src) {
	    // kinda naive but meh, ain't gonna use full-blown parser for this
	    return parserAvailable && typeof src === 'string' && src.trim().substr(0, 4) === '<svg';
	}

	// parse SVG string using `DOMParser`
	function parseFromSVGString(src) {
	    var parser = new DOMParser();
	    return parser.parseFromString(src, "image/svg+xml");
	}

	// Transform DOM prop/attr names applicable to `<svg>` element but react-limited
	function switchSVGAttrToReactProp(propName) {
	    switch (propName) {
	        case 'class':
	            return 'className';
	        default:
	            return propName;
	    }
	}

	var InlineSVG = (function (_React$Component) {
	    _inherits(InlineSVG, _React$Component);

	    _createClass(InlineSVG, null, [{
	        key: 'defaultProps',
	        value: {
	            element: 'i',
	            raw: false,
	            src: ''
	        },
	        enumerable: true
	    }, {
	        key: 'propTypes',
	        value: {
	            src: _react2['default'].PropTypes.string.isRequired,
	            element: _react2['default'].PropTypes.string,
	            raw: _react2['default'].PropTypes.bool
	        },
	        enumerable: true
	    }]);

	    function InlineSVG(props) {
	        _classCallCheck(this, InlineSVG);

	        _get(Object.getPrototypeOf(InlineSVG.prototype), 'constructor', this).call(this, props);
	        this._extractSVGProps = this._extractSVGProps.bind(this);
	    }

	    // Serialize `Attr` objects in `NamedNodeMap`

	    _createClass(InlineSVG, [{
	        key: '_serializeAttrs',
	        value: function _serializeAttrs(map) {
	            var ret = {};
	            var prop = undefined;
	            for (var i = 0; i < map.length; i++) {
	                prop = switchSVGAttrToReactProp(map[i].name);
	                ret[prop] = map[i].value;
	            }
	            return ret;
	        }

	        // get <svg /> element props
	    }, {
	        key: '_extractSVGProps',
	        value: function _extractSVGProps(src) {
	            var map = parseFromSVGString(src).documentElement.attributes;
	            return map.length > 0 ? this._serializeAttrs(map) : null;
	        }

	        // get content inside <svg> element.
	    }, {
	        key: '_stripSVG',
	        value: function _stripSVG(src) {
	            return parseFromSVGString(src).documentElement.innerHTML;
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(_ref) {
	            var children = _ref.children;

	            if ("production" !== process.env.NODE_ENV && children != null) {
	                console.info('<InlineSVG />: `children` prop will be ignored.');
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var Element = undefined,
	                __html = undefined,
	                svgProps = undefined;
	            var _props = this.props;
	            var element = _props.element;
	            var raw = _props.raw;
	            var src = _props.src;

	            var otherProps = _objectWithoutProperties(_props, ['element', 'raw', 'src']);

	            if (raw === true && isParsable(src)) {
	                Element = 'svg';
	                svgProps = this._extractSVGProps(src);
	                __html = this._stripSVG(src);
	            }
	            __html = __html || src;
	            Element = Element || element;
	            svgProps = svgProps || {};

	            return _react2['default'].createElement(Element, _extends({}, svgProps, otherProps, { src: null, children: null,
	                dangerouslySetInnerHTML: { __html: __html } }));
	        }
	    }]);

	    return InlineSVG;
	})(_react2['default'].Component);

	exports['default'] = InlineSVG;
	module.exports = exports['default'];

/***/ },
/* 347 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"-1 73 16 11\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><g id=\"Shape-Copy-3-+-Shape-Copy-4\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" transform=\"translate(0.000000, 74.000000)\"><path d=\"M0.749321284,4.16081709 L4.43130681,0.242526751 C4.66815444,-0.00952143591 5.06030999,-0.0211407611 5.30721074,0.216574262 C5.55411149,0.454289284 5.56226116,0.851320812 5.32541353,1.103369 L1.95384971,4.69131519 L5.48809879,8.09407556 C5.73499955,8.33179058 5.74314922,8.72882211 5.50630159,8.9808703 C5.26945396,9.23291849 4.87729841,9.24453781 4.63039766,9.00682279 L0.827097345,5.34502101 C0.749816996,5.31670099 0.677016974,5.27216098 0.613753508,5.21125118 C0.427367989,5.03179997 0.377040713,4.7615583 0.465458792,4.53143559 C0.492371834,4.43667624 0.541703274,4.34676528 0.613628034,4.27022448 C0.654709457,4.22650651 0.70046335,4.19002189 0.749321284,4.16081709 Z\" id=\"Shape-Copy-3\" stroke=\"#FFFFFF\" stroke-width=\"0.05\" fill=\"#DDE1E4\"></path><path d=\"M13.7119065,5.44453032 L9.77062746,9.09174784 C9.51677479,9.3266604 9.12476399,9.31089603 8.89504684,9.05653714 C8.66532968,8.80217826 8.68489539,8.40554539 8.93874806,8.17063283 L12.5546008,4.82456128 L9.26827469,1.18571135 C9.03855754,0.931352463 9.05812324,0.534719593 9.31197591,0.299807038 C9.56582858,0.0648944831 9.95783938,0.0806588502 10.1875565,0.335017737 L13.72891,4.25625178 C13.8013755,4.28980469 13.8684335,4.3382578 13.9254821,4.40142604 C14.0883019,4.58171146 14.1258883,4.83347168 14.0435812,5.04846202 C14.0126705,5.15680232 13.9526426,5.2583679 13.8641331,5.34027361 C13.8174417,5.38348136 13.7660763,5.41820853 13.7119065,5.44453032 Z\" id=\"Shape-Copy-4\" stroke=\"#FFFFFF\" stroke-width=\"0.05\" fill=\"#DDE1E4\"></path></g></svg>"

/***/ },
/* 348 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\"><path d=\"M8 13.4c-.5 0-.9-.2-1.2-.6L.4 5.2C0 4.7-.1 4.3.2 3.7S1 3 1.6 3h12.8c.6 0 1.2.1 1.4.7.3.6.2 1.1-.2 1.6l-6.4 7.6c-.3.4-.7.5-1.2.5z\"></path></svg>"

/***/ },
/* 349 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><g fill-rule=\"evenodd\"><circle cx=\"8\" cy=\"8.5\" r=\"1.5\"></circle><path d=\"M15.498 8.28l-.001-.03v-.002-.004l-.002-.018-.004-.031c0-.002 0-.002 0 0l-.004-.035.006.082c-.037-.296-.133-.501-.28-.661-.4-.522-.915-1.042-1.562-1.604-1.36-1.182-2.74-1.975-4.178-2.309a6.544 6.544 0 0 0-2.755-.042c-.78.153-1.565.462-2.369.91C3.252 5.147 2.207 6 1.252 7.035c-.216.233-.36.398-.499.577-.338.437-.338 1 0 1.437.428.552.941 1.072 1.59 1.635 1.359 1.181 2.739 1.975 4.177 2.308.907.21 1.829.223 2.756.043.78-.153 1.564-.462 2.369-.91 1.097-.612 2.141-1.464 3.097-2.499.217-.235.36-.398.498-.578.12-.128.216-.334.248-.554 0 .01 0 .01-.008.04l.013-.079-.001.011.003-.031.001-.017v.005l.001-.02v.008l.002-.03.001-.05-.001-.044v-.004-.004zm-.954.045v.007l.001.004V8.33v.012l-.001.01v-.005-.005l.002-.015-.001.008c-.002.014-.002.014 0 0l-.007.084c.003-.057-.004-.041-.014-.031-.143.182-.27.327-.468.543-.89.963-1.856 1.752-2.86 2.311-.724.404-1.419.677-2.095.81a5.63 5.63 0 0 1-2.374-.036c-1.273-.295-2.523-1.014-3.774-2.101-.604-.525-1.075-1.001-1.457-1.496-.054-.07-.054-.107 0-.177.117-.152.244-.298.442-.512.89-.963 1.856-1.752 2.86-2.311.724-.404 1.419-.678 2.095-.81a5.631 5.631 0 0 1 2.374.036c1.272.295 2.523 1.014 3.774 2.101.603.524 1.074 1 1.457 1.496.035.041.043.057.046.076 0 .01 0 .01.008.043l-.009-.047.003.02-.002-.013v-.008.016c0-.004 0-.004 0 0v-.004z\"></path></g></svg>"

/***/ },
/* 350 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 60 12\"><path id=\"base-path\" d=\"M53.9,0H1C0.4,0,0,0.4,0,1v10c0,0.6,0.4,1,1,1h52.9c0.6,0,1.2-0.3,1.5-0.7L60,6l-4.4-5.3C55,0.3,54.5,0,53.9,0z\"></path></svg>"

/***/ },
/* 351 */
/***/ function(module, exports) {

	module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 20 16\" stroke=\"none\" fillrule=\"evenodd\"><path d=\"M10.919,13 L9.463,13 C9.29966585,13 9.16550052,12.9591671 9.0605,12.8775 C8.95549947,12.7958329 8.8796669,12.6943339 8.833,12.573 L8.077,10.508 L3.884,10.508 L3.128,12.573 C3.09066648,12.6803339 3.01716722,12.7783329 2.9075,12.867 C2.79783279,12.9556671 2.66366746,13 2.505,13 L1.042,13 L5.018,2.878 L6.943,2.878 L10.919,13 Z M4.367,9.178 L7.594,9.178 L6.362,5.811 C6.30599972,5.66166592 6.24416701,5.48550102 6.1765,5.2825 C6.108833,5.07949898 6.04233366,4.85900119 5.977,4.621 C5.91166634,4.85900119 5.84750032,5.08066564 5.7845,5.286 C5.72149969,5.49133436 5.65966697,5.67099923 5.599,5.825 L4.367,9.178 Z M18.892,13 L18.115,13 C17.9516658,13 17.8233338,12.9755002 17.73,12.9265 C17.6366662,12.8774998 17.5666669,12.7783341 17.52,12.629 L17.366,12.118 C17.1839991,12.2813341 17.0055009,12.4248327 16.8305,12.5485 C16.6554991,12.6721673 16.4746676,12.7759996 16.288,12.86 C16.1013324,12.9440004 15.903001,13.0069998 15.693,13.049 C15.4829989,13.0910002 15.2496679,13.112 14.993,13.112 C14.6896651,13.112 14.4096679,13.0711671 14.153,12.9895 C13.896332,12.9078329 13.6758342,12.7853342 13.4915,12.622 C13.3071657,12.4586658 13.1636672,12.2556679 13.061,12.013 C12.9583328,11.7703321 12.907,11.4880016 12.907,11.166 C12.907,10.895332 12.9781659,10.628168 13.1205,10.3645 C13.262834,10.100832 13.499665,9.8628344 13.831,9.6505 C14.162335,9.43816561 14.6033306,9.2620007 15.154,9.122 C15.7046694,8.9819993 16.3883292,8.90266676 17.205,8.884 L17.205,8.464 C17.205,7.98333093 17.103501,7.62750116 16.9005,7.3965 C16.697499,7.16549885 16.4023352,7.05 16.015,7.05 C15.7349986,7.05 15.5016676,7.08266634 15.315,7.148 C15.1283324,7.21333366 14.9661673,7.28683292 14.8285,7.3685 C14.6908326,7.45016707 14.5636672,7.52366634 14.447,7.589 C14.3303327,7.65433366 14.2020007,7.687 14.062,7.687 C13.9453327,7.687 13.8450004,7.65666697 13.761,7.596 C13.6769996,7.53533303 13.6093336,7.46066711 13.558,7.372 L13.243,6.819 C14.0690041,6.06299622 15.0653275,5.685 16.232,5.685 C16.6520021,5.685 17.0264983,5.75383264 17.3555,5.8915 C17.6845016,6.02916736 17.9633322,6.22049877 18.192,6.4655 C18.4206678,6.71050122 18.5944994,7.00333163 18.7135,7.344 C18.8325006,7.68466837 18.892,8.05799797 18.892,8.464 L18.892,13 Z M15.532,11.922 C15.7093342,11.922 15.8726659,11.9056668 16.022,11.873 C16.1713341,11.8403332 16.3124993,11.7913337 16.4455,11.726 C16.5785006,11.6606663 16.7068327,11.5801671 16.8305,11.4845 C16.9541673,11.3888329 17.0789993,11.2756673 17.205,11.145 L17.205,9.934 C16.7009975,9.95733345 16.279835,10.0004997 15.9415,10.0635 C15.603165,10.1265003 15.3313343,10.2069995 15.126,10.305 C14.9206656,10.4030005 14.7748337,10.5173327 14.6885,10.648 C14.6021662,10.7786673 14.559,10.9209992 14.559,11.075 C14.559,11.3783349 14.6488324,11.5953327 14.8285,11.726 C15.0081675,11.8566673 15.2426652,11.922 15.532,11.922 L15.532,11.922 Z\"></path></svg>"

/***/ },
/* 352 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 6 6\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><path d=\"M1.35191454,5.27895256 L5.31214367,1.35518468 C5.50830675,1.16082764 5.50977084,0.844248536 5.3154138,0.648085456 C5.12105677,0.451922377 4.80447766,0.450458288 4.60831458,0.644815324 L0.648085456,4.56858321 C0.451922377,4.76294025 0.450458288,5.07951935 0.644815324,5.27568243 C0.83917236,5.47184551 1.15575146,5.4733096 1.35191454,5.27895256 L1.35191454,5.27895256 Z\" id=\"Line\" stroke=\"none\" fill=\"#696969\" fill-rule=\"evenodd\"></path><path d=\"M5.31214367,4.56858321 L1.35191454,0.644815324 C1.15575146,0.450458288 0.83917236,0.451922377 0.644815324,0.648085456 C0.450458288,0.844248536 0.451922377,1.16082764 0.648085456,1.35518468 L4.60831458,5.27895256 C4.80447766,5.4733096 5.12105677,5.47184551 5.3154138,5.27568243 C5.50977084,5.07951935 5.50830675,4.76294025 5.31214367,4.56858321 L5.31214367,4.56858321 Z\" id=\"Line-Copy-2\" stroke=\"none\" fill=\"#696969\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 353 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.05 4.634l-2.144.003-.116.116v1.445l.92.965.492.034.116-.116v-.617L9.13 5.7l.035-.95M12.482 10.38l-1.505-1.462H9.362l-.564.516-.034 1.108.72.768 1.323.034-.117-.116v1.2l.972 1.02.315.034.116-.116v-1.154l.422-.374.034-.927-.117.117h.26l.408-.36V10.5l-.125-.124-.575-.033\"></path><path d=\"M8.47 15.073c-3.088 0-5.6-2.513-5.6-5.602V9.4v-.003c0-.018 0-.018.002-.034l.182-.088.724.587.49.033.497.543-.034.9.317.383h.47l.114.096-.032 1.9.524.553h.105l.025-.338 1.004-.95.054-.474.53-.462v-.888l-.588-.038-1.118-1.155H4.48l-.154-.09V9.01l.155-.1h1.164v-.273l.12-.115.7.033.494-.443.034-.746-.624-.655h-.724v.28l-.11.07H4.64l-.114-.09.025-.64.48-.43v-.244h-.382c-.102 0-.152-.128-.08-.2 1.04-1.01 2.428-1.59 3.903-1.59 1.374 0 2.672.5 3.688 1.39.08.068.03.198-.075.198l-1.144-.034-.81.803.52.523v.16l-.382.388h-.158l-.176-.177v-.16l.076-.074-.252-.252-.37.362.53.53c.072.072.005.194-.096.194l-.752-.005v.844h.783L9.885 8l.16-.143h.16l.62.61v.267l.58.027.003.002V8.76l.18-.03 1.234 1.24.753-.708h.382l.116.108c0 .02.003.016.003.036v.065c0 3.09-2.515 5.603-5.605 5.603M8.47 3C4.904 3 2 5.903 2 9.47c0 3.57 2.903 6.472 6.47 6.472 3.57 0 6.472-2.903 6.472-6.47C14.942 5.9 12.04 3 8.472 3\"></path></svg>"

/***/ },
/* 354 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4 2v12h9V4.775L9.888 2H4zm0-1h5.888c.246 0 .483.09.666.254l3.112 2.774c.212.19.334.462.334.747V14c0 .552-.448 1-1 1H4c-.552 0-1-.448-1-1V2c0-.552.448-1 1-1z\"></path><path d=\"M9 1.5v4c0 .325.306.564.62.485l4-1c.27-.067.432-.338.365-.606-.067-.27-.338-.432-.606-.365l-4 1L10 5.5v-4c0-.276-.224-.5-.5-.5s-.5.224-.5.5z\"></path></svg>"

/***/ },
/* 355 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 5.193v7.652c0 .003-.002 0 .007 0H14v-7.69c0-.003.002 0-.007 0h-7.53v-2.15c0-.002-.004-.005-.01-.005H2.01C2 3 2 3 2 3.005V5.193zm-1 0V3.005C1 2.45 1.444 2 2.01 2h4.442c.558 0 1.01.45 1.01 1.005v1.15h6.53c.557 0 1.008.44 1.008 1v7.69c0 .553-.45 1-1.007 1H2.007c-.556 0-1.007-.44-1.007-1V5.193zM6.08 4.15H2v1h4.46v-1h-.38z\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 356 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"14 6 13 12\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><g id=\"world\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" transform=\"translate(14.000000, 6.000000)\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M6.35076107,0.354 C3.25095418,0.354 0.729,2.87582735 0.729,5.9758879 C0.729,9.07544113 3.25082735,11.5972685 6.35076107,11.5972685 C9.45044113,11.5972685 11.9723953,9.07544113 11.9723953,5.97576107 C11.9723953,2.87582735 9.45044113,0.354 6.35076107,0.354 L6.35076107,0.354 Z M6.35076107,10.8289121 C3.67445071,10.8289121 1.49722956,8.65181776 1.49722956,5.97576107 C1.49722956,5.9443064 1.49900522,5.91335907 1.49976622,5.88215806 L2.20090094,6.4213266 L2.56313696,6.4213266 L2.97268183,6.8306178 L2.97268183,7.68217686 L3.32324919,8.03287105 L3.73926255,8.03287105 L3.73926255,9.79940584 L4.27386509,10.3361645 L4.4591686,10.3361645 L4.4591686,10.000183 L5.37655417,9.08343163 L5.37655417,8.73400577 L5.85585737,8.25203907 L5.85585737,7.37206934 L5.32518666,7.37206934 L4.28439226,6.33140176 L2.82225748,6.33140176 L2.82225748,5.56938704 L3.96286973,5.56938704 L3.96286973,5.23949352 L4.65068695,5.23949352 L5.11477015,4.77667865 L5.11477015,4.03001076 L4.49087694,3.40662489 L3.75359472,3.40662489 L3.75359472,3.78725175 L2.96228149,3.78725175 L2.96228149,3.28385021 L3.42217919,2.82319151 L3.42217919,2.49786399 L2.97001833,2.49786399 C3.84466106,1.64744643 5.03714814,1.12222956 6.35063424,1.12222956 C7.57292716,1.12222956 8.69020207,1.57730759 9.54442463,2.32587797 L8.46164839,2.32587797 L7.680355,3.10666403 L8.21508437,3.64088607 L7.87238068,3.98257509 L7.7165025,3.82669692 L7.85297518,3.68946324 L7.78930484,3.62566607 L7.78943167,3.62566607 L7.56011699,3.39559038 L7.55986332,3.39571722 L7.49758815,3.33318838 L7.01904595,3.78585658 L7.55910232,4.32654712 L6.8069806,4.32198112 L6.8069806,5.25864535 L7.66716433,5.25864535 L7.6723645,4.72112565 L7.81289584,4.57996014 L8.31819988,5.08653251 L8.31819988,5.41921636 L9.00703176,5.41921636 L9.03366676,5.39321553 L9.03430093,5.39194719 L10.195587,6.55259911 L10.8637451,5.88520206 L11.2018828,5.88520206 C11.2023901,5.9153884 11.2041658,5.94532107 11.2041658,5.97563424 C11.2040389,8.65181776 9.0269446,10.8289121 6.35076107,10.8289121 L6.35076107,10.8289121 Z\" id=\"Shape\" stroke=\"#DDE1E5\" stroke-width=\"0.25\" fill=\"#DDE1E5\"></path><polygon id=\"Shape\" stroke=\"#DDE1E5\" stroke-width=\"0.25\" fill=\"#DDE1E5\" points=\"6.50676608 1.61523076 4.52892694 1.61789426 4.52892694 2.95192735 5.34560683 3.76733891 5.72496536 3.76733891 5.72496536 3.1967157 6.50676608 2.41592965\"></polygon><polygon id=\"Shape\" stroke=\"#DDE1E5\" stroke-width=\"0.25\" fill=\"#DDE1E5\" points=\"9.59959714 6.88718547 8.28623788 5.57268471 8.28623788 5.57002121 6.79607294 5.57002121 6.35101474 6.01469891 6.35101474 6.96201714 6.98429362 7.59466185 8.12909136 7.59466185 8.12909136 8.70343893 8.99434843 9.56882283 9.20971144 9.56882283 9.20971144 8.50329592 9.63029081 8.08271655 9.63029081 7.3026915 9.87025949 7.3026915 10.1711082 7.00082814 10.0558167 6.88718547\"></polygon></g></svg>"

/***/ },
/* 357 */
/***/ function(module, exports) {

	module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path class=\"st0\" d=\"M9 9.3l3.6 3.6\"></path><ellipse fill=\"transparent\" cx=\"5.9\" cy=\"6.2\" rx=\"4.5\" ry=\"4.5\"></ellipse></svg>"

/***/ },
/* 358 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><g fill-rule=\"evenodd\"><path d=\"M5 12.503l.052-9a.5.5 0 0 0-1-.006l-.052 9a.5.5 0 0 0 1 .006zM12 12.497l-.05-9A.488.488 0 0 0 11.474 3a.488.488 0 0 0-.473.503l.05 9a.488.488 0 0 0 .477.497.488.488 0 0 0 .473-.503z\"></path></g></svg>"

/***/ },
/* 359 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.483 13.995H5.517l-3.512-3.512V5.516l3.512-3.512h4.966l3.512 3.512v4.967l-3.512 3.512zm4.37-9.042l-3.807-3.805A.503.503 0 0 0 10.691 1H5.309a.503.503 0 0 0-.356.148L1.147 4.953A.502.502 0 0 0 1 5.308v5.383c0 .134.053.262.147.356l3.806 3.806a.503.503 0 0 0 .356.147h5.382a.503.503 0 0 0 .355-.147l3.806-3.806A.502.502 0 0 0 15 10.69V5.308a.502.502 0 0 0-.147-.355z\"></path><path d=\"M10 10.5a.5.5 0 1 0 1 0v-5a.5.5 0 1 0-1 0v5zM5 10.5a.5.5 0 1 0 1 0v-5a.5.5 0 0 0-1 0v5z\"></path></svg>"

/***/ },
/* 360 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8.5 8.5V14a.5.5 0 1 1-1 0V8.5H2a.5.5 0 0 1 0-1h5.5V2a.5.5 0 0 1 1 0v5.5H14a.5.5 0 1 1 0 1H8.5z\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 361 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.525 13.21h-.472c-.574 0-.987-.154-1.24-.463-.253-.31-.38-.882-.38-1.719v-.573c0-.746-.097-1.265-.292-1.557-.196-.293-.51-.44-.945-.44v-.974c.435 0 .75-.146.945-.44.195-.292.293-.811.293-1.556v-.58c0-.833.126-1.404.379-1.712.253-.31.666-.464 1.24-.464h.472v.783h-.179c-.37 0-.628.08-.774.24-.145.159-.218.54-.218 1.141v.383c0 .824-.096 1.432-.287 1.823-.191.39-.516.679-.974.866.458.191.783.482.974.873.191.39.287.998.287 1.823v.382c0 .602.073.982.218 1.142.146.16.404.239.774.239h.18v.783zm9.502-4.752c-.43 0-.744.147-.942.44-.197.292-.296.811-.296 1.557v.573c0 .837-.125 1.41-.376 1.719-.251.309-.664.463-1.237.463h-.478v-.783h.185c.37 0 .628-.08.774-.24.145-.159.218-.539.218-1.14v-.383c0-.825.096-1.433.287-1.823.191-.39.516-.682.974-.873-.458-.187-.783-.476-.974-.866-.191-.391-.287-.999-.287-1.823v-.383c0-.602-.073-.982-.218-1.142-.146-.159-.404-.239-.774-.239h-.185v-.783h.478c.573 0 .986.155 1.237.464.25.308.376.88.376 1.712v.58c0 .673.088 1.174.263 1.503.176.329.5.493.975.493v.974z\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 362 */
/***/ function(module, exports) {

	module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 20 16\" stroke=\"none\" fillrule=\"evenodd\"><rect x=\"3\" y=\"10\" width=\"3\" height=\"3\" rx=\"1\"></rect><rect x=\"12\" y=\"3\" width=\"2\" height=\"9\" rx=\"1\"></rect><rect transform=\"translate(13.000000, 7.500000) rotate(60.000000) translate(-13.000000, -7.500000) \" x=\"12\" y=\"3\" width=\"2\" height=\"9\" rx=\"1\"></rect><rect transform=\"translate(13.000000, 7.500000) rotate(-60.000000) translate(-13.000000, -7.500000) \" x=\"12\" y=\"3\" width=\"2\" height=\"9\" rx=\"1\"></rect></svg>"

/***/ },
/* 363 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6.925 12.5l7.4-5-7.4-5v10zM6 12.5v-10c0-.785.8-1.264 1.415-.848l7.4 5c.58.392.58 1.304 0 1.696l-7.4 5C6.8 13.764 6 13.285 6 12.5z\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 364 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 33 12\"><path id=\"base-path\" d=\"M27.1,0H1C0.4,0,0,0.4,0,1v10c0,0.6,0.4,1,1,1h26.1 c0.6,0,1.2-0.3,1.5-0.7L33,6l-4.4-5.3C28.2,0.3,27.7,0,27.1,0z\"></path></svg>"

/***/ },
/* 365 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><g fill-rule=\"evenodd\"><path d=\"M1.5 14.042h4.095a.5.5 0 0 0 0-1H1.5a.5.5 0 1 0 0 1zM7.983 2a.5.5 0 0 1 .517.5v7.483l3.136-3.326a.5.5 0 1 1 .728.686l-4 4.243a.499.499 0 0 1-.73-.004L3.635 7.343a.5.5 0 0 1 .728-.686L7.5 9.983V3H1.536C1.24 3 1 2.776 1 2.5s.24-.5.536-.5h6.447zM10.5 14.042h4.095a.5.5 0 0 0 0-1H10.5a.5.5 0 1 0 0 1z\"></path></g></svg>"

/***/ },
/* 366 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><g fill-rule=\"evenodd\"><path d=\"M5 13.5H1a.5.5 0 1 0 0 1h4a.5.5 0 1 0 0-1zM12 13.5H8a.5.5 0 1 0 0 1h4a.5.5 0 1 0 0-1zM6.11 5.012A.427.427 0 0 1 6.21 5h7.083L9.646 1.354a.5.5 0 1 1 .708-.708l4.5 4.5a.498.498 0 0 1 0 .708l-4.5 4.5a.5.5 0 0 1-.708-.708L13.293 6H6.5v5.5a.5.5 0 1 1-1 0v-6a.5.5 0 0 1 .61-.488z\"></path></g></svg>"

/***/ },
/* 367 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><g fill-rule=\"evenodd\"><path d=\"M13.297 6.912C12.595 4.39 10.167 2.5 7.398 2.5A5.898 5.898 0 0 0 1.5 8.398a.5.5 0 0 0 1 0A4.898 4.898 0 0 1 7.398 3.5c2.75 0 5.102 2.236 5.102 4.898v.004L8.669 7.029a.5.5 0 0 0-.338.942l4.462 1.598a.5.5 0 0 0 .651-.34.506.506 0 0 0 .02-.043l2-5a.5.5 0 1 0-.928-.372l-1.24 3.098z\"></path><circle cx=\"7\" cy=\"12\" r=\"1\"></circle></g></svg>"

/***/ },
/* 368 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.219 7c.345 0 .635.117.869.352.234.234.351.524.351.869 0 .351-.118.652-.356.903-.238.25-.526.376-.864.376-.332 0-.615-.125-.85-.376a1.276 1.276 0 0 1-.351-.903A1.185 1.185 0 0 1 12.218 7zM8.234 7c.345 0 .635.117.87.352.234.234.351.524.351.869 0 .351-.119.652-.356.903-.238.25-.526.376-.865.376-.332 0-.613-.125-.844-.376a1.286 1.286 0 0 1-.347-.903c0-.352.114-.643.342-.874.228-.231.51-.347.85-.347zM4.201 7c.339 0 .627.117.864.352.238.234.357.524.357.869 0 .351-.119.652-.357.903-.237.25-.525.376-.864.376-.338 0-.623-.125-.854-.376A1.286 1.286 0 0 1 3 8.221 1.185 1.185 0 0 1 4.201 7z\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 369 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><g fill-rule=\"evenodd\"><path d=\"M3.233 11.25l-.417 1H1.712C.763 12.25 0 11.574 0 10.747V6.503C0 5.675.755 5 1.712 5h4.127l-.417 1H1.597C1.257 6 1 6.225 1 6.503v4.244c0 .277.267.503.597.503h1.636zM7.405 11.27L7 12.306c.865.01 2.212-.024 2.315-.04.112-.016.112-.016.185-.035.075-.02.156-.046.251-.082.152-.056.349-.138.592-.244.415-.182.962-.435 1.612-.744l.138-.066a179.35 179.35 0 0 0 2.255-1.094c1.191-.546 1.191-2.074-.025-2.632l-.737-.34a3547.554 3547.554 0 0 0-3.854-1.78c-.029.11-.065.222-.11.336l-.232.596c.894.408 4.56 2.107 4.56 2.107.458.21.458.596 0 .806L9.197 11.27H7.405zM4.462 14.692l5-12a.5.5 0 1 0-.924-.384l-5 12a.5.5 0 1 0 .924.384z\"></path></g></svg>"

/***/ },
/* 370 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"#0b0b0b\"><path fill-opacity=\".3\" d=\"M12,3h2v10h-2V3z M5,9.9V6.1L8,8L5,9.9z\"></path><path d=\"M14,2H2C1.4,2,1,2.4,1,3v10c0,0.6,0.4,1,1,1h12c0.6,0,1-0.4,1-1V3C15,2.4,14.6,2,14,2z M2,13L2,13V3h0h9v10 H2L2,13z M14,13C14,13,14,13,14,13h-2V3h2c0,0,0,0,0,0V13z M8.5,7.2l-3-1.9C4.6,4.7,4,5,4,6.1v3.8c0,1.1,0.6,1.4,1.5,0.8l3-1.9 C9.5,8.3,9.5,7.8,8.5,7.2z M5,9.9V6.1L8,8L5,9.9z\"></path></svg>"

/***/ },
/* 371 */
/***/ function(module, exports) {

	module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\" stroke=\"none\" fillrule=\"evenodd\"><rect opacity=\"0.6\" x=\"1\" y=\"3\" width=\"2\" height=\"6\"></rect><rect opacity=\"0.6\" x=\"17\" y=\"3\" width=\"2\" height=\"6\"></rect><rect x=\"6\" y=\"3\" width=\"2\" height=\"6\"></rect><rect x=\"12\" y=\"3\" width=\"2\" height=\"6\"></rect><rect x=\"9\" y=\"3\" width=\"2\" height=\"6\"></rect><path d=\"M4.5,13 L15.5,13 L16,13 L16,12 L15.5,12 L4.5,12 L4,12 L4,13 L4.5,13 L4.5,13 Z\"></path><path d=\"M4,10.5 L4,12.5 L4,13 L5,13 L5,12.5 L5,10.5 L5,10 L4,10 L4,10.5 L4,10.5 Z\"></path><path d=\"M15,10.5 L15,12.5 L15,13 L16,13 L16,12.5 L16,10.5 L16,10 L15,10 L15,10.5 L15,10.5 Z\"></path></svg>"

/***/ },
/* 372 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M8.5 8.793L5.854 6.146l-.04-.035L7.5 4.426c.2-.2.3-.4.3-.6 0-.2-.1-.4-.2-.6l-1-1c-.4-.3-.9-.3-1.2 0l-4.1 4.1c-.2.2-.3.4-.3.6 0 .2.1.4.2.6l1 1c.3.3.9.3 1.2 0l1.71-1.71.036.04L7.793 9.5l-3.647 3.646c-.195.196-.195.512 0 .708.196.195.512.195.708 0L8.5 10.207l3.646 3.647c.196.195.512.195.708 0 .195-.196.195-.512 0-.708L9.207 9.5l2.565-2.565L13.3 8.5c.1.1 2.3 1.1 2.7.7.4-.4-.3-2.7-.5-2.9l-1.1-1.1c.1-.1.2-.4.2-.6 0-.2-.1-.4-.2-.6l-.4-.4c-.3-.3-.8-.3-1.1 0l-1.5-1.4c-.2-.2-.3-.2-.5-.2s-.3.1-.5.2L9.2 3.4c-.2.1-.2.2-.2.4s.1.4.2.5l1.874 1.92L8.5 8.792z\"></path></svg>"

/***/ },
/* 373 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" fill=\"#D92215\"><path d=\"M8 14.5c-3.6 0-6.5-2.9-6.5-6.5S4.4 1.5 8 1.5s6.5 2.9 6.5 6.5-2.9 6.5-6.5 6.5zm0-12C5 2.5 2.5 5 2.5 8S5 13.5 8 13.5 13.5 11 13.5 8 11 2.5 8 2.5z\"></path><circle cx=\"5\" cy=\"6\" r=\"1\" transform=\"translate(1 1)\"></circle><circle cx=\"9\" cy=\"6\" r=\"1\" transform=\"translate(1 1)\"></circle><path d=\"M5.5 11c-.1 0-.2 0-.3-.1-.2-.1-.3-.4-.1-.7C6 9 7 8.5 8.1 8.5c1.7.1 2.8 1.7 2.8 1.8.2.2.1.5-.1.7-.2.1-.6 0-.7-.2 0 0-.9-1.3-2-1.3-.7 0-1.4.4-2.1 1.3-.2.2-.4.2-.5.2z\"></path></svg>"

/***/ },
/* 374 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.917 7C13.44 4.162 10.973 2 8 2 4.686 2 2 4.686 2 8s2.686 6 6 6c2.22 0 4.16-1.207 5.197-3H12c-.912 1.214-2.364 2-4 2-2.76 0-5-2.24-5-5s2.24-5 5-5c2.42 0 4.437 1.718 4.9 4h1.017z\"></path><path d=\"M14 1L8 7h6V1zm-1 1L9 6h4V2z\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 375 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 376 */,
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _devtoolsConfig = __webpack_require__(828);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _Close = __webpack_require__(378);

	var _Close2 = _interopRequireDefault(_Close);

	__webpack_require__(381);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class SearchInput extends _react.Component {

	  static get defaultProps() {
	    return {
	      size: ""
	    };
	  }

	  renderSvg() {
	    var _props = this.props,
	        count = _props.count,
	        query = _props.query;


	    if (count == 0 && query.trim() != "") {
	      return (0, _Svg2.default)("sad-face");
	    }

	    return (0, _Svg2.default)("magnifying-glass");
	  }

	  renderNav() {
	    if (!(0, _devtoolsConfig.isEnabled)("searchNav")) {
	      return;
	    }

	    var _props2 = this.props,
	        count = _props2.count,
	        handleNext = _props2.handleNext,
	        handlePrev = _props2.handlePrev;

	    if (!handleNext && !handlePrev || !count || count == 1) {
	      return;
	    }

	    return _react.DOM.div({ className: "search-nav-buttons" }, (0, _Svg2.default)("arrow-down", {
	      className: (0, _classnames2.default)("nav-btn", "next"),
	      onClick: handleNext,
	      title: "Next Result"
	    }), (0, _Svg2.default)("arrow-up", {
	      className: (0, _classnames2.default)("nav-btn", "prev"),
	      onClick: handlePrev,
	      title: "Previous Result"
	    }));
	  }

	  render() {
	    var _props3 = this.props,
	        query = _props3.query,
	        placeholder = _props3.placeholder,
	        count = _props3.count,
	        summaryMsg = _props3.summaryMsg,
	        onChange = _props3.onChange,
	        onKeyDown = _props3.onKeyDown,
	        onKeyUp = _props3.onKeyUp,
	        onFocus = _props3.onFocus,
	        onBlur = _props3.onBlur,
	        handleClose = _props3.handleClose,
	        size = _props3.size;


	    return _react.DOM.div({
	      className: `search-field ${size}`
	    }, this.renderSvg(), _react.DOM.input({
	      className: (0, _classnames2.default)({
	        empty: count == 0 && query.trim() != ""
	      }),
	      onChange,
	      onKeyDown,
	      onKeyUp,
	      onFocus,
	      onBlur,
	      placeholder,
	      value: query,
	      spellCheck: false
	    }), _react.DOM.div({ className: "summary" }, query != "" ? summaryMsg : ""), this.renderNav(), (0, _Close2.default)({
	      handleClick: handleClose,
	      buttonClass: size
	    }));
	  }
	}

	SearchInput.propTypes = {
	  query: _react.PropTypes.string.isRequired,
	  count: _react.PropTypes.number.isRequired,
	  placeholder: _react.PropTypes.string.isRequired,
	  summaryMsg: _react.PropTypes.string.isRequired,
	  onChange: _react.PropTypes.func.isRequired,
	  handleClose: _react.PropTypes.func.isRequired,
	  onKeyUp: _react.PropTypes.func,
	  onKeyDown: _react.PropTypes.func,
	  onFocus: _react.PropTypes.func,
	  onBlur: _react.PropTypes.func,
	  size: _react.PropTypes.string,
	  handleNext: _react.PropTypes.func,
	  handlePrev: _react.PropTypes.func
	};

	exports.default = SearchInput;

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	__webpack_require__(379);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function CloseButton(_ref) {
	  var handleClick = _ref.handleClick,
	      buttonClass = _ref.buttonClass,
	      tooltip = _ref.tooltip;

	  return _react.DOM.div({
	    className: buttonClass ? `close-btn ${buttonClass}` : "close-btn",
	    onClick: handleClick,
	    title: tooltip
	  }, (0, _Svg2.default)("close"));
	}


	CloseButton.propTypes = {
	  handleClick: _react.PropTypes.func.isRequired
	};

	exports.default = CloseButton;

/***/ },
/* 379 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 380 */,
/* 381 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 382 */,
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	__webpack_require__(384);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class ResultList extends _react.Component {

	  constructor(props) {
	    super(props);
	    this.renderListItem = this.renderListItem.bind(this);
	  }

	  renderListItem(item, index) {
	    return _react.DOM.li({
	      onClick: event => this.props.selectItem(event, item, index),
	      key: `${item.id}${item.value}${index}`,
	      ref: index,
	      title: item.value,
	      className: (0, _classnames2.default)({
	        selected: index === this.props.selected
	      })
	    }, _react.DOM.div({ className: "title" }, item.title), _react.DOM.div({ className: "subtitle" }, item.subtitle));
	  }

	  render() {
	    var size = this.props.size;

	    size = size || "";
	    return _react.DOM.ul({
	      className: `result-list ${size}`
	    }, this.props.items.map(this.renderListItem));
	  }
	}

	exports.default = ResultList;
	ResultList.propTypes = {
	  items: _react.PropTypes.array.isRequired,
	  selected: _react.PropTypes.number.isRequired,
	  selectItem: _react.PropTypes.func.isRequired,
	  size: _react.PropTypes.string
	};

	ResultList.defaultProps = {
	  size: ""
	};

/***/ },
/* 384 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 385 */,
/* 386 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 387 */,
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _reactImmutableProptypes = __webpack_require__(150);

	var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

	var _redux = __webpack_require__(3);

	var _reactRedux = __webpack_require__(151);

	var _text = __webpack_require__(389);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	__webpack_require__(424);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Outline = (0, _react.createFactory)(__webpack_require__(921).default);

	var SourcesTree = (0, _react.createFactory)(__webpack_require__(390).default);


	class Sources extends _react.Component {

	  constructor(props) {
	    super(props);
	    this.renderShortcut = this.renderShortcut.bind(this);
	  }

	  renderShortcut() {
	    if (this.props.horizontal) {
	      return _react.DOM.span({
	        className: "sources-header-info",
	        dir: "ltr",
	        onClick: () => this.props.toggleProjectSearch()
	      }, L10N.getFormatStr("sources.search", (0, _text.formatKeyShortcut)(`CmdOrCtrl+${L10N.getStr("sources.search.key")}`)));
	    }
	  }

	  render() {
	    var _props = this.props,
	        sources = _props.sources,
	        selectSource = _props.selectSource;


	    return _react.DOM.div({ className: "sources-panel" }, _react.DOM.div({ className: "sources-header" }, this.renderShortcut()), SourcesTree({ sources, selectSource }), Outline({}));
	  }
	}

	Sources.propTypes = {
	  sources: _reactImmutableProptypes2.default.map.isRequired,
	  selectSource: _react.PropTypes.func.isRequired,
	  horizontal: _react.PropTypes.bool.isRequired,
	  toggleProjectSearch: _react.PropTypes.func.isRequired
	};

	Sources.displayName = "Sources";

	exports.default = (0, _reactRedux.connect)(state => ({
	  sources: (0, _selectors.getSources)(state)
	}), dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(Sources);

/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * Utils for keyboard command strings
	 * @module utils/text
	 */

	var _require = __webpack_require__(830),
	    appinfo = _require.Services.appinfo;

	var isMacOS = appinfo.OS === "Darwin";

	/**
	 * Formats key for use in tooltips
	 * For macOS we use the following unicode
	 *
	 * cmd ⌘ = \u2318
	 * shift ⇧ – \u21E7
	 * option (alt) ⌥ \u2325
	 *
	 * For Win/Lin this replaces CommandOrControl or CmdOrCtrl with Ctrl
	 *
	 * @memberof utils/text
	 * @static
	 */
	function formatKeyShortcut(shortcut) {
	  if (isMacOS) {
	    return shortcut.replace(/Shift\+/g, "\u21E7+").replace(/Command\+|Cmd\+/g, "\u2318+").replace(/CommandOrControl\+|CmdOrCtrl\+/g, "\u2318+").replace(/Alt\+/g, "\u2325+");
	  }
	  return shortcut.replace(/CommandOrControl\+|CmdOrCtrl\+/g, `${L10N.getStr("ctrl")}+`);
	}

	module.exports = {
	  formatKeyShortcut
	};

/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _redux = __webpack_require__(3);

	var _reactRedux = __webpack_require__(151);

	var _react = __webpack_require__(2);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _reactImmutableProptypes = __webpack_require__(150);

	var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

	var _immutable = __webpack_require__(146);

	var _selectors = __webpack_require__(242);

	var _sourcesTree = __webpack_require__(391);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	var _devtoolsLaunchpad = __webpack_require__(131);

	var _clipboard = __webpack_require__(423);

	var _utils = __webpack_require__(234);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ManagedTree = (0, _react.createFactory)(__webpack_require__(419).default);


	class SourcesTree extends _react.Component {

	  constructor(props) {
	    super(props);
	    this.state = (0, _sourcesTree.createTree)(this.props.sources, this.props.debuggeeUrl);

	    this.focusItem = this.focusItem.bind(this);
	    this.selectItem = this.selectItem.bind(this);
	    this.getIcon = this.getIcon.bind(this);
	    this.onContextMenu = this.onContextMenu.bind(this);
	    this.renderItem = this.renderItem.bind(this);

	    this.queueUpdate = (0, _utils.throttle)(function () {
	      if (!this.mounted) {
	        return;
	      }

	      this.forceUpdate();
	    }, 50);
	  }

	  componentDidMount() {
	    this.mounted = true;
	  }

	  componentWillUnMount() {
	    this.mounted = false;
	  }

	  shouldComponentUpdate() {
	    this.queueUpdate();
	    return false;
	  }

	  componentWillReceiveProps(nextProps) {
	    var selectedSource = this.props.selectedSource;

	    if (nextProps.shownSource && nextProps.shownSource != this.props.shownSource) {
	      var _listItems = (0, _sourcesTree.getDirectories)(nextProps.shownSource, this.state.sourceTree);

	      if (_listItems && _listItems[0]) {
	        this.selectItem(_listItems[0]);
	      }

	      return this.setState({ listItems: _listItems });
	    }

	    if (nextProps.selectedSource && nextProps.selectedSource != selectedSource) {
	      var _highlightItems = (0, _sourcesTree.getDirectories)(nextProps.selectedSource.get("url"), this.state.sourceTree);

	      return this.setState({ highlightItems: _highlightItems });
	    }

	    if (nextProps.sources === this.props.sources) {
	      return;
	    }

	    if (nextProps.sources.size === 0) {
	      this.setState((0, _sourcesTree.createTree)(nextProps.sources, this.props.debuggeeUrl));
	      return;
	    }

	    var next = (0, _immutable.Set)(nextProps.sources.valueSeq());
	    var prev = (0, _immutable.Set)(this.props.sources.valueSeq());
	    var newSet = next.subtract(prev);

	    var uncollapsedTree = this.state.uncollapsedTree;
	    for (var source of newSet) {
	      (0, _sourcesTree.addToTree)(uncollapsedTree, source, this.props.debuggeeUrl);
	    }

	    // TODO: recreating the tree every time messes with the expanded
	    // state of ManagedTree, because it depends on item instances
	    // being the same. The result is that if a source is added at a
	    // later time, all expanded state is lost.
	    var sourceTree = newSet.size > 0 ? (0, _sourcesTree.collapseTree)(uncollapsedTree) : this.state.sourceTree;

	    this.setState({
	      uncollapsedTree,
	      sourceTree,
	      parentMap: (0, _sourcesTree.createParentMap)(sourceTree)
	    });
	  }

	  focusItem(item) {
	    this.setState({ focusedItem: item });
	  }

	  selectItem(item) {
	    if (!(0, _sourcesTree.nodeHasChildren)(item)) {
	      this.props.selectSource(item.contents.get("id"));
	    }
	  }

	  getIcon(item, depth) {
	    if (depth === 0) {
	      return (0, _Svg2.default)("domain");
	    }

	    if (!(0, _sourcesTree.nodeHasChildren)(item)) {
	      return (0, _Svg2.default)("file");
	    }

	    return (0, _Svg2.default)("folder");
	  }

	  onContextMenu(event, item) {
	    var copySourceUrlLabel = L10N.getStr("copySourceUrl");
	    var copySourceUrlKey = L10N.getStr("copySourceUrl.accesskey");

	    event.stopPropagation();
	    event.preventDefault();

	    var menuOptions = [];

	    if (!(0, _sourcesTree.isDirectory)(item)) {
	      var source = item.contents.get("url");
	      var copySourceUrl = {
	        id: "node-menu-copy-source",
	        label: copySourceUrlLabel,
	        accesskey: copySourceUrlKey,
	        disabled: false,
	        click: () => (0, _clipboard.copyToTheClipboard)(source)
	      };

	      menuOptions.push(copySourceUrl);
	    }

	    (0, _devtoolsLaunchpad.showMenu)(event, menuOptions);
	  }

	  renderItem(item, depth, focused, _, expanded, _ref) {
	    var setExpanded = _ref.setExpanded;

	    var arrow = (0, _Svg2.default)("arrow", {
	      className: (0, _classnames2.default)({
	        expanded: expanded,
	        hidden: !(0, _sourcesTree.nodeHasChildren)(item)
	      }),
	      onClick: e => {
	        e.stopPropagation();
	        setExpanded(item, !expanded);
	      }
	    });

	    var icon = this.getIcon(item, depth);
	    var paddingDir = "paddingRight";
	    if (document.body && document.body.parentElement) {
	      paddingDir = document.body.parentElement.dir == "ltr" ? "paddingLeft" : "paddingRight";
	    }

	    return _react.DOM.div({
	      className: (0, _classnames2.default)("node", { focused }),
	      style: { [paddingDir]: `${depth * 15}px` },
	      key: item.path,
	      onClick: () => {
	        this.selectItem(item);
	        setExpanded(item, !expanded);
	      },
	      onContextMenu: e => this.onContextMenu(e, item)
	    }, _react.DOM.div(null, arrow, icon, item.name));
	  }

	  render() {
	    var _state = this.state,
	        focusedItem = _state.focusedItem,
	        sourceTree = _state.sourceTree,
	        parentMap = _state.parentMap,
	        listItems = _state.listItems,
	        highlightItems = _state.highlightItems;

	    var isEmpty = sourceTree.contents.length === 0;

	    var tree = ManagedTree({
	      key: isEmpty ? "empty" : "full",
	      getParent: item => {
	        return parentMap.get(item);
	      },
	      getChildren: item => {
	        if ((0, _sourcesTree.nodeHasChildren)(item)) {
	          return item.contents;
	        }
	        return [];
	      },
	      getRoots: () => sourceTree.contents,
	      getKey: (item, i) => item.path,
	      itemHeight: 18,
	      autoExpandDepth: 1,
	      autoExpandAll: false,
	      onFocus: this.focusItem,
	      listItems,
	      highlightItems,
	      renderItem: this.renderItem
	    });

	    var noSourcesMessage = _react.DOM.div({
	      className: "no-sources-message"
	    }, L10N.getStr("sources.noSourcesAvailable"));

	    if (isEmpty) {
	      return noSourcesMessage;
	    }
	    return _react.DOM.div({
	      className: "sources-list",
	      onKeyDown: e => {
	        if (e.keyCode === 13 && focusedItem) {
	          this.selectItem(focusedItem);
	        }
	      }
	    }, tree);
	  }
	}

	SourcesTree.propTypes = {
	  sources: _reactImmutableProptypes2.default.map.isRequired,
	  selectSource: _react.PropTypes.func.isRequired,
	  shownSource: _react.PropTypes.string,
	  selectedSource: _reactImmutableProptypes2.default.map,
	  debuggeeUrl: _react.PropTypes.string.isRequired
	};

	SourcesTree.displayName = "SourcesTree";

	exports.default = (0, _reactRedux.connect)(state => {
	  return {
	    shownSource: (0, _selectors.getShownSource)(state),
	    selectedSource: (0, _selectors.getSelectedSource)(state),
	    debuggeeUrl: (0, _selectors.getDebuggeeUrl)(state)
	  };
	}, dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(SourcesTree);

/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * Utils for Sources Tree Component
	 * @module utils/sources-tree
	 */

	var _require = __webpack_require__(334),
	    parse = _require.parse;

	var _require2 = __webpack_require__(222),
	    assert = _require2.assert;

	var _require3 = __webpack_require__(233),
	    isPretty = _require3.isPretty;

	var merge = __webpack_require__(392);

	var IGNORED_URLS = ["debugger eval code", "XStringBundle"];

	/**
	 * Temporary Source type to be used only within this module
	 * TODO: Replace with real Source type definition when refactoring types
	 * @memberof utils/sources-tree
	 * @static
	 */


	/**
	 * TODO: createNode is exported so this type could be useful to other modules
	 * @memberof utils/sources-tree
	 * @static
	 */


	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function nodeHasChildren(item) {
	  return Array.isArray(item.contents);
	}

	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function createNode(name, path, contents) {
	  return {
	    name,
	    path,
	    contents: contents || null
	  };
	}

	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function createParentMap(tree) {
	  var map = new WeakMap();

	  function _traverse(subtree) {
	    if (nodeHasChildren(subtree)) {
	      for (var child of subtree.contents) {
	        map.set(child, subtree);
	        _traverse(child);
	      }
	    }
	  }

	  // Don't link each top-level path to the "root" node because the
	  // user never sees the root
	  tree.contents.forEach(_traverse);
	  return map;
	}

	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function getFilenameFromPath(pathname) {
	  var filename = "";
	  if (pathname) {
	    filename = pathname.substring(pathname.lastIndexOf("/") + 1);
	    // This file does not have a name. Default should be (index).
	    if (filename == "" || !filename.includes(".")) {
	      filename = "(index)";
	    }
	  }
	  return filename;
	}

	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function getURL(sourceUrl) {
	  var url = sourceUrl;
	  var def = { path: "", group: "", filename: "" };
	  if (!url) {
	    return def;
	  }

	  var _parse = parse(url),
	      pathname = _parse.pathname,
	      protocol = _parse.protocol,
	      host = _parse.host,
	      path = _parse.path;

	  var filename = getFilenameFromPath(pathname);

	  switch (protocol) {
	    case "javascript:":
	      // Ignore `javascript:` URLs for now
	      return def;

	    case "about:":
	      // An about page is a special case
	      return merge(def, {
	        path: "/",
	        group: url,
	        filename: filename
	      });

	    case null:
	      if (pathname && pathname.startsWith("/")) {
	        // If it's just a URL like "/foo/bar.js", resolve it to the file
	        // protocol
	        return merge(def, {
	          path: path,
	          group: "file://",
	          filename: filename
	        });
	      } else if (host === null) {
	        // We don't know what group to put this under, and it's a script
	        // with a weird URL. Just group them all under an anonymous group.
	        return merge(def, {
	          path: url,
	          group: "(no domain)",
	          filename: filename
	        });
	      }
	      break;

	    case "http:":
	    case "https:":
	      return merge(def, {
	        path: pathname,
	        group: host,
	        filename: filename
	      });
	  }

	  return merge(def, {
	    path: path,
	    group: protocol ? `${protocol}//` : "",
	    filename: filename
	  });
	}

	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function isDirectory(url) {
	  var parts = url.path.split("/").filter(p => p !== "");

	  // Assume that all urls point to files except when they end with '/'
	  // Or directory node has children
	  return parts.length === 0 || url.path.slice(-1) === "/" || nodeHasChildren(url);
	}

	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function addToTree(tree, source, debuggeeUrl) {
	  var url = getURL(source.get("url"));

	  if (IGNORED_URLS.indexOf(url) != -1 || !source.get("url") || !url.group || isPretty(source.toJS())) {
	    return;
	  }

	  url.path = decodeURIComponent(url.path);

	  var parts = url.path.split("/").filter(p => p !== "");
	  var isDir = isDirectory(url);
	  parts.unshift(url.group);

	  var path = "";
	  var subtree = tree;

	  for (var i = 0; i < parts.length; i++) {
	    var part = parts[i];
	    var isLastPart = i === parts.length - 1;

	    // Currently we assume that we are descending into a node with
	    // children. This will fail if a path has a directory named the
	    // same as another file, like `foo/bar.js/file.js`.
	    //
	    // TODO: Be smarter about this, which we'll probably do when we
	    // are smarter about folders and collapsing empty ones.
	    assert(nodeHasChildren(subtree), `${subtree.name} should have children`);
	    var children = subtree.contents;

	    var index = determineFileSortOrder(children, part, isLastPart, i === 0 ? debuggeeUrl : "");

	    if (index >= 0 && children[index].name === part) {
	      // A node with the same name already exists, simply traverse
	      // into it.
	      subtree = children[index];
	    } else {
	      // No node with this name exists, so insert a new one in the
	      // place that is alphabetically sorted.
	      var node = createNode(part, `${path}/${part}`, []);
	      var where = index === -1 ? children.length : index;
	      children.splice(where, 0, node);
	      subtree = children[where];
	    }

	    // Keep track of the children so we can tag each node with them.
	    path = `${path}/${part}`;
	  }

	  // Overwrite the contents of the final node to store the source
	  // there.
	  if (isDir) {
	    subtree.contents.unshift(createNode("(index)", source.get("url"), source));
	  } else {
	    subtree.contents = source;
	  }
	}

	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function isExactUrlMatch(pathPart, debuggeeUrl) {
	  // compare to hostname with an optional 'www.' prefix
	  var _parse2 = parse(debuggeeUrl),
	      host = _parse2.host;

	  if (!host) {
	    return false;
	  }
	  return host.replace(/^www\./, "") === pathPart.replace(/^www\./, "");
	}

	/**
	 * Look at the nodes in the source tree, and determine the index of where to
	 * insert a new node. The ordering is index -> folder -> file.
	 * @memberof utils/sources-tree
	 * @static
	 */
	function determineFileSortOrder(nodes, pathPart, isLastPart, debuggeeUrl) {
	  var partIsDir = !isLastPart || pathPart.indexOf(".") === -1;

	  return nodes.findIndex(node => {
	    var nodeIsDir = nodeHasChildren(node);

	    // The index will always be the first thing, so this pathPart will be
	    // after it.
	    if (node.name === "(index)") {
	      return false;
	    }

	    // Directory or not, checking root url must be done first
	    if (debuggeeUrl) {
	      var rootUrlMatch = isExactUrlMatch(pathPart, debuggeeUrl);
	      var nodeUrlMatch = isExactUrlMatch(node.name, debuggeeUrl);
	      if (rootUrlMatch) {
	        // pathPart matches root url and must go first
	        return true;
	      }
	      if (nodeUrlMatch) {
	        // Examined item matches root url and must go first
	        return false;
	      }
	      // If neither is the case, continue to compare alphabetically
	    }

	    // If both the pathPart and node are the same type, then compare them
	    // alphabetically.
	    if (partIsDir === nodeIsDir) {
	      return node.name.localeCompare(pathPart) >= 0;
	    }

	    // If the pathPart and node differ, then stop here if the pathPart is a
	    // directory. Keep on searching if the part is a file, as it needs to be
	    // placed after the directories.
	    return partIsDir;
	  });
	}

	/**
	 * Take an existing source tree, and return a new one with collapsed nodes.
	 * @memberof utils/sources-tree
	 * @static
	 */
	function collapseTree(node) {
	  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	  // Node is a folder.
	  if (nodeHasChildren(node)) {
	    // Node is not a root/domain node, and only contains 1 item.
	    if (depth > 1 && node.contents.length === 1) {
	      var next = node.contents[0];
	      // Do not collapse if the next node is a leaf node.
	      if (nodeHasChildren(next)) {
	        return collapseTree(createNode(`${node.name}/${next.name}`, next.path, next.contents), depth + 1);
	      }
	    }
	    // Map the contents.
	    return createNode(node.name, node.path, node.contents.map(next => collapseTree(next, depth + 1)));
	  }
	  // Node is a leaf, not a folder, do not modify it.
	  return node;
	}

	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function createTree(sources, debuggeeUrl) {
	  var uncollapsedTree = createNode("root", "", []);
	  for (var source of sources.valueSeq()) {
	    addToTree(uncollapsedTree, source, debuggeeUrl);
	  }
	  var sourceTree = collapseTree(uncollapsedTree);

	  return {
	    uncollapsedTree,
	    sourceTree,
	    parentMap: createParentMap(sourceTree),
	    focusedItem: null
	  };
	}

	function findSource(sourceTree, sourceUrl) {
	  var returnTarget = null;
	  function _traverse(subtree) {
	    if (nodeHasChildren(subtree)) {
	      for (var child of subtree.contents) {
	        _traverse(child);
	      }
	    } else if (!returnTarget && subtree.path.replace(/http(s)?:\//, "") == sourceUrl) {
	      returnTarget = subtree;
	      return;
	    }
	  }

	  sourceTree.contents.forEach(_traverse);
	  return returnTarget;
	}

	function getDirectories(sourceUrl, sourceTree) {
	  var url = getURL(sourceUrl);
	  var fullUrl = `/${url.group}${url.path}`;
	  var parentMap = createParentMap(sourceTree);
	  var source = findSource(sourceTree, fullUrl);

	  if (!source) {
	    return [];
	  }

	  var node = source;
	  var directories = [];
	  directories.push(source);
	  while (true) {
	    node = parentMap.get(node);
	    if (!node) {
	      return directories;
	    }
	    directories.push(node);
	  }
	}

	module.exports = {
	  createNode,
	  nodeHasChildren,
	  createParentMap,
	  isDirectory,
	  addToTree,
	  collapseTree,
	  createTree,
	  getDirectories,
	  getURL,
	  isExactUrlMatch
	};

/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	var baseMerge = __webpack_require__(393),
	    createAssigner = __webpack_require__(410);

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function(object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});

	module.exports = merge;


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(267),
	    assignMergeValue = __webpack_require__(394),
	    baseFor = __webpack_require__(395),
	    baseMergeDeep = __webpack_require__(397),
	    isObject = __webpack_require__(84),
	    keysIn = __webpack_require__(407);

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor(source, function(srcValue, key) {
	    if (isObject(srcValue)) {
	      stack || (stack = new Stack);
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn);
	}

	module.exports = baseMerge;


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(115),
	    eq = __webpack_require__(97);

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignMergeValue;


/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(396);

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	module.exports = baseFor;


/***/ },
/* 396 */
/***/ function(module, exports) {

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	module.exports = createBaseFor;


/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	var assignMergeValue = __webpack_require__(394),
	    cloneBuffer = __webpack_require__(398),
	    cloneTypedArray = __webpack_require__(399),
	    copyArray = __webpack_require__(401),
	    initCloneObject = __webpack_require__(402),
	    isArguments = __webpack_require__(208),
	    isArray = __webpack_require__(70),
	    isArrayLikeObject = __webpack_require__(404),
	    isBuffer = __webpack_require__(210),
	    isFunction = __webpack_require__(83),
	    isObject = __webpack_require__(84),
	    isPlainObject = __webpack_require__(5),
	    isTypedArray = __webpack_require__(212),
	    toPlainObject = __webpack_require__(405);

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = object[key],
	      srcValue = source[key],
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray(srcValue),
	        isBuff = !isArr && isBuffer(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
	        newValue = initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	}

	module.exports = baseMergeDeep;


/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(8);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	module.exports = cloneBuffer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module)))

/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	var cloneArrayBuffer = __webpack_require__(400);

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	module.exports = cloneTypedArray;


/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	var Uint8Array = __webpack_require__(282);

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}

	module.exports = cloneArrayBuffer;


/***/ },
/* 401 */
/***/ function(module, exports) {

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	module.exports = copyArray;


/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(403),
	    getPrototype = __webpack_require__(12),
	    isPrototype = __webpack_require__(218);

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	module.exports = initCloneObject;


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(84);

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	module.exports = baseCreate;


/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(220),
	    isObjectLike = __webpack_require__(14);

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	module.exports = isArrayLikeObject;


/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(406),
	    keysIn = __webpack_require__(407);

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return copyObject(value, keysIn(value));
	}

	module.exports = toPlainObject;


/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(114),
	    baseAssignValue = __webpack_require__(115);

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	module.exports = copyObject;


/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(206),
	    baseKeysIn = __webpack_require__(408),
	    isArrayLike = __webpack_require__(220);

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	module.exports = keysIn;


/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(84),
	    isPrototype = __webpack_require__(218),
	    nativeKeysIn = __webpack_require__(409);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeysIn;


/***/ },
/* 409 */
/***/ function(module, exports) {

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = nativeKeysIn;


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(411),
	    isIterateeCall = __webpack_require__(418);

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	module.exports = createAssigner;


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(298),
	    overRest = __webpack_require__(412),
	    setToString = __webpack_require__(414);

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	module.exports = baseRest;


/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(413);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	module.exports = overRest;


/***/ },
/* 413 */
/***/ function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	module.exports = apply;


/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	var baseSetToString = __webpack_require__(415),
	    shortOut = __webpack_require__(417);

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	module.exports = setToString;


/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(416),
	    defineProperty = __webpack_require__(116),
	    identity = __webpack_require__(298);

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	module.exports = baseSetToString;


/***/ },
/* 416 */
/***/ function(module, exports) {

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	module.exports = constant;


/***/ },
/* 417 */
/***/ function(module, exports) {

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	module.exports = shortOut;


/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(97),
	    isArrayLike = __webpack_require__(220),
	    isIndex = __webpack_require__(117),
	    isObject = __webpack_require__(84);

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	module.exports = isIterateeCall;


/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var Tree = (0, _react.createFactory)(__webpack_require__(830).Tree);

	__webpack_require__(420);

	class ManagedTree extends _react.Component {

	  constructor() {
	    super();

	    this.state = {
	      expanded: new Set(),
	      focusedItem: null
	    };

	    var self = this;
	    self.setExpanded = this.setExpanded.bind(this);
	    self.focusItem = this.focusItem.bind(this);
	  }

	  componentWillReceiveProps(nextProps) {
	    var listItems = nextProps.listItems;
	    if (listItems && listItems != this.props.listItems && listItems.length) {
	      this.expandListItems(listItems);
	    }

	    var highlightItems = nextProps.highlightItems;
	    if (highlightItems && highlightItems != this.props.highlightItems && highlightItems.length) {
	      this.highlightItem(highlightItems);
	    }
	  }

	  componentWillMount() {
	    if (this.props.getExpanded) {
	      var _expanded = this.props.getExpanded();
	      this.setState({ expanded: _expanded });
	    }
	  }

	  componentWillUnmount() {
	    if (this.props.setExpanded) {
	      this.props.setExpanded(this.state.expanded);
	    }
	  }

	  setExpanded(item, isExpanded) {
	    var expanded = this.state.expanded;
	    var key = this.props.getKey(item);
	    if (isExpanded) {
	      expanded.add(key);
	    } else {
	      expanded.delete(key);
	    }
	    this.setState({ expanded });

	    if (isExpanded && this.props.onExpand) {
	      this.props.onExpand(item);
	    } else if (!expanded && this.props.onCollapse) {
	      this.props.onCollapse(item);
	    }
	  }

	  expandListItems(listItems) {
	    var expanded = this.state.expanded;
	    listItems.forEach(item => expanded.add(this.props.getKey(item)));
	    this.focusItem(listItems[0]);
	    this.setState({ expanded: expanded });
	  }

	  highlightItem(highlightItems) {
	    var expanded = this.state.expanded;

	    // This file is visible, so we highlight it.
	    if (expanded.has(this.props.getKey(highlightItems[0]))) {
	      this.focusItem(highlightItems[0]);
	    } else {
	      // Look at folders starting from the top-level until finds a
	      // closed folder and highlights this folder
	      var index = highlightItems.reverse().findIndex(item => !expanded.has(this.props.getKey(item)));
	      this.focusItem(highlightItems[index]);
	    }
	  }

	  focusItem(item) {
	    if (!this.props.disabledFocus && this.state.focusedItem !== item) {
	      this.setState({ focusedItem: item });

	      if (this.props.onFocus) {
	        this.props.onFocus(item);
	      }
	    }
	  }

	  render() {
	    var _this = this;

	    var _state = this.state,
	        expanded = _state.expanded,
	        focusedItem = _state.focusedItem;


	    var props = Object.assign({}, this.props, {
	      isExpanded: item => expanded.has(this.props.getKey(item)),
	      focused: focusedItem,

	      onExpand: item => this.setExpanded(item, true),
	      onCollapse: item => this.setExpanded(item, false),
	      onFocus: this.focusItem,

	      renderItem: function () {
	        var _props;

	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }

	        return (_props = _this.props).renderItem.apply(_props, args.concat([{
	          setExpanded: _this.setExpanded
	        }]));
	      }
	    });

	    return Tree(props);
	  }
	}

	ManagedTree.displayName = "ManagedTree";

	ManagedTree.propTypes = Object.assign({}, Tree.propTypes, {
	  getExpanded: _react.PropTypes.func,
	  setExpanded: _react.PropTypes.func
	});

	exports.default = ManagedTree;

/***/ },
/* 420 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 421 */,
/* 422 */,
/* 423 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * Clipboard function taken from
	 * https://dxr.mozilla.org/mozilla-central/source/devtools/shared/platform/content/clipboard.js
	 */
	function copyToTheClipboard(string) {
	  var doCopy = function (e) {
	    e.clipboardData.setData("text/plain", string);
	    e.preventDefault();
	  };

	  document.addEventListener("copy", doCopy);
	  document.execCommand("copy", false, null);
	  document.removeEventListener("copy", doCopy);
	}

	module.exports = { copyToTheClipboard };

/***/ },
/* 424 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 425 */,
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _reactImmutableProptypes = __webpack_require__(150);

	var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

	var _redux = __webpack_require__(3);

	var _reactRedux = __webpack_require__(151);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _debounce = __webpack_require__(651);

	var _debounce2 = _interopRequireDefault(_debounce);

	var _source = __webpack_require__(233);

	var _GutterMenu = __webpack_require__(655);

	var _GutterMenu2 = _interopRequireDefault(_GutterMenu);

	var _EditorMenu = __webpack_require__(656);

	var _EditorMenu2 = _interopRequireDefault(_EditorMenu);

	var _ConditionalPanel = __webpack_require__(711);

	var _devtoolsLaunchpad = __webpack_require__(131);

	var _devtoolsConfig = __webpack_require__(828);

	var _selectors = __webpack_require__(242);

	var _breakpoints = __webpack_require__(236);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _editor = __webpack_require__(257);

	var _scopes = __webpack_require__(732);

	__webpack_require__(716);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var ReactDOM = __webpack_require__(22);


	var Footer = (0, _react.createFactory)(__webpack_require__(427).default);
	var SearchBar = (0, _react.createFactory)(__webpack_require__(433).default);

	var Preview = (0, _react.createFactory)(__webpack_require__(657).default);

	var Breakpoint = (0, _react.createFactory)(__webpack_require__(714).default);
	var HitMarker = (0, _react.createFactory)(__webpack_require__(715).default);

	var cssVars = {
	  searchbarHeight: "var(--editor-searchbar-height)",
	  secondSearchbarHeight: "var(--editor-second-searchbar-height)",
	  footerHeight: "var(--editor-footer-height)"
	};

	class Editor extends _react.Component {

	  constructor() {
	    super();

	    this.cbPanel = null;
	    this.editor = null;
	    this.pendingJumpLine = null;
	    this.lastJumpLine = null;

	    this.state = {
	      searchResults: {
	        index: -1,
	        count: 0
	      },
	      selectedToken: null,
	      selectedExpression: null
	    };

	    var self = this;
	    self.closeConditionalPanel = this.closeConditionalPanel.bind(this);
	    self.onEscape = this.onEscape.bind(this);
	    self.onGutterClick = this.onGutterClick.bind(this);
	    self.onGutterContextMenu = this.onGutterContextMenu.bind(this);
	    self.onScroll = this.onScroll.bind(this);
	    self.onSearchAgain = this.onSearchAgain.bind(this);
	    self.onToggleBreakpoint = this.onToggleBreakpoint.bind(this);
	    self.previewSelectedToken = (0, _debounce2.default)(this.previewSelectedToken.bind(this), 100);
	    self.toggleBreakpoint = this.toggleBreakpoint.bind(this);
	    // eslint-disable-next-line max-len
	    self.toggleBreakpointDisabledStatus = this.toggleBreakpointDisabledStatus.bind(this);
	    self.toggleConditionalPanel = this.toggleConditionalPanel.bind(this);
	    self.updateSearchResults = this.updateSearchResults.bind(this);
	  }

	  componentWillReceiveProps(nextProps) {
	    // This lifecycle method is responsible for updating the editor
	    // text.
	    var sourceText = nextProps.sourceText,
	        selectedLocation = nextProps.selectedLocation;

	    this.clearDebugLine(this.props.selectedFrame);

	    if (!sourceText) {
	      this.showMessage("");
	    } else if (!(0, _editor.isTextForSource)(sourceText)) {
	      this.showMessage(sourceText.get("error") || L10N.getStr("loadingText"));
	    } else if (this.props.sourceText !== sourceText) {
	      this.showSourceText(sourceText, selectedLocation);
	    }

	    this.setDebugLine(nextProps.selectedFrame, selectedLocation);
	    (0, _editor.resizeBreakpointGutter)(this.editor.codeMirror);
	  }

	  setupEditor() {
	    var editor = (0, _editor.createEditor)();

	    // disables the default search shortcuts
	    editor._initShortcuts = () => {};

	    var node = ReactDOM.findDOMNode(this);
	    if (node instanceof HTMLElement) {
	      editor.appendToLocalElement(node.querySelector(".editor-mount"));
	    }

	    var codeMirror = editor.codeMirror;

	    var codeMirrorWrapper = codeMirror.getWrapperElement();

	    (0, _editor.resizeBreakpointGutter)(codeMirror);
	    (0, _devtoolsLaunchpad.debugGlobal)("cm", codeMirror);

	    codeMirror.on("gutterClick", this.onGutterClick);

	    // Set code editor wrapper to be focusable
	    codeMirrorWrapper.tabIndex = 0;
	    codeMirrorWrapper.addEventListener("keydown", e => this.onKeyDown(e));
	    codeMirrorWrapper.addEventListener("mouseover", e => this.onMouseOver(e));

	    if (!(0, _devtoolsConfig.isFirefox)()) {
	      codeMirror.on("gutterContextMenu", (cm, line, eventName, event) => this.onGutterContextMenu(event));

	      codeMirror.on("contextmenu", (cm, event) => this.openMenu(event, cm));
	    } else {
	      codeMirrorWrapper.addEventListener("contextmenu", event => this.openMenu(event, codeMirror));
	    }

	    codeMirror.on("scroll", this.onScroll);

	    return editor;
	  }

	  componentDidMount() {
	    this.cbPanel = null;
	    this.editor = this.setupEditor();

	    var _props = this.props,
	        selectedSource = _props.selectedSource,
	        sourceText = _props.sourceText;
	    var shortcuts = this.context.shortcuts;


	    var searchAgainKey = L10N.getStr("sourceSearch.search.again.key");

	    shortcuts.on("CmdOrCtrl+B", this.onToggleBreakpoint);
	    shortcuts.on("CmdOrCtrl+Shift+B", this.onToggleBreakpoint);
	    shortcuts.on("Esc", this.onEscape);
	    shortcuts.on(`CmdOrCtrl+Shift+${searchAgainKey}`, this.onSearchAgain);
	    shortcuts.on(`CmdOrCtrl+${searchAgainKey}`, this.onSearchAgain);

	    (0, _editor.updateDocument)(this.editor, selectedSource, sourceText);
	  }

	  componentWillUnmount() {
	    this.editor.destroy();
	    this.editor = null;

	    var searchAgainKey = L10N.getStr("sourceSearch.search.again.key");
	    var shortcuts = this.context.shortcuts;
	    shortcuts.off("CmdOrCtrl+B");
	    shortcuts.off("CmdOrCtrl+Shift+B");
	    shortcuts.off(`CmdOrCtrl+Shift+${searchAgainKey}`);
	    shortcuts.off(`CmdOrCtrl+${searchAgainKey}`);
	  }

	  componentDidUpdate(prevProps) {
	    // This is in `componentDidUpdate` so helper functions can expect
	    // `this.props` to be the current props. This lifecycle method is
	    // responsible for updating the editor annotations.
	    var selectedLocation = this.props.selectedLocation;

	    // If the location is different and a new line is requested,
	    // update the pending jump line. Note that if jumping to a line in
	    // a source where the text hasn't been loaded yet, we will set the
	    // line here but not jump until rendering the actual source.

	    if (prevProps.selectedLocation !== selectedLocation) {
	      if (selectedLocation && selectedLocation.line != undefined) {
	        this.pendingJumpLine = selectedLocation.line;
	      } else {
	        this.pendingJumpLine = null;
	      }
	    }

	    // Only update and jump around in real source texts. This will
	    // keep the jump state around until the real source text is
	    // loaded.
	    if (this.props.sourceText && (0, _editor.isTextForSource)(this.props.sourceText)) {
	      this.highlightLine();
	    }
	  }

	  onToggleBreakpoint(key, e) {
	    e.preventDefault();
	    var codeMirror = this.editor.codeMirror;

	    var line = (0, _editor.getCursorLine)(codeMirror);

	    if (e.shiftKey) {
	      this.toggleConditionalPanel(line);
	    } else {
	      this.toggleBreakpoint(line);
	    }
	  }

	  onKeyDown(e) {
	    var codeMirror = this.editor.codeMirror;
	    var key = e.key,
	        target = e.target;

	    var codeWrapper = codeMirror.getWrapperElement();
	    var textArea = codeWrapper.querySelector("textArea");

	    if (key === "Escape" && target == textArea) {
	      e.stopPropagation();
	      e.preventDefault();
	      codeWrapper.focus();
	    } else if (key === "Enter" && target == codeWrapper) {
	      e.preventDefault();
	      // Focus into editor's text area
	      textArea.focus();
	    }
	  }

	  /*
	   * The default Esc command is overridden in the CodeMirror keymap to allow
	   * the Esc keypress event to be catched by the toolbox and trigger the
	   * split console. Restore it here, but preventDefault if and only if there
	   * is a multiselection.
	   */
	  onEscape(key, e) {
	    var codeMirror = this.editor.codeMirror;

	    if (codeMirror.listSelections().length > 1) {
	      codeMirror.execCommand("singleSelection");
	      e.preventDefault();
	    }
	  }

	  onScroll(e) {
	    return this.setState({ selectedToken: null, selectedExpression: null });
	  }

	  onMouseOver(e) {
	    this.previewSelectedToken(e);
	  }

	  onSearchAgain(_, e) {
	    var _props2 = this.props,
	        query = _props2.query,
	        searchModifiers = _props2.searchModifiers;
	    var codeMirror = this.editor.editor.codeMirror;

	    var ctx = { ed: this.editor, cm: codeMirror };

	    if (!searchModifiers) {
	      return;
	    }

	    var direction = e.shiftKey ? "prev" : "next";
	    (0, _editor.traverseResults)(e, ctx, query, direction, searchModifiers.toJS());
	  }

	  previewSelectedToken(e) {
	    var _this = this;

	    return _asyncToGenerator(function* () {
	      var _props3 = _this.props,
	          selectedFrame = _props3.selectedFrame,
	          selectedSource = _props3.selectedSource,
	          pauseData = _props3.pauseData,
	          sourceText = _props3.sourceText,
	          addExpression = _props3.addExpression;
	      var selectedToken = _this.state.selectedToken;

	      var token = e.target;

	      if (!selectedFrame || !sourceText || !(0, _devtoolsConfig.isEnabled)("editorPreview") || !selectedSource || selectedFrame.location.sourceId !== selectedSource.get("id")) {
	        return;
	      }

	      if (selectedToken) {
	        selectedToken.classList.remove("selected-token");
	        _this.setState({ selectedToken: null, selectedExpression: null });
	      }

	      var _ref = yield (0, _editor.resolveToken)(_this.editor.codeMirror, token, sourceText, selectedFrame),
	          expression = _ref.expression,
	          inScope = _ref.inScope;

	      if (!inScope) {
	        return;
	      }

	      var variables = (0, _scopes.getVisibleVariablesFromScope)(pauseData, selectedFrame);

	      if (expression) {
	        addExpression(expression.value, { visible: false });
	      }

	      var displayedExpression = (0, _editor.previewExpression)({
	        expression: expression,
	        variables,
	        selectedFrame,
	        tokenText: token.textContent
	      });

	      if (displayedExpression) {
	        _this.setState({
	          selectedToken: token,
	          selectedExpression: displayedExpression
	        });
	      }
	    })();
	  }

	  openMenu(event, codeMirror) {
	    var _props4 = this.props,
	        selectedSource = _props4.selectedSource,
	        selectedLocation = _props4.selectedLocation,
	        showSource = _props4.showSource,
	        jumpToMappedLocation = _props4.jumpToMappedLocation,
	        addExpression = _props4.addExpression,
	        toggleBlackBox = _props4.toggleBlackBox;


	    return (0, _EditorMenu2.default)({
	      codeMirror,
	      event,
	      selectedLocation,
	      selectedSource,
	      showSource,
	      jumpToMappedLocation,
	      addExpression,
	      toggleBlackBox,
	      onGutterContextMenu: this.onGutterContextMenu
	    });
	  }

	  updateSearchResults(_ref2) {
	    var count = _ref2.count,
	        _ref2$index = _ref2.index,
	        index = _ref2$index === undefined ? -1 : _ref2$index;

	    this.setState({ searchResults: { count, index } });
	  }

	  onGutterClick(cm, line, gutter, ev) {
	    var selectedSource = this.props.selectedSource;

	    // ignore right clicks in the gutter

	    if (ev.which === 3 || selectedSource && selectedSource.get("isBlackBoxed")) {
	      return;
	    }

	    if (this.isCbPanelOpen()) {
	      return this.closeConditionalPanel(line);
	    }

	    if (gutter !== "CodeMirror-foldgutter") {
	      this.toggleBreakpoint(line);
	    }
	  }

	  onGutterContextMenu(event) {
	    var selectedSource = this.props.selectedSource;


	    if (selectedSource && selectedSource.get("isBlackBoxed")) {
	      event.preventDefault();
	      return;
	    }

	    var line = this.editor.codeMirror.lineAtHeight(event.clientY);
	    var bp = (0, _editor.breakpointAtLine)(this.props.breakpoints, line);
	    (0, _GutterMenu2.default)({
	      event,
	      line,
	      bp,
	      toggleBreakpoint: this.toggleBreakpoint,
	      showConditionalPanel: this.toggleConditionalPanel,
	      toggleBreakpointDisabledStatus: this.toggleBreakpointDisabledStatus,
	      isCbPanelOpen: this.isCbPanelOpen(),
	      closeConditionalPanel: this.closeConditionalPanel
	    });
	  }

	  toggleConditionalPanel(line) {
	    if (this.isCbPanelOpen()) {
	      return this.closeConditionalPanel();
	    }

	    var _props5 = this.props,
	        selectedLocation = _props5.selectedLocation,
	        setBreakpointCondition = _props5.setBreakpointCondition,
	        breakpoints = _props5.breakpoints;

	    var sourceId = selectedLocation ? selectedLocation.sourceId : "";

	    var bp = (0, _editor.breakpointAtLine)(breakpoints, line);
	    var location = { sourceId, line: line + 1 };
	    var condition = bp ? bp.condition : "";

	    var setBreakpoint = value => setBreakpointCondition(location, {
	      condition: value,
	      getTextForLine: l => (0, _editor.getTextForLine)(this.editor.codeMirror, l)
	    });

	    var panel = (0, _ConditionalPanel.renderConditionalPanel)({
	      condition,
	      setBreakpoint,
	      closePanel: this.closeConditionalPanel
	    });

	    this.cbPanel = this.editor.codeMirror.addLineWidget(line, panel, {
	      coverGutter: true,
	      noHScroll: true
	    });
	    this.cbPanel.node.querySelector("input").focus();
	  }

	  closeConditionalPanel() {
	    this.cbPanel.clear();
	    this.cbPanel = null;
	  }

	  isCbPanelOpen() {
	    return !!this.cbPanel;
	  }

	  toggleBreakpoint(line) {
	    var _props6 = this.props,
	        selectedSource = _props6.selectedSource,
	        selectedLocation = _props6.selectedLocation,
	        breakpoints = _props6.breakpoints,
	        addBreakpoint = _props6.addBreakpoint,
	        removeBreakpoint = _props6.removeBreakpoint;

	    var bp = (0, _editor.breakpointAtLine)(breakpoints, line);

	    if (bp && bp.loading || !selectedLocation || !selectedSource) {
	      return;
	    }

	    var sourceId = selectedLocation.sourceId;


	    if (bp) {
	      removeBreakpoint({
	        sourceId: sourceId,
	        line: line + 1
	      });
	    } else {
	      addBreakpoint({
	        sourceId: sourceId,
	        sourceUrl: selectedSource.get("url"),
	        line: line + 1
	      },
	      // Pass in a function to get line text because the breakpoint
	      // may slide and it needs to compute the value at the new
	      // line.
	      { getTextForLine: l => (0, _editor.getTextForLine)(this.editor.codeMirror, l) });
	    }
	  }

	  toggleBreakpointDisabledStatus(line) {
	    var bp = (0, _editor.breakpointAtLine)(this.props.breakpoints, line);
	    var selectedLocation = this.props.selectedLocation;


	    if (bp && bp.loading || !selectedLocation) {
	      return;
	    }

	    var sourceId = selectedLocation.sourceId;


	    if (!bp) {
	      throw new Error("attempt to disable breakpoint that does not exist");
	    }

	    if (!bp.disabled) {
	      this.props.disableBreakpoint({
	        sourceId: sourceId,
	        line: line + 1
	      });
	    } else {
	      this.props.enableBreakpoint({
	        sourceId: sourceId,
	        line: line + 1
	      });
	    }
	  }

	  clearDebugLine(selectedFrame) {
	    if (selectedFrame) {
	      var line = selectedFrame.location.line;
	      this.editor.codeMirror.removeLineClass(line - 1, "line", "debug-line");
	    }
	  }

	  setDebugLine(selectedFrame, selectedLocation) {
	    if (selectedFrame && selectedLocation && selectedFrame.location.sourceId === selectedLocation.sourceId) {
	      var line = selectedFrame.location.line;
	      this.editor.codeMirror.addLineClass(line - 1, "line", "debug-line");
	    }
	  }

	  // If the location has changed and a specific line is requested,
	  // move to that line and flash it.
	  highlightLine() {
	    if (!this.pendingJumpLine) {
	      return;
	    }

	    // Make sure to clean up after ourselves. Not only does this
	    // cancel any existing animation, but it avoids it from
	    // happening ever again (in case CodeMirror re-applies the
	    // class, etc).
	    if (this.lastJumpLine) {
	      (0, _editor.clearLineClass)(this.editor.codeMirror, "highlight-line");
	    }

	    var line = this.pendingJumpLine;
	    this.editor.alignLine(line);

	    // We only want to do the flashing animation if it's not a debug
	    // line, which has it's own styling.
	    // Also, if it the first time the debugger is being loaded, we don't want
	    // to flash the previously saved selected line.
	    if (this.lastJumpLine && (!this.props.selectedFrame || this.props.selectedFrame.location.line !== line)) {
	      this.editor.codeMirror.addLineClass(line - 1, "line", "highlight-line");
	    }

	    this.lastJumpLine = line;
	    this.pendingJumpLine = null;
	  }

	  setText(text) {
	    if (!text || !this.editor) {
	      return;
	    }

	    this.editor.setText(text);
	  }

	  showMessage(msg) {
	    this.editor.replaceDocument(this.editor.createDocument());
	    this.setText(msg);
	    this.editor.setMode({ name: "text" });
	  }

	  /**
	   * Handle getting the source document or creating a new
	   * document with the correct mode and text.
	   *
	   */
	  showSourceText(sourceText, selectedLocation) {
	    if (!selectedLocation) {
	      return;
	    }

	    var doc = (0, _editor.getDocument)(selectedLocation.sourceId);
	    if (doc) {
	      this.editor.replaceDocument(doc);
	      return doc;
	    }

	    doc = this.editor.createDocument();
	    (0, _editor.setDocument)(selectedLocation.sourceId, doc);
	    this.editor.replaceDocument(doc);

	    this.setText(sourceText.get("text"));
	    this.editor.setMode((0, _source.getMode)(sourceText.toJS()));
	  }

	  renderBreakpoints() {
	    var _props7 = this.props,
	        breakpoints = _props7.breakpoints,
	        sourceText = _props7.sourceText,
	        selectedSource = _props7.selectedSource;

	    var isLoading = sourceText && sourceText.get("loading");

	    if (isLoading || !breakpoints || selectedSource && selectedSource.get("isBlackBoxed")) {
	      return;
	    }

	    return breakpoints.valueSeq().map(bp => Breakpoint({
	      key: (0, _breakpoints.makeLocationId)(bp.location),
	      breakpoint: bp,
	      editor: this.editor && this.editor.codeMirror
	    }));
	  }

	  renderHitCounts() {
	    var _props8 = this.props,
	        hitCount = _props8.hitCount,
	        sourceText = _props8.sourceText;

	    var isLoading = sourceText && sourceText.get("loading");

	    if (isLoading || !hitCount) {
	      return;
	    }

	    return hitCount.filter(marker => marker.get("count") > 0).map(marker => HitMarker({
	      key: marker.get("line"),
	      hitData: marker.toJS(),
	      editor: this.editor && this.editor.codeMirror
	    }));
	  }

	  getInlineEditorStyles() {
	    var _props9 = this.props,
	        selectedSource = _props9.selectedSource,
	        horizontal = _props9.horizontal,
	        searchOn = _props9.searchOn;


	    var subtractions = [];

	    if ((0, _editor.shouldShowFooter)(selectedSource, horizontal)) {
	      subtractions.push(cssVars.footerHeight);
	    }

	    if (searchOn) {
	      subtractions.push(cssVars.searchbarHeight);

	      var secondSearchBarOn = (0, _devtoolsConfig.isEnabled)("searchModifiers") && (0, _devtoolsConfig.isEnabled)("symbolSearch");

	      if (secondSearchBarOn) {
	        subtractions.push(cssVars.secondSearchbarHeight);
	      }
	    }

	    return {
	      height: subtractions.length === 0 ? "100%" : `calc(100% - ${subtractions.join(" - ")})`
	    };
	  }

	  renderPreview() {
	    var _state = this.state,
	        selectedToken = _state.selectedToken,
	        selectedExpression = _state.selectedExpression;
	    var _props10 = this.props,
	        selectedFrame = _props10.selectedFrame,
	        sourceText = _props10.sourceText;


	    if (!this.editor || !sourceText) {
	      return null;
	    }

	    if (!(0, _devtoolsConfig.isEnabled)("editorPreview") || !selectedToken || !selectedFrame || !selectedExpression) {
	      return;
	    }

	    var token = selectedToken.textContent;
	    selectedToken.classList.add("selected-token");

	    var value = (0, _editor.getExpressionValue)(selectedExpression, {
	      getExpression: this.props.getExpression
	    });

	    if (!value) {
	      return;
	    }

	    return Preview({
	      value,
	      expression: token,
	      popoverTarget: selectedToken,
	      onClose: () => {
	        selectedToken.classList.remove("selected-token");
	        this.setState({
	          selectedToken: null,
	          selectedExpression: null
	        });
	      }
	    });
	  }

	  render() {
	    var _props11 = this.props,
	        sourceText = _props11.sourceText,
	        selectSource = _props11.selectSource,
	        selectedSource = _props11.selectedSource,
	        coverageOn = _props11.coverageOn,
	        horizontal = _props11.horizontal;
	    var searchResults = this.state.searchResults;


	    return _react.DOM.div({
	      className: (0, _classnames2.default)("editor-wrapper", { "coverage-on": coverageOn })
	    }, SearchBar({
	      editor: this.editor,
	      selectSource,
	      selectedSource,
	      sourceText,
	      searchResults,
	      updateSearchResults: this.updateSearchResults
	    }), _react.DOM.div({
	      className: "editor-mount devtools-monospace",
	      style: this.getInlineEditorStyles()
	    }), this.renderBreakpoints(), this.renderHitCounts(), Footer({ editor: this.editor, horizontal }), this.renderPreview());
	  }
	}

	Editor.displayName = "Editor";

	Editor.propTypes = {
	  breakpoints: _reactImmutableProptypes2.default.map.isRequired,
	  hitCount: _react.PropTypes.object,
	  selectedLocation: _react.PropTypes.object,
	  selectedSource: _reactImmutableProptypes2.default.map,
	  sourceText: _reactImmutableProptypes2.default.map,
	  searchOn: _react.PropTypes.bool,
	  addBreakpoint: _react.PropTypes.func.isRequired,
	  disableBreakpoint: _react.PropTypes.func.isRequired,
	  enableBreakpoint: _react.PropTypes.func.isRequired,
	  removeBreakpoint: _react.PropTypes.func.isRequired,
	  setBreakpointCondition: _react.PropTypes.func.isRequired,
	  selectSource: _react.PropTypes.func,
	  jumpToMappedLocation: _react.PropTypes.func,
	  toggleBlackBox: _react.PropTypes.func,
	  showSource: _react.PropTypes.func,
	  coverageOn: _react.PropTypes.bool,
	  pauseData: _reactImmutableProptypes2.default.map,
	  selectedFrame: _react.PropTypes.object,
	  getExpression: _react.PropTypes.func.isRequired,
	  addExpression: _react.PropTypes.func.isRequired,
	  horizontal: _react.PropTypes.bool,
	  query: _react.PropTypes.string.isRequired,
	  searchModifiers: _reactImmutableProptypes2.default.recordOf({
	    caseSensitive: _react.PropTypes.bool.isRequired,
	    regexMatch: _react.PropTypes.bool.isRequired,
	    wholeWord: _react.PropTypes.bool.isRequired
	  }).isRequired
	};

	Editor.contextTypes = {
	  shortcuts: _react.PropTypes.object
	};

	exports.default = (0, _reactRedux.connect)(state => {
	  var selectedLocation = (0, _selectors.getSelectedLocation)(state);
	  var sourceId = selectedLocation && selectedLocation.sourceId;
	  var selectedSource = (0, _selectors.getSelectedSource)(state);

	  return {
	    selectedLocation,
	    selectedSource,
	    searchOn: (0, _selectors.getFileSearchState)(state),
	    sourceText: (0, _selectors.getSourceText)(state, sourceId),
	    loadedObjects: (0, _selectors.getLoadedObjects)(state),
	    breakpoints: (0, _selectors.getBreakpointsForSource)(state, sourceId || ""),
	    hitCount: (0, _selectors.getHitCountForSource)(state, sourceId),
	    selectedFrame: (0, _selectors.getSelectedFrame)(state),
	    getExpression: _selectors.getExpression.bind(null, state),
	    pauseData: (0, _selectors.getPause)(state),
	    coverageOn: (0, _selectors.getCoverageEnabled)(state),
	    query: (0, _selectors.getFileSearchQueryState)(state),
	    searchModifiers: (0, _selectors.getFileSearchModifierState)(state)
	  };
	}, dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(Editor);

/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _reactRedux = __webpack_require__(151);

	var _redux = __webpack_require__(3);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	var _reactImmutableProptypes = __webpack_require__(150);

	var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _devtoolsConfig = __webpack_require__(828);

	var _source = __webpack_require__(233);

	var _editor = __webpack_require__(257);

	var _PaneToggle = __webpack_require__(428);

	var _PaneToggle2 = _interopRequireDefault(_PaneToggle);

	__webpack_require__(431);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var PaneToggleButton = _react2.default.createFactory(_PaneToggle2.default);

	class SourceFooter extends _react.Component {
	  prettyPrintButton() {
	    var _props = this.props,
	        selectedSource = _props.selectedSource,
	        sourceText = _props.sourceText,
	        togglePrettyPrint = _props.togglePrettyPrint;

	    var sourceLoaded = selectedSource && sourceText && !sourceText.get("loading");

	    if (!(0, _editor.shouldShowPrettyPrint)(selectedSource)) {
	      return;
	    }

	    var tooltip = L10N.getStr("sourceTabs.prettyPrint");
	    var type = "prettyPrint";

	    return _react.DOM.button({
	      onClick: () => togglePrettyPrint(selectedSource.get("id")),
	      className: (0, _classnames2.default)("action", type, {
	        active: sourceLoaded,
	        pretty: (0, _source.isPretty)(selectedSource.toJS())
	      }),
	      key: type,
	      title: tooltip,
	      "aria-label": tooltip
	    }, (0, _Svg2.default)(type));
	  }

	  blackBoxButton() {
	    var _props2 = this.props,
	        selectedSource = _props2.selectedSource,
	        sourceText = _props2.sourceText,
	        toggleBlackBox = _props2.toggleBlackBox;

	    var sourceLoaded = selectedSource && sourceText && !sourceText.get("loading");

	    var blackboxed = selectedSource.get("isBlackBoxed");

	    if (!(0, _devtoolsConfig.isEnabled)("blackbox")) {
	      return;
	    }

	    var tooltip = L10N.getStr("sourceFooter.blackbox");
	    var type = "black-box";

	    return _react.DOM.button({
	      onClick: () => toggleBlackBox(selectedSource.toJS()),
	      className: (0, _classnames2.default)("action", type, {
	        active: sourceLoaded,
	        blackboxed
	      }),
	      key: type,
	      title: tooltip,
	      "aria-label": tooltip
	    }, (0, _Svg2.default)("blackBox"));
	  }

	  blackBoxSummary() {
	    var selectedSource = this.props.selectedSource;

	    var blackboxed = selectedSource.get("isBlackBoxed");

	    if (!blackboxed) {
	      return;
	    }

	    return _react.DOM.span({ className: "blackbox-summary" }, L10N.getStr("sourceFooter.blackboxed"));
	  }

	  coverageButton() {
	    var recordCoverage = this.props.recordCoverage;


	    if (!(0, _devtoolsConfig.isEnabled)("codeCoverage")) {
	      return;
	    }

	    return _react.DOM.button({
	      className: "coverage action",
	      title: "Code Coverage",
	      onClick: () => recordCoverage(),
	      "aria-label": "Code Coverage"
	    }, "C");
	  }

	  renderToggleButton() {
	    if (this.props.horizontal) {
	      return;
	    }

	    return PaneToggleButton({
	      position: "end",
	      collapsed: !this.props.endPanelCollapsed,
	      horizontal: this.props.horizontal,
	      handleClick: this.props.togglePaneCollapse
	    });
	  }

	  renderCommands() {
	    var selectedSource = this.props.selectedSource;

	    if (!(0, _editor.shouldShowPrettyPrint)(selectedSource)) {
	      return null;
	    }

	    return _react.DOM.div({ className: "commands" }, this.prettyPrintButton(), this.blackBoxButton(), this.blackBoxSummary(), this.coverageButton());
	  }

	  render() {
	    var _props3 = this.props,
	        selectedSource = _props3.selectedSource,
	        horizontal = _props3.horizontal;


	    if (!(0, _editor.shouldShowFooter)(selectedSource, horizontal)) {
	      return null;
	    }

	    return _react.DOM.div({ className: "source-footer" }, this.renderCommands(), this.renderToggleButton());
	  }
	}

	SourceFooter.propTypes = {
	  selectedSource: _reactImmutableProptypes2.default.map,
	  togglePrettyPrint: _react.PropTypes.func,
	  toggleBlackBox: _react.PropTypes.func,
	  recordCoverage: _react.PropTypes.func,
	  sourceText: _reactImmutableProptypes2.default.map,
	  selectSource: _react.PropTypes.func,
	  editor: _react.PropTypes.object,
	  endPanelCollapsed: _react.PropTypes.bool,
	  togglePaneCollapse: _react.PropTypes.func,
	  horizontal: _react.PropTypes.bool
	};

	SourceFooter.displayName = "SourceFooter";

	exports.default = (0, _reactRedux.connect)(state => {
	  var selectedSource = (0, _selectors.getSelectedSource)(state);
	  var selectedId = selectedSource && selectedSource.get("id");
	  return {
	    selectedSource,
	    sourceText: (0, _selectors.getSourceText)(state, selectedId),
	    prettySource: (0, _selectors.getPrettySource)(state, selectedId),
	    endPanelCollapsed: (0, _selectors.getPaneCollapse)(state, "end")
	  };
	}, dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(SourceFooter);

/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	__webpack_require__(429);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class PaneToggleButton extends _react.Component {
	  shouldComponentUpdate(nextProps) {
	    var _props = this.props,
	        collapsed = _props.collapsed,
	        horizontal = _props.horizontal;


	    return horizontal !== nextProps.horizontal || collapsed !== nextProps.collapsed;
	  }

	  render() {
	    var _props2 = this.props,
	        position = _props2.position,
	        collapsed = _props2.collapsed,
	        horizontal = _props2.horizontal,
	        handleClick = _props2.handleClick;

	    var title = !collapsed ? L10N.getStr("expandPanes") : L10N.getStr("collapsePanes");

	    return _react.DOM.div({
	      className: (0, _classnames2.default)(`toggle-button-${position}`, {
	        collapsed,
	        vertical: horizontal != null ? !horizontal : false
	      }),
	      onClick: () => handleClick(position, collapsed),
	      title
	    }, (0, _Svg2.default)("togglePanes"));
	  }
	}

	PaneToggleButton.propTypes = {
	  position: _react.PropTypes.string.isRequired,
	  collapsed: _react.PropTypes.bool.isRequired,
	  horizontal: _react.PropTypes.bool,
	  handleClick: _react.PropTypes.func.isRequired
	};

	PaneToggleButton.displayName = "PaneToggleButton";

	exports.default = PaneToggleButton;

/***/ },
/* 429 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 430 */,
/* 431 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 432 */,
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _reactRedux = __webpack_require__(151);

	var _redux = __webpack_require__(3);

	var _devtoolsConfig = __webpack_require__(828);

	var _fuzzaldrinPlus = __webpack_require__(161);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	var _editor = __webpack_require__(257);

	var _parser = __webpack_require__(827);

	var _resultList = __webpack_require__(343);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _debounce = __webpack_require__(651);

	var _debounce2 = _interopRequireDefault(_debounce);

	var _reactImmutableProptypes = __webpack_require__(150);

	var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

	__webpack_require__(653);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var _require = __webpack_require__(22),
	    findDOMNode = _require.findDOMNode;

	var SearchInput = (0, _react.createFactory)(__webpack_require__(377).default);
	var ResultList = (0, _react.createFactory)(__webpack_require__(383).default);


	function getShortcuts() {
	  var searchAgainKey = L10N.getStr("sourceSearch.search.again.key");
	  var fnSearchKey = L10N.getStr("symbolSearch.search.key");

	  return {
	    shiftSearchAgainShortcut: `CmdOrCtrl+Shift+${searchAgainKey}`,
	    searchAgainShortcut: `CmdOrCtrl+${searchAgainKey}`,
	    symbolSearchShortcut: `CmdOrCtrl+Shift+${fnSearchKey}`,
	    searchShortcut: `CmdOrCtrl+${L10N.getStr("sourceSearch.search.key")}`
	  };
	}

	class SearchBar extends _react.Component {

	  constructor(props) {
	    super(props);
	    this.state = {
	      symbolSearchEnabled: false,
	      selectedSymbolType: "functions",
	      symbolSearchResults: [],
	      selectedResultIndex: 0,
	      count: 0,
	      index: -1
	    };

	    var self = this;
	    self.onEscape = this.onEscape.bind(this);
	    self.clearSearch = this.clearSearch.bind(this);
	    self.closeSearch = this.closeSearch.bind(this);
	    self.toggleSearch = this.toggleSearch.bind(this);
	    self.toggleSymbolSearch = this.toggleSymbolSearch.bind(this);
	    self.setSearchValue = this.setSearchValue.bind(this);
	    self.selectSearchInput = this.selectSearchInput.bind(this);
	    self.searchInput = this.searchInput.bind(this);
	    self.updateSymbolSearchResults = this.updateSymbolSearchResults.bind(this);
	    self.doSearch = this.doSearch.bind(this);
	    self.searchContents = this.searchContents.bind(this);
	    self.traverseSymbolResults = this.traverseSymbolResults.bind(this);
	    self.traverseCodeResults = this.traverseCodeResults.bind(this);
	    self.traverseResults = this.traverseResults.bind(this);
	    self.selectResultItem = this.selectResultItem.bind(this);
	    self.onSelectResultItem = this.onSelectResultItem.bind(this);
	    self.onChange = this.onChange.bind(this);
	    self.onKeyUp = this.onKeyUp.bind(this);
	    self.onKeyDown = this.onKeyDown.bind(this);
	    self.buildSummaryMsg = this.buildSummaryMsg.bind(this);
	    self.buildPlaceHolder = this.buildPlaceHolder.bind(this);
	    self.renderSearchModifiers = this.renderSearchModifiers.bind(this);
	    self.renderSearchTypeToggle = this.renderSearchTypeToggle.bind(this);
	    self.renderBottomBar = this.renderBottomBar.bind(this);
	    self.renderResults = this.renderResults.bind(this);
	  }

	  componentWillUnmount() {
	    var shortcuts = this.context.shortcuts;

	    var _getShortcuts = getShortcuts(),
	        searchShortcut = _getShortcuts.searchShortcut,
	        searchAgainShortcut = _getShortcuts.searchAgainShortcut,
	        shiftSearchAgainShortcut = _getShortcuts.shiftSearchAgainShortcut,
	        symbolSearchShortcut = _getShortcuts.symbolSearchShortcut;

	    shortcuts.off(searchShortcut);
	    shortcuts.off("Escape");
	    shortcuts.off(searchAgainShortcut);
	    shortcuts.off(shiftSearchAgainShortcut);
	    shortcuts.off(symbolSearchShortcut);
	  }

	  componentDidMount() {
	    // overwrite searchContents with a debounced version to reduce the
	    // frequency of queries which improves perf on large files
	    // $FlowIgnore
	    this.searchContents = (0, _debounce2.default)(this.searchContents, 100);

	    var shortcuts = this.context.shortcuts;

	    var _getShortcuts2 = getShortcuts(),
	        searchShortcut = _getShortcuts2.searchShortcut,
	        searchAgainShortcut = _getShortcuts2.searchAgainShortcut,
	        shiftSearchAgainShortcut = _getShortcuts2.shiftSearchAgainShortcut,
	        symbolSearchShortcut = _getShortcuts2.symbolSearchShortcut;

	    shortcuts.on(searchShortcut, (_, e) => this.toggleSearch(e));
	    shortcuts.on("Escape", (_, e) => this.onEscape(e));

	    shortcuts.on(shiftSearchAgainShortcut, (_, e) => this.traverseResults(e, true));

	    shortcuts.on(searchAgainShortcut, (_, e) => this.traverseResults(e, false));

	    if ((0, _devtoolsConfig.isEnabled)("symbolSearch")) {
	      shortcuts.on(symbolSearchShortcut, (_, e) => this.toggleSymbolSearch(e, {
	        toggle: false,
	        searchType: "functions"
	      }));
	    }
	  }

	  componentDidUpdate(prevProps, prevState) {
	    var _props = this.props,
	        sourceText = _props.sourceText,
	        selectedSource = _props.selectedSource,
	        query = _props.query,
	        modifiers = _props.modifiers;

	    var searchInput = this.searchInput();

	    if (searchInput) {
	      searchInput.focus();
	    }

	    if (this.refs.resultList && this.refs.resultList.refs) {
	      (0, _resultList.scrollList)(this.refs.resultList.refs, this.state.selectedResultIndex);
	    }

	    var hasLoaded = sourceText && !sourceText.get("loading");
	    var wasLoading = prevProps.sourceText && prevProps.sourceText.get("loading");

	    var doneLoading = wasLoading && hasLoaded;
	    var changedFiles = selectedSource != prevProps.selectedSource && hasLoaded;
	    var modifiersUpdated = modifiers && !modifiers.equals(prevProps.modifiers);

	    var isOpen = this.props.searchOn || this.state.symbolSearchEnabled;
	    var _state = this.state,
	        selectedSymbolType = _state.selectedSymbolType,
	        symbolSearchEnabled = _state.symbolSearchEnabled;

	    var changedSearchType = selectedSymbolType != prevState.selectedSymbolType || symbolSearchEnabled != prevState.symbolSearchEnabled;

	    if (isOpen && (doneLoading || changedFiles || modifiersUpdated || changedSearchType)) {
	      this.doSearch(query);
	    }
	  }

	  onEscape(e) {
	    this.closeSearch(e);
	  }

	  clearSearch() {
	    var _props2 = this.props,
	        ed = _props2.editor,
	        query = _props2.query,
	        modifiers = _props2.modifiers;

	    if (ed && modifiers) {
	      var ctx = { ed, cm: ed.codeMirror };
	      (0, _editor.removeOverlay)(ctx, query, modifiers.toJS());
	    }
	  }

	  closeSearch(e) {
	    var ed = this.props.editor;


	    if (this.props.searchOn && ed) {
	      this.clearSearch();
	      this.props.toggleFileSearch(false);
	      this.setState({
	        symbolSearchEnabled: false,
	        selectedSymbolType: "functions"
	      });
	      e.stopPropagation();
	      e.preventDefault();
	    }
	  }

	  toggleSearch(e) {
	    e.stopPropagation();
	    e.preventDefault();
	    var editor = this.props.editor;


	    if (!this.props.searchOn) {
	      this.props.toggleFileSearch();
	    }

	    if (this.state.symbolSearchEnabled) {
	      this.clearSearch();
	      this.setState({
	        symbolSearchEnabled: false,
	        selectedSymbolType: "functions"
	      });
	    }

	    if (this.props.searchOn && editor) {
	      var selection = editor.codeMirror.getSelection();
	      this.setSearchValue(selection);
	      if (selection !== "") {
	        this.doSearch(selection);
	      }
	      this.selectSearchInput();
	    }
	  }

	  toggleSymbolSearch(e) {
	    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        toggle = _ref.toggle,
	        searchType = _ref.searchType;

	    var sourceText = this.props.sourceText;


	    if (e) {
	      e.preventDefault();
	      e.stopPropagation();
	    }

	    if (!sourceText) {
	      return;
	    }

	    if (!this.props.searchOn) {
	      this.props.toggleFileSearch();
	    }

	    if (this.state.symbolSearchEnabled) {
	      if (toggle) {
	        this.setState({ symbolSearchEnabled: false });
	      } else {
	        this.setState({ selectedSymbolType: searchType });
	      }
	      return;
	    }

	    if (this.props.selectedSource) {
	      this.clearSearch();
	      this.setState({
	        symbolSearchEnabled: true,
	        selectedSymbolType: searchType
	      });
	    }
	  }

	  setSearchValue(value) {
	    var searchInput = this.searchInput();
	    if (value == "" || !searchInput) {
	      return;
	    }

	    searchInput.value = value;
	  }

	  selectSearchInput() {
	    var searchInput = this.searchInput();
	    if (searchInput) {
	      searchInput.setSelectionRange(0, searchInput.value.length);
	    }
	  }

	  searchInput() {
	    var node = findDOMNode(this);
	    if (node instanceof HTMLElement) {
	      var input = node.querySelector("input");
	      if (input instanceof HTMLInputElement) {
	        return input;
	      }
	    }
	    return null;
	  }

	  updateSymbolSearchResults(query) {
	    var _this = this;

	    return _asyncToGenerator(function* () {
	      var _props3 = _this.props,
	          sourceText = _props3.sourceText,
	          updateSearchResults = _props3.updateSearchResults;
	      var selectedSymbolType = _this.state.selectedSymbolType;


	      if (query == "" || !sourceText) {
	        return;
	      }

	      var symbolDeclarations = yield (0, _parser.getSymbols)(sourceText.toJS());
	      var symbolSearchResults = (0, _fuzzaldrinPlus.filter)(symbolDeclarations[selectedSymbolType], query, { key: "value" });

	      updateSearchResults({ count: symbolSearchResults.length });
	      return _this.setState({ symbolSearchResults });
	    })();
	  }

	  doSearch(query) {
	    var _this2 = this;

	    return _asyncToGenerator(function* () {
	      var _props4 = _this2.props,
	          sourceText = _props4.sourceText,
	          setFileSearchQuery = _props4.setFileSearchQuery,
	          ed = _props4.editor;

	      if (!sourceText || !sourceText.get("text")) {
	        return;
	      }

	      setFileSearchQuery(query);

	      if (_this2.state.symbolSearchEnabled) {
	        return yield _this2.updateSymbolSearchResults(query);
	      } else if (ed) {
	        _this2.searchContents(query);
	      }
	    })();
	  }

	  searchContents(query) {
	    var _props5 = this.props,
	        sourceText = _props5.sourceText,
	        modifiers = _props5.modifiers,
	        ed = _props5.editor,
	        index = _props5.searchResults.index;


	    if (!ed || !sourceText || !sourceText.get("text") || !modifiers) {
	      return;
	    }

	    var ctx = { ed, cm: ed.codeMirror };

	    var newCount = (0, _editor.countMatches)(query, sourceText.get("text"), modifiers.toJS());

	    if (index == -1) {
	      (0, _editor.clearIndex)(ctx, query, modifiers.toJS());
	    }

	    var newIndex = (0, _editor.find)(ctx, query, true, modifiers.toJS());
	    this.props.updateSearchResults({
	      count: newCount,
	      index: newIndex
	    });
	  }

	  traverseSymbolResults(rev) {
	    var _state2 = this.state,
	        symbolSearchResults = _state2.symbolSearchResults,
	        selectedResultIndex = _state2.selectedResultIndex;

	    var searchResults = symbolSearchResults;
	    var resultCount = searchResults.length;

	    if (rev) {
	      var nextResultIndex = Math.max(0, selectedResultIndex - 1);

	      if (selectedResultIndex === 0) {
	        nextResultIndex = resultCount - 1;
	      }
	      this.setState({ selectedResultIndex: nextResultIndex });
	      this.onSelectResultItem(searchResults[nextResultIndex]);
	    } else {
	      var _nextResultIndex = Math.min(resultCount - 1, selectedResultIndex + 1);

	      if (selectedResultIndex === resultCount - 1) {
	        _nextResultIndex = 0;
	      }
	      this.setState({ selectedResultIndex: _nextResultIndex });
	      this.onSelectResultItem(searchResults[_nextResultIndex]);
	    }
	  }

	  traverseCodeResults(rev) {
	    var ed = this.props.editor;

	    if (!ed) {
	      return;
	    }

	    var ctx = { ed, cm: ed.codeMirror };

	    var _props6 = this.props,
	        query = _props6.query,
	        modifiers = _props6.modifiers,
	        updateSearchResults = _props6.updateSearchResults,
	        _props6$searchResults = _props6.searchResults,
	        count = _props6$searchResults.count,
	        index = _props6$searchResults.index;


	    if (query === "") {
	      this.props.toggleFileSearch(true);
	    }

	    if (index == -1 && modifiers) {
	      (0, _editor.clearIndex)(ctx, query, modifiers.toJS());
	    }

	    if (modifiers) {
	      var findFnc = rev ? _editor.findPrev : _editor.findNext;
	      var newIndex = findFnc(ctx, query, true, modifiers.toJS());
	      updateSearchResults({
	        index: newIndex,
	        count
	      });
	    }
	  }

	  traverseResults(e, rev) {
	    e.stopPropagation();
	    e.preventDefault();

	    var symbolSearchEnabled = this.state.symbolSearchEnabled;


	    if (symbolSearchEnabled) {
	      return this.traverseSymbolResults(rev);
	    }

	    this.traverseCodeResults(rev);
	  }

	  // Handlers
	  selectResultItem(e, item) {
	    var _props7 = this.props,
	        selectSource = _props7.selectSource,
	        selectedSource = _props7.selectedSource;


	    if (selectedSource) {
	      selectSource(selectedSource.get("id"), {
	        line: item.location.start.line
	      });

	      this.closeSearch(e);
	    }
	  }

	  onSelectResultItem(item) {
	    var _props8 = this.props,
	        selectSource = _props8.selectSource,
	        selectedSource = _props8.selectedSource;

	    if (selectedSource) {
	      selectSource(selectedSource.get("id"), {
	        line: item.location.start.line
	      });
	    }
	  }

	  onChange(e) {
	    var _this3 = this;

	    return _asyncToGenerator(function* () {
	      return _this3.doSearch(e.target.value);
	    })();
	  }

	  onKeyUp(e) {
	    if (e.key !== "Enter" || e.key !== "F3") {
	      return;
	    }

	    this.traverseResults(e, e.shiftKey);
	  }

	  onKeyDown(e) {
	    var _state3 = this.state,
	        symbolSearchEnabled = _state3.symbolSearchEnabled,
	        symbolSearchResults = _state3.symbolSearchResults;

	    if (!symbolSearchEnabled || this.props.query == "") {
	      return;
	    }

	    var searchResults = symbolSearchResults;

	    if (e.key === "ArrowUp") {
	      this.traverseSymbolResults(true);
	      e.preventDefault();
	    } else if (e.key === "ArrowDown") {
	      this.traverseSymbolResults(false);
	      e.preventDefault();
	    } else if (e.key === "Enter") {
	      if (searchResults.length) {
	        this.selectResultItem(e, searchResults[this.state.selectedResultIndex]);
	      }
	      this.closeSearch(e);
	      e.preventDefault();
	    } else if (e.key === "Tab") {
	      this.closeSearch(e);
	      e.preventDefault();
	    }
	  }

	  // Renderers
	  buildSummaryMsg() {
	    if (this.state.symbolSearchEnabled) {
	      if (this.state.symbolSearchResults.length > 1) {
	        return L10N.getFormatStr("editor.searchResults", this.state.selectedResultIndex + 1, this.state.symbolSearchResults.length);
	      } else if (this.state.symbolSearchResults.length === 1) {
	        return L10N.getFormatStr("editor.singleResult");
	      }
	    }

	    var _props9 = this.props,
	        _props9$searchResults = _props9.searchResults,
	        count = _props9$searchResults.count,
	        index = _props9$searchResults.index,
	        query = _props9.query;


	    if (query.trim() == "") {
	      return "";
	    }

	    if (count == 0) {
	      return L10N.getStr("editor.noResults");
	    }

	    if (index == -1) {
	      return L10N.getFormatStr("sourceSearch.resultsSummary1", count);
	    }

	    return L10N.getFormatStr("editor.searchResults", index + 1, count);
	  }

	  buildPlaceHolder() {
	    var _state4 = this.state,
	        symbolSearchEnabled = _state4.symbolSearchEnabled,
	        selectedSymbolType = _state4.selectedSymbolType;

	    if (symbolSearchEnabled) {
	      return L10N.getFormatStr(`symbolSearch.search.${selectedSymbolType}Placeholder`);
	    }

	    return L10N.getStr("sourceSearch.search.placeholder");
	  }

	  renderSearchModifiers() {
	    if (!(0, _devtoolsConfig.isEnabled)("searchModifiers")) {
	      return;
	    }

	    var _props10 = this.props,
	        modifiers = _props10.modifiers,
	        toggleFileSearchModifier = _props10.toggleFileSearchModifier;
	    var symbolSearchEnabled = this.state.symbolSearchEnabled;


	    function searchModBtn(modVal, className, svgName, tooltip) {
	      return _react.DOM.button({
	        className: (0, _classnames2.default)(className, {
	          active: !symbolSearchEnabled && modifiers && modifiers.get(modVal),
	          disabled: symbolSearchEnabled
	        }),
	        onClick: () => !symbolSearchEnabled ? toggleFileSearchModifier(modVal) : null,
	        title: tooltip
	      }, (0, _Svg2.default)(svgName));
	    }

	    return _react.DOM.div({ className: "search-modifiers" }, searchModBtn("regexMatch", "regex-match-btn", "regex-match", L10N.getStr("symbolSearch.searchModifier.regex")), searchModBtn("caseSensitive", "case-sensitive-btn", "case-match", L10N.getStr("symbolSearch.searchModifier.caseSensitive")), searchModBtn("wholeWord", "whole-word-btn", "whole-word-match", L10N.getStr("symbolSearch.searchModifier.wholeWord")));
	  }

	  renderSearchTypeToggle() {
	    if (!(0, _devtoolsConfig.isEnabled)("symbolSearch")) {
	      return;
	    }
	    var toggleSymbolSearch = this.toggleSymbolSearch;
	    var _state5 = this.state,
	        symbolSearchEnabled = _state5.symbolSearchEnabled,
	        selectedSymbolType = _state5.selectedSymbolType;


	    function searchTypeBtn(searchType) {
	      return _react.DOM.button({
	        className: (0, _classnames2.default)("search-type-btn", {
	          active: symbolSearchEnabled && selectedSymbolType == searchType
	        }),
	        onClick: e => {
	          if (selectedSymbolType == searchType) {
	            toggleSymbolSearch(e, { toggle: true, searchType });
	            return;
	          }
	          toggleSymbolSearch(e, { toggle: false, searchType });
	        }
	      }, searchType);
	    }

	    return _react.DOM.section({ className: "search-type-toggles" }, _react.DOM.h1({ className: "search-toggle-title" }, L10N.getStr("editor.searchTypeToggleTitle")), searchTypeBtn("functions"), searchTypeBtn("variables"));
	  }

	  renderBottomBar() {
	    if (!(0, _devtoolsConfig.isEnabled)("searchModifiers") || !(0, _devtoolsConfig.isEnabled)("symbolSearch")) {
	      return;
	    }

	    return _react.DOM.div({ className: "search-bottom-bar" }, this.renderSearchTypeToggle(), this.renderSearchModifiers());
	  }

	  renderResults() {
	    var _state6 = this.state,
	        symbolSearchEnabled = _state6.symbolSearchEnabled,
	        symbolSearchResults = _state6.symbolSearchResults,
	        selectedResultIndex = _state6.selectedResultIndex;
	    var query = this.props.query;

	    if (query == "" || !symbolSearchEnabled || !symbolSearchResults.length) {
	      return;
	    }

	    return ResultList({
	      items: symbolSearchResults,
	      selected: selectedResultIndex,
	      selectItem: this.selectResultItem,
	      ref: "resultList"
	    });
	  }

	  render() {
	    var _props11 = this.props,
	        count = _props11.searchResults.count,
	        query = _props11.query,
	        searchOn = _props11.searchOn;


	    if (!searchOn) {
	      return _react.DOM.div();
	    }

	    return _react.DOM.div({ className: "search-bar" }, SearchInput({
	      query,
	      count,
	      placeholder: this.buildPlaceHolder(),
	      summaryMsg: this.buildSummaryMsg(),
	      onChange: this.onChange,
	      onKeyUp: this.onKeyUp,
	      onKeyDown: this.onKeyDown,
	      handleNext: e => this.traverseResults(e, false),
	      handlePrev: e => this.traverseResults(e, true),
	      handleClose: this.closeSearch
	    }), this.renderResults(), this.renderBottomBar());
	  }
	}

	SearchBar.propTypes = {
	  editor: _react.PropTypes.object,
	  sourceText: _reactImmutableProptypes2.default.map,
	  selectSource: _react.PropTypes.func.isRequired,
	  selectedSource: _reactImmutableProptypes2.default.map,
	  searchOn: _react.PropTypes.bool,
	  toggleFileSearch: _react.PropTypes.func.isRequired,
	  searchResults: _react.PropTypes.object.isRequired,
	  modifiers: _reactImmutableProptypes2.default.recordOf({
	    caseSensitive: _react.PropTypes.bool.isRequired,
	    regexMatch: _react.PropTypes.bool.isRequired,
	    wholeWord: _react.PropTypes.bool.isRequired
	  }).isRequired,
	  toggleFileSearchModifier: _react.PropTypes.func.isRequired,
	  query: _react.PropTypes.string.isRequired,
	  setFileSearchQuery: _react.PropTypes.func.isRequired,
	  updateSearchResults: _react.PropTypes.func.isRequired
	};

	SearchBar.displayName = "SearchBar";

	SearchBar.contextTypes = {
	  shortcuts: _react.PropTypes.object
	};

	exports.default = (0, _reactRedux.connect)(state => {
	  return {
	    searchOn: (0, _selectors.getFileSearchState)(state),
	    query: (0, _selectors.getFileSearchQueryState)(state),
	    modifiers: (0, _selectors.getFileSearchModifierState)(state)
	  };
	}, dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(SearchBar);

/***/ },
/* 434 */,
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */,
/* 445 */,
/* 446 */,
/* 447 */,
/* 448 */,
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */,
/* 465 */,
/* 466 */,
/* 467 */,
/* 468 */,
/* 469 */,
/* 470 */,
/* 471 */,
/* 472 */,
/* 473 */,
/* 474 */,
/* 475 */,
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */,
/* 488 */,
/* 489 */,
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */,
/* 515 */,
/* 516 */,
/* 517 */,
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */,
/* 522 */,
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */,
/* 527 */,
/* 528 */,
/* 529 */,
/* 530 */,
/* 531 */,
/* 532 */,
/* 533 */,
/* 534 */,
/* 535 */,
/* 536 */,
/* 537 */,
/* 538 */,
/* 539 */,
/* 540 */,
/* 541 */,
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */,
/* 561 */,
/* 562 */,
/* 563 */,
/* 564 */,
/* 565 */,
/* 566 */,
/* 567 */,
/* 568 */,
/* 569 */,
/* 570 */,
/* 571 */,
/* 572 */,
/* 573 */,
/* 574 */,
/* 575 */,
/* 576 */,
/* 577 */,
/* 578 */,
/* 579 */,
/* 580 */,
/* 581 */,
/* 582 */,
/* 583 */,
/* 584 */,
/* 585 */,
/* 586 */,
/* 587 */,
/* 588 */,
/* 589 */,
/* 590 */,
/* 591 */,
/* 592 */,
/* 593 */,
/* 594 */,
/* 595 */,
/* 596 */,
/* 597 */,
/* 598 */,
/* 599 */,
/* 600 */,
/* 601 */,
/* 602 */,
/* 603 */,
/* 604 */,
/* 605 */,
/* 606 */,
/* 607 */,
/* 608 */,
/* 609 */,
/* 610 */,
/* 611 */,
/* 612 */,
/* 613 */,
/* 614 */,
/* 615 */,
/* 616 */,
/* 617 */,
/* 618 */,
/* 619 */,
/* 620 */,
/* 621 */,
/* 622 */,
/* 623 */,
/* 624 */,
/* 625 */,
/* 626 */,
/* 627 */,
/* 628 */,
/* 629 */,
/* 630 */,
/* 631 */,
/* 632 */,
/* 633 */,
/* 634 */,
/* 635 */,
/* 636 */,
/* 637 */,
/* 638 */,
/* 639 */,
/* 640 */,
/* 641 */,
/* 642 */,
/* 643 */,
/* 644 */,
/* 645 */,
/* 646 */,
/* 647 */,
/* 648 */,
/* 649 */,
/* 650 */,
/* 651 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(84),
	    now = __webpack_require__(652),
	    toNumber = __webpack_require__(304);

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max,
	    nativeMin = Math.min;

	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  wait = toNumber(wait) || 0;
	  if (isObject(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }

	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;

	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }

	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }

	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        result = wait - timeSinceLastCall;

	    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
	  }

	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;

	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }

	  function timerExpired() {
	    var time = now();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }

	  function trailingEdge(time) {
	    timerId = undefined;

	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }

	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }

	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now());
	  }

	  function debounced() {
	    var time = now(),
	        isInvoking = shouldInvoke(time);

	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;

	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}

	module.exports = debounce;


/***/ },
/* 652 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(8);

	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return root.Date.now();
	};

	module.exports = now;


/***/ },
/* 653 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 654 */,
/* 655 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = GutterMenu;

	var _devtoolsLaunchpad = __webpack_require__(131);

	function GutterMenu(_ref) {
	  var bp = _ref.bp,
	      line = _ref.line,
	      event = _ref.event,
	      toggleBreakpoint = _ref.toggleBreakpoint,
	      showConditionalPanel = _ref.showConditionalPanel,
	      toggleBreakpointDisabledStatus = _ref.toggleBreakpointDisabledStatus,
	      isCbPanelOpen = _ref.isCbPanelOpen,
	      closeConditionalPanel = _ref.closeConditionalPanel;

	  event.stopPropagation();
	  event.preventDefault();
	  var breakpoint = {
	    id: "node-menu-add-breakpoint",
	    label: L10N.getStr("editor.addBreakpoint")
	  },
	      conditional = {
	    id: "node-menu-add-conditional-breakpoint",
	    label: L10N.getStr("editor.addConditionalBreakpoint")
	  },
	      disabled = void 0;
	  if (bp) {
	    breakpoint = {
	      id: "node-menu-remove-breakpoint",
	      label: L10N.getStr("editor.removeBreakpoint")
	    };
	    conditional = {
	      id: "node-menu-edit-conditional-breakpoint",
	      label: L10N.getStr("editor.editBreakpoint")
	    };
	    if (bp.disabled) {
	      disabled = {
	        id: "node-menu-enable-breakpoint",
	        label: L10N.getStr("editor.enableBreakpoint")
	      };
	    } else {
	      disabled = {
	        id: "node-menu-disable-breakpoint",
	        label: L10N.getStr("editor.disableBreakpoint")
	      };
	    }
	  }

	  var toggleBreakpointItem = Object.assign({
	    accesskey: "B",
	    disabled: false,
	    click: () => {
	      toggleBreakpoint(line);
	      if (isCbPanelOpen) {
	        closeConditionalPanel();
	      }
	    }
	  }, breakpoint);

	  var conditionalBreakpoint = Object.assign({
	    accesskey: "C",
	    disabled: false,
	    click: () => showConditionalPanel(line)
	  }, conditional);

	  var items = [toggleBreakpointItem, conditionalBreakpoint];

	  if (bp) {
	    var disableBreakpoint = Object.assign({
	      accesskey: "D",
	      disabled: false,
	      click: () => toggleBreakpointDisabledStatus(line)
	    }, disabled);
	    items.push(disableBreakpoint);
	  }

	  (0, _devtoolsLaunchpad.showMenu)(event, items);
	}

/***/ },
/* 656 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var EditorMenu = (() => {
	  var _ref2 = _asyncToGenerator(function* (options) {
	    var event = options.event,
	        onGutterContextMenu = options.onGutterContextMenu;


	    if (event.target.classList.contains("CodeMirror-linenumber")) {
	      return onGutterContextMenu(event);
	    }

	    event.stopPropagation();
	    event.preventDefault();

	    (0, _devtoolsLaunchpad.showMenu)(event, getMenuItems(event, options));
	  });

	  return function EditorMenu(_x) {
	    return _ref2.apply(this, arguments);
	  };
	})();

	var _devtoolsLaunchpad = __webpack_require__(131);

	var _devtoolsConfig = __webpack_require__(828);

	var _devtoolsSourceMap = __webpack_require__(898);

	var _clipboard = __webpack_require__(423);

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	function getMenuItems(event, _ref) {
	  var codeMirror = _ref.codeMirror,
	      selectedLocation = _ref.selectedLocation,
	      selectedSource = _ref.selectedSource,
	      showSource = _ref.showSource,
	      onGutterContextMenu = _ref.onGutterContextMenu,
	      jumpToMappedLocation = _ref.jumpToMappedLocation,
	      toggleBlackBox = _ref.toggleBlackBox,
	      addExpression = _ref.addExpression;

	  var copySourceUrlLabel = L10N.getStr("copySourceUrl");
	  var copySourceUrlKey = L10N.getStr("copySourceUrl.accesskey");
	  var revealInTreeLabel = L10N.getStr("sourceTabs.revealInTree");
	  var revealInTreeKey = L10N.getStr("sourceTabs.revealInTree.accesskey");
	  var blackboxLabel = L10N.getStr("sourceFooter.blackbox");
	  var unblackboxLabel = L10N.getStr("sourceFooter.unblackbox");
	  var blackboxKey = L10N.getStr("sourceFooter.blackbox.accesskey");
	  var toggleBlackBoxLabel = selectedSource.get("isBlackBoxed") ? unblackboxLabel : blackboxLabel;

	  var copySourceUrl = {
	    id: "node-menu-copy-source",
	    label: copySourceUrlLabel,
	    accesskey: copySourceUrlKey,
	    disabled: false,
	    click: () => (0, _clipboard.copyToTheClipboard)(selectedSource.get("url"))
	  };

	  var _codeMirror$coordsCha = codeMirror.coordsChar({
	    left: event.clientX,
	    top: event.clientY
	  }),
	      line = _codeMirror$coordsCha.line,
	      ch = _codeMirror$coordsCha.ch;

	  var sourceLocation = {
	    sourceId: selectedLocation.sourceId,
	    line: line + 1,
	    column: ch + 1
	  };

	  var pairedType = (0, _devtoolsSourceMap.isOriginalId)(selectedLocation.sourceId) ? L10N.getStr("generated") : L10N.getStr("original");

	  var jumpLabel = {
	    accesskey: "C",
	    disabled: false,
	    label: L10N.getFormatStr("editor.jumpToMappedLocation1", pairedType),
	    click: () => jumpToMappedLocation(sourceLocation)
	  };

	  var watchExpressionLabel = {
	    accesskey: "E",
	    label: L10N.getStr("expressions.placeholder"),
	    click: () => addExpression(codeMirror.getSelection())
	  };

	  var blackBoxMenuItem = {
	    id: "node-menu-blackbox",
	    label: toggleBlackBoxLabel,
	    accesskey: blackboxKey,
	    disabled: false,
	    click: () => toggleBlackBox(selectedSource.toJS())
	  };

	  // TODO: Find a new way to only add this for mapped sources?
	  var textSelected = codeMirror.somethingSelected();

	  var showSourceMenuItem = {
	    id: "node-menu-show-source",
	    label: revealInTreeLabel,
	    accesskey: revealInTreeKey,
	    disabled: false,
	    click: () => showSource(selectedSource.get("id"))
	  };

	  if (selectedSource && selectedSource.get("isBlackBoxed")) {
	    return [blackBoxMenuItem];
	  }

	  var menuItems = [copySourceUrl, jumpLabel, showSourceMenuItem, blackBoxMenuItem];

	  if ((0, _devtoolsConfig.isEnabled)("watchExpressions") && textSelected) {
	    menuItems.push(watchExpressionLabel);
	  }

	  return menuItems;
	}

	exports.default = EditorMenu;

/***/ },
/* 657 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _reactRedux = __webpack_require__(151);

	var _redux = __webpack_require__(3);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	var _objectInspector = __webpack_require__(658);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ObjectInspector = _react2.default.createFactory(__webpack_require__(696).default);
	var Popover = _react2.default.createFactory(__webpack_require__(698).default);
	var previewFunction = __webpack_require__(701).default;

	var Rep = __webpack_require__(697).default;

	var _require = __webpack_require__(924),
	    MODE = _require.MODE;

	var dom = _react2.default.DOM,
	    PropTypes = _react2.default.PropTypes,
	    Component = _react2.default.Component;


	__webpack_require__(709);

	class Preview extends Component {
	  componentDidMount() {
	    var _props = this.props,
	        loadObjectProperties = _props.loadObjectProperties,
	        loadedObjects = _props.loadedObjects,
	        value = _props.value;


	    if (!value || !value.type == "object") {
	      return;
	    }

	    if (value.actor && !loadedObjects.has(value.actor)) {
	      loadObjectProperties(value);
	    }
	  }

	  getChildren(root, getObjectProperties) {
	    var actors = {};

	    var children = (0, _objectInspector.getChildren)({
	      getObjectProperties,
	      actors,
	      item: root
	    });

	    if (children.length > 0) {
	      return children;
	    }

	    return [root];
	  }

	  renderFunctionPreview(value, root) {
	    var selectSourceURL = this.props.selectSourceURL;
	    var location = value.location;


	    return dom.div({
	      className: "preview",
	      onClick: () => selectSourceURL(location.url, { line: location.line })
	    }, previewFunction(value));
	  }

	  renderObjectPreview(expression, root) {
	    return dom.div({ className: "preview" }, this.renderObjectInspector(root));
	  }

	  renderSimplePreview(value) {
	    return dom.div({ className: "preview" }, Rep({ object: value, mode: MODE.LONG }));
	  }

	  renderObjectInspector(root) {
	    var _props2 = this.props,
	        loadObjectProperties = _props2.loadObjectProperties,
	        loadedObjects = _props2.loadedObjects;


	    var getObjectProperties = id => loadedObjects.get(id);
	    var roots = this.getChildren(root, getObjectProperties);

	    return ObjectInspector({
	      roots,
	      getObjectProperties,
	      autoExpandDepth: 0,
	      onDoubleClick: () => {},
	      loadObjectProperties,
	      getActors: () => ({})
	    });
	  }

	  renderPreview(expression, value) {
	    var root = {
	      name: expression,
	      path: expression,
	      contents: { value }
	    };

	    if (value.class === "Function") {
	      return this.renderFunctionPreview(value, root);
	    }

	    if (value.type === "object") {
	      return this.renderObjectPreview(expression, root);
	    }

	    return this.renderSimplePreview(value);
	  }

	  render() {
	    var _props3 = this.props,
	        popoverTarget = _props3.popoverTarget,
	        onClose = _props3.onClose,
	        value = _props3.value,
	        expression = _props3.expression;


	    var type = value.class === "Function" ? "tooltip" : "popover";

	    return Popover({
	      target: popoverTarget,
	      onMouseLeave: onClose,
	      type
	    }, this.renderPreview(expression, value));
	  }
	}

	Preview.propTypes = {
	  loadObjectProperties: PropTypes.func,
	  loadedObjects: PropTypes.object,
	  selectedFrame: PropTypes.object,
	  popoverTarget: PropTypes.object,
	  value: PropTypes.any,
	  expression: PropTypes.string,
	  onClose: PropTypes.func,
	  selectSourceURL: PropTypes.func
	};

	Preview.displayName = "Preview";

	exports.default = (0, _reactRedux.connect)(state => ({
	  loadedObjects: (0, _selectors.getLoadedObjects)(state)
	}), dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(Preview);

/***/ },
/* 658 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var get = __webpack_require__(67);

	var _require = __webpack_require__(924),
	    maybeEscapePropertyName = _require.maybeEscapePropertyName;

	var WINDOW_PROPERTIES = {};

	if (typeof window == "object") {
	  WINDOW_PROPERTIES = Object.getOwnPropertyNames(window);
	}

	function getValue(item) {
	  return get(item, "contents.value", undefined);
	}

	function isBucket(item) {
	  return item.path && item.path.match(/bucket(\d+)$/);
	}

	function nodeHasChildren(item) {
	  return Array.isArray(item.contents) || isBucket(item);
	}

	function nodeIsObject(item) {
	  var value = getValue(item);
	  return value && value.type === "object";
	}

	function nodeIsArray(value) {
	  return value && value.class === "Array";
	}

	function nodeIsFunction(item) {
	  var value = getValue(item);
	  return value && value.class === "Function";
	}

	function nodeIsOptimizedOut(item) {
	  var value = getValue(item);
	  return !nodeHasChildren(item) && value && value.optimizedOut;
	}

	function nodeIsMissingArguments(item) {
	  var value = getValue(item);
	  return !nodeHasChildren(item) && value && value.missingArguments;
	}

	function nodeHasProperties(item) {
	  return !nodeHasChildren(item) && nodeIsObject(item);
	}

	function nodeIsPrimitive(item) {
	  return !nodeHasChildren(item) && !nodeHasProperties(item);
	}

	function isPromise(item) {
	  var value = getValue(item);
	  return value.class == "Promise";
	}

	function getPromiseProperties(item) {
	  var _getValue = getValue(item),
	      _getValue$promiseStat = _getValue.promiseState,
	      reason = _getValue$promiseStat.reason,
	      value = _getValue$promiseStat.value;

	  return createNode("reason", `${item.path}/reason`, {
	    value: !reason ? value : reason
	  });
	}

	function isDefault(item) {
	  return WINDOW_PROPERTIES.includes(item.name);
	}

	function sortProperties(properties) {
	  return properties.sort((a, b) => {
	    // Sort numbers in ascending order and sort strings lexicographically
	    var aInt = parseInt(a, 10);
	    var bInt = parseInt(b, 10);

	    if (isNaN(aInt) || isNaN(bInt)) {
	      return a > b ? 1 : -1;
	    }

	    return aInt - bInt;
	  });
	}

	function makeNumericalBuckets(props, bucketSize, parentPath, ownProperties) {
	  var numProperties = props.length;
	  var numBuckets = Math.ceil(numProperties / bucketSize);
	  var buckets = [];

	  var _loop = function (i) {
	    var bucketKey = `bucket${i}`;
	    var minKey = (i - 1) * bucketSize;
	    var maxKey = Math.min(i * bucketSize - 1, numProperties);
	    var bucketName = `[${minKey}..${maxKey}]`;
	    var bucketProperties = props.slice(minKey, maxKey);

	    var bucketNodes = bucketProperties.map(name => createNode(name, `${parentPath}/${bucketKey}/${name}`, ownProperties[name]));

	    buckets.push(createNode(bucketName, `${parentPath}/${bucketKey}`, bucketNodes));
	  };

	  for (var i = 1; i <= numBuckets; i++) {
	    _loop(i);
	  }
	  return buckets;
	}

	function makeDefaultPropsBucket(props, parentPath, ownProperties) {
	  var userProps = props.filter(name => !isDefault({ name }));
	  var defaultProps = props.filter(name => isDefault({ name }));

	  var nodes = userProps.map(name => createNode(maybeEscapePropertyName(name), `${parentPath}/${name}`, ownProperties[name]));

	  if (defaultProps.length > 0) {
	    var defaultNodes = defaultProps.map((name, index) => createNode(maybeEscapePropertyName(name), `${parentPath}/bucket${index}/${name}`, ownProperties[name]));
	    nodes.push(createNode("[default properties]", `${parentPath}/default`, defaultNodes));
	  }
	  return nodes;
	}

	/*

	 * Ignore non-concrete values like getters and setters
	 * for now by making sure we have a value.
	*/
	function makeNodesForProperties(objProps, parentPath) {
	  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
	      _ref$bucketSize = _ref.bucketSize,
	      bucketSize = _ref$bucketSize === undefined ? 100 : _ref$bucketSize;

	  var ownProperties = objProps.ownProperties,
	      prototype = objProps.prototype,
	      ownSymbols = objProps.ownSymbols;


	  var properties = sortProperties(Object.keys(ownProperties)).filter(name => ownProperties[name].hasOwnProperty("value"));

	  var numProperties = properties.length;

	  var nodes = [];
	  if (nodeIsArray(prototype) && numProperties > bucketSize) {
	    nodes = makeNumericalBuckets(properties, bucketSize, parentPath, ownProperties);
	  } else {
	    nodes = makeDefaultPropsBucket(properties, parentPath, ownProperties);
	  }

	  for (var index in ownSymbols) {
	    nodes.push(createNode(ownSymbols[index].name, `${parentPath}/##symbol-${index}`, ownSymbols[index].descriptor));
	  }

	  // Add the prototype if it exists and is not null
	  if (prototype && prototype.type !== "null") {
	    nodes.push(createNode("__proto__", `${parentPath}/__proto__`, { value: prototype }));
	  }

	  return nodes;
	}

	function createNode(name, path, contents) {
	  // The path is important to uniquely identify the item in the entire
	  // tree. This helps debugging & optimizes React's rendering of large
	  // lists. The path will be separated by property name,
	  // i.e. `{ foo: { bar: { baz: 5 }}}` will have a path of `foo/bar/baz`
	  // for the inner object.
	  return { name, path, contents };
	}

	function getChildren(_ref2) {
	  var getObjectProperties = _ref2.getObjectProperties,
	      actors = _ref2.actors,
	      item = _ref2.item;

	  var obj = item.contents;

	  // Nodes can either have children already, or be an object with
	  // properties that we need to go and fetch.
	  if (nodeHasChildren(item)) {
	    return item.contents;
	  }

	  if (!nodeHasProperties(item)) {
	    return [];
	  }

	  var actor = obj.value.actor;

	  // Because we are dynamically creating the tree as the user
	  // expands it (not precalcuated tree structure), we cache child
	  // arrays. This not only helps performance, but is necessary
	  // because the expanded state depends on instances of nodes
	  // being the same across renders. If we didn't do this, each
	  // node would be a new instance every render.
	  var key = item.path;
	  if (actors && actors[key]) {
	    if (item.contents.value && item.contents.value.preview) {
	      actors[key] = updateActor(item, actors, key);
	    }

	    return actors[key];
	  }

	  if (isBucket(item)) {
	    return item.contents.children;
	  }

	  var loadedProps = getObjectProperties(actor);

	  var _ref3 = loadedProps || {},
	      ownProperties = _ref3.ownProperties,
	      prototype = _ref3.prototype;

	  if (!ownProperties && !prototype) {
	    return [];
	  }

	  var children = makeNodesForProperties(loadedProps, item.path);
	  if (isPromise(item)) {
	    children.unshift(getPromiseProperties(item));
	  }
	  actors[key] = children;
	  return children;
	}

	function updateActor(item, actors, key) {
	  var properties = item.contents.value.preview.ownProperties;

	  var _loop2 = function (pKey) {
	    if (properties.hasOwnProperty(pKey)) {
	      var cacheObject = actors[key].filter(a => a.name == pKey)[0];
	      var cacheObjectIndex = actors[key].findIndex(a => a.name == pKey);
	      // Assign new values to the cache actor if it goes stale
	      if (cacheObject && cacheObject.contents.value != properties[pKey].value) {
	        actors[key][cacheObjectIndex].contents = properties[pKey];
	      }
	    }
	  };

	  for (var pKey in properties) {
	    _loop2(pKey);
	  }
	  return actors[key];
	}

	module.exports = {
	  nodeHasChildren,
	  nodeIsOptimizedOut,
	  nodeIsMissingArguments,
	  nodeHasProperties,
	  nodeIsPrimitive,
	  nodeIsObject,
	  nodeIsFunction,
	  isDefault,
	  sortProperties,
	  makeNodesForProperties,
	  getChildren,
	  createNode,
	  isPromise,
	  getPromiseProperties
	};

/***/ },
/* 659 */,
/* 660 */,
/* 661 */,
/* 662 */,
/* 663 */,
/* 664 */,
/* 665 */,
/* 666 */,
/* 667 */,
/* 668 */,
/* 669 */,
/* 670 */,
/* 671 */,
/* 672 */,
/* 673 */,
/* 674 */,
/* 675 */,
/* 676 */,
/* 677 */,
/* 678 */,
/* 679 */,
/* 680 */,
/* 681 */,
/* 682 */,
/* 683 */,
/* 684 */,
/* 685 */,
/* 686 */,
/* 687 */,
/* 688 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8,3L12,3L12,7L14,7L14,8L12,8L12,12L8,12L8,14L7,14L7,12L3,12L3,8L1,8L1,7L3,7L3,3L7,3L7,1L8,1L8,3ZM10,10L10,5L5,5L5,10L10,10Z\"></path></svg>"

/***/ },
/* 689 */,
/* 690 */,
/* 691 */,
/* 692 */,
/* 693 */,
/* 694 */,
/* 695 */,
/* 696 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	var _Rep = __webpack_require__(697);

	var _Rep2 = _interopRequireDefault(_Rep);

	var _previewFunction = __webpack_require__(701);

	var _previewFunction2 = _interopRequireDefault(_previewFunction);

	var _devtoolsReps = __webpack_require__(924);

	var _objectInspector = __webpack_require__(658);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ManagedTree = (0, _react.createFactory)(__webpack_require__(419).default);


	// This implements a component that renders an interactive inspector
	// for looking at JavaScript objects. It expects descriptions of
	// objects from the protocol, and will dynamically fetch child
	// properties as objects are expanded.
	//
	// If you want to inspect a single object, pass the name and the
	// protocol descriptor of it:
	//
	//  ObjectInspector({
	//    name: "foo",
	//    desc: { writable: true, ..., { value: { actor: "1", ... }}},
	//    ...
	//  })
	//
	// If you want multiple top-level objects (like scopes), you can pass
	// an array of manually constructed nodes as `roots`:
	//
	//  ObjectInspector({
	//    roots: [{ name: ... }, ...],
	//    ...
	//  });

	// There are 3 types of nodes: a simple node with a children array, an
	// object that has properties that should be children when they are
	// fetched, and a primitive value that should be displayed with no
	// children.

	class ObjectInspector extends _react.Component {

	  constructor() {
	    super();

	    this.actors = null;

	    var self = this;
	    self.getChildren = this.getChildren.bind(this);
	    self.renderItem = this.renderItem.bind(this);
	  }

	  componentWillMount() {
	    // Cache of dynamically built nodes. We shouldn't need to clear
	    // this out ever, since we don't ever "switch out" the object
	    // being inspected.
	    this.actors = this.props.getActors();
	  }

	  componentWillUnmount() {
	    if (this.props.setActors) {
	      this.props.setActors(this.actors);
	    }
	  }

	  getChildren(item) {
	    var getObjectProperties = this.props.getObjectProperties;
	    var actors = this.actors;


	    return (0, _objectInspector.getChildren)({
	      getObjectProperties,
	      actors,
	      item
	    });
	  }

	  renderItem(item, depth, focused, _, expanded, _ref) {
	    var setExpanded = _ref.setExpanded;

	    var objectValue = void 0;
	    var label = item.name;
	    if ((0, _objectInspector.nodeIsOptimizedOut)(item)) {
	      objectValue = _react.DOM.span({ className: "unavailable" }, "(optimized away)");
	    } else if ((0, _objectInspector.nodeIsMissingArguments)(item)) {
	      objectValue = _react.DOM.span({ className: "unavailable" }, "(unavailable)");
	    } else if ((0, _objectInspector.nodeIsFunction)(item)) {
	      objectValue = null;
	      label = (0, _previewFunction2.default)(item);
	    } else if ((0, _objectInspector.nodeHasProperties)(item) || (0, _objectInspector.nodeIsPrimitive)(item)) {
	      var object = item.contents.value;
	      objectValue = (0, _Rep2.default)({ object, mode: _devtoolsReps.MODE.TINY });
	    }

	    return _react.DOM.div({
	      className: (0, _classnames2.default)("node object-node", {
	        focused,
	        "default-property": (0, _objectInspector.isDefault)(item)
	      }),
	      style: { marginLeft: depth * 15 },
	      onClick: e => {
	        e.stopPropagation();
	        setExpanded(item, !expanded);
	      },
	      onDoubleClick: event => {
	        event.stopPropagation();
	        this.props.onDoubleClick(item, {
	          depth,
	          focused,
	          expanded
	        });
	      }
	    }, (0, _Svg2.default)("arrow", {
	      className: (0, _classnames2.default)({
	        expanded: expanded,
	        hidden: (0, _objectInspector.nodeIsPrimitive)(item)
	      })
	    }), _react.DOM.span({
	      className: "object-label",
	      dir: "ltr",
	      onClick: event => {
	        event.stopPropagation();
	        this.props.onLabelClick(item, {
	          depth,
	          focused,
	          expanded,
	          setExpanded
	        });
	      }
	    }, label), _react.DOM.span({ className: "object-delimiter" }, objectValue ? ": " : ""), _react.DOM.span({ className: "object-value" }, objectValue || ""));
	  }

	  render() {
	    var _props = this.props,
	        name = _props.name,
	        desc = _props.desc,
	        loadObjectProperties = _props.loadObjectProperties,
	        autoExpandDepth = _props.autoExpandDepth,
	        getExpanded = _props.getExpanded,
	        setExpanded = _props.setExpanded;


	    var roots = this.props.roots;
	    if (!roots) {
	      roots = [(0, _objectInspector.createNode)(name, name, desc)];
	    }

	    return ManagedTree({
	      itemHeight: 20,
	      getParent: item => null,
	      getChildren: this.getChildren,
	      getRoots: () => roots,
	      getKey: item => item.path,
	      autoExpand: 0,
	      autoExpandDepth,
	      autoExpandAll: false,
	      disabledFocus: true,
	      onExpand: item => {
	        if ((0, _objectInspector.nodeHasProperties)(item)) {
	          loadObjectProperties(item.contents.value);
	        }
	      },
	      getExpanded,
	      setExpanded,
	      renderItem: this.renderItem
	    });
	  }
	}

	ObjectInspector.displayName = "ObjectInspector";

	ObjectInspector.propTypes = {
	  autoExpandDepth: _react.PropTypes.number,
	  name: _react.PropTypes.string,
	  desc: _react.PropTypes.object,
	  roots: _react.PropTypes.array,
	  getObjectProperties: _react.PropTypes.func.isRequired,
	  loadObjectProperties: _react.PropTypes.func.isRequired,
	  onLabelClick: _react.PropTypes.func.isRequired,
	  onDoubleClick: _react.PropTypes.func.isRequired,
	  getExpanded: _react.PropTypes.func,
	  setExpanded: _react.PropTypes.func,
	  getActors: _react.PropTypes.func.isRequired,
	  setActors: _react.PropTypes.func
	};

	ObjectInspector.defaultProps = {
	  onLabelClick: () => {},
	  onDoubleClick: () => {},
	  autoExpandDepth: 1,
	  getActors: () => ({})
	};

	exports.default = ObjectInspector;

/***/ },
/* 697 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = renderRep;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _require = __webpack_require__(924),
	    _require$REPS = _require.REPS,
	    Rep = _require$REPS.Rep,
	    Grip = _require$REPS.Grip;

	Rep = _react2.default.createFactory(Rep);

	function renderRep(_ref) {
	  var object = _ref.object,
	      mode = _ref.mode;

	  return Rep({ object, defaultRep: Grip, mode });
	}

/***/ },
/* 698 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ReactDOM = __webpack_require__(22);


	__webpack_require__(699);

	class Popover extends _react.Component {
	  constructor() {
	    super();
	    this.state = {
	      left: 0,
	      top: 0
	    };
	  }

	  componentDidMount() {
	    var type = this.props.type;

	    var _ref = type == "popover" ? this.getPopoverCoords() : this.getTooltipCoords(),
	        left = _ref.left,
	        top = _ref.top,
	        dir = _ref.dir;

	    // eslint-disable-next-line react/no-did-mount-set-state


	    this.setState({ left, top, dir });
	  }

	  getPopoverCoords() {
	    var el = ReactDOM.findDOMNode(this);

	    var _el$getBoundingClient = el.getBoundingClientRect(),
	        width = _el$getBoundingClient.width,
	        height = _el$getBoundingClient.height;

	    var _props$target$getBoun = this.props.target.getBoundingClientRect(),
	        targetLeft = _props$target$getBoun.left,
	        targetWidth = _props$target$getBoun.width,
	        targetBottom = _props$target$getBoun.bottom,
	        targetTop = _props$target$getBoun.top;

	    // width division corresponds to calc in Popover.css


	    var left = targetLeft + targetWidth / 2 - width / 5;
	    var dir = targetBottom + height > window.innerHeight ? "up" : "down";
	    var top = dir == "down" ? targetBottom : targetTop - height;

	    return { left, top, dir };
	  }

	  getTooltipCoords() {
	    var el = ReactDOM.findDOMNode(this);

	    var _el$getBoundingClient2 = el.getBoundingClientRect(),
	        height = _el$getBoundingClient2.height;

	    var _props$target$getBoun2 = this.props.target.getBoundingClientRect(),
	        targetLeft = _props$target$getBoun2.left,
	        targetWidth = _props$target$getBoun2.width,
	        targetTop = _props$target$getBoun2.top;

	    var left = targetLeft + targetWidth / 4 - 10;
	    var top = targetTop - height;

	    return { left, top, dir: "up" };
	  }

	  getChildren() {
	    var children = this.props.children;
	    var dir = this.state.dir;

	    var gap = _react.DOM.div({ className: "gap", key: "gap" });
	    return dir === "up" ? [children, gap] : [gap, children];
	  }

	  renderPopover() {
	    var onMouseLeave = this.props.onMouseLeave;
	    var _state = this.state,
	        top = _state.top,
	        left = _state.left,
	        dir = _state.dir;


	    return _react.DOM.div({
	      className: (0, _classnames2.default)("popover", { up: dir === "up" }),
	      onMouseLeave,
	      style: { top, left }
	    }, this.getChildren());
	  }

	  renderTooltip() {
	    var onMouseLeave = this.props.onMouseLeave;
	    var _state2 = this.state,
	        top = _state2.top,
	        left = _state2.left;


	    return _react.DOM.div({
	      className: "tooltip",
	      onMouseLeave,
	      style: { top, left }
	    }, this.getChildren());
	  }

	  render() {
	    var type = this.props.type;


	    if (type === "tooltip") {
	      return this.renderTooltip();
	    }

	    return this.renderPopover();
	  }
	}

	Popover.propTypes = {
	  target: _react.PropTypes.object,
	  children: _react.PropTypes.object,
	  onMouseLeave: _react.PropTypes.func,
	  type: _react.PropTypes.string
	};

	Popover.defaultProps = {
	  onMouseLeave: () => {},
	  type: "popover"
	};

	Popover.displayName = "Popover";

	exports.default = Popover;

/***/ },
/* 699 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 700 */,
/* 701 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _times = __webpack_require__(702);

	var _times2 = _interopRequireDefault(_times);

	var _zip = __webpack_require__(704);

	var _zip2 = _interopRequireDefault(_zip);

	var _flatten = __webpack_require__(706);

	var _flatten2 = _interopRequireDefault(_flatten);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	__webpack_require__(971);

	function renderFunctionName(value) {
	  var name = value.userDisplayName || value.displayName || value.name || "";
	  return _react.DOM.span({ className: "function-name" }, name);
	}

	function renderParams(value) {
	  var _value$parameterNames = value.parameterNames,
	      parameterNames = _value$parameterNames === undefined ? [] : _value$parameterNames;

	  var params = parameterNames.filter(i => i).map(param => _react.DOM.span({ className: "param" }, param));

	  var commas = (0, _times2.default)(params.length - 1).map(() => _react.DOM.span({ className: "delimiter" }, ", "));

	  return (0, _flatten2.default)((0, _zip2.default)(params, commas));
	}

	function renderParen(paren) {
	  return _react.DOM.span({ className: "paren" }, paren);
	}

	function previewFunction(value) {
	  return _react.DOM.span.apply(_react.DOM, [{ className: "function-signature" }, renderFunctionName(value), renderParen("(")].concat(_toConsumableArray(renderParams(value)), [renderParen(")")]));
	}

	exports.default = previewFunction;

/***/ },
/* 702 */
/***/ function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(207),
	    castFunction = __webpack_require__(703),
	    toInteger = __webpack_require__(302);

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used as references for the maximum length and index of an array. */
	var MAX_ARRAY_LENGTH = 4294967295;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin = Math.min;

	/**
	 * Invokes the iteratee `n` times, returning an array of the results of
	 * each invocation. The iteratee is invoked with one argument; (index).
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 * @example
	 *
	 * _.times(3, String);
	 * // => ['0', '1', '2']
	 *
	 *  _.times(4, _.constant(0));
	 * // => [0, 0, 0, 0]
	 */
	function times(n, iteratee) {
	  n = toInteger(n);
	  if (n < 1 || n > MAX_SAFE_INTEGER) {
	    return [];
	  }
	  var index = MAX_ARRAY_LENGTH,
	      length = nativeMin(n, MAX_ARRAY_LENGTH);

	  iteratee = castFunction(iteratee);
	  n -= MAX_ARRAY_LENGTH;

	  var result = baseTimes(length, iteratee);
	  while (++index < n) {
	    iteratee(index);
	  }
	  return result;
	}

	module.exports = times;


/***/ },
/* 703 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(298);

	/**
	 * Casts `value` to `identity` if it's not a function.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Function} Returns cast function.
	 */
	function castFunction(value) {
	  return typeof value == 'function' ? value : identity;
	}

	module.exports = castFunction;


/***/ },
/* 704 */
/***/ function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(411),
	    unzip = __webpack_require__(705);

	/**
	 * Creates an array of grouped elements, the first of which contains the
	 * first elements of the given arrays, the second of which contains the
	 * second elements of the given arrays, and so on.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to process.
	 * @returns {Array} Returns the new array of grouped elements.
	 * @example
	 *
	 * _.zip(['a', 'b'], [1, 2], [true, false]);
	 * // => [['a', 1, true], ['b', 2, false]]
	 */
	var zip = baseRest(unzip);

	module.exports = zip;


/***/ },
/* 705 */
/***/ function(module, exports, __webpack_require__) {

	var arrayFilter = __webpack_require__(289),
	    arrayMap = __webpack_require__(110),
	    baseProperty = __webpack_require__(300),
	    baseTimes = __webpack_require__(207),
	    isArrayLikeObject = __webpack_require__(404);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * This method is like `_.zip` except that it accepts an array of grouped
	 * elements and creates an array regrouping the elements to their pre-zip
	 * configuration.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.2.0
	 * @category Array
	 * @param {Array} array The array of grouped elements to process.
	 * @returns {Array} Returns the new array of regrouped elements.
	 * @example
	 *
	 * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	 * // => [['a', 1, true], ['b', 2, false]]
	 *
	 * _.unzip(zipped);
	 * // => [['a', 'b'], [1, 2], [true, false]]
	 */
	function unzip(array) {
	  if (!(array && array.length)) {
	    return [];
	  }
	  var length = 0;
	  array = arrayFilter(array, function(group) {
	    if (isArrayLikeObject(group)) {
	      length = nativeMax(group.length, length);
	      return true;
	    }
	  });
	  return baseTimes(length, function(index) {
	    return arrayMap(array, baseProperty(index));
	  });
	}

	module.exports = unzip;


/***/ },
/* 706 */
/***/ function(module, exports, __webpack_require__) {

	var baseFlatten = __webpack_require__(707);

	/**
	 * Flattens `array` a single level deep.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * _.flatten([1, [2, [3, [4]], 5]]);
	 * // => [1, 2, [3, [4]], 5]
	 */
	function flatten(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? baseFlatten(array, 1) : [];
	}

	module.exports = flatten;


/***/ },
/* 707 */
/***/ function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(287),
	    isFlattenable = __webpack_require__(708);

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	module.exports = baseFlatten;


/***/ },
/* 708 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(7),
	    isArguments = __webpack_require__(208),
	    isArray = __webpack_require__(70);

	/** Built-in value references. */
	var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	module.exports = isFlattenable;


/***/ },
/* 709 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 710 */,
/* 711 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.renderConditionalPanel = undefined;

	var _react = __webpack_require__(2);

	var _Close = __webpack_require__(378);

	var _Close2 = _interopRequireDefault(_Close);

	__webpack_require__(712);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ReactDOM = __webpack_require__(22);


	function renderConditionalPanel(_ref) {
	  var condition = _ref.condition,
	      closePanel = _ref.closePanel,
	      setBreakpoint = _ref.setBreakpoint;

	  var panel = document.createElement("div");
	  var input = null;

	  function setInput(node) {
	    input = node;
	  }

	  function saveAndClose() {
	    if (input) {
	      setBreakpoint(input.value);
	    }

	    closePanel();
	  }

	  function onKey(e) {
	    if (e.key === "Enter") {
	      saveAndClose();
	    } else if (e.key === "Escape") {
	      closePanel();
	    }
	  }

	  ReactDOM.render(_react.DOM.div({ className: "conditional-breakpoint-panel" }, _react.DOM.div({ className: "prompt" }, "»"), _react.DOM.input({
	    defaultValue: condition,
	    placeholder: L10N.getStr("editor.conditionalPanel.placeholder"),
	    onKeyDown: onKey,
	    ref: setInput
	  }), (0, _Close2.default)({
	    handleClick: closePanel,
	    buttonClass: "big",
	    tooltip: L10N.getStr("editor.conditionalPanel.close")
	  })), panel);

	  return panel;
	}

	exports.renderConditionalPanel = renderConditionalPanel;

/***/ },
/* 712 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 713 */,
/* 714 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _devtoolsConfig = __webpack_require__(828);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ReactDOM = __webpack_require__(22);

	var breakpointSvg = document.createElement("div");
	ReactDOM.render((0, _Svg2.default)("breakpoint"), breakpointSvg);

	function makeMarker(isDisabled) {
	  var bp = breakpointSvg.cloneNode(true);
	  bp.className = (0, _classnames2.default)("editor new-breakpoint", {
	    "breakpoint-disabled": isDisabled,
	    "folding-enabled": (0, _devtoolsConfig.isEnabled)("codeFolding")
	  });

	  return bp;
	}

	class Breakpoint extends _react.Component {

	  constructor() {
	    super();
	    this.addBreakpoint = this.addBreakpoint.bind(this);
	  }

	  addBreakpoint() {
	    var bp = this.props.breakpoint;
	    var line = bp.location.line - 1;

	    this.props.editor.setGutterMarker(line, "breakpoints", makeMarker(bp.disabled));
	    this.props.editor.addLineClass(line, "line", "new-breakpoint");
	    if (bp.condition) {
	      this.props.editor.addLineClass(line, "line", "has-condition");
	    } else {
	      this.props.editor.removeLineClass(line, "line", "has-condition");
	    }
	  }
	  shouldComponentUpdate(nextProps) {
	    return this.props.editor !== nextProps.editor || this.props.breakpoint.disabled !== nextProps.breakpoint.disabled || this.props.breakpoint.condition !== nextProps.breakpoint.condition;
	  }
	  componentDidMount() {
	    if (!this.props.editor) {
	      return;
	    }

	    this.addBreakpoint();
	  }
	  componentDidUpdate() {
	    this.addBreakpoint();
	  }
	  componentWillUnmount() {
	    if (!this.props.editor) {
	      return;
	    }

	    var bp = this.props.breakpoint;
	    var line = bp.location.line - 1;

	    this.props.editor.setGutterMarker(line, "breakpoints", null);
	    this.props.editor.removeLineClass(line, "line", "new-breakpoint");
	    this.props.editor.removeLineClass(line, "line", "has-condition");
	  }
	  render() {
	    return null;
	  }
	}

	Breakpoint.propTypes = {
	  breakpoint: _react.PropTypes.object.isRequired,
	  editor: _react.PropTypes.object.isRequired
	};

	Breakpoint.displayName = "Breakpoint";

	exports.default = Breakpoint;

/***/ },
/* 715 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var markerEl = document.createElement("div");


	function makeMarker() {
	  var marker = markerEl.cloneNode(true);
	  marker.className = "editor hit-marker";
	  return marker;
	}

	class HitMarker extends _react.Component {
	  addMarker() {
	    var hitData = this.props.hitData;
	    var line = hitData.line - 1;

	    this.props.editor.setGutterMarker(line, "hit-markers", makeMarker());

	    this.props.editor.addLineClass(line, "line", "hit-marker");
	  }

	  shouldComponentUpdate(nextProps) {
	    return this.props.editor !== nextProps.editor || this.props.hitData !== nextProps.hitData;
	  }

	  componentDidMount() {
	    if (!this.props.editor) {
	      return;
	    }

	    this.addMarker();
	  }

	  componentDidUpdate() {
	    this.addMarker();
	  }

	  componentWillUnmount() {
	    if (!this.props.editor) {
	      return;
	    }

	    var hitData = this.props.hitData;
	    var line = hitData.line - 1;

	    this.props.editor.setGutterMarker(line, "hit-markers", null);
	    this.props.editor.removeLineClass(line, "line", "hit-marker");
	  }

	  render() {
	    return null;
	  }
	}

	HitMarker.displayName = "HitMarker";

	HitMarker.propTypes = {
	  hitData: _react.PropTypes.object.isRequired,
	  editor: _react.PropTypes.object.isRequired
	};

	exports.default = HitMarker;

/***/ },
/* 716 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 717 */,
/* 718 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _reactRedux = __webpack_require__(151);

	var _redux = __webpack_require__(3);

	var _reactImmutableProptypes = __webpack_require__(150);

	var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	var _devtoolsConfig = __webpack_require__(828);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	var _prefs = __webpack_require__(226);

	var _Expressions2 = __webpack_require__(719);

	var _Expressions3 = _interopRequireDefault(_Expressions2);

	__webpack_require__(745);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var WhyPaused = (0, _react.createFactory)(__webpack_require__(722).default);
	var Breakpoints = (0, _react.createFactory)(__webpack_require__(725).default);

	var Expressions = (0, _react.createFactory)(_Expressions3.default);

	var SplitBox = (0, _react.createFactory)(__webpack_require__(830).SplitBox);
	var Scopes = (0, _devtoolsConfig.isEnabled)("chromeScopes") ? (0, _react.createFactory)(__webpack_require__(728).default) : (0, _react.createFactory)(__webpack_require__(731).default);

	var Frames = (0, _react.createFactory)(__webpack_require__(733).default);
	var EventListeners = (0, _react.createFactory)(__webpack_require__(736).default);
	var Accordion = (0, _react.createFactory)(__webpack_require__(739).default);
	var CommandBar = (0, _react.createFactory)(__webpack_require__(742).default);

	function debugBtn(onClick, type, className, tooltip) {
	  className = `${type} ${className}`;
	  return _react.DOM.button({ onClick, className, key: type, title: tooltip }, (0, _Svg2.default)(type, { title: tooltip, "aria-label": tooltip }));
	}

	class SecondaryPanes extends _react.Component {
	  renderBreakpointsToggle() {
	    var _props = this.props,
	        toggleAllBreakpoints = _props.toggleAllBreakpoints,
	        breakpoints = _props.breakpoints,
	        breakpointsDisabled = _props.breakpointsDisabled,
	        breakpointsLoading = _props.breakpointsLoading;

	    var boxClassName = "breakpoints-toggle";
	    var isIndeterminate = !breakpointsDisabled && breakpoints.some(x => x.disabled);

	    if (breakpoints.size == 0) {
	      return null;
	    }

	    return _react.DOM.input({
	      type: "checkbox",
	      "aria-label": breakpointsDisabled ? L10N.getStr("breakpoints.enable") : L10N.getStr("breakpoints.disable"),
	      className: boxClassName,
	      disabled: breakpointsLoading,
	      onClick: () => toggleAllBreakpoints(!breakpointsDisabled),
	      checked: !breakpointsDisabled && !isIndeterminate,
	      ref: input => {
	        if (input) {
	          input.indeterminate = isIndeterminate;
	        }
	      },
	      title: breakpointsDisabled ? L10N.getStr("breakpoints.enable") : L10N.getStr("breakpoints.disable")
	    });
	  }

	  watchExpressionHeaderButtons() {
	    return [debugBtn(evt => {
	      evt.stopPropagation();
	      this.props.evaluateExpressions();
	    }, "refresh", "refresh", L10N.getStr("watchExpressions.refreshButton"))];
	  }

	  getScopeItem() {
	    var isPaused = () => !!this.props.pauseData;

	    return {
	      header: L10N.getStr("scopes.header"),
	      component: Scopes,
	      opened: _prefs.prefs.scopesVisible,
	      onToggle: opened => {
	        _prefs.prefs.scopesVisible = opened;
	      },
	      shouldOpen: isPaused
	    };
	  }

	  getWatchItem() {
	    return {
	      header: L10N.getStr("watchExpressions.header"),
	      buttons: this.watchExpressionHeaderButtons(),
	      component: Expressions,
	      opened: true
	    };
	  }

	  getStartItems() {
	    var scopesContent = this.props.horizontal ? this.getScopeItem() : null;
	    var isPaused = () => !!this.props.pauseData;

	    var items = [{
	      header: L10N.getStr("breakpoints.header"),
	      buttons: this.renderBreakpointsToggle(),
	      component: Breakpoints,
	      opened: true
	    }, {
	      header: L10N.getStr("callStack.header"),
	      component: Frames,
	      opened: _prefs.prefs.callStackVisible,
	      onToggle: opened => {
	        _prefs.prefs.callStackVisible = opened;
	      },
	      shouldOpen: isPaused
	    }, scopesContent];

	    if ((0, _devtoolsConfig.isEnabled)("eventListeners")) {
	      items.push({
	        header: L10N.getStr("eventListenersHeader"),
	        component: EventListeners
	      });
	    }

	    if ((0, _devtoolsConfig.isEnabled)("watchExpressions") && this.props.horizontal) {
	      items.unshift(this.getWatchItem());
	    }

	    return items.filter(item => item);
	  }

	  renderHorizontalLayout() {
	    return Accordion({
	      items: this.getItems()
	    });
	  }

	  getEndItems() {
	    var items = [];

	    if (!this.props.horizontal) {
	      items.unshift(this.getScopeItem());
	    }

	    if ((0, _devtoolsConfig.isEnabled)("watchExpressions") && !this.props.horizontal) {
	      items.unshift(this.getWatchItem());
	    }

	    return items;
	  }

	  getItems() {
	    return [].concat(_toConsumableArray(this.getStartItems()), _toConsumableArray(this.getEndItems()));
	  }

	  renderVerticalLayout() {
	    return SplitBox({
	      style: { width: "100vw" },
	      initialSize: "300px",
	      minSize: 10,
	      maxSize: "50%",
	      splitterSize: 1,
	      startPanel: Accordion({ items: this.getStartItems() }),
	      endPanel: Accordion({ items: this.getEndItems() })
	    });
	  }

	  render() {
	    return _react.DOM.div({
	      className: "secondary-panes",
	      style: { overflowX: "hidden" }
	    }, CommandBar(), WhyPaused(), this.props.horizontal ? this.renderHorizontalLayout() : this.renderVerticalLayout());
	  }
	}

	SecondaryPanes.propTypes = {
	  evaluateExpressions: _react.PropTypes.func.isRequired,
	  pauseData: _reactImmutableProptypes2.default.map,
	  horizontal: _react.PropTypes.bool,
	  breakpoints: _reactImmutableProptypes2.default.map.isRequired,
	  breakpointsDisabled: _react.PropTypes.bool,
	  breakpointsLoading: _react.PropTypes.bool,
	  toggleAllBreakpoints: _react.PropTypes.func.isRequired
	};

	SecondaryPanes.contextTypes = {
	  shortcuts: _react.PropTypes.object
	};

	SecondaryPanes.displayName = "SecondaryPanes";

	exports.default = (0, _reactRedux.connect)(state => ({
	  pauseData: (0, _selectors.getPause)(state),
	  breakpoints: (0, _selectors.getBreakpoints)(state),
	  breakpointsDisabled: (0, _selectors.getBreakpointsDisabled)(state),
	  breakpointsLoading: (0, _selectors.getBreakpointsLoading)(state)
	}), dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(SecondaryPanes);

/***/ },
/* 719 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _reactRedux = __webpack_require__(151);

	var _redux = __webpack_require__(3);

	var _reactImmutableProptypes = __webpack_require__(150);

	var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	__webpack_require__(720);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var CloseButton = _react2.default.createFactory(__webpack_require__(378).default);
	var ObjectInspector = _react2.default.createFactory(__webpack_require__(696).default);
	var dom = _react2.default.DOM,
	    PropTypes = _react2.default.PropTypes;

	function getValue(expression) {
	  var value = expression.value;
	  if (!value) {
	    return {
	      path: expression.from,
	      value: "<not available>"
	    };
	  }

	  if (value.exception) {
	    return {
	      path: expression.from,
	      value: value.exception
	    };
	  }

	  if (typeof value.result == "object") {
	    return {
	      path: value.result.actor,
	      value: value.result
	    };
	  }

	  return {
	    path: value.input,
	    value: value.result
	  };
	}

	class Expressions extends _react2.default.Component {

	  constructor() {
	    super(...arguments);

	    this.state = {
	      editing: null
	    };

	    this.renderExpression = this.renderExpression.bind(this);
	  }

	  componentDidMount() {
	    var _props = this.props,
	        expressions = _props.expressions,
	        evaluateExpressions = _props.evaluateExpressions;

	    if (expressions.size > 0) {
	      evaluateExpressions();
	    }
	  }

	  shouldComponentUpdate(nextProps, nextState) {
	    var editing = this.state.editing;
	    var _props2 = this.props,
	        expressions = _props2.expressions,
	        loadedObjects = _props2.loadedObjects;

	    return expressions !== nextProps.expressions || loadedObjects !== nextProps.loadedObjects || editing !== nextState.editing;
	  }

	  editExpression(expression, _ref) {
	    var depth = _ref.depth;

	    if (depth > 0) {
	      return;
	    }

	    this.setState({ editing: expression.input });
	  }

	  deleteExpression(e, expression) {
	    e.stopPropagation();
	    var deleteExpression = this.props.deleteExpression;

	    deleteExpression(expression);
	  }

	  inputKeyPress(e, expression) {
	    if (e.key !== "Enter") {
	      return;
	    }

	    var value = e.target.value;
	    if (value == "") {
	      return;
	    }

	    this.setState({ editing: null });
	    e.target.value = "";
	    this.props.updateExpression(value, expression);
	  }

	  renderExpressionEditInput(expression) {
	    return dom.span({ className: "expression-input-container" }, dom.input({
	      type: "text",
	      className: "input-expression",
	      onKeyPress: e => this.inputKeyPress(e, expression),
	      onBlur: () => {
	        this.setState({ editing: null });
	      },
	      defaultValue: expression.input,
	      ref: c => {
	        this._input = c;
	      }
	    }));
	  }

	  renderExpression(expression) {
	    var _props3 = this.props,
	        loadObjectProperties = _props3.loadObjectProperties,
	        loadedObjects = _props3.loadedObjects;
	    var editing = this.state.editing;
	    var input = expression.input,
	        updating = expression.updating;


	    if (editing == input) {
	      return this.renderExpressionEditInput(expression);
	    }

	    if (updating) {
	      return;
	    }

	    var _getValue = getValue(expression),
	        value = _getValue.value,
	        path = _getValue.path;

	    var root = {
	      name: expression.input,
	      path,
	      contents: { value }
	    };

	    return dom.div({
	      className: "expression-container",
	      key: path || input
	    }, ObjectInspector({
	      roots: [root],
	      getObjectProperties: id => loadedObjects.get(id),
	      autoExpandDepth: 0,
	      onDoubleClick: (item, options) => this.editExpression(expression, options),
	      loadObjectProperties,
	      getActors: () => ({})
	    }), CloseButton({ handleClick: e => this.deleteExpression(e, expression) }));
	  }

	  componentDidUpdate() {
	    if (this._input) {
	      this._input.focus();
	    }
	  }

	  renderNewExpressionInput() {
	    var onKeyPress = e => {
	      if (e.key !== "Enter") {
	        return;
	      }

	      var value = e.target.value;
	      if (value == "") {
	        return;
	      }

	      e.stopPropagation();
	      e.target.value = "";
	      this.props.addExpression(value);
	    };
	    return dom.span({ className: "expression-input-container" }, dom.input({
	      type: "text",
	      className: "input-expression",
	      placeholder: L10N.getStr("expressions.placeholder"),
	      onBlur: e => {
	        e.target.value = "";
	      },
	      onKeyPress
	    }));
	  }

	  render() {
	    var expressions = this.props.expressions;

	    return dom.span({ className: "pane expressions-list" }, expressions.map(this.renderExpression), this.renderNewExpressionInput());
	  }
	}

	Expressions.propTypes = {
	  expressions: _reactImmutableProptypes2.default.list.isRequired,
	  addExpression: PropTypes.func.isRequired,
	  evaluateExpressions: PropTypes.func.isRequired,
	  updateExpression: PropTypes.func.isRequired,
	  deleteExpression: PropTypes.func.isRequired,
	  loadObjectProperties: PropTypes.func,
	  loadedObjects: _reactImmutableProptypes2.default.map.isRequired
	};

	Expressions.displayName = "Expressions";

	exports.default = (0, _reactRedux.connect)(state => ({
	  pauseInfo: (0, _selectors.getPause)(state),
	  expressions: (0, _selectors.getVisibleExpressions)(state),
	  loadedObjects: (0, _selectors.getLoadedObjects)(state)
	}), dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(Expressions);

/***/ },
/* 720 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 721 */,
/* 722 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _redux = __webpack_require__(3);

	var _reactRedux = __webpack_require__(151);

	var _reactImmutableProptypes = __webpack_require__(150);

	var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	var _pause = __webpack_require__(255);

	__webpack_require__(723);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class WhyPaused extends _react.Component {
	  renderMessage(pauseInfo) {
	    if (!pauseInfo) {
	      return null;
	    }

	    var message = pauseInfo.getIn(["why"]).get("message");
	    if (!message) {
	      return null;
	    }

	    return _react.DOM.div(null, message);
	  }

	  render() {
	    var pauseInfo = this.props.pauseInfo;

	    var reason = (0, _pause.getPauseReason)(pauseInfo);

	    if (!reason) {
	      return null;
	    }

	    return _react.DOM.div({ className: "pane why-paused" }, _react.DOM.div(null, L10N.getStr(reason)), this.renderMessage(pauseInfo));
	  }
	}

	WhyPaused.displayName = "WhyPaused";

	WhyPaused.propTypes = {
	  pauseInfo: _reactImmutableProptypes2.default.map
	};

	exports.default = (0, _reactRedux.connect)(state => ({
	  pauseInfo: (0, _selectors.getPause)(state)
	}), dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(WhyPaused);

/***/ },
/* 723 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 724 */,
/* 725 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _reactRedux = __webpack_require__(151);

	var _redux = __webpack_require__(3);

	var _reactImmutableProptypes = __webpack_require__(150);

	var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	var _breakpoints = __webpack_require__(236);

	var _utils = __webpack_require__(234);

	var _path = __webpack_require__(235);

	var _Close = __webpack_require__(378);

	var _Close2 = _interopRequireDefault(_Close);

	__webpack_require__(726);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isCurrentlyPausedAtBreakpoint(state, breakpoint) {
	  var pause = (0, _selectors.getPause)(state);
	  if (!pause || pause.get("isInterrupted")) {
	    return false;
	  }

	  var bpId = (0, _breakpoints.makeLocationId)(breakpoint.location);
	  var pausedId = (0, _breakpoints.makeLocationId)(pause.getIn(["frame", "location"]).toJS());

	  return bpId === pausedId;
	}

	function renderSourceLocation(source, line) {
	  var url = source.get("url") ? (0, _path.basename)(source.get("url")) : null;
	  // const line = url !== "" ? `: ${line}` : "";
	  return url ? _react.DOM.div({ className: "location" }, `${(0, _utils.endTruncateStr)(url, 30)}: ${line}`) : null;
	}

	class Breakpoints extends _react.Component {
	  shouldComponentUpdate(nextProps, nextState) {
	    var breakpoints = this.props.breakpoints;

	    return breakpoints !== nextProps.breakpoints;
	  }

	  handleCheckbox(breakpoint) {
	    if (breakpoint.loading) {
	      return;
	    }

	    if (breakpoint.disabled) {
	      this.props.enableBreakpoint(breakpoint.location);
	    } else {
	      this.props.disableBreakpoint(breakpoint.location);
	    }
	  }

	  selectBreakpoint(breakpoint) {
	    var sourceId = breakpoint.location.sourceId;
	    var line = breakpoint.location.line;
	    this.props.selectSource(sourceId, { line });
	  }

	  removeBreakpoint(event, breakpoint) {
	    event.stopPropagation();
	    this.props.removeBreakpoint(breakpoint.location);
	  }

	  renderBreakpoint(breakpoint) {
	    var snippet = breakpoint.text || "";
	    var locationId = breakpoint.locationId;
	    var line = breakpoint.location.line;
	    var isCurrentlyPaused = breakpoint.isCurrentlyPaused;
	    var isDisabled = breakpoint.disabled;
	    var isConditional = !!breakpoint.condition;

	    return _react.DOM.div({
	      className: (0, _classnames2.default)({
	        breakpoint,
	        paused: isCurrentlyPaused,
	        disabled: isDisabled,
	        "is-conditional": isConditional
	      }),
	      key: locationId,
	      onClick: () => this.selectBreakpoint(breakpoint)
	    }, _react.DOM.input({
	      type: "checkbox",
	      className: "breakpoint-checkbox",
	      checked: !isDisabled,
	      onChange: () => this.handleCheckbox(breakpoint),
	      // Prevent clicking on the checkbox from triggering the onClick of
	      // the surrounding div
	      onClick: ev => ev.stopPropagation()
	    }), _react.DOM.div({ className: "breakpoint-label", title: breakpoint.text }, _react.DOM.div({}, renderSourceLocation(breakpoint.location.source, line))), _react.DOM.div({ className: "breakpoint-snippet" }, snippet), (0, _Close2.default)({
	      handleClick: ev => this.removeBreakpoint(ev, breakpoint),
	      tooltip: L10N.getStr("breakpoints.removeBreakpointTooltip")
	    }));
	  }

	  render() {
	    var breakpoints = this.props.breakpoints;

	    return _react.DOM.div({ className: "pane breakpoints-list" }, breakpoints.size === 0 ? _react.DOM.div({ className: "pane-info" }, L10N.getStr("breakpoints.none")) : breakpoints.valueSeq().map(bp => {
	      return this.renderBreakpoint(bp);
	    }));
	  }
	}

	Breakpoints.displayName = "Breakpoints";

	Breakpoints.propTypes = {
	  breakpoints: _reactImmutableProptypes2.default.map.isRequired,
	  enableBreakpoint: _react.PropTypes.func.isRequired,
	  disableBreakpoint: _react.PropTypes.func.isRequired,
	  selectSource: _react.PropTypes.func.isRequired,
	  removeBreakpoint: _react.PropTypes.func.isRequired
	};

	function updateLocation(state, bp) {
	  var source = (0, _selectors.getSource)(state, bp.location.sourceId);
	  var isCurrentlyPaused = isCurrentlyPausedAtBreakpoint(state, bp);
	  var locationId = (0, _breakpoints.makeLocationId)(bp.location);

	  var location = Object.assign({}, bp.location, { source });
	  var localBP = Object.assign({}, bp, {
	    location,
	    locationId,
	    isCurrentlyPaused
	  });

	  return localBP;
	}

	function _getBreakpoints(state) {
	  return (0, _selectors.getBreakpoints)(state).map(bp => updateLocation(state, bp)).filter(bp => bp.location.source && !bp.location.source.get("isBlackBoxed"));
	}

	exports.default = (0, _reactRedux.connect)((state, props) => ({ breakpoints: _getBreakpoints(state) }), dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(Breakpoints);

/***/ },
/* 726 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 727 */,
/* 728 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _reactImmutableProptypes = __webpack_require__(150);

	var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

	var _redux = __webpack_require__(3);

	var _reactRedux = __webpack_require__(151);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	__webpack_require__(729);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ManagedTree = (0, _react.createFactory)(__webpack_require__(419).default);


	function info(text) {
	  return _react.DOM.div({ className: "pane-info" }, text);
	}

	// check to see if its an object with propertie
	function nodeHasProperties(item) {
	  return !nodeHasChildren(item) && item.contents.value.type === "object";
	}

	function nodeIsPrimitive(item) {}

	function nodeHasChildren(item) {
	  return Array.isArray(item.contents);
	}

	function createNode(name, path, contents) {
	  // The path is important to uniquely identify the item in the entire
	  // tree. This helps debugging & optimizes React's rendering of large
	  // lists. The path will be separated by property name,
	  // i.e. `{ foo: { bar: { baz: 5 }}}` will have a path of `foo/bar/baz`
	  // for the inner object.
	  return { name, path, contents };
	}

	class Scopes extends _react.Component {

	  constructor() {
	    super(...arguments);

	    // Cache of dynamically built nodes. We shouldn't need to clear
	    // this out ever, since we don't ever "switch out" the object
	    // being inspected.
	    this.objectCache = {};

	    this.getChildren = this.getChildren.bind(this);
	    this.onExpand = this.onExpand.bind(this);
	    this.renderItem = this.renderItem.bind(this);
	  }

	  makeNodesForProperties(objProps, parentPath) {
	    var ownProperties = objProps.ownProperties,
	        prototype = objProps.prototype;


	    var nodes = Object.keys(ownProperties).sort().filter(name => {
	      // Ignore non-concrete values like getters and setters
	      // for now by making sure we have a value.
	      return "value" in ownProperties[name];
	    }).map(name => {
	      return createNode(name, `${parentPath}/${name}`, ownProperties[name]);
	    });

	    // Add the prototype if it exists and is not null
	    if (prototype && prototype.type !== "null") {
	      nodes.push(createNode("__proto__", `${parentPath}/__proto__`, {
	        value: prototype
	      }));
	    }

	    return nodes;
	  }

	  renderItem(item, depth, focused, _, expanded, _ref) {
	    var setExpanded = _ref.setExpanded;

	    var notEnumberable = false;
	    var objectValue = "";

	    return _react.DOM.div({
	      className: (0, _classnames2.default)("node object-node", {
	        focused: false,
	        "not-enumerable": notEnumberable
	      }),
	      style: { marginLeft: depth * 15 },
	      key: item.path,
	      onClick: e => {
	        e.stopPropagation();
	        setExpanded(item, !expanded);
	      }
	    }, (0, _Svg2.default)("arrow", {
	      className: (0, _classnames2.default)({
	        expanded: expanded,
	        hidden: nodeIsPrimitive(item)
	      })
	    }), _react.DOM.span({ className: "object-label" }, item.name), _react.DOM.span({ className: "object-delimiter" }, objectValue ? ": " : ""), _react.DOM.span({ className: "object-value" }, objectValue || ""));
	  }

	  getObjectProperties(item) {
	    this.props.loadedObjects.get(item.contents.value.objectId);
	  }

	  getChildren(item) {
	    var obj = item.contents;

	    // Nodes can either have children already, or be an object with
	    // properties that we need to go and fetch.
	    if (nodeHasChildren(item)) {
	      return item.contents;
	    } else if (nodeHasProperties(item)) {
	      var objectId = obj.value.objectId;

	      // Because we are dynamically creating the tree as the user
	      // expands it (not precalcuated tree structure), we cache child
	      // arrays. This not only helps performance, but is necessary
	      // because the expanded state depends on instances of nodes
	      // being the same across renders. If we didn't do this, each
	      // node would be a new instance every render.
	      var key = item.path;
	      if (this.objectCache[key]) {
	        return this.objectCache[key];
	      }

	      var loadedProps = this.getObjectProperties(item);
	      if (loadedProps) {
	        var children = this.makeNodesForProperties(loadedProps, item.path);
	        this.objectCache[objectId] = children;
	        return children;
	      }
	      return [];
	    }
	    return [];
	  }

	  onExpand(item) {
	    var loadObjectProperties = this.props.loadObjectProperties;


	    if (nodeHasProperties(item)) {
	      loadObjectProperties(item.contents.value);
	    }
	  }

	  getRoots() {
	    return this.props.scopes.map(scope => {
	      var name = scope.name || (scope.type == "global" ? "Window" : "");

	      return {
	        name: name,
	        path: name,
	        contents: { value: scope.object }
	      };
	    });
	  }

	  render() {
	    var pauseInfo = this.props.pauseInfo;


	    if (!pauseInfo) {
	      return _react.DOM.div({ className: "pane scopes-list" }, info(L10N.getStr("scopes.notPaused")));
	    }

	    var roots = this.getRoots();

	    return _react.DOM.div({ className: "pane scopes-list" }, ManagedTree({
	      itemHeight: 20,
	      getParent: item => null,
	      getChildren: this.getChildren,
	      getRoots: () => roots,
	      getKey: item => item.path,
	      autoExpand: 0,
	      autoExpandDepth: 1,
	      autoExpandAll: false,
	      disabledFocus: true,
	      onExpand: this.onExpand,
	      renderItem: this.renderItem
	    }));
	  }
	}

	Scopes.propTypes = {
	  scopes: _react.PropTypes.array,
	  loadedObjects: _reactImmutableProptypes2.default.map,
	  loadObjectProperties: _react.PropTypes.func,
	  pauseInfo: _react.PropTypes.object
	};

	Scopes.displayName = "Scopes";

	exports.default = (0, _reactRedux.connect)(state => ({
	  pauseInfo: (0, _selectors.getPause)(state),
	  loadedObjects: (0, _selectors.getLoadedObjects)(state),
	  scopes: (0, _selectors.getChromeScopes)(state)
	}), dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(Scopes);

/***/ },
/* 729 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 730 */,
/* 731 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _redux = __webpack_require__(3);

	var _reactRedux = __webpack_require__(151);

	var _reactImmutableProptypes = __webpack_require__(150);

	var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	var _scopes = __webpack_require__(732);

	__webpack_require__(729);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ObjectInspector = (0, _react.createFactory)(__webpack_require__(696).default);


	function info(text) {
	  return _react.DOM.div({ className: "pane-info" }, text);
	}

	var expandedCache = new Set();
	var actorsCache = [];

	class Scopes extends _react.Component {

	  constructor(props) {
	    var pauseInfo = props.pauseInfo,
	        selectedFrame = props.selectedFrame;

	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    super(props, ...args);

	    this.state = {
	      scopes: (0, _scopes.getScopes)(pauseInfo, selectedFrame)
	    };
	  }

	  shouldComponentUpdate(nextProps, nextState) {
	    var _props = this.props,
	        pauseInfo = _props.pauseInfo,
	        selectedFrame = _props.selectedFrame,
	        loadedObjects = _props.loadedObjects;

	    return pauseInfo !== nextProps.pauseInfo || selectedFrame !== nextProps.selectedFrame || loadedObjects !== nextProps.loadedObjects;
	  }

	  componentWillReceiveProps(nextProps) {
	    var _props2 = this.props,
	        pauseInfo = _props2.pauseInfo,
	        selectedFrame = _props2.selectedFrame;

	    var pauseInfoChanged = pauseInfo !== nextProps.pauseInfo;
	    var selectedFrameChange = selectedFrame !== nextProps.selectedFrame;

	    if (pauseInfoChanged || selectedFrameChange) {
	      this.setState({
	        scopes: (0, _scopes.getScopes)(nextProps.pauseInfo, nextProps.selectedFrame)
	      });
	    }
	  }

	  render() {
	    var _props3 = this.props,
	        pauseInfo = _props3.pauseInfo,
	        loadObjectProperties = _props3.loadObjectProperties,
	        loadedObjects = _props3.loadedObjects;
	    var scopes = this.state.scopes;


	    var scopeInspector = info(L10N.getStr("scopes.notAvailable"));
	    if (scopes) {
	      scopeInspector = ObjectInspector({
	        roots: scopes,
	        getObjectProperties: id => loadedObjects.get(id),
	        loadObjectProperties: loadObjectProperties,
	        setExpanded: expanded => {
	          expandedCache = expanded;
	        },
	        getExpanded: () => expandedCache,
	        setActors: actors => {
	          actorsCache = actors;
	        },
	        getActors: () => actorsCache,
	        onLabelClick: (item, _ref) => {
	          var expanded = _ref.expanded,
	              setExpanded = _ref.setExpanded;

	          setExpanded(item, !expanded);
	        }
	      });
	    }

	    return _react.DOM.div({ className: "pane scopes-list" }, pauseInfo ? scopeInspector : info(L10N.getStr("scopes.notPaused")));
	  }
	}

	Scopes.propTypes = {
	  pauseInfo: _reactImmutableProptypes2.default.map,
	  loadedObjects: _reactImmutableProptypes2.default.map,
	  loadObjectProperties: _react.PropTypes.func,
	  selectedFrame: _react.PropTypes.object
	};

	Scopes.displayName = "Scopes";

	exports.default = (0, _reactRedux.connect)(state => ({
	  pauseInfo: (0, _selectors.getPause)(state),
	  selectedFrame: (0, _selectors.getSelectedFrame)(state),
	  loadedObjects: (0, _selectors.getLoadedObjects)(state)
	}), dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(Scopes);

/***/ },
/* 732 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _toPairs = __webpack_require__(195);

	var _toPairs2 = _interopRequireDefault(_toPairs);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	// Create the tree nodes representing all the variables and arguments
	// for the bindings from a scope.
	function getBindingVariables(bindings, parentName) {
	  var args = bindings.arguments.map(arg => (0, _toPairs2.default)(arg)[0]);
	  var variables = (0, _toPairs2.default)(bindings.variables);

	  return args.concat(variables).map(binding => ({
	    name: binding[0],
	    path: `${parentName}/${binding[0]}`,
	    contents: binding[1]
	  }));
	}

	// Support dehydrating immutable objects, while ignoring
	// primitive values like strings, numbers...
	function dehydrateValue(value) {
	  if (typeof value == "object" && !!value && value.toJS) {
	    value = value.toJS();
	  }

	  return value;
	}

	function getSpecialVariables(pauseInfo, path) {
	  var thrown = pauseInfo.getIn(["why", "frameFinished", "throw"], undefined);

	  var returned = pauseInfo.getIn(["why", "frameFinished", "return"], undefined);

	  var vars = [];

	  if (thrown !== undefined) {
	    thrown = dehydrateValue(thrown);
	    vars.push({
	      name: "<exception>",
	      path: `${path}/<exception>`,
	      contents: { value: thrown }
	    });
	  }

	  if (returned !== undefined) {
	    returned = dehydrateValue(returned);

	    // Do not display a return value of "undefined",
	    if (!returned || !returned.type || returned.type !== "undefined") {
	      vars.push({
	        name: "<return>",
	        path: `${path}/<return>`,
	        contents: { value: returned }
	      });
	    }
	  }

	  return vars;
	}

	function getThisVariable(frame, path) {
	  var this_ = frame.this;

	  if (!this_) {
	    return null;
	  }

	  return {
	    name: "<this>",
	    path: `${path}/<this>`,
	    contents: { value: this_ }
	  };
	}

	function getScopes(pauseInfo, selectedFrame) {
	  if (!pauseInfo || !selectedFrame) {
	    return null;
	  }

	  var selectedScope = selectedFrame.scope;

	  if (!selectedScope) {
	    return null;
	  }

	  var scopes = [];

	  var scope = selectedScope;
	  var pausedScopeActor = pauseInfo.getIn(["frame", "scope"]).get("actor");

	  do {
	    var type = scope.type;
	    var key = scope.actor;
	    if (type === "function" || type === "block") {
	      var bindings = scope.bindings;
	      var title = void 0;
	      if (type === "function") {
	        title = scope.function.displayName || "(anonymous)";
	      } else {
	        title = L10N.getStr("scopes.block");
	      }

	      var vars = getBindingVariables(bindings, title);

	      // show exception, return, and this variables in innermost scope
	      if (scope.actor === pausedScopeActor) {
	        vars = vars.concat(getSpecialVariables(pauseInfo, key));
	      }

	      if (scope.actor === selectedScope.actor) {
	        var this_ = getThisVariable(selectedFrame, key);

	        if (this_) {
	          vars.push(this_);
	        }
	      }

	      if (vars && vars.length) {
	        vars.sort((a, b) => a.name.localeCompare(b.name));
	        scopes.push({ name: title, path: key, contents: vars });
	      }
	    } else if (type === "object") {
	      var value = scope.object;
	      // If this is the global window scope, mark it as such so that it will
	      // preview Window: Global instead of Window: Window
	      if (value.class === "Window") {
	        value = Object.assign({}, scope.object, { displayClass: "Global" });
	      }
	      scopes.push({
	        name: scope.object.class,
	        path: key,
	        contents: { value }
	      });
	    }
	  } while (scope = scope.parent); // eslint-disable-line no-cond-assign

	  return scopes;
	}

	/**
	 * Returns variables that are visible from this scope.
	 * TODO: returns global variables as well
	 */
	function getVisibleVariablesFromScope(pauseInfo, selectedFrame) {
	  var _ref;

	  var result = new Map();

	  var scopes = getScopes(pauseInfo, selectedFrame);
	  if (!scopes) {
	    return result;
	  }

	  // reverse so that the local variables shadow global variables
	  var scopeContents = scopes.reverse().map(scope => scope.contents);
	  scopeContents = (_ref = []).concat.apply(_ref, _toConsumableArray(scopeContents));

	  scopeContents.forEach(content => {
	    result.set(content.name || null, content);
	  });

	  return result;
	}

	module.exports = {
	  getScopes,
	  getSpecialVariables,
	  getVisibleVariablesFromScope
	};

/***/ },
/* 733 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _react = __webpack_require__(2);

	var _redux = __webpack_require__(3);

	var _reactRedux = __webpack_require__(151);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _utils = __webpack_require__(234);

	var _source = __webpack_require__(233);

	var _function = __webpack_require__(973);

	var _function2 = _interopRequireDefault(_function);

	var _get = __webpack_require__(67);

	var _get2 = _interopRequireDefault(_get);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	var _devtoolsConfig = __webpack_require__(828);

	var _devtoolsLaunchpad = __webpack_require__(131);

	var _clipboard = __webpack_require__(423);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	__webpack_require__(734);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _require = __webpack_require__(242),
	    getFrames = _require.getFrames,
	    getSelectedFrame = _require.getSelectedFrame,
	    getSource = _require.getSource;

	var NUM_FRAMES_SHOWN = 7;

	function renderFrameTitle(_ref) {
	  var displayName = _ref.displayName;

	  var simplifiedDisplaName = (0, _function2.default)(displayName);
	  var truncatedDisplayName = (0, _utils.endTruncateStr)(simplifiedDisplaName, 40);
	  return _react.DOM.div({ className: "title" }, truncatedDisplayName);
	}

	function renderFrameLocation(_ref2) {
	  var source = _ref2.source,
	      location = _ref2.location,
	      library = _ref2.library;

	  var thisSource = source;
	  if (thisSource == null) {
	    return;
	  }

	  if (library) {
	    return _react.DOM.div({ className: "location" }, library, (0, _Svg2.default)(library.toLowerCase(), { className: "annotation-logo" }));
	  }

	  var filename = (0, _source.getFilename)(thisSource);
	  return _react.DOM.div({ className: "location" }, `${filename}: ${location.line}`);
	}

	class Frames extends _react.Component {

	  constructor() {
	    super(...arguments);

	    this.state = {
	      showAllFrames: false
	    };

	    this.renderFrame = this.renderFrame.bind(this);
	    this.toggleFramesDisplay = this.toggleFramesDisplay.bind(this);
	  }

	  shouldComponentUpdate(nextProps, nextState) {
	    var _props = this.props,
	        frames = _props.frames,
	        selectedFrame = _props.selectedFrame;
	    var showAllFrames = this.state.showAllFrames;

	    return frames !== nextProps.frames || selectedFrame !== nextProps.selectedFrame || showAllFrames !== nextState.showAllFrames;
	  }

	  toggleFramesDisplay() {
	    this.setState({
	      showAllFrames: !this.state.showAllFrames
	    });
	  }

	  onContextMenu(event, frame) {
	    var copySourceUrlLabel = L10N.getStr("copySourceUrl");
	    var copySourceUrlKey = L10N.getStr("copySourceUrl.accesskey");

	    event.stopPropagation();
	    event.preventDefault();

	    var menuOptions = [];

	    var source = frame.source;
	    if (source) {
	      var copySourceUrl = {
	        id: "node-menu-copy-source",
	        label: copySourceUrlLabel,
	        accesskey: copySourceUrlKey,
	        disabled: false,
	        click: () => (0, _clipboard.copyToTheClipboard)(source.url)
	      };

	      menuOptions.push(copySourceUrl);
	    }

	    (0, _devtoolsLaunchpad.showMenu)(event, menuOptions);
	  }

	  renderFrame(frame) {
	    var selectedFrame = this.props.selectedFrame;

	    return _react.DOM.li({
	      key: frame.id,
	      className: (0, _classnames2.default)("frame", {
	        selected: selectedFrame && selectedFrame.id === frame.id
	      }),
	      onMouseDown: e => this.onMouseDown(e, frame, selectedFrame),
	      onKeyUp: e => this.onKeyUp(e, frame, selectedFrame),
	      onContextMenu: e => this.onContextMenu(e, frame),
	      tabIndex: 0
	    }, renderFrameTitle(frame), renderFrameLocation(frame));
	  }

	  onMouseDown(e, frame, selectedFrame) {
	    if (e.nativeEvent.which == 3 && selectedFrame.id != frame.id) {
	      return;
	    }
	    this.props.selectFrame(frame);
	  }

	  onKeyUp(event, frame, selectedFrame) {
	    if (event.key != "Enter" || selectedFrame.id == frame.id) {
	      return;
	    }
	    this.props.selectFrame(frame);
	  }

	  renderFrames(frames) {
	    var numFramesToShow = this.state.showAllFrames ? frames.length : NUM_FRAMES_SHOWN;

	    var framesToShow = frames.slice(0, numFramesToShow);

	    return _react.DOM.ul({}, framesToShow.map(this.renderFrame));
	  }

	  renderToggleButton(frames) {
	    var buttonMessage = this.state.showAllFrames ? L10N.getStr("callStack.collapse") : L10N.getStr("callStack.expand");

	    if (frames.length < NUM_FRAMES_SHOWN) {
	      return null;
	    }

	    return _react.DOM.div({ className: "show-more", onClick: this.toggleFramesDisplay }, buttonMessage);
	  }

	  render() {
	    var frames = this.props.frames;


	    if (!frames) {
	      return _react.DOM.div({ className: "pane frames" }, _react.DOM.div({ className: "pane-info empty" }, L10N.getStr("callStack.notPaused")));
	    }

	    return _react.DOM.div({ className: "pane frames" }, this.renderFrames(frames), this.renderToggleButton(frames));
	  }
	}

	Frames.propTypes = {
	  frames: _react.PropTypes.array,
	  selectedFrame: _react.PropTypes.object,
	  selectFrame: _react.PropTypes.func.isRequired
	};

	Frames.displayName = "Frames";

	function getSourceForFrame(state, frame) {
	  return getSource(state, frame.location.sourceId);
	}

	function filterFrameworkFrames(frames) {
	  return (0, _utils.filterDuplicates)(frames, (_ref3) => {
	    var _ref4 = _slicedToArray(_ref3, 2),
	        prev = _ref4[0],
	        item = _ref4[1];

	    return !(prev.library && prev.library == item.library);
	  });
	}

	function annotateFrame(frame) {
	  if (!(0, _devtoolsConfig.isEnabled)("collapseFrame")) {
	    return frame;
	  }
	  var source = frame.source;

	  if (source && source.url && source.url.match(/react/i)) {
	    return Object.assign({}, frame, {
	      library: "React"
	    });
	  }
	  return frame;
	}

	function appendSource(state, frame) {
	  return Object.assign({}, frame, {
	    source: getSourceForFrame(state, frame).toJS()
	  });
	}

	function getAndProcessFrames(state) {
	  var frames = getFrames(state);
	  if (!frames) {
	    return null;
	  }

	  frames = frames.toJS().filter(frame => getSourceForFrame(state, frame)).map(frame => Object.assign({}, frame, {
	    source: getSourceForFrame(state, frame).toJS()
	  })).filter(frame => !(0, _get2.default)(frame, "source.isBlackBoxed")).map(frame => appendSource(state, frame)).map(annotateFrame);
	  frames = filterFrameworkFrames(frames);
	  return frames;
	}

	exports.default = (0, _reactRedux.connect)(state => ({
	  frames: getAndProcessFrames(state),
	  selectedFrame: getSelectedFrame(state)
	}), dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(Frames);

/***/ },
/* 734 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 735 */,
/* 736 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _redux = __webpack_require__(3);

	var _reactRedux = __webpack_require__(151);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	var _Close = __webpack_require__(378);

	var _Close2 = _interopRequireDefault(_Close);

	__webpack_require__(737);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var dom = _react2.default.DOM,
	    PropTypes = _react2.default.PropTypes,
	    Component = _react2.default.Component;


	class EventListeners extends Component {

	  constructor() {
	    super(...arguments);

	    this.renderListener = this.renderListener.bind(this);
	  }

	  renderListener(_ref) {
	    var type = _ref.type,
	        selector = _ref.selector,
	        line = _ref.line,
	        sourceId = _ref.sourceId,
	        breakpoint = _ref.breakpoint;

	    var checked = breakpoint && !breakpoint.disabled;
	    var location = { sourceId, line };

	    return dom.div({
	      className: "listener",
	      onClick: () => this.props.selectSource(sourceId, { line }),
	      key: `${type}.${selector}.${sourceId}.${line}`
	    }, dom.input({
	      type: "checkbox",
	      className: "listener-checkbox",
	      checked,
	      onChange: () => this.handleCheckbox(breakpoint, location)
	    }), dom.span({ className: "type" }, type), dom.span({ className: "selector" }, selector), breakpoint ? (0, _Close2.default)({
	      handleClick: ev => this.removeBreakpoint(ev, breakpoint)
	    }) : "");
	  }

	  handleCheckbox(breakpoint, location) {
	    if (!breakpoint) {
	      return this.props.addBreakpoint(location);
	    }

	    if (breakpoint.loading) {
	      return;
	    }

	    if (breakpoint.disabled) {
	      this.props.enableBreakpoint(breakpoint.location);
	    } else {
	      this.props.disableBreakpoint(breakpoint.location);
	    }
	  }

	  removeBreakpoint(event, breakpoint) {
	    event.stopPropagation();
	    this.props.removeBreakpoint(breakpoint.location);
	  }

	  render() {
	    var listeners = this.props.listeners;

	    return dom.div({
	      className: "pane event-listeners"
	    }, listeners.map(this.renderListener));
	  }
	}

	EventListeners.propTypes = {
	  listeners: PropTypes.array.isRequired,
	  selectSource: PropTypes.func.isRequired,
	  addBreakpoint: PropTypes.func.isRequired,
	  enableBreakpoint: PropTypes.func.isRequired,
	  disableBreakpoint: PropTypes.func.isRequired,
	  removeBreakpoint: PropTypes.func.isRequired
	};

	EventListeners.displayName = "EventListeners";

	exports.default = (0, _reactRedux.connect)(state => {
	  var listeners = (0, _selectors.getEventListeners)(state).map(l => Object.assign({}, l, {
	    breakpoint: (0, _selectors.getBreakpoint)(state, {
	      sourceId: l.sourceId,
	      line: l.line
	    })
	  }));

	  return { listeners };
	}, dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(EventListeners);

/***/ },
/* 737 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 738 */,
/* 739 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	__webpack_require__(740);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	class Accordion extends _react2.default.Component {

	  constructor(props) {
	    super();

	    this.state = {
	      opened: props.items.map(item => item.opened),
	      created: []
	    };

	    var self = this;
	    self.renderContainer = this.renderContainer.bind(this);
	  }

	  componentWillReceiveProps(nextProps) {
	    var newOpened = this.state.opened.map((isOpen, i) => {
	      var shouldOpen = nextProps.items[i].shouldOpen;


	      return isOpen || shouldOpen && shouldOpen();
	    });

	    this.setState({ opened: newOpened });
	  }

	  handleHeaderClick(i) {
	    var opened = [].concat(_toConsumableArray(this.state.opened));
	    var created = [].concat(_toConsumableArray(this.state.created));
	    var item = this.props.items[i];

	    opened[i] = !opened[i];
	    created[i] = true;

	    if (opened[i] && item.onOpened) {
	      item.onOpened();
	    }

	    if (item.onToggle) {
	      item.onToggle(opened[i]);
	    }

	    this.setState({ opened, created });
	  }

	  renderContainer(item, i) {
	    var _state = this.state,
	        opened = _state.opened,
	        created = _state.created;

	    var containerClassName = `${item.header.toLowerCase().replace(/\s/g, "-")}-pane`;

	    return _react.DOM.div({ className: containerClassName, key: i }, _react.DOM.div({ className: "_header", onClick: () => this.handleHeaderClick(i) }, (0, _Svg2.default)("arrow", { className: opened[i] ? "expanded" : "" }), item.header, item.buttons ? _react.DOM.div({ className: "header-buttons" }, item.buttons) : null), created[i] || opened[i] ? _react.DOM.div({
	      className: "_content",
	      style: { display: opened[i] ? "block" : "none" }
	    }, (0, _react.createElement)(item.component, item.componentProps || {})) : null);
	  }

	  render() {
	    return _react.DOM.div({ className: "accordion" }, this.props.items.map(this.renderContainer));
	  }
	}

	Accordion.displayName = "Accordion";

	Accordion.propTypes = {
	  items: _react.PropTypes.array.isRequired
	};

	exports.default = Accordion;

/***/ },
/* 740 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 741 */,
/* 742 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _reactRedux = __webpack_require__(151);

	var _redux = __webpack_require__(3);

	var _selectors = __webpack_require__(242);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	var _reactImmutableProptypes = __webpack_require__(150);

	var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

	var _text = __webpack_require__(389);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	__webpack_require__(743);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _require = __webpack_require__(22),
	    findDOMNode = _require.findDOMNode;

	var _require2 = __webpack_require__(830),
	    appinfo = _require2.Services.appinfo;

	var isMacOS = appinfo.OS === "Darwin";

	var COMMANDS = ["resume", "stepOver", "stepIn", "stepOut"];

	var KEYS = {
	  WINNT: {
	    resume: "F8",
	    pause: "F8",
	    stepOver: "F10",
	    stepIn: "F11",
	    stepOut: "Shift+F11"
	  },
	  Darwin: {
	    resume: "Cmd+\\",
	    pause: "Cmd+\\",
	    stepOver: "Cmd+'",
	    stepIn: "Cmd+;",
	    stepOut: "Cmd+Shift+:",
	    stepOutDisplay: "Cmd+Shift+;"
	  },
	  Linux: {
	    resume: "F8",
	    pause: "F8",
	    stepOver: "F10",
	    stepIn: "Ctrl+F11",
	    stepOut: "Ctrl+Shift+F11"
	  }
	};

	function getKey(action) {
	  return getKeyForOS(appinfo.OS, action);
	}

	function getKeyForOS(os, action) {
	  return KEYS[os][action];
	}

	function formatKey(action) {
	  var key = getKey(`${action}Display`) || getKey(action);
	  if (isMacOS) {
	    var winKey = getKeyForOS("WINNT", `${action}Display`) || getKeyForOS("WINNT", action);
	    // display both Windows type and Mac specific keys
	    return (0, _text.formatKeyShortcut)([key, winKey].join(" "));
	  }
	  return (0, _text.formatKeyShortcut)(key);
	}

	function handlePressAnimation(button) {
	  if (!button) {
	    return;
	  }

	  button.style.opacity = "0";
	  button.style.transform = "scale(1.3)";
	  setTimeout(() => {
	    if (button) {
	      button.style.opacity = "1";
	      button.style.transform = "none";
	    }
	  }, 200);
	}

	function debugBtn(onClick, type, className, tooltip) {
	  var disabled = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

	  className = `${type} ${className}`;
	  return _react.DOM.button({
	    onClick,
	    className,
	    key: type,
	    "aria-label": tooltip,
	    title: tooltip,
	    disabled
	  }, (0, _Svg2.default)(type));
	}

	class CommandBar extends _react.Component {
	  componentWillUnmount() {
	    var shortcuts = this.context.shortcuts;
	    COMMANDS.forEach(action => shortcuts.off(getKey(action)));
	    if (isMacOS) {
	      COMMANDS.forEach(action => shortcuts.off(getKeyForOS("WINNT", action)));
	    }
	  }

	  componentDidMount() {
	    var shortcuts = this.context.shortcuts;

	    COMMANDS.forEach(action => shortcuts.on(getKey(action), (_, e) => this.handleEvent(e, action)));

	    if (isMacOS) {
	      // The Mac supports both the Windows Function keys
	      // as well as the Mac non-Function keys
	      COMMANDS.forEach(action => shortcuts.on(getKeyForOS("WINNT", action), (_, e) => this.handleEvent(e, action)));
	    }
	  }

	  handleEvent(e, action) {
	    e.preventDefault();
	    e.stopPropagation();

	    this.props[action]();
	    var node = findDOMNode(this);
	    if (node instanceof HTMLElement) {
	      handlePressAnimation(node.querySelector(`.${action}`));
	    }
	  }

	  renderStepButtons() {
	    var isPaused = this.props.pause;
	    var className = isPaused ? "active" : "disabled";
	    var isDisabled = !this.props.pause;

	    return [debugBtn(this.props.stepOver, "stepOver", className, L10N.getFormatStr("stepOverTooltip", formatKey("stepOver")), isDisabled), debugBtn(this.props.stepIn, "stepIn", className, L10N.getFormatStr("stepInTooltip", formatKey("stepIn")), isDisabled), debugBtn(this.props.stepOut, "stepOut", className, L10N.getFormatStr("stepOutTooltip", formatKey("stepOut")), isDisabled)];
	  }

	  renderPauseButton() {
	    var _props = this.props,
	        pause = _props.pause,
	        breakOnNext = _props.breakOnNext,
	        isWaitingOnBreak = _props.isWaitingOnBreak;


	    if (pause) {
	      return debugBtn(this.props.resume, "resume", "active", L10N.getFormatStr("resumeButtonTooltip", formatKey("resume")));
	    }

	    if (isWaitingOnBreak) {
	      return debugBtn(null, "pause", "disabled", L10N.getStr("pausePendingButtonTooltip"), true);
	    }

	    return debugBtn(breakOnNext, "pause", "active", L10N.getFormatStr("pauseButtonTooltip", formatKey("pause")));
	  }

	  /*
	   * The pause on exception button has three states in this order:
	   *  1. don't pause on exceptions      [false, false]
	   *  2. pause on uncaught exceptions   [true, true]
	   *  3. pause on all exceptions        [true, false]
	  */
	  renderPauseOnExceptions() {
	    var _props2 = this.props,
	        shouldPauseOnExceptions = _props2.shouldPauseOnExceptions,
	        shouldIgnoreCaughtExceptions = _props2.shouldIgnoreCaughtExceptions,
	        pauseOnExceptions = _props2.pauseOnExceptions;


	    if (!shouldPauseOnExceptions && !shouldIgnoreCaughtExceptions) {
	      return debugBtn(() => pauseOnExceptions(true, true), "pause-exceptions", "enabled", L10N.getStr("ignoreExceptions"));
	    }

	    if (shouldPauseOnExceptions && shouldIgnoreCaughtExceptions) {
	      return debugBtn(() => pauseOnExceptions(true, false), "pause-exceptions", "uncaught enabled", L10N.getStr("pauseOnUncaughtExceptions"));
	    }

	    return debugBtn(() => pauseOnExceptions(false, false), "pause-exceptions", "all enabled", L10N.getStr("pauseOnExceptions"));
	  }

	  render() {
	    return _react.DOM.div({ className: "command-bar" }, this.renderPauseButton(), this.renderStepButtons(), this.renderPauseOnExceptions());
	  }
	}

	CommandBar.propTypes = {
	  sources: _react.PropTypes.object,
	  selectedSource: _react.PropTypes.object,
	  resume: _react.PropTypes.func,
	  stepIn: _react.PropTypes.func,
	  stepOut: _react.PropTypes.func,
	  stepOver: _react.PropTypes.func,
	  breakOnNext: _react.PropTypes.func,
	  pause: _reactImmutableProptypes2.default.map,
	  pauseOnExceptions: _react.PropTypes.func,
	  shouldPauseOnExceptions: _react.PropTypes.bool,
	  shouldIgnoreCaughtExceptions: _react.PropTypes.bool,
	  isWaitingOnBreak: _react.PropTypes.bool
	};

	CommandBar.contextTypes = {
	  shortcuts: _react.PropTypes.object
	};

	CommandBar.displayName = "CommandBar";

	exports.default = (0, _reactRedux.connect)(state => {
	  return {
	    pause: (0, _selectors.getPause)(state),
	    isWaitingOnBreak: (0, _selectors.getIsWaitingOnBreak)(state),
	    shouldPauseOnExceptions: (0, _selectors.getShouldPauseOnExceptions)(state),
	    shouldIgnoreCaughtExceptions: (0, _selectors.getShouldIgnoreCaughtExceptions)(state)
	  };
	}, dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(CommandBar);

/***/ },
/* 743 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 744 */,
/* 745 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 746 */,
/* 747 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _reactRedux = __webpack_require__(151);

	var _redux = __webpack_require__(3);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	var _text = __webpack_require__(389);

	__webpack_require__(748);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var PaneToggleButton = (0, _react.createFactory)(__webpack_require__(428).default);

	class WelcomeBox extends _react.Component {
	  renderToggleButton() {
	    if (this.props.horizontal) {
	      return;
	    }

	    return PaneToggleButton({
	      position: "end",
	      collapsed: !this.props.endPanelCollapsed,
	      horizontal: this.props.horizontal,
	      handleClick: this.props.togglePaneCollapse
	    });
	  }

	  render() {
	    var searchLabel = L10N.getFormatStr("welcome.search", (0, _text.formatKeyShortcut)(`CmdOrCtrl+${L10N.getStr("sources.search.key")}`));
	    return _react.DOM.div({ className: "welcomebox" }, searchLabel, this.renderToggleButton());
	  }
	}

	WelcomeBox.propTypes = {
	  horizontal: _react.PropTypes.bool,
	  togglePaneCollapse: _react.PropTypes.func,
	  endPanelCollapsed: _react.PropTypes.bool
	};

	WelcomeBox.displayName = "WelcomeBox";

	exports.default = (0, _reactRedux.connect)(state => ({
	  endPanelCollapsed: (0, _selectors.getPaneCollapse)(state, "end")
	}), dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(WelcomeBox);

/***/ },
/* 748 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 749 */,
/* 750 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _react = __webpack_require__(2);

	var _reactImmutableProptypes = __webpack_require__(150);

	var _reactImmutableProptypes2 = _interopRequireDefault(_reactImmutableProptypes);

	var _reactRedux = __webpack_require__(151);

	var _redux = __webpack_require__(3);

	var _selectors = __webpack_require__(242);

	var _source = __webpack_require__(233);

	var _classnames = __webpack_require__(175);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _Close = __webpack_require__(378);

	var _Close2 = _interopRequireDefault(_Close);

	var _Svg = __webpack_require__(344);

	var _Svg2 = _interopRequireDefault(_Svg);

	var _devtoolsLaunchpad = __webpack_require__(131);

	var _debounce = __webpack_require__(651);

	var _debounce2 = _interopRequireDefault(_debounce);

	var _text = __webpack_require__(389);

	__webpack_require__(754);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var PaneToggleButton = (0, _react.createFactory)(__webpack_require__(428).default);

	var Dropdown = (0, _react.createFactory)(__webpack_require__(751).default);


	/*
	 * Finds the hidden tabs by comparing the tabs' top offset.
	 * hidden tabs will have a great top offset.
	 *
	 * @param sourceTabs Immutable.list
	 * @param sourceTabEls HTMLCollection
	 *
	 * @returns Immutable.list
	 */
	function getHiddenTabs(sourceTabs, sourceTabEls) {
	  sourceTabEls = [].slice.call(sourceTabEls);
	  function getTopOffset() {
	    var topOffsets = sourceTabEls.map(t => t.getBoundingClientRect().top);
	    return Math.min.apply(Math, _toConsumableArray(topOffsets));
	  }

	  var tabTopOffset = getTopOffset();
	  return sourceTabs.filter((tab, index) => {
	    return sourceTabEls[index].getBoundingClientRect().top > tabTopOffset;
	  });
	}

	/**
	 * Clipboard function taken from
	 * https://dxr.mozilla.org/mozilla-central/source/devtools/shared/platform/content/clipboard.js
	 */
	function copyToTheClipboard(string) {
	  var doCopy = function (e) {
	    e.clipboardData.setData("text/plain", string);
	    e.preventDefault();
	  };

	  document.addEventListener("copy", doCopy);
	  document.execCommand("copy", false, null);
	  document.removeEventListener("copy", doCopy);
	}

	class SourceTabs extends _react.Component {

	  constructor(props) {
	    super(props);
	    this.state = {
	      dropdownShown: false,
	      hiddenSourceTabs: null
	    };

	    this.onTabContextMenu = this.onTabContextMenu.bind(this);
	    this.showContextMenu = this.showContextMenu.bind(this);
	    this.updateHiddenSourceTabs = this.updateHiddenSourceTabs.bind(this);
	    this.toggleSourcesDropdown = this.toggleSourcesDropdown.bind(this);
	    this.renderDropdownSource = this.renderDropdownSource.bind(this);
	    this.renderTabs = this.renderTabs.bind(this);
	    this.renderTab = this.renderTab.bind(this);
	    this.renderNewButton = this.renderNewButton.bind(this);
	    this.renderDropDown = this.renderDropdown.bind(this);
	    this.renderStartPanelToggleButton = this.renderStartPanelToggleButton.bind(this);
	    this.renderEndPanelToggleButton = this.renderEndPanelToggleButton.bind(this);

	    this.onResize = (0, _debounce2.default)(() => {
	      this.updateHiddenSourceTabs();
	    });
	  }

	  componentDidUpdate(prevProps) {
	    if (!(prevProps === this.props)) {
	      this.updateHiddenSourceTabs();
	    }
	  }

	  componentDidMount() {
	    this.updateHiddenSourceTabs();
	    window.addEventListener("resize", this.onResize);
	  }

	  componentWillUnmount() {
	    window.removeEventListener("resize", this.onResize);
	  }

	  onTabContextMenu(event, tab) {
	    event.preventDefault();
	    this.showContextMenu(event, tab);
	  }

	  showContextMenu(e, tab) {
	    var _props = this.props,
	        closeTab = _props.closeTab,
	        closeTabs = _props.closeTabs,
	        sourceTabs = _props.sourceTabs,
	        showSource = _props.showSource,
	        togglePrettyPrint = _props.togglePrettyPrint;


	    var closeTabLabel = L10N.getStr("sourceTabs.closeTab");
	    var closeOtherTabsLabel = L10N.getStr("sourceTabs.closeOtherTabs");
	    var closeTabsToEndLabel = L10N.getStr("sourceTabs.closeTabsToEnd");
	    var closeAllTabsLabel = L10N.getStr("sourceTabs.closeAllTabs");
	    var revealInTreeLabel = L10N.getStr("sourceTabs.revealInTree");
	    var copyLinkLabel = L10N.getStr("sourceTabs.copyLink");
	    var prettyPrintLabel = L10N.getStr("sourceTabs.prettyPrint");

	    var closeTabKey = L10N.getStr("sourceTabs.closeTab.accesskey");
	    var closeOtherTabsKey = L10N.getStr("sourceTabs.closeOtherTabs.accesskey");
	    var closeTabsToEndKey = L10N.getStr("sourceTabs.closeTabsToEnd.accesskey");
	    var closeAllTabsKey = L10N.getStr("sourceTabs.closeAllTabs.accesskey");
	    var revealInTreeKey = L10N.getStr("sourceTabs.revealInTree.accesskey");
	    var copyLinkKey = L10N.getStr("sourceTabs.copyLink.accesskey");
	    var prettyPrintKey = L10N.getStr("sourceTabs.prettyPrint.accesskey");

	    var tabs = sourceTabs.map(t => t.get("id"));
	    var otherTabs = sourceTabs.filter(t => t.get("id") !== tab);
	    var sourceTab = sourceTabs.find(t => t.get("id") == tab);
	    var tabURLs = sourceTabs.map(thisTab => thisTab.get("url"));
	    var otherTabURLs = otherTabs.map(thisTab => thisTab.get("url"));
	    var isPrettySource = (0, _source.isPretty)(sourceTab.toJS());

	    var closeTabMenuItem = {
	      id: "node-menu-close-tab",
	      label: closeTabLabel,
	      accesskey: closeTabKey,
	      disabled: false,
	      click: () => closeTab(sourceTab.get("url"))
	    };

	    var closeOtherTabsMenuItem = {
	      id: "node-menu-close-other-tabs",
	      label: closeOtherTabsLabel,
	      accesskey: closeOtherTabsKey,
	      disabled: false,
	      click: () => closeTabs(otherTabURLs)
	    };

	    var closeTabsToEndMenuItem = {
	      id: "node-menu-close-tabs-to-end",
	      label: closeTabsToEndLabel,
	      accesskey: closeTabsToEndKey,
	      disabled: false,
	      click: () => {
	        var tabIndex = tabs.findIndex(t => t == tab);
	        closeTabs(tabURLs.filter((t, i) => i > tabIndex));
	      }
	    };

	    var closeAllTabsMenuItem = {
	      id: "node-menu-close-all-tabs",
	      label: closeAllTabsLabel,
	      accesskey: closeAllTabsKey,
	      disabled: false,
	      click: () => closeTabs(tabURLs)
	    };

	    var showSourceMenuItem = {
	      id: "node-menu-show-source",
	      label: revealInTreeLabel,
	      accesskey: revealInTreeKey,
	      disabled: false,
	      click: () => showSource(tab)
	    };

	    var copySourceUrl = {
	      id: "node-menu-close-tabs-to-right",
	      label: copyLinkLabel,
	      accesskey: copyLinkKey,
	      disabled: false,
	      click: () => copyToTheClipboard(sourceTab.get("url"))
	    };

	    var prettyPrint = {
	      id: "node-menu-pretty-print",
	      label: prettyPrintLabel,
	      accesskey: prettyPrintKey,
	      disabled: false,
	      click: () => togglePrettyPrint(sourceTab.get("id"))
	    };

	    var items = [{ item: closeTabMenuItem }, { item: closeOtherTabsMenuItem, hidden: () => tabs.size === 1 }, {
	      item: closeTabsToEndMenuItem,
	      hidden: () => tabs.some((t, i) => t === tab && tabs.size - 1 === i)
	    }, { item: closeAllTabsMenuItem }, { item: { type: "separator" } }, { item: copySourceUrl }];

	    if (!isPrettySource) {
	      items.push({ item: showSourceMenuItem });
	      items.push({ item: prettyPrint });
	    }

	    (0, _devtoolsLaunchpad.showMenu)(e, (0, _devtoolsLaunchpad.buildMenu)(items));
	  }

	  /*
	   * Updates the hiddenSourceTabs state, by
	   * finding the source tabs which are wrapped and are not on the top row.
	   */
	  updateHiddenSourceTabs() {
	    if (!this.refs.sourceTabs) {
	      return;
	    }
	    var _props2 = this.props,
	        selectedSource = _props2.selectedSource,
	        sourceTabs = _props2.sourceTabs,
	        selectSource = _props2.selectSource;

	    var sourceTabEls = this.refs.sourceTabs.children;
	    var hiddenSourceTabs = getHiddenTabs(sourceTabs, sourceTabEls);

	    if (hiddenSourceTabs.indexOf(selectedSource) !== -1) {
	      return selectSource(selectedSource.get("id"), { tabIndex: 0 });
	    }

	    this.setState({ hiddenSourceTabs });
	  }

	  toggleSourcesDropdown(e) {
	    this.setState({
	      dropdownShown: !this.state.dropdownShown
	    });
	  }

	  renderDropdownSource(source) {
	    var selectSource = this.props.selectSource;

	    var filename = (0, _source.getFilename)(source.toJS());

	    return _react.DOM.li({
	      key: source.get("id"),
	      onClick: () => {
	        // const tabIndex = getLastVisibleTabIndex(sourceTabs, sourceTabEls);
	        var tabIndex = 0;
	        selectSource(source.get("id"), { tabIndex });
	      }
	    }, filename);
	  }

	  renderTabs() {
	    var sourceTabs = this.props.sourceTabs;
	    return _react.DOM.div({ className: "source-tabs", ref: "sourceTabs" }, sourceTabs.map(this.renderTab));
	  }

	  renderTab(source) {
	    var _props3 = this.props,
	        selectedSource = _props3.selectedSource,
	        selectSource = _props3.selectSource,
	        closeTab = _props3.closeTab;

	    var filename = (0, _source.getFilename)(source.toJS());
	    var active = selectedSource && source.get("id") == selectedSource.get("id");
	    var isPrettyCode = (0, _source.isPretty)(source.toJS());

	    function onClickClose(ev) {
	      ev.stopPropagation();
	      closeTab(source.get("url"));
	    }

	    return _react.DOM.div({
	      className: (0, _classnames2.default)("source-tab", {
	        active,
	        pretty: isPrettyCode
	      }),
	      key: source.get("id"),
	      onClick: () => selectSource(source.get("id")),
	      onContextMenu: e => this.onTabContextMenu(e, source.get("id")),
	      title: (0, _source.getFilename)(source.toJS())
	    }, isPrettyCode ? (0, _Svg2.default)("prettyPrint") : null, _react.DOM.div({ className: "filename" }, filename), (0, _Close2.default)({
	      handleClick: onClickClose,
	      tooltip: L10N.getStr("sourceTabs.closeTabButtonTooltip")
	    }));
	  }

	  renderNewButton() {
	    var newTabTooltip = L10N.getFormatStr("sourceTabs.newTabButtonTooltip", (0, _text.formatKeyShortcut)(`CmdOrCtrl+${L10N.getStr("sources.search.key")}`));
	    return _react.DOM.div({
	      className: "new-tab-btn",
	      onClick: () => this.props.toggleProjectSearch(),
	      title: newTabTooltip
	    }, (0, _Svg2.default)("plus"));
	  }

	  renderDropdown() {
	    var hiddenSourceTabs = this.state.hiddenSourceTabs;
	    if (!hiddenSourceTabs || hiddenSourceTabs.size == 0) {
	      return _react.DOM.div({});
	    }

	    return Dropdown({
	      panel: _react.DOM.ul({}, hiddenSourceTabs.map(this.renderDropdownSource))
	    });
	  }

	  renderStartPanelToggleButton() {
	    return PaneToggleButton({
	      position: "start",
	      collapsed: !this.props.startPanelCollapsed,
	      handleClick: this.props.togglePaneCollapse
	    });
	  }

	  renderEndPanelToggleButton() {
	    if (!this.props.horizontal) {
	      return;
	    }

	    return PaneToggleButton({
	      position: "end",
	      collapsed: !this.props.endPanelCollapsed,
	      handleClick: this.props.togglePaneCollapse,
	      horizontal: this.props.horizontal
	    });
	  }

	  render() {
	    return _react.DOM.div({ className: "source-header" }, this.renderStartPanelToggleButton(), this.renderTabs(), this.renderNewButton(), this.renderDropdown(), this.renderEndPanelToggleButton());
	  }
	}

	SourceTabs.propTypes = {
	  sourceTabs: _reactImmutableProptypes2.default.list.isRequired,
	  selectedSource: _reactImmutableProptypes2.default.map,
	  selectSource: _react.PropTypes.func.isRequired,
	  closeTab: _react.PropTypes.func.isRequired,
	  closeTabs: _react.PropTypes.func.isRequired,
	  toggleProjectSearch: _react.PropTypes.func.isRequired,
	  togglePrettyPrint: _react.PropTypes.func.isRequired,
	  togglePaneCollapse: _react.PropTypes.func.isRequired,
	  showSource: _react.PropTypes.func.isRequired,
	  horizontal: _react.PropTypes.bool.isRequired,
	  startPanelCollapsed: _react.PropTypes.bool.isRequired,
	  endPanelCollapsed: _react.PropTypes.bool.isRequired
	};

	SourceTabs.displayName = "SourceTabs";

	function getTabs(state) {
	  return (0, _selectors.getSourceTabs)(state).map(url => (0, _selectors.getSourceByURL)(state, url));
	}

	module.exports = (0, _reactRedux.connect)(state => {
	  return {
	    selectedSource: (0, _selectors.getSelectedSource)(state),
	    sourceTabs: getTabs(state),
	    searchOn: (0, _selectors.getProjectSearchState)(state)
	  };
	}, dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(SourceTabs);

/***/ },
/* 751 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	__webpack_require__(752);

	class Dropdown extends _react.Component {

	  constructor(props) {
	    super(props);
	    this.state = {
	      dropdownShown: false
	    };

	    this.toggleDropdown = this.toggleDropdown.bind(this);
	    this.renderPanel = this.renderPanel.bind(this);
	    this.renderButton = this.renderButton.bind(this);
	    this.renderMask = this.renderMask.bind(this);
	  }

	  toggleDropdown(e) {
	    this.setState({
	      dropdownShown: !this.state.dropdownShown
	    });
	  }

	  renderPanel() {
	    return _react.DOM.div({
	      className: "dropdown",
	      onClick: this.toggleDropdown,
	      style: { display: this.state.dropdownShown ? "block" : "none" }
	    }, this.props.panel);
	  }

	  renderButton() {
	    return _react.DOM.button({
	      className: "dropdown-button",
	      onClick: this.toggleDropdown
	    }, "»");
	  }

	  renderMask() {
	    return _react.DOM.div({
	      className: "dropdown-mask",
	      onClick: this.toggleDropdown,
	      style: { display: this.state.dropdownShown ? "block" : "none" }
	    });
	  }

	  render() {
	    return _react.DOM.div({ className: "dropdown-block" }, this.renderPanel(), this.renderButton(), this.renderMask());
	  }
	}

	Dropdown.propTypes = {
	  panel: _react.PropTypes.object
	};

	Dropdown.displayName = "Dropdown";

	exports.default = Dropdown;

/***/ },
/* 752 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 753 */,
/* 754 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 755 */,
/* 756 */,
/* 757 */,
/* 758 */,
/* 759 */,
/* 760 */,
/* 761 */,
/* 762 */,
/* 763 */,
/* 764 */,
/* 765 */,
/* 766 */,
/* 767 */,
/* 768 */,
/* 769 */,
/* 770 */,
/* 771 */,
/* 772 */,
/* 773 */,
/* 774 */,
/* 775 */,
/* 776 */,
/* 777 */,
/* 778 */,
/* 779 */,
/* 780 */,
/* 781 */,
/* 782 */,
/* 783 */,
/* 784 */,
/* 785 */,
/* 786 */,
/* 787 */,
/* 788 */,
/* 789 */,
/* 790 */,
/* 791 */,
/* 792 */,
/* 793 */,
/* 794 */,
/* 795 */,
/* 796 */,
/* 797 */,
/* 798 */,
/* 799 */,
/* 800 */,
/* 801 */,
/* 802 */,
/* 803 */,
/* 804 */,
/* 805 */,
/* 806 */,
/* 807 */,
/* 808 */,
/* 809 */,
/* 810 */,
/* 811 */,
/* 812 */,
/* 813 */,
/* 814 */,
/* 815 */,
/* 816 */,
/* 817 */,
/* 818 */,
/* 819 */,
/* 820 */,
/* 821 */,
/* 822 */,
/* 823 */,
/* 824 */,
/* 825 */,
/* 826 */,
/* 827 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _require = __webpack_require__(900),
	    WorkerDispatcher = _require.workerUtils.WorkerDispatcher;

	var dispatcher = new WorkerDispatcher();

	var getSymbols = dispatcher.task("getSymbols");
	var getVariablesInScope = dispatcher.task("getVariablesInScope");
	var resolveToken = dispatcher.task("resolveToken");

	module.exports = {
	  getSymbols,
	  getVariablesInScope,
	  resolveToken,
	  startParserWorker: dispatcher.start.bind(dispatcher),
	  stopParserWorker: dispatcher.stop.bind(dispatcher)
	};

/***/ },
/* 828 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var feature = __webpack_require__(829);

	module.exports = feature;

/***/ },
/* 829 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var pick = __webpack_require__(67);
	var put = __webpack_require__(112);
	var fs = __webpack_require__(118);
	var path = __webpack_require__(119);

	var config = void 0;

	var flag = __webpack_require__(121);

	/**
	 * Gets a config value for a given key
	 * e.g "chrome.webSocketPort"
	 */
	function getValue(key) {
	  return pick(config, key);
	}

	function setValue(key, value) {
	  return put(config, key, value);
	}

	function isEnabled(key) {
	  return config.features && typeof config.features[key] == "object" ? config.features[key].enabled : config.features[key];
	}

	function isDevelopment() {
	  if (isFirefoxPanel()) {
	    // Default to production if compiling for the Firefox panel
	    return ("production") === "development";
	  }
	  return ("production") !== "production";
	}

	function isTesting() {
	  return flag.testing;
	}

	function isFirefoxPanel() {
	  return ("firefox-panel") == "firefox-panel";
	}

	function isApplication() {
	  return ("firefox-panel") == "application";
	}

	function isFirefox() {
	  return (/firefox/i.test(navigator.userAgent)
	  );
	}

	function setConfig(value) {
	  config = value;
	}

	function getConfig() {
	  return config;
	}

	function updateLocalConfig(relativePath) {
	  var localConfigPath = path.resolve(relativePath, "../configs/local.json");
	  try {
	    var output = JSON.stringify(config, null, 2);
	    fs.writeFileSync(localConfigPath, output);
	    return output;
	  } catch (err) {
	    return "{}";
	  }
	}

	module.exports = {
	  isEnabled,
	  getValue,
	  setValue,
	  isDevelopment,
	  isTesting,
	  isFirefoxPanel,
	  isApplication,
	  isFirefox,
	  getConfig,
	  setConfig,
	  updateLocalConfig
	};

/***/ },
/* 830 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppConstants = __webpack_require__(831);
	var clipboardHelper = __webpack_require__(832);
	var DevToolsUtils = __webpack_require__(833);
	var EventEmitter = __webpack_require__(844);
	var FileSaver = __webpack_require__(845);
	var frame = __webpack_require__(846);
	var Menu = __webpack_require__(848);
	var MenuItem = __webpack_require__(849);
	var networkRequest = __webpack_require__(850);
	var PrefsHelper = __webpack_require__(851).PrefsHelper;
	var SearchBox = __webpack_require__(852);
	var Services = __webpack_require__(29);
	var sourceUtils = __webpack_require__(847);
	var SplitBox = __webpack_require__(854);
	var sprintf = __webpack_require__(856).sprintf;
	// const Tabbar = require("./client/shared/components/tabs/tabbar");
	// const TabPanel = require("./client/shared/components/tabs/tabs");
	var Tree = __webpack_require__(857);
	var WebsocketTransport = __webpack_require__(858);
	var workerUtils = __webpack_require__(859);

	var _require = __webpack_require__(860),
	    Chart = _require.Chart;

	var _require2 = __webpack_require__(861),
	    CurlUtils = _require2.CurlUtils;

	var _require3 = __webpack_require__(862),
	    DebuggerClient = _require3.DebuggerClient;

	var _require4 = __webpack_require__(866),
	    DebuggerTransport = _require4.DebuggerTransport;

	var defer = __webpack_require__(871);

	var _require5 = __webpack_require__(872),
	    gDevTools = _require5.gDevTools;

	var _require6 = __webpack_require__(873),
	    HTMLTooltip = _require6.HTMLTooltip;

	var _require7 = __webpack_require__(877),
	    KeyCodes = _require7.KeyCodes;

	var _require8 = __webpack_require__(853),
	    KeyShortcuts = _require8.KeyShortcuts;

	var _require9 = __webpack_require__(878),
	    PluralForm = _require9.PluralForm;

	var _require10 = __webpack_require__(879),
	    setNamedTimeout = _require10.setNamedTimeout;

	var _require11 = __webpack_require__(880),
	    TargetFactory = _require11.TargetFactory;

	var _require12 = __webpack_require__(881),
	    TimelineFront = _require12.TimelineFront;
	// const { LocalizationHelper, localizeMarkup, MultiLocalizationHelper } = require("./shared/l10n");

	module.exports = {
	  AppConstants,
	  Chart,
	  CurlUtils,
	  DebuggerClient,
	  DebuggerTransport,
	  defer,
	  DevToolsUtils,
	  EventEmitter,
	  FileSaver,
	  frame,
	  gDevTools,
	  HTMLTooltip,
	  KeyCodes,
	  KeyShortcuts,
	  Menu,
	  MenuItem,
	  networkRequest,
	  PluralForm,
	  PrefsHelper,
	  SearchBox,
	  Services,
	  setNamedTimeout,
	  sourceUtils,
	  SplitBox,
	  // LocalizationHelper,
	  // localizeMarkup,
	  // MultiLocalizationHelper,
	  sprintf,
	  // Tabbar,
	  // TabPanel,
	  TargetFactory,
	  TimelineFront,
	  Tree,
	  WebsocketTransport,
	  workerUtils,
	  clipboardHelper
	};

/***/ },
/* 831 */
/***/ function(module, exports) {

	"use strict";

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/AppConstants.jsm
	 */

	module.exports = { AppConstants: {} };

/***/ },
/* 832 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * Clipboard function taken from
	 * https://dxr.mozilla.org/mozilla-central/source/devtools/shared/platform/content/clipboard.js
	 */
	function copyString(string) {
	  var doCopy = function (e) {
	    e.clipboardData.setData("text/plain", string);
	    e.preventDefault();
	  };

	  document.addEventListener("copy", doCopy);
	  document.execCommand("copy", false, null);
	  document.removeEventListener("copy", doCopy);
	}

	module.exports = { copyString };

/***/ },
/* 833 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/* General utilities used throughout devtools. */
	var _require = __webpack_require__(834),
	    Ci = _require.Ci,
	    Cu = _require.Cu,
	    Cc = _require.Cc,
	    components = _require.components;

	var promise = __webpack_require__(839);

	var _require2 = __webpack_require__(840),
	    FileUtils = _require2.FileUtils;

	/**
	 * Turn the error |aError| into a string, without fail.
	 */


	exports.safeErrorString = function safeErrorString(aError) {
	  try {
	    var errorString = aError.toString();
	    if (typeof errorString == "string") {
	      // Attempt to attach a stack to |errorString|. If it throws an error, or
	      // isn't a string, don't use it.
	      try {
	        if (aError.stack) {
	          var stack = aError.stack.toString();
	          if (typeof stack == "string") {
	            errorString += "\nStack: " + stack;
	          }
	        }
	      } catch (ee) {}

	      // Append additional line and column number information to the output,
	      // since it might not be part of the stringified error.
	      if (typeof aError.lineNumber == "number" && typeof aError.columnNumber == "number") {
	        errorString += "Line: " + aError.lineNumber + ", column: " + aError.columnNumber;
	      }

	      return errorString;
	    }
	  } catch (ee) {}

	  // We failed to find a good error description, so do the next best thing.
	  return Object.prototype.toString.call(aError);
	};

	/**
	 * Report that |aWho| threw an exception, |aException|.
	 */
	exports.reportException = function reportException(aWho, aException) {
	  var msg = aWho + " threw an exception: " + exports.safeErrorString(aException);

	  console.log(msg);

	  //  if (Cu && console.error) {
	  //    /*
	  //     * Note that the xpcshell test harness registers an observer for
	  //     * console messages, so when we're running tests, this will cause
	  //     * the test to quit.
	  //     */
	  //    console.error(msg);
	  //  }
	};

	/**
	 * Given a handler function that may throw, return an infallible handler
	 * function that calls the fallible handler, and logs any exceptions it
	 * throws.
	 *
	 * @param aHandler function
	 *      A handler function, which may throw.
	 * @param aName string
	 *      A name for aHandler, for use in error messages. If omitted, we use
	 *      aHandler.name.
	 *
	 * (SpiderMonkey does generate good names for anonymous functions, but we
	 * don't have a way to get at them from JavaScript at the moment.)
	 */
	exports.makeInfallible = function makeInfallible(aHandler, aName) {
	  if (!aName) aName = aHandler.name;

	  return function () /* arguments */{
	    // try {
	    return aHandler.apply(this, arguments);
	    // } catch (ex) {
	    //   let who = "Handler function";
	    //   if (aName) {
	    //     who += " " + aName;
	    //   }
	    //   return exports.reportException(who, ex);
	    // }
	  };
	};

	/**
	 * Waits for the next tick in the event loop to execute a callback.
	 */
	exports.executeSoon = function executeSoon(aFn) {
	  setTimeout(aFn, 0);
	};

	/**
	 * Waits for the next tick in the event loop.
	 *
	 * @return Promise
	 *         A promise that is resolved after the next tick in the event loop.
	 */
	exports.waitForTick = function waitForTick() {
	  var deferred = promise.defer();
	  exports.executeSoon(deferred.resolve);
	  return deferred.promise;
	};

	/**
	 * Waits for the specified amount of time to pass.
	 *
	 * @param number aDelay
	 *        The amount of time to wait, in milliseconds.
	 * @return Promise
	 *         A promise that is resolved after the specified amount of time passes.
	 */
	exports.waitForTime = function waitForTime(aDelay) {
	  var deferred = promise.defer();
	  setTimeout(deferred.resolve, aDelay);
	  return deferred.promise;
	};

	/**
	 * Like Array.prototype.forEach, but doesn't cause jankiness when iterating over
	 * very large arrays by yielding to the browser and continuing execution on the
	 * next tick.
	 *
	 * @param Array aArray
	 *        The array being iterated over.
	 * @param Function aFn
	 *        The function called on each item in the array. If a promise is
	 *        returned by this function, iterating over the array will be paused
	 *        until the respective promise is resolved.
	 * @returns Promise
	 *          A promise that is resolved once the whole array has been iterated
	 *          over, and all promises returned by the aFn callback are resolved.
	 */
	exports.yieldingEach = function yieldingEach(aArray, aFn) {
	  var deferred = promise.defer();

	  var i = 0;
	  var len = aArray.length;
	  var outstanding = [deferred.promise];

	  (function loop() {
	    var start = Date.now();

	    while (i < len) {
	      // Don't block the main thread for longer than 16 ms at a time. To
	      // maintain 60fps, you have to render every frame in at least 16ms; we
	      // aren't including time spent in non-JS here, but this is Good
	      // Enough(tm).
	      if (Date.now() - start > 16) {
	        exports.executeSoon(loop);
	        return;
	      }

	      try {
	        outstanding.push(aFn(aArray[i], i++));
	      } catch (e) {
	        deferred.reject(e);
	        return;
	      }
	    }

	    deferred.resolve();
	  })();

	  return promise.all(outstanding);
	};

	/**
	 * Like XPCOMUtils.defineLazyGetter, but with a |this| sensitive getter that
	 * allows the lazy getter to be defined on a prototype and work correctly with
	 * instances.
	 *
	 * @param Object aObject
	 *        The prototype object to define the lazy getter on.
	 * @param String aKey
	 *        The key to define the lazy getter on.
	 * @param Function aCallback
	 *        The callback that will be called to determine the value. Will be
	 *        called with the |this| value of the current instance.
	 */
	exports.defineLazyPrototypeGetter = function defineLazyPrototypeGetter(aObject, aKey, aCallback) {
	  Object.defineProperty(aObject, aKey, {
	    configurable: true,
	    get: function () {
	      var value = aCallback.call(this);

	      Object.defineProperty(this, aKey, {
	        configurable: true,
	        writable: true,
	        value: value
	      });

	      return value;
	    }
	  });
	};

	/**
	 * Safely get the property value from a Debugger.Object for a given key. Walks
	 * the prototype chain until the property is found.
	 *
	 * @param Debugger.Object aObject
	 *        The Debugger.Object to get the value from.
	 * @param String aKey
	 *        The key to look for.
	 * @return Any
	 */
	exports.getProperty = function getProperty(aObj, aKey) {
	  var root = aObj;
	  try {
	    do {
	      var desc = aObj.getOwnPropertyDescriptor(aKey);
	      if (desc) {
	        if ("value" in desc) {
	          return desc.value;
	        }
	        // Call the getter if it's safe.
	        return exports.hasSafeGetter(desc) ? desc.get.call(root).return : undefined;
	      }
	      aObj = aObj.proto;
	    } while (aObj);
	  } catch (e) {
	    // If anything goes wrong report the error and return undefined.
	    exports.reportException("getProperty", e);
	  }
	  return undefined;
	};

	/**
	 * Determines if a descriptor has a getter which doesn't call into JavaScript.
	 *
	 * @param Object aDesc
	 *        The descriptor to check for a safe getter.
	 * @return Boolean
	 *         Whether a safe getter was found.
	 */
	exports.hasSafeGetter = function hasSafeGetter(aDesc) {
	  // Scripted functions that are CCWs will not appear scripted until after
	  // unwrapping.
	  try {
	    var fn = aDesc.get.unwrap();
	    return fn && fn.callable && fn.class == "Function" && fn.script === undefined;
	  } catch (e) {
	    // Avoid exception 'Object in compartment marked as invisible to Debugger'
	    return false;
	  }
	};

	/**
	 * Check if it is safe to read properties and execute methods from the given JS
	 * object. Safety is defined as being protected from unintended code execution
	 * from content scripts (or cross-compartment code).
	 *
	 * See bugs 945920 and 946752 for discussion.
	 *
	 * @type Object aObj
	 *       The object to check.
	 * @return Boolean
	 *         True if it is safe to read properties from aObj, or false otherwise.
	 */
	exports.isSafeJSObject = function isSafeJSObject(aObj) {
	  // If we are running on a worker thread, Cu is not available. In this case,
	  // we always return false, just to be on the safe side.
	  if (isWorker) {
	    return false;
	  }

	  if (Cu.getGlobalForObject(aObj) == Cu.getGlobalForObject(exports.isSafeJSObject)) {
	    return true; // aObj is not a cross-compartment wrapper.
	  }

	  var principal = Cu.getObjectPrincipal(aObj);
	  // if (Services.scriptSecurityManager.isSystemPrincipal(principal)) {
	  //   return true; // allow chrome objects
	  // }

	  return Cu.isXrayWrapper(aObj);
	};

	exports.dumpn = function dumpn(str) {
	  if (exports.dumpn.wantLogging) {
	    console.log("DBG-SERVER: " + str + "\n");
	  }
	};

	// We want wantLogging to be writable. The exports object is frozen by the
	// loader, so define it on dumpn instead.
	exports.dumpn.wantLogging = false;

	/**
	 * A verbose logger for low-level tracing.
	 */
	exports.dumpv = function (msg) {
	  if (exports.dumpv.wantVerbose) {
	    exports.dumpn(msg);
	  }
	};

	// We want wantLogging to be writable. The exports object is frozen by the
	// loader, so define it on dumpn instead.
	exports.dumpv.wantVerbose = false;

	/**
	 * Utility function for updating an object with the properties of
	 * other objects.
	 *
	 * @param aTarget Object
	 *        The object being updated.
	 * @param aNewAttrs Object
	 *        The rest params are objects to update aTarget with. You
	 *        can pass as many as you like.
	 */
	exports.update = function update(aTarget) {
	  for (var _len = arguments.length, aArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    aArgs[_key - 1] = arguments[_key];
	  }

	  for (var attrs of aArgs) {
	    for (var key in attrs) {
	      var desc = Object.getOwnPropertyDescriptor(attrs, key);

	      if (desc) {
	        Object.defineProperty(aTarget, key, desc);
	      }
	    }
	  }

	  return aTarget;
	};

	/**
	 * Utility function for getting the values from an object as an array
	 *
	 * @param aObject Object
	 *        The object to iterate over
	 */
	exports.values = function values(aObject) {
	  return Object.keys(aObject).map(k => aObject[k]);
	};

	/**
	 * Defines a getter on a specified object that will be created upon first use.
	 *
	 * @param aObject
	 *        The object to define the lazy getter on.
	 * @param aName
	 *        The name of the getter to define on aObject.
	 * @param aLambda
	 *        A function that returns what the getter should return.  This will
	 *        only ever be called once.
	 */
	exports.defineLazyGetter = function defineLazyGetter(aObject, aName, aLambda) {
	  Object.defineProperty(aObject, aName, {
	    get: function () {
	      delete aObject[aName];
	      return aObject[aName] = aLambda.apply(aObject);
	    },
	    configurable: true,
	    enumerable: true
	  });
	};

	// DEPRECATED: use DevToolsUtils.assert(condition, message) instead!
	var haveLoggedDeprecationMessage = false;
	exports.dbg_assert = function dbg_assert(cond, e) {
	  if (!haveLoggedDeprecationMessage) {
	    haveLoggedDeprecationMessage = true;
	    var deprecationMessage = "DevToolsUtils.dbg_assert is deprecated! Use DevToolsUtils.assert instead!" + Error().stack;
	    console.log(deprecationMessage);
	    if (typeof console === "object" && console && console.warn) {
	      console.warn(deprecationMessage);
	    }
	  }

	  if (!cond) {
	    return e;
	  }
	};

	var _require3 = __webpack_require__(831),
	    AppConstants = _require3.AppConstants;

	/**
	 * No operation. The empty function.
	 */


	exports.noop = function () {};

	function reallyAssert(condition, message) {
	  if (!condition) {
	    var err = new Error("Assertion failure: " + message);
	    exports.reportException("DevToolsUtils.assert", err);
	    throw err;
	  }
	}

	/**
	 * DevToolsUtils.assert(condition, message)
	 *
	 * @param Boolean condition
	 * @param String message
	 *
	 * Assertions are enabled when any of the following are true:
	 *   - This is a DEBUG_JS_MODULES build
	 *   - This is a DEBUG build
	 *   - DevToolsUtils.testing is set to true
	 *
	 * If assertions are enabled, then `condition` is checked and if false-y, the
	 * assertion failure is logged and then an error is thrown.
	 *
	 * If assertions are not enabled, then this function is a no-op.
	 *
	 * This is an improvement over `dbg_assert`, which doesn't actually cause any
	 * fatal behavior, and is therefore much easier to accidentally ignore.
	 */
	Object.defineProperty(exports, "assert", {
	  get: () => AppConstants.DEBUG || AppConstants.DEBUG_JS_MODULES || undefined.testing ? reallyAssert : exports.noop
	});

	/**
	 * Defines a getter on a specified object for a module.  The module will not
	 * be imported until first use.
	 *
	 * @param aObject
	 *        The object to define the lazy getter on.
	 * @param aName
	 *        The name of the getter to define on aObject for the module.
	 * @param aResource
	 *        The URL used to obtain the module.
	 * @param aSymbol
	 *        The name of the symbol exported by the module.
	 *        This parameter is optional and defaults to aName.
	 */
	exports.defineLazyModuleGetter = function defineLazyModuleGetter(aObject, aName, aResource, aSymbol) {
	  this.defineLazyGetter(aObject, aName, function XPCU_moduleLambda() {
	    var temp = {};
	    Cu.import(aResource, temp);
	    return temp[aSymbol || aName];
	  });
	};

	var _require4 = __webpack_require__(841),
	    NetUtil = _require4.NetUtil;

	var _require5 = __webpack_require__(842),
	    TextDecoder = _require5.TextDecoder,
	    OS = _require5.OS;

	var NetworkHelper = __webpack_require__(843);

	/**
	 * Performs a request to load the desired URL and returns a promise.
	 *
	 * @param aURL String
	 *        The URL we will request.
	 * @param aOptions Object
	 *        An object with the following optional properties:
	 *        - loadFromCache: if false, will bypass the cache and
	 *          always load fresh from the network (default: true)
	 *        - policy: the nsIContentPolicy type to apply when fetching the URL
	 *        - window: the window to get the loadGroup from
	 *        - charset: the charset to use if the channel doesn't provide one
	 * @returns Promise that resolves with an object with the following members on
	 *          success:
	 *           - content: the document at that URL, as a string,
	 *           - contentType: the content type of the document
	 *
	 *          If an error occurs, the promise is rejected with that error.
	 *
	 * XXX: It may be better to use nsITraceableChannel to get to the sources
	 * without relying on caching when we can (not for eval, etc.):
	 * http://www.softwareishard.com/blog/firebug/nsitraceablechannel-intercept-http-traffic/
	 */
	function mainThreadFetch(aURL) {
	  var aOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { loadFromCache: true,
	    policy: Ci.nsIContentPolicy.TYPE_OTHER,
	    window: null,
	    charset: null };

	  // Create a channel.
	  var url = aURL.split(" -> ").pop();
	  var channel = void 0;
	  try {
	    channel = newChannelForURL(url, aOptions);
	  } catch (ex) {
	    return promise.reject(ex);
	  }

	  // Set the channel options.
	  channel.loadFlags = aOptions.loadFromCache ? channel.LOAD_FROM_CACHE : channel.LOAD_BYPASS_CACHE;

	  if (aOptions.window) {
	    // Respect private browsing.
	    channel.loadGroup = aOptions.window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocumentLoader).loadGroup;
	  }

	  var deferred = promise.defer();
	  var onResponse = (stream, status, request) => {
	    if (!components.isSuccessCode(status)) {
	      deferred.reject(new Error(`Failed to fetch ${url}. Code ${status}.`));
	      return;
	    }

	    try {
	      // We cannot use NetUtil to do the charset conversion as if charset
	      // information is not available and our default guess is wrong the method
	      // might fail and we lose the stream data. This means we can't fall back
	      // to using the locale default encoding (bug 1181345).

	      // Read and decode the data according to the locale default encoding.
	      var available = stream.available();
	      var source = NetUtil.readInputStreamToString(stream, available);
	      stream.close();

	      // If the channel or the caller has correct charset information, the
	      // content will be decoded correctly. If we have to fall back to UTF-8 and
	      // the guess is wrong, the conversion fails and convertToUnicode returns
	      // the input unmodified. Essentially we try to decode the data as UTF-8
	      // and if that fails, we use the locale specific default encoding. This is
	      // the best we can do if the source does not provide charset info.
	      var charset = channel.contentCharset || aOptions.charset || "UTF-8";
	      var unicodeSource = NetworkHelper.convertToUnicode(source, charset);

	      deferred.resolve({
	        content: unicodeSource,
	        contentType: request.contentType
	      });
	    } catch (ex) {
	      var uri = request.originalURI;
	      if (ex.name === "NS_BASE_STREAM_CLOSED" && uri instanceof Ci.nsIFileURL) {
	        // Empty files cause NS_BASE_STREAM_CLOSED exception. Use OS.File to
	        // differentiate between empty files and other errors (bug 1170864).
	        // This can be removed when bug 982654 is fixed.

	        uri.QueryInterface(Ci.nsIFileURL);
	        var result = OS.File.read(uri.file.path).then(bytes => {
	          // Convert the bytearray to a String.
	          var decoder = new TextDecoder();
	          var content = decoder.decode(bytes);

	          // We can't detect the contentType without opening a channel
	          // and that failed already. This is the best we can do here.
	          return {
	            content,
	            contentType: "text/plain"
	          };
	        });

	        deferred.resolve(result);
	      } else {
	        deferred.reject(ex);
	      }
	    }
	  };

	  // Open the channel
	  try {
	    NetUtil.asyncFetch(channel, onResponse);
	  } catch (ex) {
	    return promise.reject(ex);
	  }

	  return deferred.promise;
	}

	/**
	 * Opens a channel for given URL. Tries a bit harder than NetUtil.newChannel.
	 *
	 * @param {String} url - The URL to open a channel for.
	 * @param {Object} options - The options object passed to @method fetch.
	 * @return {nsIChannel} - The newly created channel. Throws on failure.
	 */
	function newChannelForURL(url, _ref) {
	  var policy = _ref.policy;

	  var channelOptions = {
	    contentPolicyType: policy,
	    loadUsingSystemPrincipal: true,
	    uri: url
	  };

	  try {
	    return NetUtil.newChannel(channelOptions);
	  } catch (e) {
	    // In the xpcshell tests, the script url is the absolute path of the test
	    // file, which will make a malformed URI error be thrown. Add the file
	    // scheme to see if it helps.
	    channelOptions.uri = "file://" + url;

	    return NetUtil.newChannel(channelOptions);
	  }
	}

	// Fetch is defined differently depending on whether we are on the main thread
	// or a worker thread.
	if (typeof WorkerGlobalScope === "undefined") {
	  // i.e. not in a worker
	  exports.fetch = mainThreadFetch;
	} else {
	  // Services is not available in worker threads, nor is there any other way
	  // to fetch a URL. We need to enlist the help from the main thread here, by
	  // issuing an rpc request, to fetch the URL on our behalf.
	  exports.fetch = function (url, options) {
	    return rpc("fetch", url, options);
	  };
	}

	/**
	 * Returns a promise that is resolved or rejected when all promises have settled
	 * (resolved or rejected).
	 *
	 * This differs from Promise.all, which will reject immediately after the first
	 * rejection, instead of waiting for the remaining promises to settle.
	 *
	 * @param values
	 *        Iterable of promises that may be pending, resolved, or rejected. When
	 *        when all promises have settled (resolved or rejected), the returned
	 *        promise will be resolved or rejected as well.
	 *
	 * @return A new promise that is fulfilled when all values have settled
	 *         (resolved or rejected). Its resolution value will be an array of all
	 *         resolved values in the given order, or undefined if values is an
	 *         empty array. The reject reason will be forwarded from the first
	 *         promise in the list of given promises to be rejected.
	 */
	exports.settleAll = values => {
	  if (values === null || typeof values[Symbol.iterator] != "function") {
	    throw new Error("settleAll() expects an iterable.");
	  }

	  var deferred = promise.defer();

	  values = Array.isArray(values) ? values : [].concat(_toConsumableArray(values));
	  var countdown = values.length;
	  var resolutionValues = new Array(countdown);
	  var rejectionValue = void 0;
	  var rejectionOccurred = false;

	  if (!countdown) {
	    deferred.resolve(resolutionValues);
	    return deferred.promise;
	  }

	  function checkForCompletion() {
	    if (--countdown > 0) {
	      return;
	    }
	    if (!rejectionOccurred) {
	      deferred.resolve(resolutionValues);
	    } else {
	      deferred.reject(rejectionValue);
	    }
	  }

	  var _loop = function (i) {
	    var index = i;
	    var value = values[i];
	    var resolver = result => {
	      resolutionValues[index] = result;
	      checkForCompletion();
	    };
	    var rejecter = error => {
	      if (!rejectionOccurred) {
	        rejectionValue = error;
	        rejectionOccurred = true;
	      }
	      checkForCompletion();
	    };

	    if (value && typeof value.then == "function") {
	      value.then(resolver, rejecter);
	    } else {
	      // Given value is not a promise, forward it as a resolution value.
	      resolver(value);
	    }
	  };

	  for (var i = 0; i < values.length; i++) {
	    _loop(i);
	  }

	  return deferred.promise;
	};

	/**
	 * When the testing flag is set, various behaviors may be altered from
	 * production mode, typically to enable easier testing or enhanced debugging.
	 */
	var testing = false;
	Object.defineProperty(exports, "testing", {
	  get: function () {
	    return testing;
	  },
	  set: function (state) {
	    testing = state;
	  }
	});

	/**
	 * Open the file at the given path for reading.
	 *
	 * @param {String} filePath
	 *
	 * @returns Promise<nsIInputStream>
	 */
	exports.openFileStream = function (filePath) {
	  return new Promise((resolve, reject) => {
	    var uri = NetUtil.newURI(new FileUtils.File(filePath));
	    NetUtil.asyncFetch({ uri, loadUsingSystemPrincipal: true }, (stream, result) => {
	      if (!components.isSuccessCode(result)) {
	        reject(new Error(`Could not open "${filePath}": result = ${result}`));
	        return;
	      }

	      resolve(stream);
	    });
	  });
	};

	exports.isGenerator = function (fn) {
	  if (typeof fn !== "function") {
	    return false;
	  }
	  var proto = Object.getPrototypeOf(fn);
	  if (!proto) {
	    return false;
	  }
	  var ctor = proto.constructor;
	  if (!ctor) {
	    return false;
	  }
	  return ctor.name == "GeneratorFunction";
	};

	exports.isPromise = function (p) {
	  return p && typeof p.then === "function";
	};

	/**
	 * Return true if `thing` is a SavedFrame, false otherwise.
	 */
	exports.isSavedFrame = function (thing) {
	  return Object.prototype.toString.call(thing) === "[object SavedFrame]";
	};

/***/ },
/* 834 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/*
	 * A sham for https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/chrome
	 */

	var _require = __webpack_require__(835),
	    inDOMUtils = _require.inDOMUtils;

	var ourServices = {
	  inIDOMUtils: inDOMUtils,
	  nsIClipboardHelper: {
	    copyString: () => {}
	  },
	  nsIXULChromeRegistry: {
	    isLocaleRTL: () => {
	      return false;
	    }
	  },
	  nsIDOMParser: {}
	};

	module.exports = {
	  Cc: name => {
	    if (typeof console !== "undefined") {}
	    return {
	      getService: name => ourServices[name],
	      createInstance: iface => ourServices[iface]
	    };
	  },
	  CC: (name, iface, method) => {
	    if (typeof console !== "undefined") {}
	    return {};
	  },
	  Ci: {
	    nsIThread: {
	      "DISPATCH_NORMAL": 0,
	      "DISPATCH_SYNC": 1
	    },
	    nsIDOMNode: typeof HTMLElement !== "undefined" ? HTMLElement : null,
	    nsIFocusManager: {
	      MOVEFOCUS_BACKWARD: 2,
	      MOVEFOCUS_FORWARD: 1
	    },
	    nsIDOMKeyEvent: {},
	    nsIDOMCSSRule: { "UNKNOWN_RULE": 0, "STYLE_RULE": 1, "CHARSET_RULE": 2, "IMPORT_RULE": 3, "MEDIA_RULE": 4, "FONT_FACE_RULE": 5, "PAGE_RULE": 6, "KEYFRAMES_RULE": 7, "KEYFRAME_RULE": 8, "MOZ_KEYFRAMES_RULE": 7, "MOZ_KEYFRAME_RULE": 8, "NAMESPACE_RULE": 10, "COUNTER_STYLE_RULE": 11, "SUPPORTS_RULE": 12, "FONT_FEATURE_VALUES_RULE": 14 },
	    inIDOMUtils: "inIDOMUtils",
	    nsIClipboardHelper: "nsIClipboardHelper",
	    nsIXULChromeRegistry: "nsIXULChromeRegistry"
	  },
	  Cu: {
	    reportError: msg => {
	      typeof console !== "undefined" ? console.error(msg) : dump(msg);
	    },
	    callFunctionWithAsyncStack: fn => fn()
	  },
	  Cr: {},
	  components: {
	    isSuccessCode: () => (returnCode & 0x80000000) === 0
	  }
	};

/***/ },
/* 835 */
/***/ function(module, exports, __webpack_require__) {

	// A sham for inDOMUtils.

	"use strict";

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _require = __webpack_require__(836),
	    CSSLexer = _require.CSSLexer;

	var _require2 = __webpack_require__(837),
	    cssColors = _require2.cssColors;

	var _require3 = __webpack_require__(838),
	    cssProperties = _require3.cssProperties;

	var cssRGBMap;

	// From inIDOMUtils.idl.
	var EXCLUDE_SHORTHANDS = 1 << 0;
	var INCLUDE_ALIASES = 1 << 1;
	var TYPE_LENGTH = 0;
	var TYPE_PERCENTAGE = 1;
	var TYPE_COLOR = 2;
	var TYPE_URL = 3;
	var TYPE_ANGLE = 4;
	var TYPE_FREQUENCY = 5;
	var TYPE_TIME = 6;
	var TYPE_GRADIENT = 7;
	var TYPE_TIMING_FUNCTION = 8;
	var TYPE_IMAGE_RECT = 9;
	var TYPE_NUMBER = 10;

	function getCSSLexer(text) {
	  return new CSSLexer(text);
	}

	function rgbToColorName(r, g, b) {
	  if (!cssRGBMap) {
	    cssRGBMap = new Map();
	    for (var name in cssColors) {
	      cssRGBMap.set(JSON.stringify(cssColors[name]), name);
	    }
	  }
	  var value = cssRGBMap.get(JSON.stringify([r, g, b]));
	  if (!value) {
	    throw new Error("no such color");
	  }
	  return value;
	}

	// Taken from dom/tests/mochitest/ajax/mochikit/MochiKit/Color.js
	function _hslValue(n1, n2, hue) {
	  if (hue > 6.0) {
	    hue -= 6.0;
	  } else if (hue < 0.0) {
	    hue += 6.0;
	  }
	  var val;
	  if (hue < 1.0) {
	    val = n1 + (n2 - n1) * hue;
	  } else if (hue < 3.0) {
	    val = n2;
	  } else if (hue < 4.0) {
	    val = n1 + (n2 - n1) * (4.0 - hue);
	  } else {
	    val = n1;
	  }
	  return val;
	}

	// Taken from dom/tests/mochitest/ajax/mochikit/MochiKit/Color.js
	// and then modified.
	function hslToRGB(_ref) {
	  var _ref2 = _slicedToArray(_ref, 3),
	      hue = _ref2[0],
	      saturation = _ref2[1],
	      lightness = _ref2[2];

	  var red;
	  var green;
	  var blue;
	  if (saturation === 0) {
	    red = lightness;
	    green = lightness;
	    blue = lightness;
	  } else {
	    var m2;
	    if (lightness <= 0.5) {
	      m2 = lightness * (1.0 + saturation);
	    } else {
	      m2 = lightness + saturation - lightness * saturation;
	    }
	    var m1 = 2.0 * lightness - m2;
	    var f = _hslValue;
	    var h6 = hue * 6.0;
	    red = f(m1, m2, h6 + 2);
	    green = f(m1, m2, h6);
	    blue = f(m1, m2, h6 - 2);
	  }
	  return [red, green, blue];
	}

	function colorToRGBA(name) {
	  name = name.trim().toLowerCase();
	  if (name in cssColors) {
	    return cssColors[name];
	  }

	  if (name === "transparent") {
	    return [0, 0, 0, 0];
	  }

	  var lexer = getCSSLexer(name);

	  var getToken = function () {
	    while (true) {
	      var token = lexer.nextToken();
	      if (!token || token.tokenType !== "comment" || token.tokenType !== "whitespace") {
	        return token;
	      }
	    }
	  };

	  var requireComma = function (token) {
	    if (token.tokenType !== "symbol" || token.text !== ",") {
	      return null;
	    }
	    return getToken();
	  };

	  var func = getToken();
	  if (!func || func.tokenType !== "function") {
	    return null;
	  }
	  var alpha = false;
	  if (func.text === "rgb" || func.text === "hsl") {
	    // Nothing.
	  } else if (func.text === "rgba" || func.text === "hsla") {
	    alpha = true;
	  } else {
	    return null;
	  }

	  var vals = [];
	  for (var i = 0; i < 3; ++i) {
	    var token = getToken();
	    if (i > 0) {
	      token = requireComma(token);
	    }
	    if (token.tokenType !== "number" || !token.isInteger) {
	      return null;
	    }
	    var num = token.number;
	    if (num < 0) {
	      num = 0;
	    } else if (num > 255) {
	      num = 255;
	    }
	    vals.push(num);
	  }

	  if (func.text === "hsl" || func.text === "hsla") {
	    vals = hslToRGB(vals);
	  }

	  if (alpha) {
	    var _token = requireComma(getToken());
	    if (_token.tokenType !== "number") {
	      return null;
	    }
	    var _num = _token.number;
	    if (_num < 0) {
	      _num = 0;
	    } else if (_num > 1) {
	      _num = 1;
	    }
	    vals.push(_num);
	  } else {
	    vals.push(1);
	  }

	  var parenToken = getToken();
	  if (!parenToken || parenToken.tokenType !== "symbol" || parenToken.text !== ")") {
	    return null;
	  }
	  if (getToken() !== null) {
	    return null;
	  }

	  return vals;
	}

	function isValidCSSColor(name) {
	  return colorToRGBA(name) !== null;
	}

	function isVariable(name) {
	  return name.startsWith("--");
	}

	function cssPropertyIsShorthand(name) {
	  if (isVariable(name)) {
	    return false;
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  return !!cssProperties[name].subproperties;
	}

	function getSubpropertiesForCSSProperty(name) {
	  if (isVariable(name)) {
	    return [name];
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  if ("subproperties" in cssProperties[name]) {
	    return cssProperties[name].subproperties.slice();
	  }
	  return [name];
	}

	function getCSSValuesForProperty(name) {
	  if (isVariable(name)) {
	    return ["initial", "inherit", "unset"];
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  return cssProperties[name].values.slice();
	}

	function getCSSPropertyNames(flags) {
	  var names = Object.keys(cssProperties);
	  if ((flags & EXCLUDE_SHORTHANDS) !== 0) {
	    names = names.filter(name => cssProperties[name].subproperties);
	  }
	  if ((flags & INCLUDE_ALIASES) === 0) {
	    names = names.filter(name => !cssProperties[name].alias);
	  }
	  return names;
	}

	function cssPropertySupportsType(name, type) {
	  if (isVariable(name)) {
	    return false;
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  return (cssProperties[name].supports & 1 << type) !== 0;
	}

	function isInheritedProperty(name) {
	  if (isVariable(name)) {
	    return true;
	  }
	  if (!(name in cssProperties)) {
	    return false;
	  }
	  return cssProperties[name].inherited;
	}

	function cssPropertyIsValid(name, value) {
	  if (isVariable(name)) {
	    return true;
	  }
	  if (!(name in cssProperties)) {
	    return false;
	  }
	  var elt = document.createElement("div");
	  elt.style = name + ":" + value;
	  return elt.style.length > 0;
	}

	exports.inDOMUtils = {
	  getCSSLexer,
	  rgbToColorName,
	  colorToRGBA,
	  isValidCSSColor,
	  cssPropertyIsShorthand,
	  getSubpropertiesForCSSProperty,
	  getCSSValuesForProperty,
	  getCSSPropertyNames,
	  cssPropertySupportsType,
	  isInheritedProperty,
	  cssPropertyIsValid,

	  // Constants.
	  EXCLUDE_SHORTHANDS,
	  INCLUDE_ALIASES,
	  TYPE_LENGTH,
	  TYPE_PERCENTAGE,
	  TYPE_COLOR,
	  TYPE_URL,
	  TYPE_ANGLE,
	  TYPE_FREQUENCY,
	  TYPE_TIME,
	  TYPE_GRADIENT,
	  TYPE_TIMING_FUNCTION,
	  TYPE_IMAGE_RECT,
	  TYPE_NUMBER
	};

/***/ },
/* 836 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	(function (root, factory) {
		// Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
		// Rhino, and plain browser loading.
		if (true) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports !== 'undefined') {
			factory(exports);
		} else {
			factory(root);
		}
	})(undefined, function (exports) {

		function between(num, first, last) {
			return num >= first && num <= last;
		}
		function digit(code) {
			return between(code, 0x30, 0x39);
		}
		function hexdigit(code) {
			return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66);
		}
		function uppercaseletter(code) {
			return between(code, 0x41, 0x5a);
		}
		function lowercaseletter(code) {
			return between(code, 0x61, 0x7a);
		}
		function letter(code) {
			return uppercaseletter(code) || lowercaseletter(code);
		}
		function nonascii(code) {
			return code >= 0x80;
		}
		function namestartchar(code) {
			return letter(code) || nonascii(code) || code == 0x5f;
		}
		function namechar(code) {
			return namestartchar(code) || digit(code) || code == 0x2d;
		}
		function nonprintable(code) {
			return between(code, 0, 8) || code == 0xb || between(code, 0xe, 0x1f) || code == 0x7f;
		}
		function newline(code) {
			return code == 0xa;
		}
		function whitespace(code) {
			return newline(code) || code == 9 || code == 0x20;
		}

		var maximumallowedcodepoint = 0x10ffff;

		var InvalidCharacterError = function (message) {
			this.message = message;
		};
		InvalidCharacterError.prototype = new Error();
		InvalidCharacterError.prototype.name = 'InvalidCharacterError';

		function stringFromCode(code) {
			if (code <= 0xffff) return String.fromCharCode(code);
			// Otherwise, encode astral char as surrogate pair.
			code -= Math.pow(2, 20);
			var lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;
			var trail = code % Math.pow(2, 10) + 0xdc00;
			return String.fromCharCode(lead) + String.fromCharCode(trail);
		}

		function* tokenize(str, options) {
			if (options === undefined) {
				options = {};
			}
			if (options.loc === undefined) {
				options.loc = false;
			}
			if (options.offsets === undefined) {
				options.offsets = false;
			}
			if (options.keepComments === undefined) {
				options.keepComments = false;
			}
			if (options.startOffset === undefined) {
				options.startOffset = 0;
			}

			var i = options.startOffset - 1;
			var code;

			// Line number information.
			var line = 0;
			var column = 0;
			// The only use of lastLineLength is in reconsume().
			var lastLineLength = 0;
			var incrLineno = function () {
				line += 1;
				lastLineLength = column;
				column = 0;
			};
			var locStart = { line: line, column: column };
			var offsetStart = i;

			var codepoint = function (i) {
				if (i >= str.length) {
					return -1;
				}
				return str.charCodeAt(i);
			};
			var next = function (num) {
				if (num === undefined) num = 1;
				if (num > 3) throw "Spec Error: no more than three codepoints of lookahead.";

				var rcode;
				for (var offset = i + 1; num-- > 0; ++offset) {
					rcode = codepoint(offset);
					if (rcode === 0xd && codepoint(offset + 1) === 0xa) {
						++offset;
						rcode = 0xa;
					} else if (rcode === 0xd || rcode === 0xc) {
						rcode = 0xa;
					} else if (rcode === 0x0) {
						rcode = 0xfffd;
					}
				}

				return rcode;
			};
			var consume = function (num) {
				if (num === undefined) num = 1;
				while (num-- > 0) {
					++i;
					code = codepoint(i);
					if (code === 0xd && codepoint(i + 1) === 0xa) {
						++i;
						code = 0xa;
					} else if (code === 0xd || code === 0xc) {
						code = 0xa;
					} else if (code === 0x0) {
						code = 0xfffd;
					}
					if (newline(code)) incrLineno();else column++;
				}
				return true;
			};
			var reconsume = function () {
				i -= 1; // This is ok even in the \r\n case.
				if (newline(code)) {
					line -= 1;
					column = lastLineLength;
				} else {
					column -= 1;
				}
				return true;
			};
			var eof = function (codepoint) {
				if (codepoint === undefined) codepoint = code;
				return codepoint == -1;
			};
			var donothing = function () {};
			var parseerror = function () {
				console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + ".");return true;
			};

			var consumeAToken = function () {
				consume();
				if (!options.keepComments) {
					while (code == 0x2f && next() == 0x2a) {
						consumeAComment();
						consume();
					}
				}
				locStart.line = line;
				locStart.column = column;
				offsetStart = i;
				if (whitespace(code)) {
					while (whitespace(next())) {
						consume();
					}return new WhitespaceToken();
				} else if (code == 0x2f && next() == 0x2a) return consumeAComment();else if (code == 0x22) return consumeAStringToken();else if (code == 0x23) {
					if (namechar(next()) || areAValidEscape(next(1), next(2))) {
						var token = new HashToken();
						if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
							token.type = "id";
							token.tokenType = "id";
						}
						token.value = consumeAName();
						token.text = token.value;
						return token;
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x24) {
					if (next() == 0x3d) {
						consume();
						return new SuffixMatchToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x27) return consumeAStringToken();else if (code == 0x28) return new OpenParenToken();else if (code == 0x29) return new CloseParenToken();else if (code == 0x2a) {
					if (next() == 0x3d) {
						consume();
						return new SubstringMatchToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x2b) {
					if (startsWithANumber()) {
						reconsume();
						return consumeANumericToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x2c) return new CommaToken();else if (code == 0x2d) {
					if (startsWithANumber()) {
						reconsume();
						return consumeANumericToken();
					} else if (next(1) == 0x2d && next(2) == 0x3e) {
						consume(2);
						return new CDCToken();
					} else if (startsWithAnIdentifier()) {
						reconsume();
						return consumeAnIdentlikeToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x2e) {
					if (startsWithANumber()) {
						reconsume();
						return consumeANumericToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x3a) return new ColonToken();else if (code == 0x3b) return new SemicolonToken();else if (code == 0x3c) {
					if (next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {
						consume(3);
						return new CDOToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x40) {
					if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
						return new AtKeywordToken(consumeAName());
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x5b) return new OpenSquareToken();else if (code == 0x5c) {
					if (startsWithAValidEscape()) {
						reconsume();
						return consumeAnIdentlikeToken();
					} else {
						parseerror();
						return new DelimToken(code);
					}
				} else if (code == 0x5d) return new CloseSquareToken();else if (code == 0x5e) {
					if (next() == 0x3d) {
						consume();
						return new PrefixMatchToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x7b) return new OpenCurlyToken();else if (code == 0x7c) {
					if (next() == 0x3d) {
						consume();
						return new DashMatchToken();
						// } else if(next() == 0x7c) {
						// 	consume();
						// 	return new ColumnToken();
					} else {
						return new DelimToken(code);
					}
				} else if (code == 0x7d) return new CloseCurlyToken();else if (code == 0x7e) {
					if (next() == 0x3d) {
						consume();
						return new IncludeMatchToken();
					} else {
						return new DelimToken(code);
					}
				} else if (digit(code)) {
					reconsume();
					return consumeANumericToken();
				} else if (namestartchar(code)) {
					reconsume();
					return consumeAnIdentlikeToken();
				} else if (eof()) return new EOFToken();else return new DelimToken(code);
			};

			var consumeAComment = function () {
				consume();
				var comment = "";
				while (true) {
					consume();
					if (code == 0x2a && next() == 0x2f) {
						consume();
						break;
					} else if (eof()) {
						break;
					}
					comment += stringFromCode(code);
				}
				return new CommentToken(comment);
			};

			var consumeANumericToken = function () {
				var num = consumeANumber();
				var token;
				if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
					token = new DimensionToken();
					token.value = num.value;
					token.repr = num.repr;
					token.type = num.type;
					token.unit = consumeAName();
					token.text = token.unit;
				} else if (next() == 0x25) {
					consume();
					token = new PercentageToken();
					token.value = num.value;
					token.repr = num.repr;
				} else {
					var token = new NumberToken();
					token.value = num.value;
					token.repr = num.repr;
					token.type = num.type;
				}
				token.number = token.value;
				token.isInteger = token.type === "integer";
				// FIXME hasSign
				return token;
			};

			var consumeAnIdentlikeToken = function () {
				var str = consumeAName();
				if (str.toLowerCase() == "url" && next() == 0x28) {
					consume();
					while (whitespace(next(1)) && whitespace(next(2))) {
						consume();
					}if (next() == 0x22 || next() == 0x27 || whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {
						while (whitespace(next())) {
							consume();
						}consume();
						var _str = consumeAStringToken();
						while (whitespace(next())) {
							consume();
						} // The closing paren.
						consume();
						return new URLToken(_str.text);
					} else {
						return consumeAURLToken();
					}
				} else if (next() == 0x28) {
					consume();
					return new FunctionToken(str);
				} else {
					return new IdentToken(str);
				}
			};

			var consumeAStringToken = function (endingCodePoint) {
				if (endingCodePoint === undefined) endingCodePoint = code;
				var string = "";
				while (consume()) {
					if (code == endingCodePoint || eof()) {
						return new StringToken(string);
					} else if (newline(code)) {
						reconsume();
						return new BadStringToken(string);
					} else if (code == 0x5c) {
						if (eof(next())) {
							donothing();
						} else if (newline(next())) {
							consume();
						} else {
							string += stringFromCode(consumeEscape());
						}
					} else {
						string += stringFromCode(code);
					}
				}
			};

			var consumeAURLToken = function () {
				var token = new URLToken("");
				while (whitespace(next())) {
					consume();
				}if (eof(next())) return token;
				while (consume()) {
					if (code == 0x29 || eof()) {
						break;
					} else if (whitespace(code)) {
						while (whitespace(next())) {
							consume();
						}if (next() == 0x29 || eof(next())) {
							consume();
							break;
						} else {
							consumeTheRemnantsOfABadURL();
							return new BadURLToken();
						}
					} else if (code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {
						parseerror();
						consumeTheRemnantsOfABadURL();
						return new BadURLToken();
					} else if (code == 0x5c) {
						if (startsWithAValidEscape()) {
							token.value += stringFromCode(consumeEscape());
						} else {
							parseerror();
							consumeTheRemnantsOfABadURL();
							return new BadURLToken();
						}
					} else {
						token.value += stringFromCode(code);
					}
				}
				token.text = token.value;
				return token;
			};

			var consumeEscape = function () {
				// Assume the the current character is the \
				// and the next code point is not a newline.
				consume();
				if (hexdigit(code)) {
					// Consume 1-6 hex digits
					var digits = [code];
					for (var total = 0; total < 5; total++) {
						if (hexdigit(next())) {
							consume();
							digits.push(code);
						} else {
							break;
						}
					}
					if (whitespace(next())) consume();
					var value = parseInt(digits.map(function (x) {
						return String.fromCharCode(x);
					}).join(''), 16);
					if (value > maximumallowedcodepoint) value = 0xfffd;
					return value;
				} else if (eof()) {
					return 0xfffd;
				} else {
					return code;
				}
			};

			var areAValidEscape = function (c1, c2) {
				if (c1 != 0x5c) return false;
				if (newline(c2)) return false;
				return true;
			};
			var startsWithAValidEscape = function () {
				return areAValidEscape(code, next());
			};

			var wouldStartAnIdentifier = function (c1, c2, c3) {
				if (c1 == 0x2d) {
					return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);
				} else if (namestartchar(c1)) {
					return true;
				} else if (c1 == 0x5c) {
					return areAValidEscape(c1, c2);
				} else {
					return false;
				}
			};
			var startsWithAnIdentifier = function () {
				return wouldStartAnIdentifier(code, next(1), next(2));
			};

			var wouldStartANumber = function (c1, c2, c3) {
				if (c1 == 0x2b || c1 == 0x2d) {
					if (digit(c2)) return true;
					if (c2 == 0x2e && digit(c3)) return true;
					return false;
				} else if (c1 == 0x2e) {
					if (digit(c2)) return true;
					return false;
				} else if (digit(c1)) {
					return true;
				} else {
					return false;
				}
			};
			var startsWithANumber = function () {
				return wouldStartANumber(code, next(1), next(2));
			};

			var consumeAName = function () {
				var result = "";
				while (consume()) {
					if (namechar(code)) {
						result += stringFromCode(code);
					} else if (startsWithAValidEscape()) {
						result += stringFromCode(consumeEscape());
					} else {
						reconsume();
						return result;
					}
				}
			};

			var consumeANumber = function () {
				var repr = [];
				var type = "integer";
				if (next() == 0x2b || next() == 0x2d) {
					consume();
					repr += stringFromCode(code);
				}
				while (digit(next())) {
					consume();
					repr += stringFromCode(code);
				}
				if (next(1) == 0x2e && digit(next(2))) {
					consume();
					repr += stringFromCode(code);
					consume();
					repr += stringFromCode(code);
					type = "number";
					while (digit(next())) {
						consume();
						repr += stringFromCode(code);
					}
				}
				var c1 = next(1),
				    c2 = next(2),
				    c3 = next(3);
				if ((c1 == 0x45 || c1 == 0x65) && digit(c2)) {
					consume();
					repr += stringFromCode(code);
					consume();
					repr += stringFromCode(code);
					type = "number";
					while (digit(next())) {
						consume();
						repr += stringFromCode(code);
					}
				} else if ((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {
					consume();
					repr += stringFromCode(code);
					consume();
					repr += stringFromCode(code);
					consume();
					repr += stringFromCode(code);
					type = "number";
					while (digit(next())) {
						consume();
						repr += stringFromCode(code);
					}
				}
				var value = convertAStringToANumber(repr);
				return { type: type, value: value, repr: repr };
			};

			var convertAStringToANumber = function (string) {
				// CSS's number rules are identical to JS, afaik.
				return +string;
			};

			var consumeTheRemnantsOfABadURL = function () {
				while (consume()) {
					if (code == 0x2d || eof()) {
						return;
					} else if (startsWithAValidEscape()) {
						consumeEscape();
						donothing();
					} else {
						donothing();
					}
				}
			};

			var iterationCount = 0;
			while (!eof(next())) {
				var token = consumeAToken();
				if (options.loc) {
					token.loc = {};
					token.loc.start = { line: locStart.line, column: locStart.column };
					token.loc.end = { line: line, column: column };
				}
				if (options.offsets) {
					token.startOffset = offsetStart;
					token.endOffset = i + 1;
				}
				yield token;
				iterationCount++;
				if (iterationCount > str.length * 2) return "I'm infinite-looping!";
			}
		}

		function CSSParserToken() {
			throw "Abstract Base Class";
		}
		CSSParserToken.prototype.toJSON = function () {
			return { token: this.tokenType };
		};
		CSSParserToken.prototype.toString = function () {
			return this.tokenType;
		};
		CSSParserToken.prototype.toSource = function () {
			return '' + this;
		};

		function BadStringToken(text) {
			this.text = text;
			return this;
		}
		BadStringToken.prototype = Object.create(CSSParserToken.prototype);
		BadStringToken.prototype.tokenType = "bad_string";

		function BadURLToken() {
			return this;
		}
		BadURLToken.prototype = Object.create(CSSParserToken.prototype);
		BadURLToken.prototype.tokenType = "bad_url";

		function WhitespaceToken() {
			return this;
		}
		WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
		WhitespaceToken.prototype.tokenType = "whitespace";
		WhitespaceToken.prototype.toString = function () {
			return "WS";
		};
		WhitespaceToken.prototype.toSource = function () {
			return " ";
		};

		function CDOToken() {
			return this;
		}
		CDOToken.prototype = Object.create(CSSParserToken.prototype);
		CDOToken.prototype.tokenType = "htmlcomment";
		CDOToken.prototype.toSource = function () {
			return "<!--";
		};

		function CDCToken() {
			return this;
		}
		CDCToken.prototype = Object.create(CSSParserToken.prototype);
		CDCToken.prototype.tokenType = "htmlcomment";
		CDCToken.prototype.toSource = function () {
			return "-->";
		};

		function ColonToken() {
			return this;
		}
		ColonToken.prototype = Object.create(CSSParserToken.prototype);
		ColonToken.prototype.tokenType = "symbol";
		ColonToken.prototype.text = ":";

		function SemicolonToken() {
			return this;
		}
		SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
		SemicolonToken.prototype.tokenType = "symbol";
		SemicolonToken.prototype.text = ";";

		function CommaToken() {
			return this;
		}
		CommaToken.prototype = Object.create(CSSParserToken.prototype);
		CommaToken.prototype.tokenType = "symbol";
		CommaToken.prototype.text = ",";

		function GroupingToken() {
			throw "Abstract Base Class";
		}
		GroupingToken.prototype = Object.create(CSSParserToken.prototype);

		function OpenCurlyToken() {
			this.value = "{";this.mirror = "}";return this;
		}
		OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
		OpenCurlyToken.prototype.tokenType = "symbol";
		OpenCurlyToken.prototype.text = "{";

		function CloseCurlyToken() {
			this.value = "}";this.mirror = "{";return this;
		}
		CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
		CloseCurlyToken.prototype.tokenType = "symbol";
		CloseCurlyToken.prototype.text = "}";

		function OpenSquareToken() {
			this.value = "[";this.mirror = "]";return this;
		}
		OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
		OpenSquareToken.prototype.tokenType = "symbol";
		OpenSquareToken.prototype.text = "[";

		function CloseSquareToken() {
			this.value = "]";this.mirror = "[";return this;
		}
		CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
		CloseSquareToken.prototype.tokenType = "symbol";
		CloseSquareToken.prototype.text = "]";

		function OpenParenToken() {
			this.value = "(";this.mirror = ")";return this;
		}
		OpenParenToken.prototype = Object.create(GroupingToken.prototype);
		OpenParenToken.prototype.tokenType = "symbol";
		OpenParenToken.prototype.text = "(";

		function CloseParenToken() {
			this.value = ")";this.mirror = "(";return this;
		}
		CloseParenToken.prototype = Object.create(GroupingToken.prototype);
		CloseParenToken.prototype.tokenType = "symbol";
		CloseParenToken.prototype.text = ")";

		function IncludeMatchToken() {
			return this;
		}
		IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
		IncludeMatchToken.prototype.tokenType = "includes";

		function DashMatchToken() {
			return this;
		}
		DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
		DashMatchToken.prototype.tokenType = "dashmatch";

		function PrefixMatchToken() {
			return this;
		}
		PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
		PrefixMatchToken.prototype.tokenType = "beginsmatch";

		function SuffixMatchToken() {
			return this;
		}
		SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
		SuffixMatchToken.prototype.tokenType = "endsmatch";

		function SubstringMatchToken() {
			return this;
		}
		SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
		SubstringMatchToken.prototype.tokenType = "containsmatch";

		function ColumnToken() {
			return this;
		}
		ColumnToken.prototype = Object.create(CSSParserToken.prototype);
		ColumnToken.prototype.tokenType = "||";

		function EOFToken() {
			return this;
		}
		EOFToken.prototype = Object.create(CSSParserToken.prototype);
		EOFToken.prototype.tokenType = "EOF";
		EOFToken.prototype.toSource = function () {
			return "";
		};

		function DelimToken(code) {
			this.value = stringFromCode(code);
			this.text = this.value;
			return this;
		}
		DelimToken.prototype = Object.create(CSSParserToken.prototype);
		DelimToken.prototype.tokenType = "symbol";
		DelimToken.prototype.toString = function () {
			return "DELIM(" + this.value + ")";
		};
		DelimToken.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.value = this.value;
			return json;
		};
		DelimToken.prototype.toSource = function () {
			if (this.value == "\\") return "\\\n";else return this.value;
		};

		function StringValuedToken() {
			throw "Abstract Base Class";
		}
		StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
		StringValuedToken.prototype.ASCIIMatch = function (str) {
			return this.value.toLowerCase() == str.toLowerCase();
		};
		StringValuedToken.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.value = this.value;
			return json;
		};

		function IdentToken(val) {
			this.value = val;
			this.text = val;
		}
		IdentToken.prototype = Object.create(StringValuedToken.prototype);
		IdentToken.prototype.tokenType = "ident";
		IdentToken.prototype.toString = function () {
			return "IDENT(" + this.value + ")";
		};
		IdentToken.prototype.toSource = function () {
			return escapeIdent(this.value);
		};

		function FunctionToken(val) {
			this.value = val;
			this.text = val;
			this.mirror = ")";
		}
		FunctionToken.prototype = Object.create(StringValuedToken.prototype);
		FunctionToken.prototype.tokenType = "function";
		FunctionToken.prototype.toString = function () {
			return "FUNCTION(" + this.value + ")";
		};
		FunctionToken.prototype.toSource = function () {
			return escapeIdent(this.value) + "(";
		};

		function AtKeywordToken(val) {
			this.value = val;
			this.text = val;
		}
		AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
		AtKeywordToken.prototype.tokenType = "at";
		AtKeywordToken.prototype.toString = function () {
			return "AT(" + this.value + ")";
		};
		AtKeywordToken.prototype.toSource = function () {
			return "@" + escapeIdent(this.value);
		};

		function HashToken(val) {
			this.value = val;
			this.text = val;
			this.type = "unrestricted";
		}
		HashToken.prototype = Object.create(StringValuedToken.prototype);
		HashToken.prototype.tokenType = "hash";
		HashToken.prototype.toString = function () {
			return "HASH(" + this.value + ")";
		};
		HashToken.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.value = this.value;
			json.type = this.type;
			return json;
		};
		HashToken.prototype.toSource = function () {
			if (this.type == "id") {
				return "#" + escapeIdent(this.value);
			} else {
				return "#" + escapeHash(this.value);
			}
		};

		function StringToken(val) {
			this.value = val;
			this.text = val;
		}
		StringToken.prototype = Object.create(StringValuedToken.prototype);
		StringToken.prototype.tokenType = "string";
		StringToken.prototype.toString = function () {
			return '"' + escapeString(this.value) + '"';
		};

		function CommentToken(val) {
			this.value = val;
		}
		CommentToken.prototype = Object.create(StringValuedToken.prototype);
		CommentToken.prototype.tokenType = "comment";
		CommentToken.prototype.toString = function () {
			return '/*' + this.value + '*/';
		};
		CommentToken.prototype.toSource = CommentToken.prototype.toString;

		function URLToken(val) {
			this.value = val;
			this.text = val;
		}
		URLToken.prototype = Object.create(StringValuedToken.prototype);
		URLToken.prototype.tokenType = "url";
		URLToken.prototype.toString = function () {
			return "URL(" + this.value + ")";
		};
		URLToken.prototype.toSource = function () {
			return 'url("' + escapeString(this.value) + '")';
		};

		function NumberToken() {
			this.value = null;
			this.type = "integer";
			this.repr = "";
		}
		NumberToken.prototype = Object.create(CSSParserToken.prototype);
		NumberToken.prototype.tokenType = "number";
		NumberToken.prototype.toString = function () {
			if (this.type == "integer") return "INT(" + this.value + ")";
			return "NUMBER(" + this.value + ")";
		};
		NumberToken.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.value = this.value;
			json.type = this.type;
			json.repr = this.repr;
			return json;
		};
		NumberToken.prototype.toSource = function () {
			return this.repr;
		};

		function PercentageToken() {
			this.value = null;
			this.repr = "";
		}
		PercentageToken.prototype = Object.create(CSSParserToken.prototype);
		PercentageToken.prototype.tokenType = "percentage";
		PercentageToken.prototype.toString = function () {
			return "PERCENTAGE(" + this.value + ")";
		};
		PercentageToken.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.value = this.value;
			json.repr = this.repr;
			return json;
		};
		PercentageToken.prototype.toSource = function () {
			return this.repr + "%";
		};

		function DimensionToken() {
			this.value = null;
			this.type = "integer";
			this.repr = "";
			this.unit = "";
		}
		DimensionToken.prototype = Object.create(CSSParserToken.prototype);
		DimensionToken.prototype.tokenType = "dimension";
		DimensionToken.prototype.toString = function () {
			return "DIM(" + this.value + "," + this.unit + ")";
		};
		DimensionToken.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.value = this.value;
			json.type = this.type;
			json.repr = this.repr;
			json.unit = this.unit;
			return json;
		};
		DimensionToken.prototype.toSource = function () {
			var source = this.repr;
			var unit = escapeIdent(this.unit);
			if (unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 0x30, 0x39))) {
				// Unit is ambiguous with scinot
				// Remove the leading "e", replace with escape.
				unit = "\\65 " + unit.slice(1, unit.length);
			}
			return source + unit;
		};

		function escapeIdent(string) {
			string = '' + string;
			var result = '';
			var firstcode = string.charCodeAt(0);
			for (var i = 0; i < string.length; i++) {
				var code = string.charCodeAt(i);
				if (code === 0x0) {
					throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
				}

				if (between(code, 0x1, 0x1f) || code == 0x7f || i === 0 && between(code, 0x30, 0x39) || i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d) {
					result += '\\' + code.toString(16) + ' ';
				} else if (code >= 0x80 || code == 0x2d || code == 0x5f || between(code, 0x30, 0x39) || between(code, 0x41, 0x5a) || between(code, 0x61, 0x7a)) {
					result += string[i];
				} else {
					result += '\\' + string[i];
				}
			}
			return result;
		}

		function escapeHash(string) {
			// Escapes the contents of "unrestricted"-type hash tokens.
			// Won't preserve the ID-ness of "id"-type hash tokens;
			// use escapeIdent() for that.
			string = '' + string;
			var result = '';
			for (var i = 0; i < string.length; i++) {
				var code = string.charCodeAt(i);
				if (code === 0x0) {
					throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
				}

				if (code >= 0x80 || code == 0x2d || code == 0x5f || between(code, 0x30, 0x39) || between(code, 0x41, 0x5a) || between(code, 0x61, 0x7a)) {
					result += string[i];
				} else {
					result += '\\' + code.toString(16) + ' ';
				}
			}
			return result;
		}

		function escapeString(string) {
			string = '' + string;
			var result = '';
			for (var i = 0; i < string.length; i++) {
				var code = string.charCodeAt(i);

				if (code === 0x0) {
					throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
				}

				if (between(code, 0x1, 0x1f) || code == 0x7f) {
					result += '\\' + code.toString(16) + ' ';
				} else if (code == 0x22 || code == 0x5c) {
					result += '\\' + string[i];
				} else {
					result += string[i];
				}
			}
			return result;
		}

		// Exportation.
		exports.tokenize = tokenize;
		exports.IdentToken = IdentToken;
		exports.FunctionToken = FunctionToken;
		exports.AtKeywordToken = AtKeywordToken;
		exports.HashToken = HashToken;
		exports.StringToken = StringToken;
		exports.BadStringToken = BadStringToken;
		exports.URLToken = URLToken;
		exports.BadURLToken = BadURLToken;
		exports.DelimToken = DelimToken;
		exports.NumberToken = NumberToken;
		exports.PercentageToken = PercentageToken;
		exports.DimensionToken = DimensionToken;
		exports.IncludeMatchToken = IncludeMatchToken;
		exports.DashMatchToken = DashMatchToken;
		exports.PrefixMatchToken = PrefixMatchToken;
		exports.SuffixMatchToken = SuffixMatchToken;
		exports.SubstringMatchToken = SubstringMatchToken;
		exports.ColumnToken = ColumnToken;
		exports.WhitespaceToken = WhitespaceToken;
		exports.CDOToken = CDOToken;
		exports.CDCToken = CDCToken;
		exports.ColonToken = ColonToken;
		exports.SemicolonToken = SemicolonToken;
		exports.CommaToken = CommaToken;
		exports.OpenParenToken = OpenParenToken;
		exports.CloseParenToken = CloseParenToken;
		exports.OpenSquareToken = OpenSquareToken;
		exports.CloseSquareToken = CloseSquareToken;
		exports.OpenCurlyToken = OpenCurlyToken;
		exports.CloseCurlyToken = CloseCurlyToken;
		exports.EOFToken = EOFToken;
		exports.CSSParserToken = CSSParserToken;
		exports.GroupingToken = GroupingToken;

		function TokenStream(tokens) {
			// Assume that tokens is a iterator.
			this.tokens = tokens;
			this.token = undefined;
			this.stored = [];
		}
		TokenStream.prototype.consume = function (num) {
			if (num === undefined) num = 1;
			while (num-- > 0) {
				if (this.stored.length > 0) {
					this.token = this.stored.shift();
				} else {
					var n = this.tokens.next();
					while (!n.done && n.value instanceof CommentToken) {
						n = this.tokens.next();
					}
					if (n.done) {
						this.token = new EOFToken();
						break;
					}
					this.token = n.value;
				}
			}
			//console.log(this.i, this.token);
			return true;
		};
		TokenStream.prototype.next = function () {
			if (this.stored.length === 0) {
				var n = this.tokens.next();
				while (!n.done && n.value instanceof CommentToken) {
					n = this.tokens.next();
				}
				if (n.done) return new EOFToken();
				this.stored.push(n.value);
			}
			return this.stored[0];
		};
		TokenStream.prototype.reconsume = function () {
			this.stored.unshift(this.token);
		};

		function parseerror(s, msg) {
			console.log("Parse error at token " + s.i + ": " + s.token + ".\n" + msg);
			return true;
		}
		function donothing() {
			return true;
		}

		function consumeAListOfRules(s, topLevel) {
			var rules = [];
			var rule;
			while (s.consume()) {
				if (s.token instanceof WhitespaceToken) {
					continue;
				} else if (s.token instanceof EOFToken) {
					return rules;
				} else if (s.token instanceof CDOToken || s.token instanceof CDCToken) {
					if (topLevel == "top-level") continue;
					s.reconsume();
					if (rule = consumeAQualifiedRule(s)) rules.push(rule);
				} else if (s.token instanceof AtKeywordToken) {
					s.reconsume();
					if (rule = consumeAnAtRule(s)) rules.push(rule);
				} else {
					s.reconsume();
					if (rule = consumeAQualifiedRule(s)) rules.push(rule);
				}
			}
		}

		function consumeAnAtRule(s) {
			s.consume();
			var rule = new AtRule(s.token.value);
			while (s.consume()) {
				if (s.token instanceof SemicolonToken || s.token instanceof EOFToken) {
					return rule;
				} else if (s.token instanceof OpenCurlyToken) {
					rule.value = consumeASimpleBlock(s);
					return rule;
				} else {
					s.reconsume();
					rule.prelude.push(consumeAComponentValue(s));
				}
			}
		}

		function consumeAQualifiedRule(s) {
			var rule = new QualifiedRule();
			while (s.consume()) {
				if (s.token instanceof EOFToken) {
					parseerror(s, "Hit EOF when trying to parse the prelude of a qualified rule.");
					return;
				} else if (s.token instanceof OpenCurlyToken) {
					rule.value = consumeASimpleBlock(s);
					return rule;
				} else {
					s.reconsume();
					rule.prelude.push(consumeAComponentValue(s));
				}
			}
		}

		function consumeAListOfDeclarations(s) {
			var decls = [];
			while (s.consume()) {
				if (s.token instanceof WhitespaceToken || s.token instanceof SemicolonToken) {
					donothing();
				} else if (s.token instanceof EOFToken) {
					return decls;
				} else if (s.token instanceof AtKeywordToken) {
					s.reconsume();
					decls.push(consumeAnAtRule(s));
				} else if (s.token instanceof IdentToken) {
					var temp = [s.token];
					while (!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken)) {
						temp.push(consumeAComponentValue(s));
					}var decl;
					if (decl = consumeADeclaration(new TokenStream(temp))) decls.push(decl);
				} else {
					parseerror(s);
					s.reconsume();
					while (!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken)) {
						consumeAComponentValue(s);
					}
				}
			}
		}

		function consumeADeclaration(s) {
			// Assumes that the next input token will be an ident token.
			s.consume();
			var decl = new Declaration(s.token.value);
			while (s.next() instanceof WhitespaceToken) {
				s.consume();
			}if (!(s.next() instanceof ColonToken)) {
				parseerror(s);
				return;
			} else {
				s.consume();
			}
			while (!(s.next() instanceof EOFToken)) {
				decl.value.push(consumeAComponentValue(s));
			}
			var foundImportant = false;
			for (var i = decl.value.length - 1; i >= 0; i--) {
				if (decl.value[i] instanceof WhitespaceToken) {
					continue;
				} else if (decl.value[i] instanceof IdentToken && decl.value[i].ASCIIMatch("important")) {
					foundImportant = true;
				} else if (foundImportant && decl.value[i] instanceof DelimToken && decl.value[i].value == "!") {
					decl.value.splice(i, decl.value.length);
					decl.important = true;
					break;
				} else {
					break;
				}
			}
			return decl;
		}

		function consumeAComponentValue(s) {
			s.consume();
			if (s.token instanceof OpenCurlyToken || s.token instanceof OpenSquareToken || s.token instanceof OpenParenToken) return consumeASimpleBlock(s);
			if (s.token instanceof FunctionToken) return consumeAFunction(s);
			return s.token;
		}

		function consumeASimpleBlock(s) {
			var mirror = s.token.mirror;
			var block = new SimpleBlock(s.token.value);
			block.startToken = s.token;
			while (s.consume()) {
				if (s.token instanceof EOFToken || s.token instanceof GroupingToken && s.token.value == mirror) return block;else {
					s.reconsume();
					block.value.push(consumeAComponentValue(s));
				}
			}
		}

		function consumeAFunction(s) {
			var func = new Func(s.token.value);
			while (s.consume()) {
				if (s.token instanceof EOFToken || s.token instanceof CloseParenToken) return func;else {
					s.reconsume();
					func.value.push(consumeAComponentValue(s));
				}
			}
		}

		function normalizeInput(input) {
			if (typeof input == "string") return new TokenStream(tokenize(input));
			if (input instanceof TokenStream) return input;
			if (typeof input.next == "function") return new TokenStream(input);
			if (input.length !== undefined) return new TokenStream(input[Symbol.iterator]());else throw SyntaxError(input);
		}

		function parseAStylesheet(s) {
			s = normalizeInput(s);
			var sheet = new Stylesheet();
			sheet.value = consumeAListOfRules(s, "top-level");
			return sheet;
		}

		function parseAListOfRules(s) {
			s = normalizeInput(s);
			return consumeAListOfRules(s);
		}

		function parseARule(s) {
			s = normalizeInput(s);
			while (s.next() instanceof WhitespaceToken) {
				s.consume();
			}if (s.next() instanceof EOFToken) throw SyntaxError();
			var rule;
			var startToken = s.next();
			if (startToken instanceof AtKeywordToken) {
				rule = consumeAnAtRule(s);
			} else {
				rule = consumeAQualifiedRule(s);
				if (!rule) throw SyntaxError();
			}
			rule.startToken = startToken;
			rule.endToken = s.token;
			return rule;
		}

		function parseADeclaration(s) {
			s = normalizeInput(s);
			while (s.next() instanceof WhitespaceToken) {
				s.consume();
			}if (!(s.next() instanceof IdentToken)) throw SyntaxError();
			var decl = consumeADeclaration(s);
			if (decl) return decl;else throw SyntaxError();
		}

		function parseAListOfDeclarations(s) {
			s = normalizeInput(s);
			return consumeAListOfDeclarations(s);
		}

		function parseAComponentValue(s) {
			s = normalizeInput(s);
			while (s.next() instanceof WhitespaceToken) {
				s.consume();
			}if (s.next() instanceof EOFToken) throw SyntaxError();
			var val = consumeAComponentValue(s);
			if (!val) throw SyntaxError();
			while (s.next() instanceof WhitespaceToken) {
				s.consume();
			}if (s.next() instanceof EOFToken) return val;
			throw SyntaxError();
		}

		function parseAListOfComponentValues(s) {
			s = normalizeInput(s);
			var vals = [];
			while (true) {
				var val = consumeAComponentValue(s);
				if (val instanceof EOFToken) return vals;else vals.push(val);
			}
		}

		function parseACommaSeparatedListOfComponentValues(s) {
			s = normalizeInput(s);
			var listOfCVLs = [];
			while (true) {
				var vals = [];
				while (true) {
					var val = consumeAComponentValue(s);
					if (val instanceof EOFToken) {
						listOfCVLs.push(vals);
						return listOfCVLs;
					} else if (val instanceof CommaToken) {
						listOfCVLs.push(vals);
						break;
					} else {
						vals.push(val);
					}
				}
			}
		}

		function CSSParserRule() {
			throw "Abstract Base Class";
		}
		CSSParserRule.prototype.toString = function (indent) {
			return JSON.stringify(this, null, indent);
		};
		CSSParserRule.prototype.toJSON = function () {
			return { type: this.type, value: this.value };
		};

		function Stylesheet() {
			this.value = [];
			return this;
		}
		Stylesheet.prototype = Object.create(CSSParserRule.prototype);
		Stylesheet.prototype.type = "STYLESHEET";

		function AtRule(name) {
			this.name = name;
			this.prelude = [];
			this.value = null;
			return this;
		}
		AtRule.prototype = Object.create(CSSParserRule.prototype);
		AtRule.prototype.type = "AT-RULE";
		AtRule.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.name = this.name;
			json.prelude = this.prelude;
			return json;
		};

		function QualifiedRule() {
			this.prelude = [];
			this.value = [];
			return this;
		}
		QualifiedRule.prototype = Object.create(CSSParserRule.prototype);
		QualifiedRule.prototype.type = "QUALIFIED-RULE";
		QualifiedRule.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.prelude = this.prelude;
			return json;
		};

		function Declaration(name) {
			this.name = name;
			this.value = [];
			this.important = false;
			return this;
		}
		Declaration.prototype = Object.create(CSSParserRule.prototype);
		Declaration.prototype.type = "DECLARATION";
		Declaration.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.name = this.name;
			json.important = this.important;
			return json;
		};

		function SimpleBlock(type) {
			this.name = type;
			this.value = [];
			return this;
		}
		SimpleBlock.prototype = Object.create(CSSParserRule.prototype);
		SimpleBlock.prototype.type = "BLOCK";
		SimpleBlock.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.name = this.name;
			return json;
		};

		function Func(name) {
			this.name = name;
			this.value = [];
			return this;
		}
		Func.prototype = Object.create(CSSParserRule.prototype);
		Func.prototype.type = "FUNCTION";
		Func.prototype.toJSON = function () {
			var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
			json.name = this.name;
			return json;
		};

		function CSSLexer(text) {
			this.stream = tokenize(text, {
				loc: true,
				offsets: true,
				keepComments: true
			});
			this.lineNumber = 0;
			this.columnNumber = 0;
			return this;
		}

		CSSLexer.prototype.performEOFFixup = function (input, preserveBackslash) {
			// Just lie for now.
			return "";
		};

		CSSLexer.prototype.nextToken = function () {
			if (!this.stream) {
				return null;
			}
			var v = this.stream.next();
			if (v.done || v.value.tokenType === "EOF") {
				this.stream = null;
				return null;
			}
			this.lineNumber = v.value.loc.start.line;
			this.columnNumber = v.value.loc.start.column;
			return v.value;
		};

		// Exportation.
		exports.CSSParserRule = CSSParserRule;
		exports.Stylesheet = Stylesheet;
		exports.AtRule = AtRule;
		exports.QualifiedRule = QualifiedRule;
		exports.Declaration = Declaration;
		exports.SimpleBlock = SimpleBlock;
		exports.Func = Func;
		exports.parseAStylesheet = parseAStylesheet;
		exports.parseAListOfRules = parseAListOfRules;
		exports.parseARule = parseARule;
		exports.parseADeclaration = parseADeclaration;
		exports.parseAListOfDeclarations = parseAListOfDeclarations;
		exports.parseAComponentValue = parseAComponentValue;
		exports.parseAListOfComponentValues = parseAListOfComponentValues;
		exports.parseACommaSeparatedListOfComponentValues = parseACommaSeparatedListOfComponentValues;
		exports.CSSLexer = CSSLexer;
	});

/***/ },
/* 837 */
/***/ function(module, exports) {

	"use strict";

	// auto-generated from nsColorNameList.h
	var cssColors = {
	  aliceblue: [240, 248, 255],
	  antiquewhite: [250, 235, 215],
	  aqua: [0, 255, 255],
	  aquamarine: [127, 255, 212],
	  azure: [240, 255, 255],
	  beige: [245, 245, 220],
	  bisque: [255, 228, 196],
	  black: [0, 0, 0],
	  blanchedalmond: [255, 235, 205],
	  blue: [0, 0, 255],
	  blueviolet: [138, 43, 226],
	  brown: [165, 42, 42],
	  burlywood: [222, 184, 135],
	  cadetblue: [95, 158, 160],
	  chartreuse: [127, 255, 0],
	  chocolate: [210, 105, 30],
	  coral: [255, 127, 80],
	  cornflowerblue: [100, 149, 237],
	  cornsilk: [255, 248, 220],
	  crimson: [220, 20, 60],
	  cyan: [0, 255, 255],
	  darkblue: [0, 0, 139],
	  darkcyan: [0, 139, 139],
	  darkgoldenrod: [184, 134, 11],
	  darkgray: [169, 169, 169],
	  darkgreen: [0, 100, 0],
	  darkgrey: [169, 169, 169],
	  darkkhaki: [189, 183, 107],
	  darkmagenta: [139, 0, 139],
	  darkolivegreen: [85, 107, 47],
	  darkorange: [255, 140, 0],
	  darkorchid: [153, 50, 204],
	  darkred: [139, 0, 0],
	  darksalmon: [233, 150, 122],
	  darkseagreen: [143, 188, 143],
	  darkslateblue: [72, 61, 139],
	  darkslategray: [47, 79, 79],
	  darkslategrey: [47, 79, 79],
	  darkturquoise: [0, 206, 209],
	  darkviolet: [148, 0, 211],
	  deeppink: [255, 20, 147],
	  deepskyblue: [0, 191, 255],
	  dimgray: [105, 105, 105],
	  dimgrey: [105, 105, 105],
	  dodgerblue: [30, 144, 255],
	  firebrick: [178, 34, 34],
	  floralwhite: [255, 250, 240],
	  forestgreen: [34, 139, 34],
	  fuchsia: [255, 0, 255],
	  gainsboro: [220, 220, 220],
	  ghostwhite: [248, 248, 255],
	  gold: [255, 215, 0],
	  goldenrod: [218, 165, 32],
	  gray: [128, 128, 128],
	  grey: [128, 128, 128],
	  green: [0, 128, 0],
	  greenyellow: [173, 255, 47],
	  honeydew: [240, 255, 240],
	  hotpink: [255, 105, 180],
	  indianred: [205, 92, 92],
	  indigo: [75, 0, 130],
	  ivory: [255, 255, 240],
	  khaki: [240, 230, 140],
	  lavender: [230, 230, 250],
	  lavenderblush: [255, 240, 245],
	  lawngreen: [124, 252, 0],
	  lemonchiffon: [255, 250, 205],
	  lightblue: [173, 216, 230],
	  lightcoral: [240, 128, 128],
	  lightcyan: [224, 255, 255],
	  lightgoldenrodyellow: [250, 250, 210],
	  lightgray: [211, 211, 211],
	  lightgreen: [144, 238, 144],
	  lightgrey: [211, 211, 211],
	  lightpink: [255, 182, 193],
	  lightsalmon: [255, 160, 122],
	  lightseagreen: [32, 178, 170],
	  lightskyblue: [135, 206, 250],
	  lightslategray: [119, 136, 153],
	  lightslategrey: [119, 136, 153],
	  lightsteelblue: [176, 196, 222],
	  lightyellow: [255, 255, 224],
	  lime: [0, 255, 0],
	  limegreen: [50, 205, 50],
	  linen: [250, 240, 230],
	  magenta: [255, 0, 255],
	  maroon: [128, 0, 0],
	  mediumaquamarine: [102, 205, 170],
	  mediumblue: [0, 0, 205],
	  mediumorchid: [186, 85, 211],
	  mediumpurple: [147, 112, 219],
	  mediumseagreen: [60, 179, 113],
	  mediumslateblue: [123, 104, 238],
	  mediumspringgreen: [0, 250, 154],
	  mediumturquoise: [72, 209, 204],
	  mediumvioletred: [199, 21, 133],
	  midnightblue: [25, 25, 112],
	  mintcream: [245, 255, 250],
	  mistyrose: [255, 228, 225],
	  moccasin: [255, 228, 181],
	  navajowhite: [255, 222, 173],
	  navy: [0, 0, 128],
	  oldlace: [253, 245, 230],
	  olive: [128, 128, 0],
	  olivedrab: [107, 142, 35],
	  orange: [255, 165, 0],
	  orangered: [255, 69, 0],
	  orchid: [218, 112, 214],
	  palegoldenrod: [238, 232, 170],
	  palegreen: [152, 251, 152],
	  paleturquoise: [175, 238, 238],
	  palevioletred: [219, 112, 147],
	  papayawhip: [255, 239, 213],
	  peachpuff: [255, 218, 185],
	  peru: [205, 133, 63],
	  pink: [255, 192, 203],
	  plum: [221, 160, 221],
	  powderblue: [176, 224, 230],
	  purple: [128, 0, 128],
	  rebeccapurple: [102, 51, 153],
	  red: [255, 0, 0],
	  rosybrown: [188, 143, 143],
	  royalblue: [65, 105, 225],
	  saddlebrown: [139, 69, 19],
	  salmon: [250, 128, 114],
	  sandybrown: [244, 164, 96],
	  seagreen: [46, 139, 87],
	  seashell: [255, 245, 238],
	  sienna: [160, 82, 45],
	  silver: [192, 192, 192],
	  skyblue: [135, 206, 235],
	  slateblue: [106, 90, 205],
	  slategray: [112, 128, 144],
	  slategrey: [112, 128, 144],
	  snow: [255, 250, 250],
	  springgreen: [0, 255, 127],
	  steelblue: [70, 130, 180],
	  tan: [210, 180, 140],
	  teal: [0, 128, 128],
	  thistle: [216, 191, 216],
	  tomato: [255, 99, 71],
	  turquoise: [64, 224, 208],
	  violet: [238, 130, 238],
	  wheat: [245, 222, 179],
	  white: [255, 255, 255],
	  whitesmoke: [245, 245, 245],
	  yellow: [255, 255, 0],
	  yellowgreen: [154, 205, 50]
	};
	module.exports = { cssColors };

/***/ },
/* 838 */
/***/ function(module, exports) {

	"use strict";

	// auto-generated by means you would rather not know
	var cssProperties = {
	  "-moz-appearance": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-gtk-info-bar", "-moz-mac-disclosure-button-closed", "-moz-mac-disclosure-button-open", "-moz-mac-fullscreen-button", "-moz-mac-help-button", "-moz-mac-vibrancy-dark", "-moz-mac-vibrancy-light", "-moz-win-borderless-glass", "-moz-win-browsertabbar-toolbox", "-moz-win-communications-toolbox", "-moz-win-exclude-glass", "-moz-win-glass", "-moz-win-media-toolbox", "-moz-window-button-box", "-moz-window-button-box-maximized", "-moz-window-button-close", "-moz-window-button-maximize", "-moz-window-button-minimize", "-moz-window-button-restore", "-moz-window-frame-bottom", "-moz-window-frame-left", "-moz-window-frame-right", "-moz-window-titlebar", "-moz-window-titlebar-maximized", "button", "button-arrow-down", "button-arrow-next", "button-arrow-previous", "button-arrow-up", "button-bevel", "button-focus", "caret", "checkbox", "checkbox-container", "checkbox-label", "checkmenuitem", "dialog", "dualbutton", "groupbox", "inherit", "initial", "listbox", "listitem", "menuarrow", "menubar", "menucheckbox", "menuimage", "menuitem", "menuitemtext", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menupopup", "menuradio", "menuseparator", "meterbar", "meterchunk", "none", "number-input", "progressbar", "progressbar-vertical", "progresschunk", "progresschunk-vertical", "radio", "radio-container", "radio-label", "radiomenuitem", "range", "range-thumb", "resizer", "resizerpanel", "scale-horizontal", "scale-vertical", "scalethumb-horizontal", "scalethumb-vertical", "scalethumbend", "scalethumbstart", "scalethumbtick", "scrollbar", "scrollbar-small", "scrollbarbutton-down", "scrollbarbutton-left", "scrollbarbutton-right", "scrollbarbutton-up", "scrollbarthumb-horizontal", "scrollbarthumb-vertical", "scrollbartrack-horizontal", "scrollbartrack-vertical", "searchfield", "separator", "spinner", "spinner-downbutton", "spinner-textfield", "spinner-upbutton", "splitter", "statusbar", "statusbarpanel", "tab", "tab-scroll-arrow-back", "tab-scroll-arrow-forward", "tabpanel", "tabpanels", "textfield", "textfield-multiline", "toolbar", "toolbarbutton", "toolbarbutton-dropdown", "toolbargripper", "toolbox", "tooltip", "treeheader", "treeheadercell", "treeheadersortarrow", "treeitem", "treeline", "treetwisty", "treetwistyopen", "treeview", "unset", "window"]
	  },
	  "-moz-outline-radius-topleft": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-outline-radius-topright": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-outline-radius-bottomright": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-outline-radius-bottomleft": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-tab-size": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "animation-delay": {
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset"]
	  },
	  "animation-direction": {
	    inherited: false,
	    supports: 0,
	    values: ["alternate", "alternate-reverse", "inherit", "initial", "normal", "reverse", "unset"]
	  },
	  "animation-duration": {
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset"]
	  },
	  "animation-fill-mode": {
	    inherited: false,
	    supports: 0,
	    values: ["backwards", "both", "forwards", "inherit", "initial", "none", "unset"]
	  },
	  "animation-iteration-count": {
	    inherited: false,
	    supports: 1024,
	    values: ["infinite", "inherit", "initial", "unset"]
	  },
	  "animation-name": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "none", "unset"]
	  },
	  "animation-play-state": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "paused", "running", "unset"]
	  },
	  "animation-timing-function": {
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset"]
	  },
	  "background-attachment": {
	    inherited: false,
	    supports: 0,
	    values: ["fixed", "inherit", "initial", "local", "scroll", "unset"]
	  },
	  "background-clip": {
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset"]
	  },
	  "background-color": {
	    inherited: false,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "background-image": {
	    inherited: false,
	    supports: 648,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url"]
	  },
	  "background-blend-mode": {
	    inherited: false,
	    supports: 0,
	    values: ["color", "color-burn", "color-dodge", "darken", "difference", "exclusion", "hard-light", "hue", "inherit", "initial", "lighten", "luminosity", "multiply", "normal", "overlay", "saturation", "screen", "soft-light", "unset"]
	  },
	  "background-origin": {
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset"]
	  },
	  "background-position": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "background-repeat": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "no-repeat", "repeat", "repeat-x", "repeat-y", "unset"]
	  },
	  "background-size": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-binding": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url"]
	  },
	  "block-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "border-block-end-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-block-end-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset"]
	  },
	  "border-block-end-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset"]
	  },
	  "border-block-start-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-block-start-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset"]
	  },
	  "border-block-start-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset"]
	  },
	  "border-bottom-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "-moz-border-bottom-colors": {
	    inherited: false,
	    supports: 4,
	    values: ["inherit", "initial", "unset"]
	  },
	  "border-bottom-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset"]
	  },
	  "border-bottom-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset"]
	  },
	  "border-collapse": {
	    inherited: true,
	    supports: 0,
	    values: ["collapse", "inherit", "initial", "separate", "unset"]
	  },
	  "border-image-source": {
	    inherited: false,
	    supports: 648,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url"]
	  },
	  "border-image-slice": {
	    inherited: false,
	    supports: 1026,
	    values: ["inherit", "initial", "unset"]
	  },
	  "border-image-width": {
	    inherited: false,
	    supports: 1027,
	    values: ["inherit", "initial", "unset"]
	  },
	  "border-image-outset": {
	    inherited: false,
	    supports: 1025,
	    values: ["inherit", "initial", "unset"]
	  },
	  "border-image-repeat": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "border-inline-end-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-inline-end-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset"]
	  },
	  "border-inline-end-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset"]
	  },
	  "border-inline-start-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-inline-start-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset"]
	  },
	  "border-inline-start-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset"]
	  },
	  "border-left-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "-moz-border-left-colors": {
	    inherited: false,
	    supports: 4,
	    values: ["inherit", "initial", "unset"]
	  },
	  "border-left-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset"]
	  },
	  "border-left-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset"]
	  },
	  "border-right-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "-moz-border-right-colors": {
	    inherited: false,
	    supports: 4,
	    values: ["inherit", "initial", "unset"]
	  },
	  "border-right-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset"]
	  },
	  "border-right-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset"]
	  },
	  "border-spacing": {
	    inherited: true,
	    supports: 1,
	    values: ["inherit", "initial", "unset"]
	  },
	  "border-top-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "-moz-border-top-colors": {
	    inherited: false,
	    supports: 4,
	    values: ["inherit", "initial", "unset"]
	  },
	  "border-top-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset"]
	  },
	  "border-top-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset"]
	  },
	  "border-top-left-radius": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "border-top-right-radius": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "border-bottom-right-radius": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "border-bottom-left-radius": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "bottom": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "box-decoration-break": {
	    inherited: false,
	    supports: 0,
	    values: ["clone", "inherit", "initial", "slice", "unset"]
	  },
	  "box-shadow": {
	    inherited: false,
	    supports: 5,
	    values: ["inherit", "initial", "unset"]
	  },
	  "box-sizing": {
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset"]
	  },
	  "caption-side": {
	    inherited: true,
	    supports: 0,
	    values: ["bottom", "bottom-outside", "inherit", "initial", "left", "right", "top", "top-outside", "unset"]
	  },
	  "clear": {
	    inherited: false,
	    supports: 0,
	    values: ["both", "inherit", "initial", "inline-end", "inline-start", "left", "none", "right", "unset"]
	  },
	  "clip": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "color": {
	    inherited: true,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "-moz-column-count": {
	    inherited: false,
	    supports: 1024,
	    values: ["auto", "inherit", "initial", "unset"]
	  },
	  "-moz-column-fill": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "balance", "inherit", "initial", "unset"]
	  },
	  "-moz-column-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "-moz-column-gap": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "normal", "unset"]
	  },
	  "-moz-column-rule-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "-moz-column-rule-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset"]
	  },
	  "-moz-column-rule-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset"]
	  },
	  "contain": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "layout", "none", "paint", "strict", "style", "unset"]
	  },
	  "content": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-control-character-visibility": {
	    inherited: true,
	    supports: 0,
	    values: ["hidden", "inherit", "initial", "unset", "visible"]
	  },
	  "counter-increment": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "counter-reset": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "cursor": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "unset"]
	  },
	  "direction": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "ltr", "rtl", "unset"]
	  },
	  "display": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-box", "-moz-deck", "-moz-grid", "-moz-grid-group", "-moz-grid-line", "-moz-groupbox", "-moz-inline-box", "-moz-inline-grid", "-moz-inline-stack", "-moz-popup", "-moz-stack", "block", "contents", "flex", "grid", "inherit", "initial", "inline", "inline-block", "inline-flex", "inline-grid", "inline-table", "list-item", "none", "ruby", "ruby-base", "ruby-base-container", "ruby-text", "ruby-text-container", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "unset"]
	  },
	  "empty-cells": {
	    inherited: true,
	    supports: 0,
	    values: ["hide", "inherit", "initial", "show", "unset"]
	  },
	  "align-content": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "align-items": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "align-self": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "flex-basis": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "flex-direction": {
	    inherited: false,
	    supports: 0,
	    values: ["column", "column-reverse", "inherit", "initial", "row", "row-reverse", "unset"]
	  },
	  "flex-grow": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "flex-shrink": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "flex-wrap": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "nowrap", "unset", "wrap", "wrap-reverse"]
	  },
	  "order": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "justify-content": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "justify-items": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "justify-self": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "float": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "inline-end", "inline-start", "left", "none", "right", "unset"]
	  },
	  "-moz-float-edge": {
	    inherited: false,
	    supports: 0,
	    values: ["content-box", "inherit", "initial", "margin-box", "unset"]
	  },
	  "font-family": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "font-feature-settings": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "font-kerning": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "none", "normal", "unset"]
	  },
	  "font-language-override": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "normal", "unset"]
	  },
	  "font-size": {
	    inherited: true,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "large", "larger", "medium", "small", "smaller", "unset", "x-large", "x-small", "xx-large", "xx-small"]
	  },
	  "font-size-adjust": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "none", "unset"]
	  },
	  "font-stretch": {
	    inherited: true,
	    supports: 0,
	    values: ["condensed", "expanded", "extra-condensed", "extra-expanded", "inherit", "initial", "normal", "semi-condensed", "semi-expanded", "ultra-condensed", "ultra-expanded", "unset"]
	  },
	  "font-style": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "italic", "normal", "oblique", "unset"]
	  },
	  "font-synthesis": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "font-variant-alternates": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "font-variant-caps": {
	    inherited: true,
	    supports: 0,
	    values: ["all-petite-caps", "all-small-caps", "inherit", "initial", "normal", "petite-caps", "small-caps", "titling-caps", "unicase", "unset"]
	  },
	  "font-variant-east-asian": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "font-variant-ligatures": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "font-variant-numeric": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "font-variant-position": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "normal", "sub", "super", "unset"]
	  },
	  "font-weight": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-force-broken-image-icon": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-auto-flow": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-auto-columns": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-auto-rows": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-template-areas": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-template-columns": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-template-rows": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-column-start": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-column-end": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-row-start": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-row-end": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-column-gap": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "grid-row-gap": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "height": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "image-orientation": {
	    inherited: true,
	    supports: 16,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-image-region": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "ime-mode": {
	    inherited: false,
	    supports: 0,
	    values: ["active", "auto", "disabled", "inactive", "inherit", "initial", "normal", "unset"]
	  },
	  "inline-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "left": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "letter-spacing": {
	    inherited: true,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "normal", "unset"]
	  },
	  "line-height": {
	    inherited: true,
	    supports: 1027,
	    values: ["-moz-block-height", "inherit", "initial", "normal", "unset"]
	  },
	  "list-style-image": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url"]
	  },
	  "list-style-position": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "inside", "outside", "unset"]
	  },
	  "list-style-type": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "margin-block-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "margin-block-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "margin-bottom": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "margin-inline-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "margin-inline-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "margin-left": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "margin-right": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "margin-top": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "marker-offset": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "max-block-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "none", "unset"]
	  },
	  "max-height": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "calc", "inherit", "initial", "none", "unset"]
	  },
	  "max-inline-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "calc", "inherit", "initial", "none", "unset"]
	  },
	  "max-width": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "calc", "inherit", "initial", "none", "unset"]
	  },
	  "min-height": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "min-block-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "min-inline-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "min-width": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "mix-blend-mode": {
	    inherited: false,
	    supports: 0,
	    values: ["color", "color-burn", "color-dodge", "darken", "difference", "exclusion", "hard-light", "hue", "inherit", "initial", "lighten", "luminosity", "multiply", "normal", "overlay", "saturation", "screen", "soft-light", "unset"]
	  },
	  "isolation": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "isolate", "unset"]
	  },
	  "object-fit": {
	    inherited: false,
	    supports: 0,
	    values: ["contain", "cover", "fill", "inherit", "initial", "none", "scale-down", "unset"]
	  },
	  "object-position": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "offset-block-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "offset-block-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "offset-inline-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "offset-inline-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "opacity": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-orient": {
	    inherited: false,
	    supports: 0,
	    values: ["block", "horizontal", "inherit", "initial", "inline", "unset", "vertical"]
	  },
	  "outline-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "outline-style": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "dashed", "dotted", "double", "groove", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset"]
	  },
	  "outline-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset"]
	  },
	  "outline-offset": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "overflow-x": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-hidden-unscrollable", "auto", "hidden", "inherit", "initial", "scroll", "unset", "visible"]
	  },
	  "overflow-y": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-hidden-unscrollable", "auto", "hidden", "inherit", "initial", "scroll", "unset", "visible"]
	  },
	  "padding-block-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "padding-block-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "padding-bottom": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "padding-inline-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "padding-inline-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "padding-left": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "padding-right": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "padding-top": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "page-break-after": {
	    inherited: false,
	    supports: 0,
	    values: ["always", "auto", "avoid", "inherit", "initial", "left", "right", "unset"]
	  },
	  "page-break-before": {
	    inherited: false,
	    supports: 0,
	    values: ["always", "auto", "avoid", "inherit", "initial", "left", "right", "unset"]
	  },
	  "page-break-inside": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "avoid", "inherit", "initial", "unset"]
	  },
	  "paint-order": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "pointer-events": {
	    inherited: true,
	    supports: 0,
	    values: ["all", "auto", "fill", "inherit", "initial", "none", "painted", "stroke", "unset", "visible", "visiblefill", "visiblepainted", "visiblestroke"]
	  },
	  "position": {
	    inherited: false,
	    supports: 0,
	    values: ["absolute", "fixed", "inherit", "initial", "relative", "static", "sticky", "unset"]
	  },
	  "quotes": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "resize": {
	    inherited: false,
	    supports: 0,
	    values: ["both", "horizontal", "inherit", "initial", "none", "unset", "vertical"]
	  },
	  "right": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "ruby-align": {
	    inherited: true,
	    supports: 0,
	    values: ["center", "inherit", "initial", "space-around", "space-between", "start", "unset"]
	  },
	  "ruby-position": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "over", "under", "unset"]
	  },
	  "scroll-behavior": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "smooth", "unset"]
	  },
	  "scroll-snap-coordinate": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "scroll-snap-destination": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "scroll-snap-points-x": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "scroll-snap-points-y": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "scroll-snap-type-x": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "mandatory", "none", "proximity", "unset"]
	  },
	  "scroll-snap-type-y": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "mandatory", "none", "proximity", "unset"]
	  },
	  "table-layout": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "fixed", "inherit", "initial", "unset"]
	  },
	  "text-align": {
	    inherited: true,
	    supports: 0,
	    values: ["-moz-center", "-moz-left", "-moz-right", "center", "end", "inherit", "initial", "justify", "left", "right", "start", "unset"]
	  },
	  "-moz-text-align-last": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "center", "end", "inherit", "initial", "justify", "left", "right", "start", "unset"]
	  },
	  "text-decoration-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "text-decoration-line": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "text-decoration-style": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-none", "dashed", "dotted", "double", "inherit", "initial", "solid", "unset", "wavy"]
	  },
	  "text-indent": {
	    inherited: true,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "text-orientation": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "mixed", "sideways", "sideways-right", "unset", "upright"]
	  },
	  "text-overflow": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "text-shadow": {
	    inherited: true,
	    supports: 5,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-text-size-adjust": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "none", "unset"]
	  },
	  "text-transform": {
	    inherited: true,
	    supports: 0,
	    values: ["capitalize", "full-width", "inherit", "initial", "lowercase", "none", "unset", "uppercase"]
	  },
	  "transform": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "transform-box": {
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "fill-box", "inherit", "initial", "unset", "view-box"]
	  },
	  "transform-origin": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "perspective-origin": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "perspective": {
	    inherited: false,
	    supports: 1,
	    values: ["inherit", "initial", "none", "unset"]
	  },
	  "transform-style": {
	    inherited: false,
	    supports: 0,
	    values: ["flat", "inherit", "initial", "preserve-3d", "unset"]
	  },
	  "backface-visibility": {
	    inherited: false,
	    supports: 0,
	    values: ["hidden", "inherit", "initial", "unset", "visible"]
	  },
	  "top": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "transition-delay": {
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset"]
	  },
	  "transition-duration": {
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset"]
	  },
	  "transition-property": {
	    inherited: false,
	    supports: 0,
	    values: ["all", "inherit", "initial", "none", "unset"]
	  },
	  "transition-timing-function": {
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset"]
	  },
	  "unicode-bidi": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-isolate", "-moz-isolate-override", "-moz-plaintext", "bidi-override", "embed", "inherit", "initial", "normal", "unset"]
	  },
	  "-moz-user-focus": {
	    inherited: true,
	    supports: 0,
	    values: ["ignore", "inherit", "initial", "none", "normal", "select-after", "select-all", "select-before", "select-menu", "select-same", "unset"]
	  },
	  "-moz-user-input": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "disabled", "enabled", "inherit", "initial", "none", "unset"]
	  },
	  "-moz-user-modify": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "read-only", "read-write", "unset", "write-only"]
	  },
	  "-moz-user-select": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-all", "-moz-none", "-moz-text", "all", "auto", "element", "elements", "inherit", "initial", "none", "text", "toggle", "tri-state", "unset"]
	  },
	  "vertical-align": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "-moz-middle-with-baseline", "baseline", "bottom", "calc", "inherit", "initial", "middle", "sub", "super", "text-bottom", "text-top", "top", "unset"]
	  },
	  "visibility": {
	    inherited: true,
	    supports: 0,
	    values: ["collapse", "hidden", "inherit", "initial", "unset", "visible"]
	  },
	  "white-space": {
	    inherited: true,
	    supports: 0,
	    values: ["-moz-pre-space", "inherit", "initial", "normal", "nowrap", "pre", "pre-line", "pre-wrap", "unset"]
	  },
	  "width": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "-moz-window-dragging": {
	    inherited: true,
	    supports: 0,
	    values: ["drag", "inherit", "initial", "no-drag", "unset"]
	  },
	  "word-break": {
	    inherited: true,
	    supports: 0,
	    values: ["break-all", "inherit", "initial", "keep-all", "normal", "unset"]
	  },
	  "word-spacing": {
	    inherited: true,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "normal", "unset"]
	  },
	  "word-wrap": {
	    inherited: true,
	    supports: 0,
	    values: ["break-word", "inherit", "initial", "normal", "unset"]
	  },
	  "hyphens": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "manual", "none", "unset"]
	  },
	  "writing-mode": {
	    inherited: true,
	    supports: 0,
	    values: ["horizontal-tb", "inherit", "initial", "lr", "lr-tb", "rl", "rl-tb", "sideways-lr", "sideways-rl", "tb", "tb-rl", "unset", "vertical-lr", "vertical-rl"]
	  },
	  "z-index": {
	    inherited: false,
	    supports: 1024,
	    values: ["auto", "inherit", "initial", "unset"]
	  },
	  "-moz-box-align": {
	    inherited: false,
	    supports: 0,
	    values: ["baseline", "center", "end", "inherit", "initial", "start", "stretch", "unset"]
	  },
	  "-moz-box-direction": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "normal", "reverse", "unset"]
	  },
	  "-moz-box-flex": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-box-orient": {
	    inherited: false,
	    supports: 0,
	    values: ["block-axis", "horizontal", "inherit", "initial", "inline-axis", "unset", "vertical"]
	  },
	  "-moz-box-pack": {
	    inherited: false,
	    supports: 0,
	    values: ["center", "end", "inherit", "initial", "justify", "start", "unset"]
	  },
	  "-moz-box-ordinal-group": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-stack-sizing": {
	    inherited: false,
	    supports: 0,
	    values: ["ignore", "inherit", "initial", "stretch-to-fit", "unset"]
	  },
	  "clip-path": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "unset"]
	  },
	  "clip-rule": {
	    inherited: true,
	    supports: 0,
	    values: ["evenodd", "inherit", "initial", "nonzero", "unset"]
	  },
	  "color-interpolation": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "linearrgb", "srgb", "unset"]
	  },
	  "color-interpolation-filters": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "linearrgb", "srgb", "unset"]
	  },
	  "dominant-baseline": {
	    inherited: false,
	    supports: 0,
	    values: ["alphabetic", "auto", "central", "hanging", "ideographic", "inherit", "initial", "mathematical", "middle", "no-change", "reset-size", "text-after-edge", "text-before-edge", "unset", "use-script"]
	  },
	  "fill": {
	    inherited: true,
	    supports: 12,
	    values: ["inherit", "initial", "unset"]
	  },
	  "fill-opacity": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "fill-rule": {
	    inherited: true,
	    supports: 0,
	    values: ["evenodd", "inherit", "initial", "nonzero", "unset"]
	  },
	  "filter": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "unset"]
	  },
	  "flood-color": {
	    inherited: false,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "flood-opacity": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "image-rendering": {
	    inherited: true,
	    supports: 0,
	    values: ["-moz-crisp-edges", "auto", "inherit", "initial", "optimizequality", "optimizespeed", "unset"]
	  },
	  "lighting-color": {
	    inherited: false,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "marker-end": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url"]
	  },
	  "marker-mid": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url"]
	  },
	  "marker-start": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url"]
	  },
	  "mask": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url"]
	  },
	  "mask-type": {
	    inherited: false,
	    supports: 0,
	    values: ["alpha", "inherit", "initial", "luminance", "unset"]
	  },
	  "shape-rendering": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "crispedges", "geometricprecision", "inherit", "initial", "optimizespeed", "unset"]
	  },
	  "stop-color": {
	    inherited: false,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "stop-opacity": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "stroke": {
	    inherited: true,
	    supports: 12,
	    values: ["inherit", "initial", "unset"]
	  },
	  "stroke-dasharray": {
	    inherited: true,
	    supports: 1027,
	    values: ["inherit", "initial", "unset"]
	  },
	  "stroke-dashoffset": {
	    inherited: true,
	    supports: 1027,
	    values: ["inherit", "initial", "unset"]
	  },
	  "stroke-linecap": {
	    inherited: true,
	    supports: 0,
	    values: ["butt", "inherit", "initial", "round", "square", "unset"]
	  },
	  "stroke-linejoin": {
	    inherited: true,
	    supports: 0,
	    values: ["bevel", "inherit", "initial", "miter", "round", "unset"]
	  },
	  "stroke-miterlimit": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "stroke-opacity": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "stroke-width": {
	    inherited: true,
	    supports: 1027,
	    values: ["inherit", "initial", "unset"]
	  },
	  "text-anchor": {
	    inherited: true,
	    supports: 0,
	    values: ["end", "inherit", "initial", "middle", "start", "unset"]
	  },
	  "text-rendering": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "geometricprecision", "inherit", "initial", "optimizelegibility", "optimizespeed", "unset"]
	  },
	  "vector-effect": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "non-scaling-stroke", "none", "unset"]
	  },
	  "will-change": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-outline-radius": {
	    subproperties: ["-moz-outline-radius-topleft", "-moz-outline-radius-topright", "-moz-outline-radius-bottomright", "-moz-outline-radius-bottomleft"],
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "all": {
	    subproperties: ["-moz-appearance", "-moz-outline-radius-topleft", "-moz-outline-radius-topright", "-moz-outline-radius-bottomright", "-moz-outline-radius-bottomleft", "-moz-tab-size", "-x-system-font", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "background-attachment", "background-clip", "background-color", "background-image", "background-blend-mode", "background-origin", "background-position", "background-repeat", "background-size", "-moz-binding", "block-size", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-bottom-color", "-moz-border-bottom-colors", "border-bottom-style", "border-bottom-width", "border-collapse", "border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-left-color", "-moz-border-left-colors", "border-left-style", "border-left-width", "border-right-color", "-moz-border-right-colors", "border-right-style", "border-right-width", "border-spacing", "border-top-color", "-moz-border-top-colors", "border-top-style", "border-top-width", "border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "caption-side", "clear", "clip", "color", "-moz-column-count", "-moz-column-fill", "-moz-column-width", "-moz-column-gap", "-moz-column-rule-color", "-moz-column-rule-style", "-moz-column-rule-width", "contain", "content", "-moz-control-character-visibility", "counter-increment", "counter-reset", "cursor", "display", "empty-cells", "align-content", "align-items", "align-self", "flex-basis", "flex-direction", "flex-grow", "flex-shrink", "flex-wrap", "order", "justify-content", "justify-items", "justify-self", "float", "-moz-float-edge", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "-moz-osx-font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "-moz-force-broken-image-icon", "grid-auto-flow", "grid-auto-columns", "grid-auto-rows", "grid-template-areas", "grid-template-columns", "grid-template-rows", "grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end", "grid-column-gap", "grid-row-gap", "height", "image-orientation", "-moz-image-region", "ime-mode", "inline-size", "left", "letter-spacing", "line-height", "list-style-image", "list-style-position", "list-style-type", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "marker-offset", "max-block-size", "max-height", "max-inline-size", "max-width", "-moz-min-font-size-ratio", "min-height", "min-block-size", "min-inline-size", "min-width", "mix-blend-mode", "isolation", "object-fit", "object-position", "offset-block-end", "offset-block-start", "offset-inline-end", "offset-inline-start", "opacity", "-moz-orient", "outline-color", "outline-style", "outline-width", "outline-offset", "overflow-clip-box", "overflow-x", "overflow-y", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "page-break-after", "page-break-before", "page-break-inside", "paint-order", "pointer-events", "position", "quotes", "resize", "right", "ruby-align", "ruby-position", "scroll-behavior", "scroll-snap-coordinate", "scroll-snap-destination", "scroll-snap-points-x", "scroll-snap-points-y", "scroll-snap-type-x", "scroll-snap-type-y", "table-layout", "text-align", "-moz-text-align-last", "text-combine-upright", "text-decoration-color", "text-decoration-line", "text-decoration-style", "text-indent", "text-orientation", "text-overflow", "text-shadow", "-moz-text-size-adjust", "text-transform", "transform", "transform-box", "transform-origin", "perspective-origin", "perspective", "transform-style", "backface-visibility", "top", "-moz-top-layer", "touch-action", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "-moz-user-focus", "-moz-user-input", "-moz-user-modify", "-moz-user-select", "vertical-align", "visibility", "white-space", "width", "-moz-window-dragging", "-moz-window-shadow", "word-break", "word-spacing", "word-wrap", "hyphens", "writing-mode", "z-index", "-moz-box-align", "-moz-box-direction", "-moz-box-flex", "-moz-box-orient", "-moz-box-pack", "-moz-box-ordinal-group", "-moz-stack-sizing", "clip-path", "clip-rule", "color-interpolation", "color-interpolation-filters", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "image-rendering", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "mask-type", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-rendering", "vector-effect", "will-change"],
	    inherited: false,
	    supports: 2015,
	    values: ["-moz-all", "-moz-available", "-moz-block-height", "-moz-box", "-moz-calc", "-moz-center", "-moz-crisp-edges", "-moz-deck", "-moz-element", "-moz-fit-content", "-moz-grid", "-moz-grid-group", "-moz-grid-line", "-moz-groupbox", "-moz-gtk-info-bar", "-moz-hidden-unscrollable", "-moz-image-rect", "-moz-inline-box", "-moz-inline-grid", "-moz-inline-stack", "-moz-left", "-moz-linear-gradient", "-moz-mac-disclosure-button-closed", "-moz-mac-disclosure-button-open", "-moz-mac-fullscreen-button", "-moz-mac-help-button", "-moz-mac-vibrancy-dark", "-moz-mac-vibrancy-light", "-moz-max-content", "-moz-middle-with-baseline", "-moz-min-content", "-moz-none", "-moz-popup", "-moz-pre-space", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "-moz-right", "-moz-stack", "-moz-text", "-moz-use-text-color", "-moz-win-borderless-glass", "-moz-win-browsertabbar-toolbox", "-moz-win-communications-toolbox", "-moz-win-exclude-glass", "-moz-win-glass", "-moz-win-media-toolbox", "-moz-window-button-box", "-moz-window-button-box-maximized", "-moz-window-button-close", "-moz-window-button-maximize", "-moz-window-button-minimize", "-moz-window-button-restore", "-moz-window-frame-bottom", "-moz-window-frame-left", "-moz-window-frame-right", "-moz-window-titlebar", "-moz-window-titlebar-maximized", "absolute", "active", "aliceblue", "all", "all-petite-caps", "all-small-caps", "alpha", "alphabetic", "alternate", "alternate-reverse", "always", "antiquewhite", "aqua", "aquamarine", "auto", "avoid", "azure", "backwards", "balance", "baseline", "beige", "bevel", "bisque", "black", "blanchedalmond", "block", "block-axis", "blue", "blueviolet", "border-box", "both", "bottom", "bottom-outside", "break-all", "break-word", "brown", "burlywood", "butt", "button", "button-arrow-down", "button-arrow-next", "button-arrow-previous", "button-arrow-up", "button-bevel", "button-focus", "cadetblue", "calc", "capitalize", "caret", "center", "central", "chartreuse", "checkbox", "checkbox-container", "checkbox-label", "checkmenuitem", "chocolate", "clone", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "condensed", "contain", "content-box", "contents", "coral", "cornflowerblue", "cornsilk", "cover", "crimson", "crispedges", "cubic-bezier", "currentColor", "cyan", "darkblue", "darkcyan", "darken", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dialog", "difference", "dimgray", "dimgrey", "disabled", "dodgerblue", "dotted", "double", "drag", "dualbutton", "ease", "ease-in", "ease-in-out", "ease-out", "element", "elements", "enabled", "end", "evenodd", "exclusion", "expanded", "extra-condensed", "extra-expanded", "fill", "fill-box", "firebrick", "fixed", "flat", "flex", "floralwhite", "forestgreen", "forwards", "fuchsia", "full-width", "gainsboro", "geometricprecision", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "grid", "groove", "groupbox", "hanging", "hard-light", "hidden", "hide", "honeydew", "horizontal", "horizontal-tb", "hotpink", "hsl", "hsla", "hue", "ideographic", "ignore", "inactive", "indianred", "indigo", "infinite", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-end", "inline-flex", "inline-grid", "inline-start", "inline-table", "inset", "inside", "isolate", "italic", "ivory", "justify", "keep-all", "khaki", "large", "larger", "lavender", "lavenderblush", "lawngreen", "layout", "left", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lighten", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linear", "linear-gradient", "linearrgb", "linen", "list-item", "listbox", "listitem", "local", "lowercase", "lr", "lr-tb", "luminance", "luminosity", "magenta", "mandatory", "manual", "margin-box", "maroon", "mathematical", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "menuarrow", "menubar", "menucheckbox", "menuimage", "menuitem", "menuitemtext", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menupopup", "menuradio", "menuseparator", "meterbar", "meterchunk", "middle", "midnightblue", "mintcream", "mistyrose", "miter", "mixed", "moccasin", "multiply", "navajowhite", "navy", "no-change", "no-drag", "no-repeat", "non-scaling-stroke", "none", "nonzero", "normal", "nowrap", "number-input", "oblique", "oldlace", "olive", "olivedrab", "optimizelegibility", "optimizequality", "optimizespeed", "orange", "orangered", "orchid", "outset", "outside", "over", "overlay", "padding-box", "paint", "painted", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "paused", "peachpuff", "peru", "petite-caps", "pink", "plum", "powderblue", "pre", "pre-line", "pre-wrap", "preserve-3d", "progressbar", "progressbar-vertical", "progresschunk", "progresschunk-vertical", "proximity", "purple", "radial-gradient", "radio", "radio-container", "radio-label", "radiomenuitem", "range", "range-thumb", "read-only", "read-write", "rebeccapurple", "red", "relative", "repeat", "repeat-x", "repeat-y", "repeating-linear-gradient", "repeating-radial-gradient", "reset-size", "resizer", "resizerpanel", "reverse", "rgb", "rgba", "ridge", "right", "rl", "rl-tb", "rosybrown", "round", "row", "row-reverse", "royalblue", "ruby", "ruby-base", "ruby-base-container", "ruby-text", "ruby-text-container", "running", "saddlebrown", "salmon", "sandybrown", "saturation", "scale-down", "scale-horizontal", "scale-vertical", "scalethumb-horizontal", "scalethumb-vertical", "scalethumbend", "scalethumbstart", "scalethumbtick", "screen", "scroll", "scrollbar", "scrollbar-small", "scrollbarbutton-down", "scrollbarbutton-left", "scrollbarbutton-right", "scrollbarbutton-up", "scrollbarthumb-horizontal", "scrollbarthumb-vertical", "scrollbartrack-horizontal", "scrollbartrack-vertical", "seagreen", "searchfield", "seashell", "select-after", "select-all", "select-before", "select-menu", "select-same", "semi-condensed", "semi-expanded", "separate", "separator", "show", "sideways", "sideways-lr", "sideways-right", "sideways-rl", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "slice", "small", "small-caps", "smaller", "smooth", "snow", "soft-light", "solid", "space-around", "space-between", "spinner", "spinner-downbutton", "spinner-textfield", "spinner-upbutton", "splitter", "springgreen", "square", "srgb", "start", "static", "statusbar", "statusbarpanel", "steelblue", "step-end", "step-start", "steps", "sticky", "stretch", "stretch-to-fit", "strict", "stroke", "style", "sub", "super", "tab", "tab-scroll-arrow-back", "tab-scroll-arrow-forward", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "tabpanel", "tabpanels", "tan", "tb", "tb-rl", "teal", "text", "text-after-edge", "text-before-edge", "text-bottom", "text-top", "textfield", "textfield-multiline", "thick", "thin", "thistle", "titling-caps", "toggle", "tomato", "toolbar", "toolbarbutton", "toolbarbutton-dropdown", "toolbargripper", "toolbox", "tooltip", "top", "top-outside", "transparent", "treeheader", "treeheadercell", "treeheadersortarrow", "treeitem", "treeline", "treetwisty", "treetwistyopen", "treeview", "tri-state", "turquoise", "ultra-condensed", "ultra-expanded", "under", "unicase", "unset", "uppercase", "upright", "url", "use-script", "vertical", "vertical-lr", "vertical-rl", "view-box", "violet", "visible", "visiblefill", "visiblepainted", "visiblestroke", "wavy", "wheat", "white", "whitesmoke", "window", "wrap", "wrap-reverse", "write-only", "x-large", "x-small", "xx-large", "xx-small", "yellow", "yellowgreen"]
	  },
	  "animation": {
	    subproperties: ["animation-duration", "animation-timing-function", "animation-delay", "animation-direction", "animation-fill-mode", "animation-iteration-count", "animation-play-state", "animation-name"],
	    inherited: false,
	    supports: 1344,
	    values: ["alternate", "alternate-reverse", "backwards", "both", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "forwards", "infinite", "inherit", "initial", "linear", "none", "normal", "paused", "reverse", "running", "step-end", "step-start", "steps", "unset"]
	  },
	  "background": {
	    subproperties: ["background-color", "background-image", "background-repeat", "background-attachment", "background-position", "background-clip", "background-origin", "background-size"],
	    inherited: false,
	    supports: 655,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "border-box", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "content-box", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "fixed", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linear-gradient", "linen", "local", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "no-repeat", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "padding-box", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "radial-gradient", "rebeccapurple", "red", "repeat", "repeat-x", "repeat-y", "repeating-linear-gradient", "repeating-radial-gradient", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "scroll", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "url", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border": {
	    subproperties: ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "-moz-border-top-colors", "-moz-border-right-colors", "-moz-border-bottom-colors", "-moz-border-left-colors", "border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat"],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linear-gradient", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "radial-gradient", "rebeccapurple", "red", "repeating-linear-gradient", "repeating-radial-gradient", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "url", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-block-end": {
	    subproperties: ["border-block-end-width", "border-block-end-style", "border-block-end-color"],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-block-start": {
	    subproperties: ["border-block-start-width", "border-block-start-style", "border-block-start-color"],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-bottom": {
	    subproperties: ["border-bottom-width", "border-bottom-style", "border-bottom-color"],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-color": {
	    subproperties: ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"],
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-image": {
	    subproperties: ["border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat"],
	    inherited: false,
	    supports: 1675,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url"]
	  },
	  "border-inline-end": {
	    subproperties: ["border-inline-end-width", "border-inline-end-style", "border-inline-end-color"],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-inline-start": {
	    subproperties: ["border-inline-start-width", "border-inline-start-style", "border-inline-start-color"],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-left": {
	    subproperties: ["border-left-width", "border-left-style", "border-left-color"],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-right": {
	    subproperties: ["border-right-width", "border-right-style", "border-right-color"],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-style": {
	    subproperties: ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"],
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset"]
	  },
	  "border-top": {
	    subproperties: ["border-top-width", "border-top-style", "border-top-color"],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "border-width": {
	    subproperties: ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"],
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset"]
	  },
	  "border-radius": {
	    subproperties: ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius"],
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-columns": {
	    subproperties: ["-moz-column-count", "-moz-column-width"],
	    inherited: false,
	    supports: 1025,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "-moz-column-rule": {
	    subproperties: ["-moz-column-rule-width", "-moz-column-rule-style", "-moz-column-rule-color"],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "flex": {
	    subproperties: ["flex-grow", "flex-shrink", "flex-basis"],
	    inherited: false,
	    supports: 1027,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "flex-flow": {
	    subproperties: ["flex-direction", "flex-wrap"],
	    inherited: false,
	    supports: 0,
	    values: ["column", "column-reverse", "inherit", "initial", "nowrap", "row", "row-reverse", "unset", "wrap", "wrap-reverse"]
	  },
	  "font": {
	    subproperties: ["font-family", "font-style", "font-weight", "font-size", "line-height", "font-size-adjust", "font-stretch", "-x-system-font", "font-feature-settings", "font-language-override", "font-kerning", "font-synthesis", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position"],
	    inherited: true,
	    supports: 1027,
	    values: ["-moz-block-height", "-moz-calc", "all-petite-caps", "all-small-caps", "auto", "calc", "condensed", "expanded", "extra-condensed", "extra-expanded", "inherit", "initial", "italic", "large", "larger", "medium", "none", "normal", "oblique", "petite-caps", "semi-condensed", "semi-expanded", "small", "small-caps", "smaller", "sub", "super", "titling-caps", "ultra-condensed", "ultra-expanded", "unicase", "unset", "x-large", "x-small", "xx-large", "xx-small"]
	  },
	  "font-variant": {
	    subproperties: ["font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position"],
	    inherited: true,
	    supports: 0,
	    values: ["all-petite-caps", "all-small-caps", "inherit", "initial", "normal", "petite-caps", "small-caps", "sub", "super", "titling-caps", "unicase", "unset"]
	  },
	  "grid-template": {
	    subproperties: ["grid-template-areas", "grid-template-columns", "grid-template-rows"],
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid": {
	    subproperties: ["grid-template-areas", "grid-template-columns", "grid-template-rows", "grid-auto-flow", "grid-auto-columns", "grid-auto-rows", "grid-column-gap", "grid-row-gap"],
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "grid-column": {
	    subproperties: ["grid-column-start", "grid-column-end"],
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-row": {
	    subproperties: ["grid-row-start", "grid-row-end"],
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-area": {
	    subproperties: ["grid-row-start", "grid-column-start", "grid-row-end", "grid-column-end"],
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "grid-gap": {
	    subproperties: ["grid-column-gap", "grid-row-gap"],
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "list-style": {
	    subproperties: ["list-style-type", "list-style-image", "list-style-position"],
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "inside", "none", "outside", "unset", "url"]
	  },
	  "margin": {
	    subproperties: ["margin-top", "margin-right", "margin-bottom", "margin-left"],
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "outline": {
	    subproperties: ["outline-width", "outline-style", "outline-color"],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "auto", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "overflow": {
	    subproperties: ["overflow-x", "overflow-y"],
	    inherited: false,
	    supports: 0,
	    values: ["-moz-hidden-unscrollable", "auto", "hidden", "inherit", "initial", "scroll", "unset", "visible"]
	  },
	  "padding": {
	    subproperties: ["padding-top", "padding-right", "padding-bottom", "padding-left"],
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "scroll-snap-type": {
	    subproperties: ["scroll-snap-type-x", "scroll-snap-type-y"],
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "mandatory", "none", "proximity", "unset"]
	  },
	  "text-decoration": {
	    subproperties: ["text-decoration-color", "text-decoration-line", "text-decoration-style"],
	    inherited: false,
	    supports: 4,
	    values: ["-moz-none", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wavy", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "transition": {
	    subproperties: ["transition-property", "transition-duration", "transition-timing-function", "transition-delay"],
	    inherited: false,
	    supports: 320,
	    values: ["all", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "none", "step-end", "step-start", "steps", "unset"]
	  },
	  "marker": {
	    subproperties: ["marker-start", "marker-mid", "marker-end"],
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url"]
	  },
	  "-moz-transform": {
	    alias: true,
	    subproperties: ["transform"],
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-transform-origin": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-perspective-origin": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-perspective": {
	    alias: true,
	    inherited: false,
	    supports: 1,
	    values: ["inherit", "initial", "none", "unset"]
	  },
	  "-moz-transform-style": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["flat", "inherit", "initial", "preserve-3d", "unset"]
	  },
	  "-moz-backface-visibility": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["hidden", "inherit", "initial", "unset", "visible"]
	  },
	  "-moz-border-image": {
	    alias: true,
	    subproperties: ["border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat"],
	    inherited: false,
	    supports: 1675,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url"]
	  },
	  "-moz-transition": {
	    alias: true,
	    subproperties: ["transition-property", "transition-duration", "transition-timing-function", "transition-delay"],
	    inherited: false,
	    supports: 320,
	    values: ["all", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "none", "step-end", "step-start", "steps", "unset"]
	  },
	  "-moz-transition-delay": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-transition-duration": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-transition-property": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["all", "inherit", "initial", "none", "unset"]
	  },
	  "-moz-transition-timing-function": {
	    alias: true,
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset"]
	  },
	  "-moz-animation": {
	    alias: true,
	    subproperties: ["animation-duration", "animation-timing-function", "animation-delay", "animation-direction", "animation-fill-mode", "animation-iteration-count", "animation-play-state", "animation-name"],
	    inherited: false,
	    supports: 1344,
	    values: ["alternate", "alternate-reverse", "backwards", "both", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "forwards", "infinite", "inherit", "initial", "linear", "none", "normal", "paused", "reverse", "running", "step-end", "step-start", "steps", "unset"]
	  },
	  "-moz-animation-delay": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-animation-direction": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["alternate", "alternate-reverse", "inherit", "initial", "normal", "reverse", "unset"]
	  },
	  "-moz-animation-duration": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-animation-fill-mode": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["backwards", "both", "forwards", "inherit", "initial", "none", "unset"]
	  },
	  "-moz-animation-iteration-count": {
	    alias: true,
	    inherited: false,
	    supports: 1024,
	    values: ["infinite", "inherit", "initial", "unset"]
	  },
	  "-moz-animation-name": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "none", "unset"]
	  },
	  "-moz-animation-play-state": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "paused", "running", "unset"]
	  },
	  "-moz-animation-timing-function": {
	    alias: true,
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset"]
	  },
	  "-moz-box-sizing": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset"]
	  },
	  "-moz-font-feature-settings": {
	    alias: true,
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-moz-font-language-override": {
	    alias: true,
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "normal", "unset"]
	  },
	  "-moz-padding-end": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "-moz-padding-start": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset"]
	  },
	  "-moz-margin-end": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "-moz-margin-start": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset"]
	  },
	  "-moz-border-end": {
	    alias: true,
	    subproperties: ["border-inline-end-width", "border-inline-end-style", "border-inline-end-color"],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "-moz-border-end-color": {
	    alias: true,
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "-moz-border-end-style": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset"]
	  },
	  "-moz-border-end-width": {
	    alias: true,
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset"]
	  },
	  "-moz-border-start": {
	    alias: true,
	    subproperties: ["border-inline-start-width", "border-inline-start-style", "border-inline-start-color"],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "-moz-border-start-color": {
	    alias: true,
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
	  },
	  "-moz-border-start-style": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset"]
	  },
	  "-moz-border-start-width": {
	    alias: true,
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset"]
	  },
	  "-moz-hyphens": {
	    alias: true,
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "manual", "none", "unset"]
	  },
	  "-webkit-animation": {
	    alias: true,
	    subproperties: ["animation-duration", "animation-timing-function", "animation-delay", "animation-direction", "animation-fill-mode", "animation-iteration-count", "animation-play-state", "animation-name"],
	    inherited: false,
	    supports: 1344,
	    values: ["alternate", "alternate-reverse", "backwards", "both", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "forwards", "infinite", "inherit", "initial", "linear", "none", "normal", "paused", "reverse", "running", "step-end", "step-start", "steps", "unset"]
	  },
	  "-webkit-animation-delay": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-animation-direction": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["alternate", "alternate-reverse", "inherit", "initial", "normal", "reverse", "unset"]
	  },
	  "-webkit-animation-duration": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-animation-fill-mode": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["backwards", "both", "forwards", "inherit", "initial", "none", "unset"]
	  },
	  "-webkit-animation-iteration-count": {
	    alias: true,
	    inherited: false,
	    supports: 1024,
	    values: ["infinite", "inherit", "initial", "unset"]
	  },
	  "-webkit-animation-name": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "none", "unset"]
	  },
	  "-webkit-animation-play-state": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "paused", "running", "unset"]
	  },
	  "-webkit-animation-timing-function": {
	    alias: true,
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset"]
	  },
	  "-webkit-text-size-adjust": {
	    alias: true,
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "none", "unset"]
	  },
	  "-webkit-transform": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-transform-origin": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-transform-style": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["flat", "inherit", "initial", "preserve-3d", "unset"]
	  },
	  "-webkit-backface-visibility": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["hidden", "inherit", "initial", "unset", "visible"]
	  },
	  "-webkit-perspective": {
	    alias: true,
	    inherited: false,
	    supports: 1,
	    values: ["inherit", "initial", "none", "unset"]
	  },
	  "-webkit-perspective-origin": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-transition": {
	    alias: true,
	    subproperties: ["transition-property", "transition-duration", "transition-timing-function", "transition-delay"],
	    inherited: false,
	    supports: 320,
	    values: ["all", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "none", "step-end", "step-start", "steps", "unset"]
	  },
	  "-webkit-transition-delay": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-transition-duration": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-transition-property": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["all", "inherit", "initial", "none", "unset"]
	  },
	  "-webkit-transition-timing-function": {
	    alias: true,
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset"]
	  },
	  "-webkit-border-radius": {
	    alias: true,
	    subproperties: ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius"],
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-border-top-left-radius": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-border-top-right-radius": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-border-bottom-left-radius": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-border-bottom-right-radius": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-appearance": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["-moz-gtk-info-bar", "-moz-mac-disclosure-button-closed", "-moz-mac-disclosure-button-open", "-moz-mac-fullscreen-button", "-moz-mac-help-button", "-moz-mac-vibrancy-dark", "-moz-mac-vibrancy-light", "-moz-win-borderless-glass", "-moz-win-browsertabbar-toolbox", "-moz-win-communications-toolbox", "-moz-win-exclude-glass", "-moz-win-glass", "-moz-win-media-toolbox", "-moz-window-button-box", "-moz-window-button-box-maximized", "-moz-window-button-close", "-moz-window-button-maximize", "-moz-window-button-minimize", "-moz-window-button-restore", "-moz-window-frame-bottom", "-moz-window-frame-left", "-moz-window-frame-right", "-moz-window-titlebar", "-moz-window-titlebar-maximized", "button", "button-arrow-down", "button-arrow-next", "button-arrow-previous", "button-arrow-up", "button-bevel", "button-focus", "caret", "checkbox", "checkbox-container", "checkbox-label", "checkmenuitem", "dialog", "dualbutton", "groupbox", "inherit", "initial", "listbox", "listitem", "menuarrow", "menubar", "menucheckbox", "menuimage", "menuitem", "menuitemtext", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menupopup", "menuradio", "menuseparator", "meterbar", "meterchunk", "none", "number-input", "progressbar", "progressbar-vertical", "progresschunk", "progresschunk-vertical", "radio", "radio-container", "radio-label", "radiomenuitem", "range", "range-thumb", "resizer", "resizerpanel", "scale-horizontal", "scale-vertical", "scalethumb-horizontal", "scalethumb-vertical", "scalethumbend", "scalethumbstart", "scalethumbtick", "scrollbar", "scrollbar-small", "scrollbarbutton-down", "scrollbarbutton-left", "scrollbarbutton-right", "scrollbarbutton-up", "scrollbarthumb-horizontal", "scrollbarthumb-vertical", "scrollbartrack-horizontal", "scrollbartrack-vertical", "searchfield", "separator", "spinner", "spinner-downbutton", "spinner-textfield", "spinner-upbutton", "splitter", "statusbar", "statusbarpanel", "tab", "tab-scroll-arrow-back", "tab-scroll-arrow-forward", "tabpanel", "tabpanels", "textfield", "textfield-multiline", "toolbar", "toolbarbutton", "toolbarbutton-dropdown", "toolbargripper", "toolbox", "tooltip", "treeheader", "treeheadercell", "treeheadersortarrow", "treeitem", "treeline", "treetwisty", "treetwistyopen", "treeview", "unset", "window"]
	  },
	  "-webkit-background-clip": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset"]
	  },
	  "-webkit-background-origin": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset"]
	  },
	  "-webkit-background-size": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-border-image": {
	    alias: true,
	    subproperties: ["border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat"],
	    inherited: false,
	    supports: 1675,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url"]
	  },
	  "-webkit-border-image-outset": {
	    alias: true,
	    inherited: false,
	    supports: 1025,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-border-image-repeat": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-border-image-slice": {
	    alias: true,
	    inherited: false,
	    supports: 1026,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-border-image-source": {
	    alias: true,
	    inherited: false,
	    supports: 648,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url"]
	  },
	  "-webkit-border-image-width": {
	    alias: true,
	    inherited: false,
	    supports: 1027,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-box-shadow": {
	    alias: true,
	    inherited: false,
	    supports: 5,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-box-sizing": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset"]
	  },
	  "-webkit-box-flex": {
	    alias: true,
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-box-ordinal-group": {
	    alias: true,
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-box-align": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-box-pack": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset"]
	  },
	  "-webkit-user-select": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["-moz-all", "-moz-none", "-moz-text", "all", "auto", "element", "elements", "inherit", "initial", "none", "text", "toggle", "tri-state", "unset"]
	  }
	};
	module.exports = { cssProperties };

/***/ },
/* 839 */
/***/ function(module, exports) {

	"use strict";

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/Promise.jsm
	 */

	/**
	 * Promise.jsm is mostly the Promise web API with a `defer` method. Just drop this in here,
	 * and use the native web API (although building with webpack/babel, it may replace this
	 * with it's own version if we want to target environments that do not have `Promise`.
	 */

	var p = typeof window != "undefined" ? window.Promise : Promise;
	p.defer = function defer() {
	  var resolve, reject;
	  var promise = new Promise(function () {
	    resolve = arguments[0];
	    reject = arguments[1];
	  });
	  return {
	    resolve: resolve,
	    reject: reject,
	    promise: promise
	  };
	};

	module.exports = p;

/***/ },
/* 840 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/FileUtils.jsm
	 */
	"use strict";

/***/ },
/* 841 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/netwerk/base/NetUtil.jsm
	 */
	"use strict";

/***/ },
/* 842 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/components/osfile/osfile.jsm
	 */
	"use strict";

/***/ },
/* 843 */
/***/ function(module, exports, __webpack_require__) {

	/* vim:set ts=2 sw=2 sts=2 et: */
	/*
	 * Software License Agreement (BSD License)
	 *
	 * Copyright (c) 2007, Parakey Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use of this software in source and binary forms, with or without modification,
	 * are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above
	 *   copyright notice, this list of conditions and the
	 *   following disclaimer.
	 *
	 * * Redistributions in binary form must reproduce the above
	 *   copyright notice, this list of conditions and the
	 *   following disclaimer in the documentation and/or other
	 *   materials provided with the distribution.
	 *
	 * * Neither the name of Parakey Inc. nor the names of its
	 *   contributors may be used to endorse or promote products
	 *   derived from this software without specific prior
	 *   written permission of Parakey Inc.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
	 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
	 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
	 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
	 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	/*
	 * Creator:
	 *  Joe Hewitt
	 * Contributors
	 *  John J. Barton (IBM Almaden)
	 *  Jan Odvarko (Mozilla Corp.)
	 *  Max Stepanov (Aptana Inc.)
	 *  Rob Campbell (Mozilla Corp.)
	 *  Hans Hillen (Paciello Group, Mozilla)
	 *  Curtis Bartley (Mozilla Corp.)
	 *  Mike Collins (IBM Almaden)
	 *  Kevin Decker
	 *  Mike Ratcliffe (Comartis AG)
	 *  Hernan Rodríguez Colmeiro
	 *  Austin Andrews
	 *  Christoph Dorn
	 *  Steven Roussey (AppCenter Inc, Network54)
	 *  Mihai Sucan (Mozilla Corp.)
	 */

	"use strict";

	var _require = __webpack_require__(834),
	    components = _require.components,
	    Cc = _require.Cc,
	    Ci = _require.Ci,
	    Cu = _require.Cu;

	var _require2 = __webpack_require__(841),
	    NetUtil = _require2.NetUtil;

	var DevToolsUtils = __webpack_require__(833);

	// The cache used in the `nsIURL` function.
	var gNSURLStore = new Map();

	/**
	 * Helper object for networking stuff.
	 *
	 * Most of the following functions have been taken from the Firebug source. They
	 * have been modified to match the Firefox coding rules.
	 */
	var NetworkHelper = {
	  /**
	   * Converts aText with a given aCharset to unicode.
	   *
	   * @param string aText
	   *        Text to convert.
	   * @param string aCharset
	   *        Charset to convert the text to.
	   * @returns string
	   *          Converted text.
	   */
	  convertToUnicode: function NH_convertToUnicode(aText, aCharset) {
	    var conv = Cc("@mozilla.org/intl/scriptableunicodeconverter").createInstance(Ci.nsIScriptableUnicodeConverter);
	    try {
	      conv.charset = aCharset || "UTF-8";
	      return conv.ConvertToUnicode(aText);
	    } catch (ex) {
	      return aText;
	    }
	  },

	  /**
	   * Reads all available bytes from aStream and converts them to aCharset.
	   *
	   * @param nsIInputStream aStream
	   * @param string aCharset
	   * @returns string
	   *          UTF-16 encoded string based on the content of aStream and aCharset.
	   */
	  readAndConvertFromStream: function NH_readAndConvertFromStream(aStream, aCharset) {
	    var text = null;
	    try {
	      text = NetUtil.readInputStreamToString(aStream, aStream.available());
	      return this.convertToUnicode(text, aCharset);
	    } catch (err) {
	      return text;
	    }
	  },

	  /**
	  * Reads the posted text from aRequest.
	  *
	  * @param nsIHttpChannel aRequest
	  * @param string aCharset
	  *        The content document charset, used when reading the POSTed data.
	  * @returns string or null
	  *          Returns the posted string if it was possible to read from aRequest
	  *          otherwise null.
	  */
	  readPostTextFromRequest: function NH_readPostTextFromRequest(aRequest, aCharset) {
	    if (aRequest instanceof Ci.nsIUploadChannel) {
	      var iStream = aRequest.uploadStream;

	      var isSeekableStream = false;
	      if (iStream instanceof Ci.nsISeekableStream) {
	        isSeekableStream = true;
	      }

	      var prevOffset = void 0;
	      if (isSeekableStream) {
	        prevOffset = iStream.tell();
	        iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
	      }

	      // Read data from the stream.
	      var text = this.readAndConvertFromStream(iStream, aCharset);

	      // Seek locks the file, so seek to the beginning only if necko hasn't
	      // read it yet, since necko doesn't seek to 0 before reading (at lest
	      // not till 459384 is fixed).
	      if (isSeekableStream && prevOffset == 0) {
	        iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
	      }
	      return text;
	    }
	    return null;
	  },

	  /**
	   * Reads the posted text from the page's cache.
	   *
	   * @param nsIDocShell aDocShell
	   * @param string aCharset
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from
	   *          aDocShell otherwise null.
	   */
	  readPostTextFromPage: function NH_readPostTextFromPage(aDocShell, aCharset) {
	    var webNav = aDocShell.QueryInterface(Ci.nsIWebNavigation);
	    return this.readPostTextFromPageViaWebNav(webNav, aCharset);
	  },

	  /**
	   * Reads the posted text from the page's cache, given an nsIWebNavigation
	   * object.
	   *
	   * @param nsIWebNavigation aWebNav
	   * @param string aCharset
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from
	   *          aWebNav, otherwise null.
	   */
	  readPostTextFromPageViaWebNav: function NH_readPostTextFromPageViaWebNav(aWebNav, aCharset) {
	    if (aWebNav instanceof Ci.nsIWebPageDescriptor) {
	      var descriptor = aWebNav.currentDescriptor;

	      if (descriptor instanceof Ci.nsISHEntry && descriptor.postData && descriptor instanceof Ci.nsISeekableStream) {
	        descriptor.seek(NS_SEEK_SET, 0);

	        return this.readAndConvertFromStream(descriptor, aCharset);
	      }
	    }
	    return null;
	  },

	  /**
	   * Gets the web appId that is associated with aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns number|null
	   *          The appId for the given request, if available.
	   */
	  getAppIdForRequest: function NH_getAppIdForRequest(aRequest) {
	    try {
	      return this.getRequestLoadContext(aRequest).appId;
	    } catch (ex) {
	      // request loadContent is not always available.
	    }
	    return null;
	  },

	  /**
	   * Gets the topFrameElement that is associated with aRequest. This
	   * works in single-process and multiprocess contexts. It may cross
	   * the content/chrome boundary.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns nsIDOMElement|null
	   *          The top frame element for the given request.
	   */
	  getTopFrameForRequest: function NH_getTopFrameForRequest(aRequest) {
	    try {
	      return this.getRequestLoadContext(aRequest).topFrameElement;
	    } catch (ex) {
	      // request loadContent is not always available.
	    }
	    return null;
	  },

	  /**
	   * Gets the nsIDOMWindow that is associated with aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns nsIDOMWindow or null
	   */
	  getWindowForRequest: function NH_getWindowForRequest(aRequest) {
	    try {
	      return this.getRequestLoadContext(aRequest).associatedWindow;
	    } catch (ex) {
	      // TODO: bug 802246 - getWindowForRequest() throws on b2g: there is no
	      // associatedWindow property.
	    }
	    return null;
	  },

	  /**
	   * Gets the nsILoadContext that is associated with aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns nsILoadContext or null
	   */
	  getRequestLoadContext: function NH_getRequestLoadContext(aRequest) {
	    try {
	      return aRequest.notificationCallbacks.getInterface(Ci.nsILoadContext);
	    } catch (ex) {}

	    try {
	      return aRequest.loadGroup.notificationCallbacks.getInterface(Ci.nsILoadContext);
	    } catch (ex) {}

	    return null;
	  },

	  /**
	   * Determines whether the request has been made for the top level document.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns Boolean True if the request represents the top level document.
	   */
	  isTopLevelLoad: function (aRequest) {
	    if (aRequest instanceof Ci.nsIChannel) {
	      var loadInfo = aRequest.loadInfo;
	      if (loadInfo && loadInfo.parentOuterWindowID == loadInfo.outerWindowID) {
	        return aRequest.loadFlags & Ci.nsIChannel.LOAD_DOCUMENT_URI;
	      }
	    }

	    return false;
	  },

	  /**
	   * Loads the content of aUrl from the cache.
	   *
	   * @param string aUrl
	   *        URL to load the cached content for.
	   * @param string aCharset
	   *        Assumed charset of the cached content. Used if there is no charset
	   *        on the channel directly.
	   * @param function aCallback
	   *        Callback that is called with the loaded cached content if available
	   *        or null if something failed while getting the cached content.
	   */
	  loadFromCache: function NH_loadFromCache(aUrl, aCharset, aCallback) {
	    var channel = NetUtil.newChannel({ uri: aUrl, loadUsingSystemPrincipal: true });

	    // Ensure that we only read from the cache and not the server.
	    channel.loadFlags = Ci.nsIRequest.LOAD_FROM_CACHE | Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE | Ci.nsICachingChannel.LOAD_BYPASS_LOCAL_CACHE_IF_BUSY;

	    NetUtil.asyncFetch(channel, (aInputStream, aStatusCode, aRequest) => {
	      if (!components.isSuccessCode(aStatusCode)) {
	        aCallback(null);
	        return;
	      }

	      // Try to get the encoding from the channel. If there is none, then use
	      // the passed assumed aCharset.
	      var aChannel = aRequest.QueryInterface(Ci.nsIChannel);
	      var contentCharset = aChannel.contentCharset || aCharset;

	      // Read the content of the stream using contentCharset as encoding.
	      aCallback(this.readAndConvertFromStream(aInputStream, contentCharset));
	    });
	  },

	  /**
	   * Parse a raw Cookie header value.
	   *
	   * @param string aHeader
	   *        The raw Cookie header value.
	   * @return array
	   *         Array holding an object for each cookie. Each object holds the
	   *         following properties: name and value.
	   */
	  parseCookieHeader: function NH_parseCookieHeader(aHeader) {
	    var cookies = aHeader.split(";");
	    var result = [];

	    cookies.forEach(function (aCookie) {
	      var equal = aCookie.indexOf("=");
	      var name = aCookie.substr(0, equal);
	      var value = aCookie.substr(equal + 1);
	      result.push({ name: unescape(name.trim()),
	        value: unescape(value.trim()) });
	    });

	    return result;
	  },

	  /**
	   * Parse a raw Set-Cookie header value.
	   *
	   * @param string aHeader
	   *        The raw Set-Cookie header value.
	   * @return array
	   *         Array holding an object for each cookie. Each object holds the
	   *         following properties: name, value, secure (boolean), httpOnly
	   *         (boolean), path, domain and expires (ISO date string).
	   */
	  parseSetCookieHeader: function NH_parseSetCookieHeader(aHeader) {
	    var rawCookies = aHeader.split(/\r\n|\n|\r/);
	    var cookies = [];

	    rawCookies.forEach(function (aCookie) {
	      var equal = aCookie.indexOf("=");
	      var name = unescape(aCookie.substr(0, equal).trim());
	      var parts = aCookie.substr(equal + 1).split(";");
	      var value = unescape(parts.shift().trim());

	      var cookie = { name: name, value: value };

	      parts.forEach(function (aPart) {
	        var part = aPart.trim();
	        if (part.toLowerCase() == "secure") {
	          cookie.secure = true;
	        } else if (part.toLowerCase() == "httponly") {
	          cookie.httpOnly = true;
	        } else if (part.indexOf("=") > -1) {
	          var pair = part.split("=");
	          pair[0] = pair[0].toLowerCase();
	          if (pair[0] == "path" || pair[0] == "domain") {
	            cookie[pair[0]] = pair[1];
	          } else if (pair[0] == "expires") {
	            try {
	              pair[1] = pair[1].replace(/-/g, ' ');
	              cookie.expires = new Date(pair[1]).toISOString();
	            } catch (ex) {}
	          }
	        }
	      });

	      cookies.push(cookie);
	    });

	    return cookies;
	  },

	  // This is a list of all the mime category maps jviereck could find in the
	  // firebug code base.
	  mimeCategoryMap: {
	    "text/plain": "txt",
	    "text/html": "html",
	    "text/xml": "xml",
	    "text/xsl": "txt",
	    "text/xul": "txt",
	    "text/css": "css",
	    "text/sgml": "txt",
	    "text/rtf": "txt",
	    "text/x-setext": "txt",
	    "text/richtext": "txt",
	    "text/javascript": "js",
	    "text/jscript": "txt",
	    "text/tab-separated-values": "txt",
	    "text/rdf": "txt",
	    "text/xif": "txt",
	    "text/ecmascript": "js",
	    "text/vnd.curl": "txt",
	    "text/x-json": "json",
	    "text/x-js": "txt",
	    "text/js": "txt",
	    "text/vbscript": "txt",
	    "view-source": "txt",
	    "view-fragment": "txt",
	    "application/xml": "xml",
	    "application/xhtml+xml": "xml",
	    "application/atom+xml": "xml",
	    "application/rss+xml": "xml",
	    "application/vnd.mozilla.maybe.feed": "xml",
	    "application/vnd.mozilla.xul+xml": "xml",
	    "application/javascript": "js",
	    "application/x-javascript": "js",
	    "application/x-httpd-php": "txt",
	    "application/rdf+xml": "xml",
	    "application/ecmascript": "js",
	    "application/http-index-format": "txt",
	    "application/json": "json",
	    "application/x-js": "txt",
	    "multipart/mixed": "txt",
	    "multipart/x-mixed-replace": "txt",
	    "image/svg+xml": "svg",
	    "application/octet-stream": "bin",
	    "image/jpeg": "image",
	    "image/jpg": "image",
	    "image/gif": "image",
	    "image/png": "image",
	    "image/bmp": "image",
	    "application/x-shockwave-flash": "flash",
	    "video/x-flv": "flash",
	    "audio/mpeg3": "media",
	    "audio/x-mpeg-3": "media",
	    "video/mpeg": "media",
	    "video/x-mpeg": "media",
	    "audio/ogg": "media",
	    "application/ogg": "media",
	    "application/x-ogg": "media",
	    "application/x-midi": "media",
	    "audio/midi": "media",
	    "audio/x-mid": "media",
	    "audio/x-midi": "media",
	    "music/crescendo": "media",
	    "audio/wav": "media",
	    "audio/x-wav": "media",
	    "text/json": "json",
	    "application/x-json": "json",
	    "application/json-rpc": "json",
	    "application/x-web-app-manifest+json": "json",
	    "application/manifest+json": "json"
	  },

	  /**
	   * Check if the given MIME type is a text-only MIME type.
	   *
	   * @param string aMimeType
	   * @return boolean
	   */
	  isTextMimeType: function NH_isTextMimeType(aMimeType) {
	    if (aMimeType.indexOf("text/") == 0) {
	      return true;
	    }

	    // XML and JSON often come with custom MIME types, so in addition to the
	    // standard "application/xml" and "application/json", we also look for
	    // variants like "application/x-bigcorp+xml". For JSON we allow "+json" and
	    // "-json" as suffixes.
	    if (/^application\/\w+(?:[\.-]\w+)*(?:\+xml|[-+]json)$/.test(aMimeType)) {
	      return true;
	    }

	    var category = this.mimeCategoryMap[aMimeType] || null;
	    switch (category) {
	      case "txt":
	      case "js":
	      case "json":
	      case "css":
	      case "html":
	      case "svg":
	      case "xml":
	        return true;

	      default:
	        return false;
	    }
	  },

	  /**
	   * Takes a securityInfo object of nsIRequest, the nsIRequest itself and
	   * extracts security information from them.
	   *
	   * @param object securityInfo
	   *        The securityInfo object of a request. If null channel is assumed
	   *        to be insecure.
	   * @param object httpActivity
	   *        The httpActivity object for the request with at least members
	   *        { private, hostname }.
	   *
	   * @return object
	   *         Returns an object containing following members:
	   *          - state: The security of the connection used to fetch this
	   *                   request. Has one of following string values:
	   *                    * "insecure": the connection was not secure (only http)
	   *                    * "weak": the connection has minor security issues
	   *                    * "broken": secure connection failed (e.g. expired cert)
	   *                    * "secure": the connection was properly secured.
	   *          If state == broken:
	   *            - errorMessage: full error message from nsITransportSecurityInfo.
	   *          If state == secure:
	   *            - protocolVersion: one of TLSv1, TLSv1.1, TLSv1.2.
	   *            - cipherSuite: the cipher suite used in this connection.
	   *            - cert: information about certificate used in this connection.
	   *                    See parseCertificateInfo for the contents.
	   *            - hsts: true if host uses Strict Transport Security, false otherwise
	   *            - hpkp: true if host uses Public Key Pinning, false otherwise
	   *          If state == weak: Same as state == secure and
	   *            - weaknessReasons: list of reasons that cause the request to be
	   *                               considered weak. See getReasonsForWeakness.
	   */
	  parseSecurityInfo: function NH_parseSecurityInfo(securityInfo, httpActivity) {
	    var info = {
	      state: "insecure"
	    };

	    // The request did not contain any security info.
	    if (!securityInfo) {
	      return info;
	    }

	    /**
	     * Different scenarios to consider here and how they are handled:
	     * - request is HTTP, the connection is not secure
	     *   => securityInfo is null
	     *      => state === "insecure"
	     *
	     * - request is HTTPS, the connection is secure
	     *   => .securityState has STATE_IS_SECURE flag
	     *      => state === "secure"
	     *
	     * - request is HTTPS, the connection has security issues
	     *   => .securityState has STATE_IS_INSECURE flag
	     *   => .errorCode is an NSS error code.
	     *      => state === "broken"
	     *
	     * - request is HTTPS, the connection was terminated before the security
	     *   could be validated
	     *   => .securityState has STATE_IS_INSECURE flag
	     *   => .errorCode is NOT an NSS error code.
	     *   => .errorMessage is not available.
	     *      => state === "insecure"
	     *
	     * - request is HTTPS but it uses a weak cipher or old protocol, see
	     *   https://hg.mozilla.org/mozilla-central/annotate/def6ed9d1c1a/
	     *   security/manager/ssl/nsNSSCallbacks.cpp#l1233
	     * - request is mixed content (which makes no sense whatsoever)
	     *   => .securityState has STATE_IS_BROKEN flag
	     *   => .errorCode is NOT an NSS error code
	     *   => .errorMessage is not available
	     *      => state === "weak"
	     */

	    securityInfo.QueryInterface(Ci.nsITransportSecurityInfo);
	    securityInfo.QueryInterface(Ci.nsISSLStatusProvider);

	    var wpl = Ci.nsIWebProgressListener;
	    var NSSErrorsService = Cc['@mozilla.org/nss_errors_service;1'].getService(Ci.nsINSSErrorsService);
	    var SSLStatus = securityInfo.SSLStatus;
	    if (!NSSErrorsService.isNSSErrorCode(securityInfo.errorCode)) {
	      var state = securityInfo.securityState;

	      var uri = null;
	      if (httpActivity.channel && httpActivity.channel.URI) {
	        uri = httpActivity.channel.URI;
	      }
	      if (uri && !uri.schemeIs("https") && !uri.schemeIs("wss")) {
	        // it is not enough to look at the transport security info - schemes other than
	        // https and wss are subject to downgrade/etc at the scheme level and should
	        // always be considered insecure
	        info.state = "insecure";
	      } else if (state & wpl.STATE_IS_SECURE) {
	        // The connection is secure if the scheme is sufficient
	        info.state = "secure";
	      } else if (state & wpl.STATE_IS_BROKEN) {
	        // The connection is not secure, there was no error but there's some
	        // minor security issues.
	        info.state = "weak";
	        info.weaknessReasons = this.getReasonsForWeakness(state);
	      } else if (state & wpl.STATE_IS_INSECURE) {
	        // This was most likely an https request that was aborted before
	        // validation. Return info as info.state = insecure.
	        return info;
	      } else {
	        DevToolsUtils.reportException("NetworkHelper.parseSecurityInfo", "Security state " + state + " has no known STATE_IS_* flags.");
	        return info;
	      }

	      // Cipher suite.
	      info.cipherSuite = SSLStatus.cipherName;

	      // Protocol version.
	      info.protocolVersion = this.formatSecurityProtocol(SSLStatus.protocolVersion);

	      // Certificate.
	      info.cert = this.parseCertificateInfo(SSLStatus.serverCert);

	      // HSTS and HPKP if available.
	      if (httpActivity.hostname) {
	        var sss = Cc("@mozilla.org/ssservice;1").getService(Ci.nsISiteSecurityService);

	        // SiteSecurityService uses different storage if the channel is
	        // private. Thus we must give isSecureHost correct flags or we
	        // might get incorrect results.
	        var flags = httpActivity.private ? Ci.nsISocketProvider.NO_PERMANENT_STORAGE : 0;

	        var host = httpActivity.hostname;

	        info.hsts = sss.isSecureHost(sss.HEADER_HSTS, host, flags);
	        info.hpkp = sss.isSecureHost(sss.HEADER_HPKP, host, flags);
	      } else {
	        DevToolsUtils.reportException("NetworkHelper.parseSecurityInfo", "Could not get HSTS/HPKP status as hostname is not available.");
	        info.hsts = false;
	        info.hpkp = false;
	      }
	    } else {
	      // The connection failed.
	      info.state = "broken";
	      info.errorMessage = securityInfo.errorMessage;
	    }

	    return info;
	  },

	  /**
	   * Takes an nsIX509Cert and returns an object with certificate information.
	   *
	   * @param nsIX509Cert cert
	   *        The certificate to extract the information from.
	   * @return object
	   *         An object with following format:
	   *           {
	   *             subject: { commonName, organization, organizationalUnit },
	   *             issuer: { commonName, organization, organizationUnit },
	   *             validity: { start, end },
	   *             fingerprint: { sha1, sha256 }
	   *           }
	   */
	  parseCertificateInfo: function NH_parseCertifificateInfo(cert) {
	    var info = {};
	    if (cert) {
	      info.subject = {
	        commonName: cert.commonName,
	        organization: cert.organization,
	        organizationalUnit: cert.organizationalUnit
	      };

	      info.issuer = {
	        commonName: cert.issuerCommonName,
	        organization: cert.issuerOrganization,
	        organizationUnit: cert.issuerOrganizationUnit
	      };

	      info.validity = {
	        start: cert.validity.notBeforeLocalDay,
	        end: cert.validity.notAfterLocalDay
	      };

	      info.fingerprint = {
	        sha1: cert.sha1Fingerprint,
	        sha256: cert.sha256Fingerprint
	      };
	    } else {
	      DevToolsUtils.reportException("NetworkHelper.parseCertificateInfo", "Secure connection established without certificate.");
	    }

	    return info;
	  },

	  /**
	   * Takes protocolVersion of SSLStatus object and returns human readable
	   * description.
	   *
	   * @param Number version
	   *        One of nsISSLStatus version constants.
	   * @return string
	   *         One of TLSv1, TLSv1.1, TLSv1.2 if @param version is valid,
	   *         Unknown otherwise.
	   */
	  formatSecurityProtocol: function NH_formatSecurityProtocol(version) {
	    switch (version) {
	      case Ci.nsISSLStatus.TLS_VERSION_1:
	        return "TLSv1";
	      case Ci.nsISSLStatus.TLS_VERSION_1_1:
	        return "TLSv1.1";
	      case Ci.nsISSLStatus.TLS_VERSION_1_2:
	        return "TLSv1.2";
	      default:
	        DevToolsUtils.reportException("NetworkHelper.formatSecurityProtocol", "protocolVersion " + version + " is unknown.");
	        return "Unknown";
	    }
	  },

	  /**
	   * Takes the securityState bitfield and returns reasons for weak connection
	   * as an array of strings.
	   *
	   * @param Number state
	   *        nsITransportSecurityInfo.securityState.
	   *
	   * @return Array[String]
	   *         List of weakness reasons. A subset of { cipher } where
	   *         * cipher: The cipher suite is consireded to be weak (RC4).
	   */
	  getReasonsForWeakness: function NH_getReasonsForWeakness(state) {
	    var wpl = Ci.nsIWebProgressListener;

	    // If there's non-fatal security issues the request has STATE_IS_BROKEN
	    // flag set. See http://hg.mozilla.org/mozilla-central/file/44344099d119
	    // /security/manager/ssl/nsNSSCallbacks.cpp#l1233
	    var reasons = [];

	    if (state & wpl.STATE_IS_BROKEN) {
	      var isCipher = state & wpl.STATE_USES_WEAK_CRYPTO;

	      if (isCipher) {
	        reasons.push("cipher");
	      }

	      if (!isCipher) {
	        DevToolsUtils.reportException("NetworkHelper.getReasonsForWeakness", "STATE_IS_BROKEN without a known reason. Full state was: " + state);
	      }
	    }

	    return reasons;
	  },

	  /**
	   * Parse a url's query string into its components
	   *
	   * @param string aQueryString
	   *        The query part of a url
	   * @return array
	   *         Array of query params {name, value}
	   */
	  parseQueryString: function (aQueryString) {
	    // Make sure there's at least one param available.
	    // Be careful here, params don't necessarily need to have values, so
	    // no need to verify the existence of a "=".
	    if (!aQueryString) {
	      return;
	    }

	    // Turn the params string into an array containing { name: value } tuples.
	    var paramsArray = aQueryString.replace(/^[?&]/, "").split("&").map(e => {
	      var param = e.split("=");
	      return {
	        name: param[0] ? NetworkHelper.convertToUnicode(unescape(param[0])) : "",
	        value: param[1] ? NetworkHelper.convertToUnicode(unescape(param[1])) : ""
	      };
	    });

	    return paramsArray;
	  },

	  /**
	   * Helper for getting an nsIURL instance out of a string.
	   */
	  nsIURL: function (aUrl) {
	    var aStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : gNSURLStore;

	    if (aStore.has(aUrl)) {
	      return aStore.get(aUrl);
	    }

	    var uri = Services.io.newURI(aUrl).QueryInterface(Ci.nsIURL);
	    aStore.set(aUrl, uri);
	    return uri;
	  }
	};

	for (var prop of Object.getOwnPropertyNames(NetworkHelper)) {
	  exports[prop] = NetworkHelper[prop];
	}

/***/ },
/* 844 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * EventEmitter.
	 */

	var EventEmitter = function EventEmitter() {};
	module.exports = EventEmitter;

	var _require = __webpack_require__(834),
	    Cu = _require.Cu;

	var promise = __webpack_require__(839);

	/**
	 * Decorate an object with event emitter functionality.
	 *
	 * @param Object aObjectToDecorate
	 *        Bind all public methods of EventEmitter to
	 *        the aObjectToDecorate object.
	 */
	EventEmitter.decorate = function EventEmitter_decorate(aObjectToDecorate) {
	  var emitter = new EventEmitter();
	  aObjectToDecorate.on = emitter.on.bind(emitter);
	  aObjectToDecorate.off = emitter.off.bind(emitter);
	  aObjectToDecorate.once = emitter.once.bind(emitter);
	  aObjectToDecorate.emit = emitter.emit.bind(emitter);
	};

	EventEmitter.prototype = {
	  /**
	   * Connect a listener.
	   *
	   * @param string aEvent
	   *        The event name to which we're connecting.
	   * @param function aListener
	   *        Called when the event is fired.
	   */
	  on: function EventEmitter_on(aEvent, aListener) {
	    if (!this._eventEmitterListeners) this._eventEmitterListeners = new Map();
	    if (!this._eventEmitterListeners.has(aEvent)) {
	      this._eventEmitterListeners.set(aEvent, []);
	    }
	    this._eventEmitterListeners.get(aEvent).push(aListener);
	  },

	  /**
	   * Listen for the next time an event is fired.
	   *
	   * @param string aEvent
	   *        The event name to which we're connecting.
	   * @param function aListener
	   *        (Optional) Called when the event is fired. Will be called at most
	   *        one time.
	   * @return promise
	   *        A promise which is resolved when the event next happens. The
	   *        resolution value of the promise is the first event argument. If
	   *        you need access to second or subsequent event arguments (it's rare
	   *        that this is needed) then use aListener
	   */
	  once: function EventEmitter_once(aEvent, aListener) {
	    var _this = this;

	    var deferred = promise.defer();

	    var handler = function (aEvent, aFirstArg) {
	      for (var _len = arguments.length, aRest = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	        aRest[_key - 2] = arguments[_key];
	      }

	      _this.off(aEvent, handler);
	      if (aListener) {
	        aListener.apply(null, [aEvent, aFirstArg].concat(aRest));
	      }
	      deferred.resolve(aFirstArg);
	    };

	    handler._originalListener = aListener;
	    this.on(aEvent, handler);

	    return deferred.promise;
	  },

	  /**
	   * Remove a previously-registered event listener.  Works for events
	   * registered with either on or once.
	   *
	   * @param string aEvent
	   *        The event name whose listener we're disconnecting.
	   * @param function aListener
	   *        The listener to remove.
	   */
	  off: function EventEmitter_off(aEvent, aListener) {
	    if (!this._eventEmitterListeners) return;
	    var listeners = this._eventEmitterListeners.get(aEvent);
	    if (listeners) {
	      this._eventEmitterListeners.set(aEvent, listeners.filter(l => {
	        return l !== aListener && l._originalListener !== aListener;
	      }));
	    }
	  },

	  /**
	   * Emit an event.  All arguments to this method will
	   * be sent to listener functions.
	   */
	  emit: function EventEmitter_emit(aEvent) {
	    var _this2 = this,
	        _arguments = arguments;

	    if (!this._eventEmitterListeners || !this._eventEmitterListeners.has(aEvent)) {
	      return;
	    }

	    var originalListeners = this._eventEmitterListeners.get(aEvent);

	    var _loop = function (listener) {
	      // If the object was destroyed during event emission, stop
	      // emitting.
	      if (!_this2._eventEmitterListeners) {
	        return "break";
	      }

	      // If listeners were removed during emission, make sure the
	      // event handler we're going to fire wasn't removed.
	      if (originalListeners === _this2._eventEmitterListeners.get(aEvent) || _this2._eventEmitterListeners.get(aEvent).some(l => l === listener)) {
	        try {
	          listener.apply(null, _arguments);
	        } catch (ex) {
	          // Prevent a bad listener from interfering with the others.
	          var msg = ex + ": " + ex.stack;
	          //console.error(msg);
	          console.log(msg);
	        }
	      }
	    };

	    for (var listener of this._eventEmitterListeners.get(aEvent)) {
	      var _ret = _loop(listener);

	      if (_ret === "break") break;
	    }
	  }
	};

/***/ },
/* 845 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/* eslint-env browser */

	"use strict";

	/**
	 * HTML5 file saver to provide a standard download interface with a "Save As"
	 * dialog
	 *
	 * @param {object} blob - A blob object will be downloaded
	 * @param {string} filename - Given a file name which will display in "Save As" dialog
	 * @param {object} document - Optional. A HTML document for creating a temporary anchor
	 *                            for triggering a file download.
	 */

	function saveAs(blob) {
	  var filename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
	  var doc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;

	  var url = URL.createObjectURL(blob);
	  var a = doc.createElement("a");
	  doc.body.appendChild(a);
	  a.style = "display: none";
	  a.href = url;
	  a.download = filename;
	  a.click();
	  URL.revokeObjectURL(url);
	  a.remove();
	}

	exports.saveAs = saveAs;

/***/ },
/* 846 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(2),
	    dom = _require.DOM,
	    createClass = _require.createClass,
	    PropTypes = _require.PropTypes;

	var _require2 = __webpack_require__(847),
	    getSourceNames = _require2.getSourceNames,
	    parseURL = _require2.parseURL,
	    isScratchpadScheme = _require2.isScratchpadScheme,
	    getSourceMappedFile = _require2.getSourceMappedFile;
	// const { LocalizationHelper } = require("devtools/shared/l10n");
	//
	// const l10n = new LocalizationHelper("devtools/client/locales/components.properties");
	// const webl10n = new LocalizationHelper("devtools/client/locales/webconsole.properties");

	var l10n = { getStr: () => {} };
	var webl10n = { getStr: () => {} };

	module.exports = createClass({
	  displayName: "Frame",

	  propTypes: {
	    // SavedFrame, or an object containing all the required properties.
	    frame: PropTypes.shape({
	      functionDisplayName: PropTypes.string,
	      source: PropTypes.string.isRequired,
	      line: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
	      column: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
	    }).isRequired,
	    // Clicking on the frame link -- probably should link to the debugger.
	    onClick: PropTypes.func.isRequired,
	    // Option to display a function name before the source link.
	    showFunctionName: PropTypes.bool,
	    // Option to display a function name even if it's anonymous.
	    showAnonymousFunctionName: PropTypes.bool,
	    // Option to display a host name after the source link.
	    showHost: PropTypes.bool,
	    // Option to display a host name if the filename is empty or just '/'
	    showEmptyPathAsHost: PropTypes.bool,
	    // Option to display a full source instead of just the filename.
	    showFullSourceUrl: PropTypes.bool,
	    // Service to enable the source map feature for console.
	    sourceMapService: PropTypes.object
	  },

	  getDefaultProps() {
	    return {
	      showFunctionName: false,
	      showAnonymousFunctionName: false,
	      showHost: false,
	      showEmptyPathAsHost: false,
	      showFullSourceUrl: false
	    };
	  },

	  componentWillMount() {
	    var sourceMapService = this.props.sourceMapService;
	    if (sourceMapService) {
	      var source = this.getSource();
	      sourceMapService.subscribe(source, this.onSourceUpdated);
	    }
	  },

	  componentWillUnmount() {
	    var sourceMapService = this.props.sourceMapService;
	    if (sourceMapService) {
	      var source = this.getSource();
	      sourceMapService.unsubscribe(source, this.onSourceUpdated);
	    }
	  },

	  /**
	   * Component method to update the FrameView when a resolved location is available
	   * @param event
	   * @param location
	   */
	  onSourceUpdated(event, location, resolvedLocation) {
	    var frame = this.getFrame(resolvedLocation);
	    this.setState({
	      frame,
	      isSourceMapped: true
	    });
	  },

	  /**
	   * Utility method to convert the Frame object to the
	   * Source Object model required by SourceMapService
	   * @param frame
	   * @returns {{url: *, line: *, column: *}}
	   */
	  getSource(frame) {
	    frame = frame || this.props.frame;
	    var _frame = frame,
	        source = _frame.source,
	        line = _frame.line,
	        column = _frame.column;

	    return {
	      url: source,
	      line,
	      column
	    };
	  },

	  /**
	   * Utility method to convert the Source object model to the
	   * Frame object model required by FrameView class.
	   * @param source
	   * @returns {{source: *, line: *, column: *, functionDisplayName: *}}
	   */
	  getFrame(source) {
	    var url = source.url,
	        line = source.line,
	        column = source.column;

	    return {
	      source: url,
	      line,
	      column,
	      functionDisplayName: this.props.frame.functionDisplayName
	    };
	  },

	  render() {
	    var frame = void 0,
	        isSourceMapped = void 0;
	    var _props = this.props,
	        onClick = _props.onClick,
	        showFunctionName = _props.showFunctionName,
	        showAnonymousFunctionName = _props.showAnonymousFunctionName,
	        showHost = _props.showHost,
	        showEmptyPathAsHost = _props.showEmptyPathAsHost,
	        showFullSourceUrl = _props.showFullSourceUrl;


	    if (this.state && this.state.isSourceMapped) {
	      frame = this.state.frame;
	      isSourceMapped = this.state.isSourceMapped;
	    } else {
	      frame = this.props.frame;
	    }

	    var source = frame.source ? String(frame.source) : "";
	    var line = frame.line != void 0 ? Number(frame.line) : null;
	    var column = frame.column != void 0 ? Number(frame.column) : null;

	    var _getSourceNames = getSourceNames(source),
	        short = _getSourceNames.short,
	        long = _getSourceNames.long,
	        host = _getSourceNames.host;
	    // Reparse the URL to determine if we should link this; `getSourceNames`
	    // has already cached this indirectly. We don't want to attempt to
	    // link to "self-hosted" and "(unknown)". However, we do want to link
	    // to Scratchpad URIs.
	    // Source mapped sources might not necessary linkable, but they
	    // are still valid in the debugger.


	    var isLinkable = !!(isScratchpadScheme(source) || parseURL(source)) || isSourceMapped;
	    var elements = [];
	    var sourceElements = [];
	    var sourceEl = void 0;

	    var tooltip = long;

	    // If the source is linkable and line > 0
	    var shouldDisplayLine = isLinkable && line;

	    // Exclude all falsy values, including `0`, as even
	    // a number 0 for line doesn't make sense, and should not be displayed.
	    // If source isn't linkable, don't attempt to append line and column
	    // info, as this probably doesn't make sense.
	    if (shouldDisplayLine) {
	      tooltip += `:${line}`;
	      // Intentionally exclude 0
	      if (column) {
	        tooltip += `:${column}`;
	      }
	    }

	    var attributes = {
	      "data-url": long,
	      className: "frame-link"
	    };

	    if (showFunctionName) {
	      var functionDisplayName = frame.functionDisplayName;
	      if (!functionDisplayName && showAnonymousFunctionName) {
	        functionDisplayName = webl10n.getStr("stacktrace.anonymousFunction");
	      }

	      if (functionDisplayName) {
	        elements.push(dom.span({ className: "frame-link-function-display-name" }, functionDisplayName), " ");
	      }
	    }

	    var displaySource = showFullSourceUrl ? long : short;
	    if (isSourceMapped) {
	      displaySource = getSourceMappedFile(displaySource);
	    } else if (showEmptyPathAsHost && (displaySource === "" || displaySource === "/")) {
	      displaySource = host;
	    }

	    sourceElements.push(dom.span({
	      className: "frame-link-filename"
	    }, displaySource));

	    // If source is linkable, and we have a line number > 0
	    if (shouldDisplayLine) {
	      var lineInfo = `:${line}`;
	      // Add `data-line` attribute for testing
	      attributes["data-line"] = line;

	      // Intentionally exclude 0
	      if (column) {
	        lineInfo += `:${column}`;
	        // Add `data-column` attribute for testing
	        attributes["data-column"] = column;
	      }

	      sourceElements.push(dom.span({ className: "frame-link-line" }, lineInfo));
	    }

	    // Inner el is useful for achieving ellipsis on the left and correct LTR/RTL
	    // ordering. See CSS styles for frame-link-source-[inner] and bug 1290056.
	    var sourceInnerEl = dom.span({
	      className: "frame-link-source-inner",
	      title: isLinkable ? l10n.getFormatStr("frame.viewsourceindebugger", tooltip) : tooltip
	    }, sourceElements);

	    // If source is not a URL (self-hosted, eval, etc.), don't make
	    // it an anchor link, as we can't link to it.
	    if (isLinkable) {
	      sourceEl = dom.a({
	        onClick: e => {
	          e.preventDefault();
	          onClick(this.getSource(frame));
	        },
	        href: source,
	        className: "frame-link-source",
	        draggable: false
	      }, sourceInnerEl);
	    } else {
	      sourceEl = dom.span({
	        className: "frame-link-source"
	      }, sourceInnerEl);
	    }
	    elements.push(sourceEl);

	    if (showHost && host) {
	      elements.push(" ", dom.span({ className: "frame-link-host" }, host));
	    }

	    return dom.span.apply(dom, [attributes].concat(elements));
	  }
	});

/***/ },
/* 847 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	// const { LocalizationHelper } = require("devtools/shared/l10n");
	//
	// const l10n = new LocalizationHelper("devtools/client/locales/components.properties");
	// const UNKNOWN_SOURCE_STRING = l10n.getStr("frame.unknownSource");

	var l10n = {
	  getStr: () => {}
	};

	// Character codes used in various parsing helper functions.
	var CHAR_CODE_A = "a".charCodeAt(0);
	var CHAR_CODE_C = "c".charCodeAt(0);
	var CHAR_CODE_D = "d".charCodeAt(0);
	var CHAR_CODE_E = "e".charCodeAt(0);
	var CHAR_CODE_F = "f".charCodeAt(0);
	var CHAR_CODE_H = "h".charCodeAt(0);
	var CHAR_CODE_I = "i".charCodeAt(0);
	var CHAR_CODE_J = "j".charCodeAt(0);
	var CHAR_CODE_L = "l".charCodeAt(0);
	var CHAR_CODE_M = "m".charCodeAt(0);
	var CHAR_CODE_O = "o".charCodeAt(0);
	var CHAR_CODE_P = "p".charCodeAt(0);
	var CHAR_CODE_R = "r".charCodeAt(0);
	var CHAR_CODE_S = "s".charCodeAt(0);
	var CHAR_CODE_T = "t".charCodeAt(0);
	var CHAR_CODE_U = "u".charCodeAt(0);
	var CHAR_CODE_COLON = ":".charCodeAt(0);
	var CHAR_CODE_SLASH = "/".charCodeAt(0);
	var CHAR_CODE_CAP_S = "S".charCodeAt(0);

	// The cache used in the `parseURL` function.
	var gURLStore = new Map();
	// The cache used in the `getSourceNames` function.
	var gSourceNamesStore = new Map();

	/**
	 * Takes a string and returns an object containing all the properties
	 * available on an URL instance, with additional properties (fileName),
	 * Leverages caching.
	 *
	 * @param {String} location
	 * @return {Object?} An object containing most properties available
	 *                   in https://developer.mozilla.org/en-US/docs/Web/API/URL
	 */

	function parseURL(location) {
	  var url = gURLStore.get(location);

	  if (url !== void 0) {
	    return url;
	  }

	  try {
	    url = new URL(location);
	    // The callers were generally written to expect a URL from
	    // sdk/url, which is subtly different.  So, work around some
	    // important differences here.
	    url = {
	      href: url.href,
	      protocol: url.protocol,
	      host: url.host,
	      hostname: url.hostname,
	      port: url.port || null,
	      pathname: url.pathname,
	      search: url.search,
	      hash: url.hash,
	      username: url.username,
	      password: url.password,
	      origin: url.origin
	    };

	    // Definitions:
	    // Example: https://foo.com:8888/file.js
	    // `hostname`: "foo.com"
	    // `host`: "foo.com:8888"
	    var isChrome = isChromeScheme(location);

	    url.fileName = url.pathname ? url.pathname.slice(url.pathname.lastIndexOf("/") + 1) || "/" : "/";

	    if (isChrome) {
	      url.hostname = null;
	      url.host = null;
	    }

	    gURLStore.set(location, url);
	    return url;
	  } catch (e) {
	    gURLStore.set(location, null);
	    return null;
	  }
	}

	/**
	 * Parse a source into a short and long name as well as a host name.
	 *
	 * @param {String} source
	 *        The source to parse. Can be a URI or names like "(eval)" or
	 *        "self-hosted".
	 * @return {Object}
	 *         An object with the following properties:
	 *           - {String} short: A short name for the source.
	 *             - "http://page.com/test.js#go?q=query" -> "test.js"
	 *           - {String} long: The full, long name for the source, with
	               hash/query stripped.
	 *             - "http://page.com/test.js#go?q=query" -> "http://page.com/test.js"
	 *           - {String?} host: If available, the host name for the source.
	 *             - "http://page.com/test.js#go?q=query" -> "page.com"
	 */
	function getSourceNames(source) {
	  var data = gSourceNamesStore.get(source);

	  if (data) {
	    return data;
	  }

	  var short = void 0,
	      long = void 0,
	      host = void 0;
	  var sourceStr = source ? String(source) : "";

	  // If `data:...` uri
	  if (isDataScheme(sourceStr)) {
	    var commaIndex = sourceStr.indexOf(",");
	    if (commaIndex > -1) {
	      // The `short` name for a data URI becomes `data:` followed by the actual
	      // encoded content, omitting the MIME type, and charset.
	      short = `data:${sourceStr.substring(commaIndex + 1)}`.slice(0, 100);
	      var _result = { short, long: sourceStr };
	      gSourceNamesStore.set(source, _result);
	      return _result;
	    }
	  }

	  // If Scratchpad URI, like "Scratchpad/1"; no modifications,
	  // and short/long are the same.
	  if (isScratchpadScheme(sourceStr)) {
	    var _result2 = { short: sourceStr, long: sourceStr };
	    gSourceNamesStore.set(source, _result2);
	    return _result2;
	  }

	  var parsedUrl = parseURL(sourceStr);

	  if (!parsedUrl) {
	    // Malformed URI.
	    long = sourceStr;
	    short = sourceStr.slice(0, 100);
	  } else {
	    host = parsedUrl.host;

	    long = parsedUrl.href;
	    if (parsedUrl.hash) {
	      long = long.replace(parsedUrl.hash, "");
	    }
	    if (parsedUrl.search) {
	      long = long.replace(parsedUrl.search, "");
	    }

	    short = parsedUrl.fileName;
	    // If `short` is just a slash, and we actually have a path,
	    // strip the slash and parse again to get a more useful short name.
	    // e.g. "http://foo.com/bar/" -> "bar", rather than "/"
	    if (short === "/" && parsedUrl.pathname !== "/") {
	      short = parseURL(long.replace(/\/$/, "")).fileName;
	    }
	  }

	  if (!short) {
	    if (!long) {
	      long = UNKNOWN_SOURCE_STRING;
	    }
	    short = long.slice(0, 100);
	  }

	  var result = { short, long, host };
	  gSourceNamesStore.set(source, result);
	  return result;
	}

	// For the functions below, we assume that we will never access the location
	// argument out of bounds, which is indeed the vast majority of cases.
	//
	// They are written this way because they are hot. Each frame is checked for
	// being content or chrome when processing the profile.

	function isColonSlashSlash(location) {
	  var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	  return location.charCodeAt(++i) === CHAR_CODE_COLON && location.charCodeAt(++i) === CHAR_CODE_SLASH && location.charCodeAt(++i) === CHAR_CODE_SLASH;
	}

	/**
	 * Checks for a Scratchpad URI, like "Scratchpad/1"
	 */
	function isScratchpadScheme(location) {
	  var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	  return location.charCodeAt(i) === CHAR_CODE_CAP_S && location.charCodeAt(++i) === CHAR_CODE_C && location.charCodeAt(++i) === CHAR_CODE_R && location.charCodeAt(++i) === CHAR_CODE_A && location.charCodeAt(++i) === CHAR_CODE_T && location.charCodeAt(++i) === CHAR_CODE_C && location.charCodeAt(++i) === CHAR_CODE_H && location.charCodeAt(++i) === CHAR_CODE_P && location.charCodeAt(++i) === CHAR_CODE_A && location.charCodeAt(++i) === CHAR_CODE_D && location.charCodeAt(++i) === CHAR_CODE_SLASH;
	}

	function isDataScheme(location) {
	  var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	  return location.charCodeAt(i) === CHAR_CODE_D && location.charCodeAt(++i) === CHAR_CODE_A && location.charCodeAt(++i) === CHAR_CODE_T && location.charCodeAt(++i) === CHAR_CODE_A && location.charCodeAt(++i) === CHAR_CODE_COLON;
	}

	function isContentScheme(location) {
	  var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	  var firstChar = location.charCodeAt(i);

	  switch (firstChar) {
	    // "http://" or "https://"
	    case CHAR_CODE_H:
	      if (location.charCodeAt(++i) === CHAR_CODE_T && location.charCodeAt(++i) === CHAR_CODE_T && location.charCodeAt(++i) === CHAR_CODE_P) {
	        if (location.charCodeAt(i + 1) === CHAR_CODE_S) {
	          ++i;
	        }
	        return isColonSlashSlash(location, i);
	      }
	      return false;

	    // "file://"
	    case CHAR_CODE_F:
	      if (location.charCodeAt(++i) === CHAR_CODE_I && location.charCodeAt(++i) === CHAR_CODE_L && location.charCodeAt(++i) === CHAR_CODE_E) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;

	    // "app://"
	    case CHAR_CODE_A:
	      if (location.charCodeAt(++i) == CHAR_CODE_P && location.charCodeAt(++i) == CHAR_CODE_P) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;

	    default:
	      return false;
	  }
	}

	function isChromeScheme(location) {
	  var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	  var firstChar = location.charCodeAt(i);

	  switch (firstChar) {
	    // "chrome://"
	    case CHAR_CODE_C:
	      if (location.charCodeAt(++i) === CHAR_CODE_H && location.charCodeAt(++i) === CHAR_CODE_R && location.charCodeAt(++i) === CHAR_CODE_O && location.charCodeAt(++i) === CHAR_CODE_M && location.charCodeAt(++i) === CHAR_CODE_E) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;

	    // "resource://"
	    case CHAR_CODE_R:
	      if (location.charCodeAt(++i) === CHAR_CODE_E && location.charCodeAt(++i) === CHAR_CODE_S && location.charCodeAt(++i) === CHAR_CODE_O && location.charCodeAt(++i) === CHAR_CODE_U && location.charCodeAt(++i) === CHAR_CODE_R && location.charCodeAt(++i) === CHAR_CODE_C && location.charCodeAt(++i) === CHAR_CODE_E) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;

	    // "jar:file://"
	    case CHAR_CODE_J:
	      if (location.charCodeAt(++i) === CHAR_CODE_A && location.charCodeAt(++i) === CHAR_CODE_R && location.charCodeAt(++i) === CHAR_CODE_COLON && location.charCodeAt(++i) === CHAR_CODE_F && location.charCodeAt(++i) === CHAR_CODE_I && location.charCodeAt(++i) === CHAR_CODE_L && location.charCodeAt(++i) === CHAR_CODE_E) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;

	    default:
	      return false;
	  }
	}

	/**
	 * A utility method to get the file name from a sourcemapped location
	 * The sourcemap location can be in any form. This method returns a
	 * formatted file name for different cases like Windows or OSX.
	 * @param source
	 * @returns String
	 */
	function getSourceMappedFile(source) {
	  // If sourcemapped source is a OSX path, return
	  // the characters after last "/".
	  // If sourcemapped source is a Windowss path, return
	  // the characters after last "\\".
	  if (source.lastIndexOf("/") >= 0) {
	    source = source.slice(source.lastIndexOf("/") + 1);
	  } else if (source.lastIndexOf("\\") >= 0) {
	    source = source.slice(source.lastIndexOf("\\") + 1);
	  }
	  return source;
	}

	exports.parseURL = parseURL;
	exports.getSourceNames = getSourceNames;
	exports.isScratchpadScheme = isScratchpadScheme;
	exports.isChromeScheme = isChromeScheme;
	exports.isContentScheme = isContentScheme;
	exports.isDataScheme = isDataScheme;
	exports.getSourceMappedFile = getSourceMappedFile;

/***/ },
/* 848 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var EventEmitter = __webpack_require__(844);

	/**
	 * A partial implementation of the Menu API provided by electron:
	 * https://github.com/electron/electron/blob/master/docs/api/menu.md.
	 *
	 * Extra features:
	 *  - Emits an 'open' and 'close' event when the menu is opened/closed

	 * @param String id (non standard)
	 *        Needed so tests can confirm the XUL implementation is working
	 */
	function Menu() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      _ref$id = _ref.id,
	      id = _ref$id === undefined ? null : _ref$id;

	  this.menuitems = [];
	  this.id = id;

	  Object.defineProperty(this, "items", {
	    get() {
	      return this.menuitems;
	    }
	  });

	  EventEmitter.decorate(this);
	}

	/**
	 * Add an item to the end of the Menu
	 *
	 * @param {MenuItem} menuItem
	 */
	Menu.prototype.append = function (menuItem) {
	  this.menuitems.push(menuItem);
	};

	/**
	 * Add an item to a specified position in the menu
	 *
	 * @param {int} pos
	 * @param {MenuItem} menuItem
	 */
	Menu.prototype.insert = function (pos, menuItem) {
	  throw Error("Not implemented");
	};

	/**
	 * Show the Menu at a specified location on the screen
	 *
	 * Missing features:
	 *   - browserWindow - BrowserWindow (optional) - Default is null.
	 *   - positioningItem Number - (optional) OS X
	 *
	 * @param {int} screenX
	 * @param {int} screenY
	 * @param Toolbox toolbox (non standard)
	 *        Needed so we in which window to inject XUL
	 */
	Menu.prototype.popup = function (screenX, screenY, toolbox) {
	  var doc = toolbox.doc;
	  var popupset = doc.querySelector("popupset");
	  // See bug 1285229, on Windows, opening the same popup multiple times in a
	  // row ends up duplicating the popup. The newly inserted popup doesn't
	  // dismiss the old one. So remove any previously displayed popup before
	  // opening a new one.
	  var popup = popupset.querySelector("menupopup[menu-api=\"true\"]");
	  if (popup) {
	    popup.hidePopup();
	  }

	  popup = this.createPopup(doc);
	  popup.setAttribute("menu-api", "true");

	  if (this.id) {
	    popup.id = this.id;
	  }
	  this._createMenuItems(popup);

	  // Remove the menu from the DOM once it's hidden.
	  popup.addEventListener("popuphidden", e => {
	    if (e.target === popup) {
	      popup.remove();
	      this.emit("close", popup);
	    }
	  });

	  popup.addEventListener("popupshown", e => {
	    if (e.target === popup) {
	      this.emit("open", popup);
	    }
	  });

	  popupset.appendChild(popup);
	  popup.openPopupAtScreen(screenX, screenY, true);
	};

	Menu.prototype.createPopup = function (doc) {
	  return doc.createElement("menupopup");
	};

	Menu.prototype._createMenuItems = function (parent) {
	  var doc = parent.ownerDocument;
	  this.menuitems.forEach(item => {
	    if (!item.visible) {
	      return;
	    }

	    if (item.submenu) {
	      var menupopup = doc.createElement("menupopup");
	      item.submenu._createMenuItems(menupopup);

	      var menu = doc.createElement("menu");
	      menu.appendChild(menupopup);
	      menu.setAttribute("label", item.label);
	      if (item.disabled) {
	        menu.setAttribute("disabled", "true");
	      }
	      if (item.accesskey) {
	        menu.setAttribute("accesskey", item.accesskey);
	      }
	      if (item.id) {
	        menu.id = item.id;
	      }
	      parent.appendChild(menu);
	    } else if (item.type === "separator") {
	      var menusep = doc.createElement("menuseparator");
	      parent.appendChild(menusep);
	    } else {
	      var menuitem = doc.createElement("menuitem");
	      menuitem.setAttribute("label", item.label);
	      menuitem.textContent = item.label;
	      menuitem.addEventListener("command", () => item.click());

	      if (item.type === "checkbox") {
	        menuitem.setAttribute("type", "checkbox");
	      }
	      if (item.type === "radio") {
	        menuitem.setAttribute("type", "radio");
	      }
	      if (item.disabled) {
	        menuitem.setAttribute("disabled", "true");
	      }
	      if (item.checked) {
	        menuitem.setAttribute("checked", "true");
	      }
	      if (item.accesskey) {
	        menuitem.setAttribute("accesskey", item.accesskey);
	      }
	      if (item.id) {
	        menuitem.id = item.id;
	      }

	      parent.appendChild(menuitem);
	    }
	  });
	};

	Menu.setApplicationMenu = () => {
	  throw Error("Not implemented");
	};

	Menu.sendActionToFirstResponder = () => {
	  throw Error("Not implemented");
	};

	Menu.buildFromTemplate = () => {
	  throw Error("Not implemented");
	};

	module.exports = Menu;

/***/ },
/* 849 */
/***/ function(module, exports) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * A partial implementation of the MenuItem API provided by electron:
	 * https://github.com/electron/electron/blob/master/docs/api/menu-item.md.
	 *
	 * Missing features:
	 *   - id String - Unique within a single menu. If defined then it can be used
	 *                 as a reference to this item by the position attribute.
	 *   - role String - Define the action of the menu item; when specified the
	 *                   click property will be ignored
	 *   - sublabel String
	 *   - accelerator Accelerator
	 *   - icon NativeImage
	 *   - position String - This field allows fine-grained definition of the
	 *                       specific location within a given menu.
	 *
	 * Implemented features:
	 *  @param Object options
	 *    Function click
	 *      Will be called with click(menuItem, browserWindow) when the menu item
	 *       is clicked
	 *    String type
	 *      Can be normal, separator, submenu, checkbox or radio
	 *    String label
	 *    Boolean enabled
	 *      If false, the menu item will be greyed out and unclickable.
	 *    Boolean checked
	 *      Should only be specified for checkbox or radio type menu items.
	 *    Menu submenu
	 *      Should be specified for submenu type menu items. If submenu is specified,
	 *      the type: 'submenu' can be omitted. If the value is not a Menu then it
	 *      will be automatically converted to one using Menu.buildFromTemplate.
	 *    Boolean visible
	 *      If false, the menu item will be entirely hidden.
	 */

	function MenuItem() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      _ref$accesskey = _ref.accesskey,
	      accesskey = _ref$accesskey === undefined ? null : _ref$accesskey,
	      _ref$checked = _ref.checked,
	      checked = _ref$checked === undefined ? false : _ref$checked,
	      _ref$click = _ref.click,
	      click = _ref$click === undefined ? () => {} : _ref$click,
	      _ref$disabled = _ref.disabled,
	      disabled = _ref$disabled === undefined ? false : _ref$disabled,
	      _ref$label = _ref.label,
	      label = _ref$label === undefined ? "" : _ref$label,
	      _ref$id = _ref.id,
	      id = _ref$id === undefined ? null : _ref$id,
	      _ref$submenu = _ref.submenu,
	      submenu = _ref$submenu === undefined ? null : _ref$submenu,
	      _ref$type = _ref.type,
	      type = _ref$type === undefined ? "normal" : _ref$type,
	      _ref$visible = _ref.visible,
	      visible = _ref$visible === undefined ? true : _ref$visible;

	  this.accesskey = accesskey;
	  this.checked = checked;
	  this.click = click;
	  this.disabled = disabled;
	  this.id = id;
	  this.label = label;
	  this.submenu = submenu;
	  this.type = type;
	  this.visible = visible;
	}

	module.exports = MenuItem;

/***/ },
/* 850 */
/***/ function(module, exports) {

	"use strict";

	// opts is ignored because this is only used in local development and
	// replaces a more powerful network request from Firefox that can be
	// configured.
	function networkRequest(url, opts) {
	  return Promise.race([fetch(`/get?url=${url}`).then(res => {
	    if (res.status >= 200 && res.status < 300) {
	      return res.text().then(text => ({ content: text }));
	    }
	    return Promise.reject(new Error(`failed to request ${url}`));
	  }), new Promise((resolve, reject) => {
	    setTimeout(() => reject(new Error("Connect timeout error")), 6000);
	  })]);
	}

	module.exports = networkRequest;

/***/ },
/* 851 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var Services = __webpack_require__(29);
	var EventEmitter = __webpack_require__(844);

	/**
	 * Shortcuts for lazily accessing and setting various preferences.
	 * Usage:
	 *   let prefs = new Prefs("root.path.to.branch", {
	 *     myIntPref: ["Int", "leaf.path.to.my-int-pref"],
	 *     myCharPref: ["Char", "leaf.path.to.my-char-pref"],
	 *     myJsonPref: ["Json", "leaf.path.to.my-json-pref"],
	 *     myFloatPref: ["Float", "leaf.path.to.my-float-pref"]
	 *     ...
	 *   });
	 *
	 * Get/set:
	 *   prefs.myCharPref = "foo";
	 *   let aux = prefs.myCharPref;
	 *
	 * Observe:
	 *   prefs.registerObserver();
	 *   prefs.on("pref-changed", (prefName, prefValue) => {
	 *     ...
	 *   });
	 *
	 * @param string prefsRoot
	 *        The root path to the required preferences branch.
	 * @param object prefsBlueprint
	 *        An object containing { accessorName: [prefType, prefName] } keys.
	 */
	function PrefsHelper() {
	  var prefsRoot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
	  var prefsBlueprint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  EventEmitter.decorate(this);

	  var cache = new Map();

	  for (var accessorName in prefsBlueprint) {
	    var _prefsBlueprint$acces = _slicedToArray(prefsBlueprint[accessorName], 2),
	        prefType = _prefsBlueprint$acces[0],
	        prefName = _prefsBlueprint$acces[1];

	    map(this, cache, accessorName, prefType, prefsRoot, prefName);
	  }

	  var observer = makeObserver(this, cache, prefsRoot, prefsBlueprint);
	  this.registerObserver = () => observer.register();
	  this.unregisterObserver = () => observer.unregister();
	}

	/**
	 * Helper method for getting a pref value.
	 *
	 * @param Map cache
	 * @param string prefType
	 * @param string prefsRoot
	 * @param string prefName
	 * @return any
	 */
	function get(cache, prefType, prefsRoot, prefName) {
	  var cachedPref = cache.get(prefName);
	  if (cachedPref !== undefined) {
	    return cachedPref;
	  }
	  var value = Services.prefs["get" + prefType + "Pref"]([prefsRoot, prefName].join("."));
	  cache.set(prefName, value);
	  return value;
	}

	/**
	 * Helper method for setting a pref value.
	 *
	 * @param Map cache
	 * @param string prefType
	 * @param string prefsRoot
	 * @param string prefName
	 * @param any value
	 */
	function set(cache, prefType, prefsRoot, prefName, value) {
	  Services.prefs["set" + prefType + "Pref"]([prefsRoot, prefName].join("."), value);
	  cache.set(prefName, value);
	}

	/**
	 * Maps a property name to a pref, defining lazy getters and setters.
	 * Supported types are "Bool", "Char", "Int", "Float" (sugar around "Char"
	 * type and casting), and "Json" (which is basically just sugar for "Char"
	 * using the standard JSON serializer).
	 *
	 * @param PrefsHelper self
	 * @param Map cache
	 * @param string accessorName
	 * @param string prefType
	 * @param string prefsRoot
	 * @param string prefName
	 * @param array serializer [optional]
	 */
	function map(self, cache, accessorName, prefType, prefsRoot, prefName) {
	  var serializer = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : { in: e => e, out: e => e };

	  if (prefName in self) {
	    throw new Error(`Can't use ${prefName} because it overrides a property` + "on the instance.");
	  }
	  if (prefType == "Json") {
	    map(self, cache, accessorName, "Char", prefsRoot, prefName, {
	      in: JSON.parse,
	      out: JSON.stringify
	    });
	    return;
	  }
	  if (prefType == "Float") {
	    map(self, cache, accessorName, "Char", prefsRoot, prefName, {
	      in: Number.parseFloat,
	      out: n => n + ""
	    });
	    return;
	  }

	  Object.defineProperty(self, accessorName, {
	    get: () => serializer.in(get(cache, prefType, prefsRoot, prefName)),
	    set: e => set(cache, prefType, prefsRoot, prefName, serializer.out(e))
	  });
	}

	/**
	 * Finds the accessor for the provided pref, based on the blueprint object
	 * used in the constructor.
	 *
	 * @param PrefsHelper self
	 * @param object prefsBlueprint
	 * @return string
	 */
	function accessorNameForPref(somePrefName, prefsBlueprint) {
	  for (var accessorName in prefsBlueprint) {
	    var _prefsBlueprint$acces2 = _slicedToArray(prefsBlueprint[accessorName], 2),
	        prefName = _prefsBlueprint$acces2[1];

	    if (somePrefName == prefName) {
	      return accessorName;
	    }
	  }
	  return "";
	}

	/**
	 * Creates a pref observer for `self`.
	 *
	 * @param PrefsHelper self
	 * @param Map cache
	 * @param string prefsRoot
	 * @param object prefsBlueprint
	 * @return object
	 */
	function makeObserver(self, cache, prefsRoot, prefsBlueprint) {
	  return {
	    register: function () {
	      this._branch = Services.prefs.getBranch(prefsRoot + ".");
	      this._branch.addObserver("", this);
	    },
	    unregister: function () {
	      this._branch.removeObserver("", this);
	    },
	    observe: function (subject, topic, prefName) {
	      // If this particular pref isn't handled by the blueprint object,
	      // even though it's in the specified branch, ignore it.
	      var accessorName = accessorNameForPref(prefName, prefsBlueprint);
	      if (!(accessorName in self)) {
	        return;
	      }
	      cache.delete(prefName);
	      self.emit("pref-changed", accessorName, self[accessorName]);
	    }
	  };
	}

	exports.PrefsHelper = PrefsHelper;

/***/ },
/* 852 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */

	/* global window */

	"use strict";

	var _require = __webpack_require__(2),
	    dom = _require.DOM,
	    createClass = _require.createClass,
	    PropTypes = _require.PropTypes;

	var _require2 = __webpack_require__(853),
	    KeyShortcuts = _require2.KeyShortcuts;

	/**
	 * A generic search box component for use across devtools
	 */


	module.exports = createClass({
	  displayName: "SearchBox",

	  propTypes: {
	    delay: PropTypes.number,
	    keyShortcut: PropTypes.string,
	    onChange: PropTypes.func,
	    placeholder: PropTypes.string,
	    type: PropTypes.string
	  },

	  getInitialState() {
	    return {
	      value: ""
	    };
	  },

	  componentDidMount() {
	    if (!this.props.keyShortcut) {
	      return;
	    }

	    this.shortcuts = new KeyShortcuts({
	      window
	    });
	    this.shortcuts.on(this.props.keyShortcut, (name, event) => {
	      event.preventDefault();
	      this.refs.input.focus();
	    });
	  },

	  componentWillUnmount() {
	    if (this.shortcuts) {
	      this.shortcuts.destroy();
	    }

	    // Clean up an existing timeout.
	    if (this.searchTimeout) {
	      clearTimeout(this.searchTimeout);
	    }
	  },

	  onChange() {
	    if (this.state.value !== this.refs.input.value) {
	      this.setState({ value: this.refs.input.value });
	    }

	    if (!this.props.delay) {
	      this.props.onChange(this.state.value);
	      return;
	    }

	    // Clean up an existing timeout before creating a new one.
	    if (this.searchTimeout) {
	      clearTimeout(this.searchTimeout);
	    }

	    // Execute the search after a timeout. It makes the UX
	    // smoother if the user is typing quickly.
	    this.searchTimeout = setTimeout(() => {
	      this.searchTimeout = null;
	      this.props.onChange(this.state.value);
	    }, this.props.delay);
	  },

	  onClearButtonClick() {
	    this.refs.input.value = "";
	    this.onChange();
	  },

	  render() {
	    var _props = this.props,
	        _props$type = _props.type,
	        type = _props$type === undefined ? "search" : _props$type,
	        placeholder = _props.placeholder;
	    var value = this.state.value;

	    var divClassList = ["devtools-searchbox", "has-clear-btn"];
	    var inputClassList = [`devtools-${type}input`];

	    if (value !== "") {
	      inputClassList.push("filled");
	    }
	    return dom.div({ className: divClassList.join(" ") }, dom.input({
	      className: inputClassList.join(" "),
	      onChange: this.onChange,
	      placeholder,
	      ref: "input",
	      value
	    }), dom.button({
	      className: "devtools-searchinput-clear",
	      hidden: value == "",
	      onClick: this.onClearButtonClick
	    }));
	  }
	});

/***/ },
/* 853 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var _require = __webpack_require__(29),
	    appinfo = _require.appinfo;

	var EventEmitter = __webpack_require__(844);
	var isOSX = appinfo.OS === "Darwin";
	"use strict";

	// List of electron keys mapped to DOM API (DOM_VK_*) key code
	var ElectronKeysMapping = {
	  "F1": "DOM_VK_F1",
	  "F2": "DOM_VK_F2",
	  "F3": "DOM_VK_F3",
	  "F4": "DOM_VK_F4",
	  "F5": "DOM_VK_F5",
	  "F6": "DOM_VK_F6",
	  "F7": "DOM_VK_F7",
	  "F8": "DOM_VK_F8",
	  "F9": "DOM_VK_F9",
	  "F10": "DOM_VK_F10",
	  "F11": "DOM_VK_F11",
	  "F12": "DOM_VK_F12",
	  "F13": "DOM_VK_F13",
	  "F14": "DOM_VK_F14",
	  "F15": "DOM_VK_F15",
	  "F16": "DOM_VK_F16",
	  "F17": "DOM_VK_F17",
	  "F18": "DOM_VK_F18",
	  "F19": "DOM_VK_F19",
	  "F20": "DOM_VK_F20",
	  "F21": "DOM_VK_F21",
	  "F22": "DOM_VK_F22",
	  "F23": "DOM_VK_F23",
	  "F24": "DOM_VK_F24",
	  "Space": "DOM_VK_SPACE",
	  "Backspace": "DOM_VK_BACK_SPACE",
	  "Delete": "DOM_VK_DELETE",
	  "Insert": "DOM_VK_INSERT",
	  "Return": "DOM_VK_RETURN",
	  "Enter": "DOM_VK_RETURN",
	  "Up": "DOM_VK_UP",
	  "Down": "DOM_VK_DOWN",
	  "Left": "DOM_VK_LEFT",
	  "Right": "DOM_VK_RIGHT",
	  "Home": "DOM_VK_HOME",
	  "End": "DOM_VK_END",
	  "PageUp": "DOM_VK_PAGE_UP",
	  "PageDown": "DOM_VK_PAGE_DOWN",
	  "Escape": "DOM_VK_ESCAPE",
	  "Esc": "DOM_VK_ESCAPE",
	  "Tab": "DOM_VK_TAB",
	  "VolumeUp": "DOM_VK_VOLUME_UP",
	  "VolumeDown": "DOM_VK_VOLUME_DOWN",
	  "VolumeMute": "DOM_VK_VOLUME_MUTE",
	  "PrintScreen": "DOM_VK_PRINTSCREEN"
	};

	/**
	 * Helper to listen for keyboard events decribed in .properties file.
	 *
	 * let shortcuts = new KeyShortcuts({
	 *   window
	 * });
	 * shortcuts.on("Ctrl+F", event => {
	 *   // `event` is the KeyboardEvent which relates to the key shortcuts
	 * });
	 *
	 * @param DOMWindow window
	 *        The window object of the document to listen events from.
	 * @param DOMElement target
	 *        Optional DOM Element on which we should listen events from.
	 *        If omitted, we listen for all events fired on `window`.
	 */
	function KeyShortcuts(_ref) {
	  var window = _ref.window,
	      target = _ref.target;

	  this.window = window;
	  this.target = target || window;
	  this.keys = new Map();
	  this.eventEmitter = new EventEmitter();
	  this.target.addEventListener("keydown", this);
	}

	/*
	 * Parse an electron-like key string and return a normalized object which
	 * allow efficient match on DOM key event. The normalized object matches DOM
	 * API.
	 *
	 * @param DOMWindow window
	 *        Any DOM Window object, just to fetch its `KeyboardEvent` object
	 * @param String str
	 *        The shortcut string to parse, following this document:
	 *        https://github.com/electron/electron/blob/master/docs/api/accelerator.md
	 */
	KeyShortcuts.parseElectronKey = function (window, str) {
	  var modifiers = str.split("+");
	  var key = modifiers.pop();

	  var shortcut = {
	    ctrl: false,
	    meta: false,
	    alt: false,
	    shift: false,
	    // Set for character keys
	    key: undefined,
	    // Set for non-character keys
	    keyCode: undefined
	  };
	  for (var mod of modifiers) {
	    if (mod === "Alt") {
	      shortcut.alt = true;
	    } else if (["Command", "Cmd"].includes(mod)) {
	      shortcut.meta = true;
	    } else if (["CommandOrControl", "CmdOrCtrl"].includes(mod)) {
	      if (isOSX) {
	        shortcut.meta = true;
	      } else {
	        shortcut.ctrl = true;
	      }
	    } else if (["Control", "Ctrl"].includes(mod)) {
	      shortcut.ctrl = true;
	    } else if (mod === "Shift") {
	      shortcut.shift = true;
	    } else {
	      console.error("Unsupported modifier:", mod, "from key:", str);
	      return null;
	    }
	  }

	  // Plus is a special case. It's a character key and shouldn't be matched
	  // against a keycode as it is only accessible via Shift/Capslock
	  if (key === "Plus") {
	    key = "+";
	  }

	  if (typeof key === "string" && key.length === 1) {
	    // Match any single character
	    shortcut.key = key.toLowerCase();
	  } else if (key in ElectronKeysMapping) {
	    // Maps the others manually to DOM API DOM_VK_*
	    key = ElectronKeysMapping[key];
	    shortcut.keyCode = window.KeyboardEvent[key];
	    // Used only to stringify the shortcut
	    shortcut.keyCodeString = key;
	    shortcut.key = key;
	  } else {
	    console.error("Unsupported key:", key);
	    return null;
	  }

	  return shortcut;
	};

	KeyShortcuts.stringify = function (shortcut) {
	  var list = [];
	  if (shortcut.alt) {
	    list.push("Alt");
	  }
	  if (shortcut.ctrl) {
	    list.push("Ctrl");
	  }
	  if (shortcut.meta) {
	    list.push("Cmd");
	  }
	  if (shortcut.shift) {
	    list.push("Shift");
	  }
	  var key = void 0;
	  if (shortcut.key) {
	    key = shortcut.key.toUpperCase();
	  } else {
	    key = shortcut.keyCodeString;
	  }
	  list.push(key);
	  return list.join("+");
	};

	KeyShortcuts.prototype = {
	  destroy() {
	    this.target.removeEventListener("keydown", this);
	    this.keys.clear();
	  },

	  doesEventMatchShortcut(event, shortcut) {
	    if (shortcut.meta != event.metaKey) {
	      return false;
	    }
	    if (shortcut.ctrl != event.ctrlKey) {
	      return false;
	    }
	    if (shortcut.alt != event.altKey) {
	      return false;
	    }
	    // Shift is a special modifier, it may implicitely be required if the
	    // expected key is a special character accessible via shift.
	    if (shortcut.shift != event.shiftKey && event.key && event.key.match(/[a-zA-Z]/)) {
	      return false;
	    }
	    if (shortcut.keyCode) {
	      return event.keyCode == shortcut.keyCode;
	    } else if (event.key in ElectronKeysMapping) {
	      return ElectronKeysMapping[event.key] === shortcut.key;
	    }

	    // get the key from the keyCode if key is not provided.
	    var key = event.key || String.fromCharCode(event.keyCode);

	    // For character keys, we match if the final character is the expected one.
	    // But for digits we also accept indirect match to please azerty keyboard,
	    // which requires Shift to be pressed to get digits.
	    return key.toLowerCase() == shortcut.key || shortcut.key.match(/^[0-9]$/) && event.keyCode == shortcut.key.charCodeAt(0);
	  },

	  handleEvent(event) {
	    for (var _ref2 of this.keys) {
	      var _ref3 = _slicedToArray(_ref2, 2);

	      var key = _ref3[0];
	      var shortcut = _ref3[1];

	      if (this.doesEventMatchShortcut(event, shortcut)) {
	        this.eventEmitter.emit(key, event);
	      }
	    }
	  },

	  on(key, listener) {
	    if (typeof listener !== "function") {
	      throw new Error("KeyShortcuts.on() expects a function as " + "second argument");
	    }
	    if (!this.keys.has(key)) {
	      var shortcut = KeyShortcuts.parseElectronKey(this.window, key);
	      // The key string is wrong and we were unable to compute the key shortcut
	      if (!shortcut) {
	        return;
	      }
	      this.keys.set(key, shortcut);
	    }
	    this.eventEmitter.on(key, listener);
	  },

	  off(key, listener) {
	    this.eventEmitter.off(key, listener);
	  }
	};
	exports.KeyShortcuts = KeyShortcuts;

/***/ },
/* 854 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(22);
	var Draggable = React.createFactory(__webpack_require__(855));
	var dom = React.DOM,
	    PropTypes = React.PropTypes;

	/**
	 * This component represents a Splitter. The splitter supports vertical
	 * as well as horizontal mode.
	 */

	var SplitBox = React.createClass({

	  propTypes: {
	    // Custom class name. You can use more names separated by a space.
	    className: PropTypes.string,
	    // Initial size of controlled panel.
	    initialSize: PropTypes.any,
	    // Optional initial width of controlled panel.
	    initialWidth: PropTypes.number,
	    // Optional initial height of controlled panel.
	    initialHeight: PropTypes.number,
	    // Left/top panel
	    startPanel: PropTypes.any,
	    // Left/top panel collapse state.
	    startPanelCollapsed: PropTypes.bool,
	    // Min panel size.
	    minSize: PropTypes.any,
	    // Max panel size.
	    maxSize: PropTypes.any,
	    // Right/bottom panel
	    endPanel: PropTypes.any,
	    // Right/bottom panel collapse state.
	    endPanelCollapsed: PropTypes.bool,
	    // True if the right/bottom panel should be controlled.
	    endPanelControl: PropTypes.bool,
	    // Size of the splitter handle bar.
	    splitterSize: PropTypes.number,
	    // True if the splitter bar is vertical (default is vertical).
	    vert: PropTypes.bool,
	    // Optional style properties passed into the splitbox
	    style: PropTypes.object
	  },

	  displayName: "SplitBox",

	  getDefaultProps() {
	    return {
	      splitterSize: 5,
	      vert: true,
	      endPanelControl: false,
	      endPanelCollapsed: false,
	      startPanelCollapsed: false
	    };
	  },

	  /**
	   * The state stores the current orientation (vertical or horizontal)
	   * and the current size (width/height). All these values can change
	   * during the component's life time.
	   */
	  getInitialState() {
	    return {
	      vert: this.props.vert,
	      // We use integers for these properties
	      width: parseInt(this.props.initialWidth || this.props.initialSize),
	      height: parseInt(this.props.initialHeight || this.props.initialSize)
	    };
	  },

	  componentWillReceiveProps(nextProps) {
	    if (this.props.vert !== nextProps.vert) {
	      this.setState({ vert: nextProps.vert });
	    }
	  },

	  // Dragging Events

	  /**
	   * Set 'resizing' cursor on entire document during splitter dragging.
	   * This avoids cursor-flickering that happens when the mouse leaves
	   * the splitter bar area (happens frequently).
	   */
	  onStartMove() {
	    var splitBox = ReactDOM.findDOMNode(this);
	    var doc = splitBox.ownerDocument;
	    var defaultCursor = doc.documentElement.style.cursor;
	    doc.documentElement.style.cursor = this.state.vert ? "ew-resize" : "ns-resize";

	    splitBox.classList.add("dragging");

	    this.setState({
	      defaultCursor: defaultCursor
	    });
	  },

	  onStopMove() {
	    var splitBox = ReactDOM.findDOMNode(this);
	    var doc = splitBox.ownerDocument;
	    doc.documentElement.style.cursor = this.state.defaultCursor;

	    splitBox.classList.remove("dragging");
	  },

	  /**
	   * Adjust size of the controlled panel. Depending on the current
	   * orientation we either remember the width or height of
	   * the splitter box.
	   */
	  onMove(_ref) {
	    var movementX = _ref.movementX,
	        movementY = _ref.movementY;

	    var node = ReactDOM.findDOMNode(this);
	    var doc = node.ownerDocument;

	    if (this.props.endPanelControl) {
	      // For the end panel we need to increase the width/height when the
	      // movement is towards the left/top.
	      movementX = -movementX;
	      movementY = -movementY;
	    }

	    if (this.state.vert) {
	      var isRtl = doc.dir === "rtl";
	      if (isRtl) {
	        // In RTL we need to reverse the movement again -- but only for vertical
	        // splitters
	        movementX = -movementX;
	      }

	      this.setState((state, props) => ({
	        width: state.width + movementX
	      }));
	    } else {
	      this.setState((state, props) => ({
	        height: state.height + movementY
	      }));
	    }
	  },

	  // Rendering
	  preparePanelStyles() {
	    var vert = this.state.vert;
	    var _props = this.props,
	        minSize = _props.minSize,
	        maxSize = _props.maxSize,
	        startPanelCollapsed = _props.startPanelCollapsed,
	        endPanelControl = _props.endPanelControl,
	        endPanelCollapsed = _props.endPanelCollapsed;

	    var leftPanelStyle = void 0,
	        rightPanelStyle = void 0;

	    // Set proper size for panels depending on the current state.
	    if (vert) {
	      var startWidth = endPanelControl ? null : this.state.width,
	          endWidth = endPanelControl ? this.state.width : null;

	      leftPanelStyle = {
	        maxWidth: endPanelControl ? null : maxSize,
	        minWidth: endPanelControl ? null : minSize,
	        width: startPanelCollapsed ? 0 : startWidth
	      };
	      rightPanelStyle = {
	        maxWidth: endPanelControl ? maxSize : null,
	        minWidth: endPanelControl ? minSize : null,
	        width: endPanelCollapsed ? 0 : endWidth
	      };
	    } else {
	      var startHeight = endPanelControl ? null : this.state.height,
	          endHeight = endPanelControl ? this.state.height : null;

	      leftPanelStyle = {
	        maxHeight: endPanelControl ? null : maxSize,
	        minHeight: endPanelControl ? null : minSize,
	        height: endPanelCollapsed ? maxSize : startHeight
	      };
	      rightPanelStyle = {
	        maxHeight: endPanelControl ? maxSize : null,
	        minHeight: endPanelControl ? minSize : null,
	        height: startPanelCollapsed ? maxSize : endHeight
	      };
	    }

	    return { leftPanelStyle, rightPanelStyle };
	  },

	  render() {
	    var vert = this.state.vert;
	    var _props2 = this.props,
	        startPanelCollapsed = _props2.startPanelCollapsed,
	        startPanel = _props2.startPanel,
	        endPanel = _props2.endPanel,
	        endPanelControl = _props2.endPanelControl,
	        splitterSize = _props2.splitterSize,
	        endPanelCollapsed = _props2.endPanelCollapsed;


	    var style = Object.assign({}, this.props.style);

	    // Calculate class names list.
	    var classNames = ["split-box"];
	    classNames.push(vert ? "vert" : "horz");
	    if (this.props.className) {
	      classNames = classNames.concat(this.props.className.split(" "));
	    }

	    var _preparePanelStyles = this.preparePanelStyles(),
	        leftPanelStyle = _preparePanelStyles.leftPanelStyle,
	        rightPanelStyle = _preparePanelStyles.rightPanelStyle;

	    // Calculate splitter size


	    var splitterStyle = {
	      flex: `0 0 ${splitterSize}px`
	    };

	    return dom.div({
	      className: classNames.join(" "),
	      style: style }, !startPanelCollapsed ? dom.div({
	      className: endPanelControl ? "uncontrolled" : "controlled",
	      style: leftPanelStyle }, startPanel) : null, Draggable({
	      className: "splitter",
	      style: splitterStyle,
	      onStart: this.onStartMove,
	      onStop: this.onStopMove,
	      onMove: this.onMove
	    }), !endPanelCollapsed ? dom.div({
	      className: endPanelControl ? "controlled" : "uncontrolled",
	      style: rightPanelStyle }, endPanel) : null);
	  }
	});

	module.exports = SplitBox;

/***/ },
/* 855 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(22);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;


	var Draggable = React.createClass({
	  displayName: "Draggable",

	  propTypes: {
	    onMove: PropTypes.func.isRequired,
	    onStart: PropTypes.func,
	    onStop: PropTypes.func,
	    style: PropTypes.object,
	    className: PropTypes.string
	  },

	  startDragging(ev) {
	    ev.preventDefault();
	    var doc = ReactDOM.findDOMNode(this).ownerDocument;
	    doc.addEventListener("mousemove", this.onMove);
	    doc.addEventListener("mouseup", this.onUp);
	    this.props.onStart && this.props.onStart();
	  },

	  onMove(ev) {
	    ev.preventDefault();
	    // We pass the whole event because we don't know which properties
	    // the callee needs.
	    this.props.onMove(ev);
	  },

	  onUp(ev) {
	    ev.preventDefault();
	    var doc = ReactDOM.findDOMNode(this).ownerDocument;
	    doc.removeEventListener("mousemove", this.onMove);
	    doc.removeEventListener("mouseup", this.onUp);
	    this.props.onStop && this.props.onStop();
	  },

	  render() {
	    return dom.div({
	      style: this.props.style,
	      className: this.props.className,
	      onMouseDown: this.startDragging
	    });
	  }
	});

	module.exports = Draggable;

/***/ },
/* 856 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Copyright (c) 2007-2016, Alexandru Marasteanu <hello [at) alexei (dot] ro>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 * * Neither the name of this software nor the names of its contributors may be
	 *   used to endorse or promote products derived from this software without
	 *   specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 */

	/* globals window, exports, define */

	(function (window) {
	    'use strict';

	    var re = {
	        not_string: /[^s]/,
	        not_bool: /[^t]/,
	        not_type: /[^T]/,
	        not_primitive: /[^v]/,
	        number: /[diefg]/,
	        numeric_arg: /bcdiefguxX/,
	        json: /[j]/,
	        not_json: /[^j]/,
	        text: /^[^\x25]+/,
	        modulo: /^\x25{2}/,
	        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosStTuvxX])/,
	        key: /^([a-z_][a-z_\d]*)/i,
	        key_access: /^\.([a-z_][a-z_\d]*)/i,
	        index_access: /^\[(\d+)\]/,
	        sign: /^[\+\-]/
	    };

	    function sprintf() {
	        var key = arguments[0],
	            cache = sprintf.cache;
	        if (!(cache[key] && cache.hasOwnProperty(key))) {
	            cache[key] = sprintf.parse(key);
	        }
	        return sprintf.format.call(null, cache[key], arguments);
	    }

	    sprintf.format = function (parse_tree, argv) {
	        var cursor = 1,
	            tree_length = parse_tree.length,
	            node_type = '',
	            arg,
	            output = [],
	            i,
	            k,
	            match,
	            pad,
	            pad_character,
	            pad_length,
	            is_positive = true,
	            sign = '';
	        for (i = 0; i < tree_length; i++) {
	            node_type = get_type(parse_tree[i]);
	            if (node_type === 'string') {
	                output[output.length] = parse_tree[i];
	            } else if (node_type === 'array') {
	                match = parse_tree[i]; // convenience purposes only
	                if (match[2]) {
	                    // keyword argument
	                    arg = argv[cursor];
	                    for (k = 0; k < match[2].length; k++) {
	                        if (!arg.hasOwnProperty(match[2][k])) {
	                            throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
	                        }
	                        arg = arg[match[2][k]];
	                    }
	                } else if (match[1]) {
	                    // positional argument (explicit)
	                    arg = argv[match[1]];
	                } else {
	                    // positional argument (implicit)
	                    arg = argv[cursor++];
	                }

	                if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && get_type(arg) == 'function') {
	                    arg = arg();
	                }

	                if (re.numeric_arg.test(match[8]) && get_type(arg) != 'number' && isNaN(arg)) {
	                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)));
	                }

	                if (re.number.test(match[8])) {
	                    is_positive = arg >= 0;
	                }

	                switch (match[8]) {
	                    case 'b':
	                        arg = parseInt(arg, 10).toString(2);
	                        break;
	                    case 'c':
	                        arg = String.fromCharCode(parseInt(arg, 10));
	                        break;
	                    case 'd':
	                    case 'i':
	                        arg = parseInt(arg, 10);
	                        break;
	                    case 'j':
	                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0);
	                        break;
	                    case 'e':
	                        arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential();
	                        break;
	                    case 'f':
	                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
	                        break;
	                    case 'g':
	                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg);
	                        break;
	                    case 'o':
	                        arg = arg.toString(8);
	                        break;
	                    case 's':
	                    case 'S':
	                        arg = String(arg);
	                        arg = match[7] ? arg.substring(0, match[7]) : arg;
	                        break;
	                    case 't':
	                        arg = String(!!arg);
	                        arg = match[7] ? arg.substring(0, match[7]) : arg;
	                        break;
	                    case 'T':
	                        arg = get_type(arg);
	                        arg = match[7] ? arg.substring(0, match[7]) : arg;
	                        break;
	                    case 'u':
	                        arg = parseInt(arg, 10) >>> 0;
	                        break;
	                    case 'v':
	                        arg = arg.valueOf();
	                        arg = match[7] ? arg.substring(0, match[7]) : arg;
	                        break;
	                    case 'x':
	                        arg = parseInt(arg, 10).toString(16);
	                        break;
	                    case 'X':
	                        arg = parseInt(arg, 10).toString(16).toUpperCase();
	                        break;
	                }
	                if (re.json.test(match[8])) {
	                    output[output.length] = arg;
	                } else {
	                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
	                        sign = is_positive ? '+' : '-';
	                        arg = arg.toString().replace(re.sign, '');
	                    } else {
	                        sign = '';
	                    }
	                    pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' ';
	                    pad_length = match[6] - (sign + arg).length;
	                    pad = match[6] ? pad_length > 0 ? str_repeat(pad_character, pad_length) : '' : '';
	                    output[output.length] = match[5] ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;
	                }
	            }
	        }
	        return output.join('');
	    };

	    sprintf.cache = {};

	    sprintf.parse = function (fmt) {
	        var _fmt = fmt,
	            match = [],
	            parse_tree = [],
	            arg_names = 0;
	        while (_fmt) {
	            if ((match = re.text.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = match[0];
	            } else if ((match = re.modulo.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = '%';
	            } else if ((match = re.placeholder.exec(_fmt)) !== null) {
	                if (match[2]) {
	                    arg_names |= 1;
	                    var field_list = [],
	                        replacement_field = match[2],
	                        field_match = [];
	                    if ((field_match = re.key.exec(replacement_field)) !== null) {
	                        field_list[field_list.length] = field_match[1];
	                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
	                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1];
	                            } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1];
	                            } else {
	                                throw new SyntaxError("[sprintf] failed to parse named argument key");
	                            }
	                        }
	                    } else {
	                        throw new SyntaxError("[sprintf] failed to parse named argument key");
	                    }
	                    match[2] = field_list;
	                } else {
	                    arg_names |= 2;
	                }
	                if (arg_names === 3) {
	                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
	                }
	                parse_tree[parse_tree.length] = match;
	            } else {
	                throw new SyntaxError("[sprintf] unexpected placeholder");
	            }
	            _fmt = _fmt.substring(match[0].length);
	        }
	        return parse_tree;
	    };

	    var vsprintf = function (fmt, argv, _argv) {
	        _argv = (argv || []).slice(0);
	        _argv.splice(0, 0, fmt);
	        return sprintf.apply(null, _argv);
	    };

	    /**
	     * helpers
	     */
	    function get_type(variable) {
	        if (typeof variable === 'number') {
	            return 'number';
	        } else if (typeof variable === 'string') {
	            return 'string';
	        } else {
	            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
	        }
	    }

	    var preformattedPadding = {
	        '0': ['', '0', '00', '000', '0000', '00000', '000000', '0000000'],
	        ' ': ['', ' ', '  ', '   ', '    ', '     ', '      ', '       '],
	        '_': ['', '_', '__', '___', '____', '_____', '______', '_______']
	    };
	    function str_repeat(input, multiplier) {
	        if (multiplier >= 0 && multiplier <= 7 && preformattedPadding[input]) {
	            return preformattedPadding[input][multiplier];
	        }
	        return Array(multiplier + 1).join(input);
	    }

	    /**
	     * export to either browser or node.js
	     */
	    if (true) {
	        exports.sprintf = sprintf;
	        exports.vsprintf = vsprintf;
	    } else {
	        window.sprintf = sprintf;
	        window.vsprintf = vsprintf;

	        if (typeof define === 'function' && define.amd) {
	            define(function () {
	                return {
	                    sprintf: sprintf,
	                    vsprintf: vsprintf
	                };
	            });
	        }
	    }
	})(typeof window === 'undefined' ? undefined : window);

/***/ },
/* 857 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */

	var _require = __webpack_require__(2),
	    dom = _require.DOM,
	    createClass = _require.createClass,
	    createFactory = _require.createFactory,
	    PropTypes = _require.PropTypes;
	// const { ViewHelpers } =
	// require("resource://devtools/client/shared/widgets/ViewHelpers.jsm");
	// let { VirtualScroll } = require("react-virtualized");
	// VirtualScroll = createFactory(VirtualScroll);

	var AUTO_EXPAND_DEPTH = 0; // depth

	/**
	 * An arrow that displays whether its node is expanded (▼) or collapsed
	 * (▶). When its node has no children, it is hidden.
	 */
	var ArrowExpander = createFactory(createClass({
	  displayName: "ArrowExpander",

	  shouldComponentUpdate(nextProps, nextState) {
	    return this.props.item !== nextProps.item || this.props.visible !== nextProps.visible || this.props.expanded !== nextProps.expanded;
	  },

	  render() {
	    var attrs = {
	      className: "arrow theme-twisty",
	      onClick: this.props.expanded ? () => this.props.onCollapse(this.props.item) : e => this.props.onExpand(this.props.item, e.altKey)
	    };

	    if (this.props.expanded) {
	      attrs.className += " open";
	    }

	    if (!this.props.visible) {
	      attrs.style = Object.assign({}, this.props.style || {}, {
	        visibility: "hidden"
	      });
	    }

	    return dom.div(attrs, this.props.children);
	  }
	}));

	var TreeNode = createFactory(createClass({
	  displayName: "TreeNode",

	  componentDidMount() {
	    if (this.props.focused) {
	      this.refs.button.focus();
	    }
	  },

	  componentDidUpdate() {
	    if (this.props.focused) {
	      this.refs.button.focus();
	    }
	  },

	  shouldComponentUpdate(nextProps) {
	    return this.props.item !== nextProps.item || this.props.focused !== nextProps.focused || this.props.expanded !== nextProps.expanded;
	  },

	  render() {
	    var arrow = ArrowExpander({
	      item: this.props.item,
	      expanded: this.props.expanded,
	      visible: this.props.hasChildren,
	      onExpand: this.props.onExpand,
	      onCollapse: this.props.onCollapse
	    });

	    var isOddRow = this.props.index % 2;
	    return dom.div({
	      className: `tree-node div ${isOddRow ? "tree-node-odd" : ""}`,
	      onFocus: this.props.onFocus,
	      onClick: this.props.onFocus,
	      onBlur: this.props.onBlur,
	      style: {
	        padding: 0,
	        margin: 0
	      }
	    }, this.props.renderItem(this.props.item, this.props.depth, this.props.focused, arrow, this.props.expanded),

	    // XXX: OSX won't focus/blur regular elements even if you set tabindex
	    // unless there is an input/button child.
	    dom.button(this._buttonAttrs));
	  },

	  _buttonAttrs: {
	    ref: "button",
	    style: {
	      opacity: 0,
	      width: "0 !important",
	      height: "0 !important",
	      padding: "0 !important",
	      outline: "none",
	      MozAppearance: "none",
	      // XXX: Despite resetting all of the above properties (and margin), the
	      // button still ends up with ~79px width, so we set a large negative
	      // margin to completely hide it.
	      MozMarginStart: "-1000px !important"
	    }
	  }
	}));

	/**
	 * Create a function that calls the given function `fn` only once per animation
	 * frame.
	 *
	 * @param {Function} fn
	 * @returns {Function}
	 */
	function oncePerAnimationFrame(fn) {
	  var animationId = null;
	  var argsToPass = null;
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    argsToPass = args;
	    if (animationId !== null) {
	      return;
	    }

	    animationId = requestAnimationFrame(() => {
	      fn.call.apply(fn, [this].concat(_toConsumableArray(argsToPass)));
	      animationId = null;
	      argsToPass = null;
	    });
	  };
	}

	var NUMBER_OF_OFFSCREEN_ITEMS = 1;

	/**
	 * A generic tree component. See propTypes for the public API.
	 *
	 * @see `devtools/client/memory/components/test/mochitest/head.js` for usage
	 * @see `devtools/client/memory/components/heap.js` for usage
	 */
	var Tree = module.exports = createClass({
	  displayName: "Tree",

	  propTypes: {
	    // Required props

	    // A function to get an item's parent, or null if it is a root.
	    getParent: PropTypes.func.isRequired,
	    // A function to get an item's children.
	    getChildren: PropTypes.func.isRequired,
	    // A function which takes an item and ArrowExpander and returns a
	    // component.
	    renderItem: PropTypes.func.isRequired,
	    // A function which returns the roots of the tree (forest).
	    getRoots: PropTypes.func.isRequired,
	    // A function to get a unique key for the given item.
	    getKey: PropTypes.func.isRequired,
	    // A function to get whether an item is expanded or not. If an item is not
	    // expanded, then it must be collapsed.
	    isExpanded: PropTypes.func.isRequired,
	    // The height of an item in the tree including margin and padding, in
	    // pixels.
	    itemHeight: PropTypes.number.isRequired,

	    // Optional props

	    // The currently focused item, if any such item exists.
	    focused: PropTypes.any,
	    // Handle when a new item is focused.
	    onFocus: PropTypes.func,
	    // The depth to which we should automatically expand new items.
	    autoExpandDepth: PropTypes.number,
	    // Should auto expand all new items or just the new items under the first
	    // root item.
	    autoExpandAll: PropTypes.bool,
	    // Optional event handlers for when items are expanded or collapsed.
	    onExpand: PropTypes.func,
	    onCollapse: PropTypes.func
	  },

	  getDefaultProps() {
	    return {
	      autoExpandDepth: AUTO_EXPAND_DEPTH,
	      autoExpandAll: true
	    };
	  },

	  getInitialState() {
	    return {
	      scroll: 0,
	      height: window.innerHeight,
	      seen: new Set()
	    };
	  },

	  componentDidMount() {
	    window.addEventListener("resize", this._updateHeight);
	    this._autoExpand(this.props);
	    this._updateHeight();
	  },

	  componentWillUnmount() {
	    window.removeEventListener("resize", this._updateHeight);
	  },

	  componentWillReceiveProps(nextProps) {
	    this._autoExpand(nextProps);
	    this._updateHeight();
	  },

	  _autoExpand(props) {
	    if (!props.autoExpandDepth) {
	      return;
	    }

	    // Automatically expand the first autoExpandDepth levels for new items. Do
	    // not use the usual DFS infrastructure because we don't want to ignore
	    // collapsed nodes.
	    var autoExpand = (item, currentDepth) => {
	      if (currentDepth >= props.autoExpandDepth || this.state.seen.has(item)) {
	        return;
	      }

	      props.onExpand(item);
	      this.state.seen.add(item);

	      var children = props.getChildren(item);
	      var length = children.length;
	      for (var i = 0; i < length; i++) {
	        autoExpand(children[i], currentDepth + 1);
	      }
	    };

	    var roots = props.getRoots();
	    var length = roots.length;
	    if (props.autoExpandAll) {
	      for (var i = 0; i < length; i++) {
	        autoExpand(roots[i], 0);
	      }
	    } else if (length != 0) {
	      autoExpand(roots[0], 0);
	    }
	  },

	  render() {
	    var traversal = this._dfsFromRoots();

	    // Remove `NUMBER_OF_OFFSCREEN_ITEMS` from `begin` and add `2 *
	    // NUMBER_OF_OFFSCREEN_ITEMS` to `end` so that the top and bottom of the
	    // page are filled with the `NUMBER_OF_OFFSCREEN_ITEMS` previous and next
	    // items respectively, rather than whitespace if the item is not in full
	    // view.
	    // const begin = Math.max(((this.state.scroll / this.props.itemHeight) | 0) - NUMBER_OF_OFFSCREEN_ITEMS, 0);
	    // const end = begin + (2 * NUMBER_OF_OFFSCREEN_ITEMS) + ((this.state.height / this.props.itemHeight) | 0);
	    // const toRender = traversal;

	    // const nodes = [
	    //   dom.div({
	    //     key: "top-spacer",
	    //     style: {
	    //       padding: 0,
	    //       margin: 0,
	    //       height: begin * this.props.itemHeight + "px"
	    //     }
	    //   })
	    // ];

	    var renderItem = i => {
	      var _traversal$i = traversal[i],
	          item = _traversal$i.item,
	          depth = _traversal$i.depth;

	      return TreeNode({
	        key: this.props.getKey(item, i),
	        index: i,
	        item: item,
	        depth: depth,
	        renderItem: this.props.renderItem,
	        focused: this.props.focused === item,
	        expanded: this.props.isExpanded(item),
	        hasChildren: !!this.props.getChildren(item).length,
	        onExpand: this._onExpand,
	        onCollapse: this._onCollapse,
	        onFocus: () => this._focus(i, item)
	      });
	    };

	    // nodes.push(dom.div({
	    //   key: "bottom-spacer",
	    //   style: {
	    //     padding: 0,
	    //     margin: 0,
	    //     height: (traversal.length - 1 - end) * this.props.itemHeight + "px"
	    //   }
	    // }));

	    var style = Object.assign({}, this.props.style || {}, {
	      padding: 0,
	      margin: 0
	    });

	    return dom.div({
	      className: "tree",
	      ref: "tree",
	      onKeyDown: this._onKeyDown,
	      onKeyPress: this._preventArrowKeyScrolling,
	      onKeyUp: this._preventArrowKeyScrolling,
	      onScroll: this._onScroll,
	      style
	    },
	    // VirtualScroll({
	    //   width: this.props.width,
	    //   height: this.props.height,
	    //   rowsCount: traversal.length,
	    //   rowHeight: this.props.itemHeight,
	    //   rowRenderer: renderItem
	    // })
	    traversal.map((v, i) => renderItem(i)));
	  },

	  _preventArrowKeyScrolling(e) {
	    switch (e.key) {
	      case "ArrowUp":
	      case "ArrowDown":
	      case "ArrowLeft":
	      case "ArrowRight":
	        e.preventDefault();
	        e.stopPropagation();
	        if (e.nativeEvent) {
	          if (e.nativeEvent.preventDefault) {
	            e.nativeEvent.preventDefault();
	          }
	          if (e.nativeEvent.stopPropagation) {
	            e.nativeEvent.stopPropagation();
	          }
	        }
	    }
	  },

	  /**
	   * Updates the state's height based on clientHeight.
	   */
	  _updateHeight() {
	    this.setState({
	      height: this.refs.tree.clientHeight
	    });
	  },

	  /**
	   * Perform a pre-order depth-first search from item.
	   */
	  _dfs(item) {
	    var maxDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
	    var traversal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

	    var _depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

	    traversal.push({ item, depth: _depth });

	    if (!this.props.isExpanded(item)) {
	      return traversal;
	    }

	    var nextDepth = _depth + 1;

	    if (nextDepth > maxDepth) {
	      return traversal;
	    }

	    var children = this.props.getChildren(item);
	    var length = children.length;
	    for (var i = 0; i < length; i++) {
	      this._dfs(children[i], maxDepth, traversal, nextDepth);
	    }

	    return traversal;
	  },

	  /**
	   * Perform a pre-order depth-first search over the whole forest.
	   */
	  _dfsFromRoots() {
	    var maxDepth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;

	    var traversal = [];

	    var roots = this.props.getRoots();
	    var length = roots.length;
	    for (var i = 0; i < length; i++) {
	      this._dfs(roots[i], maxDepth, traversal);
	    }

	    return traversal;
	  },

	  /**
	   * Expands current row.
	   *
	   * @param {Object} item
	   * @param {Boolean} expandAllChildren
	   */
	  _onExpand: oncePerAnimationFrame(function (item, expandAllChildren) {
	    if (this.props.onExpand) {
	      this.props.onExpand(item);

	      if (expandAllChildren) {
	        var children = this._dfs(item);
	        var length = children.length;
	        for (var i = 0; i < length; i++) {
	          this.props.onExpand(children[i].item);
	        }
	      }
	    }
	  }),

	  /**
	   * Collapses current row.
	   *
	   * @param {Object} item
	   */
	  _onCollapse: oncePerAnimationFrame(function (item) {
	    if (this.props.onCollapse) {
	      this.props.onCollapse(item);
	    }
	  }),

	  /**
	   * Sets the passed in item to be the focused item.
	   *
	   * @param {Number} index
	   *        The index of the item in a full DFS traversal (ignoring collapsed
	   *        nodes). Ignored if `item` is undefined.
	   *
	   * @param {Object|undefined} item
	   *        The item to be focused, or undefined to focus no item.
	   */
	  _focus(index, item) {
	    if (item !== undefined) {
	      var itemStartPosition = index * this.props.itemHeight;
	      var itemEndPosition = (index + 1) * this.props.itemHeight;

	      // Note that if the height of the viewport (this.state.height) is less than
	      // `this.props.itemHeight`, we could accidentally try and scroll both up and
	      // down in a futile attempt to make both the item's start and end positions
	      // visible. Instead, give priority to the start of the item by checking its
	      // position first, and then using an "else if", rather than a separate "if",
	      // for the end position.
	      if (this.state.scroll > itemStartPosition) {
	        this.refs.tree.scrollTop = itemStartPosition;
	      } else if (this.state.scroll + this.state.height < itemEndPosition) {
	        this.refs.tree.scrollTop = itemEndPosition - this.state.height;
	      }
	    }

	    if (this.props.onFocus) {
	      this.props.onFocus(item);
	    }
	  },

	  /**
	   * Sets the state to have no focused item.
	   */
	  _onBlur() {
	    this._focus(0, undefined);
	  },

	  /**
	   * Fired on a scroll within the tree's container, updates
	   * the stored position of the view port to handle virtual view rendering.
	   *
	   * @param {Event} e
	   */
	  _onScroll: oncePerAnimationFrame(function (e) {
	    this.setState({
	      scroll: Math.max(this.refs.tree.scrollTop, 0),
	      height: this.refs.tree.clientHeight
	    });
	  }),

	  /**
	   * Handles key down events in the tree's container.
	   *
	   * @param {Event} e
	   */
	  _onKeyDown(e) {
	    if (this.props.focused == null) {
	      return;
	    }

	    // Allow parent nodes to use navigation arrows with modifiers.
	    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
	      return;
	    }

	    this._preventArrowKeyScrolling(e);

	    switch (e.key) {
	      case "ArrowUp":
	        this._focusPrevNode();
	        return;

	      case "ArrowDown":
	        this._focusNextNode();
	        return;

	      case "ArrowLeft":
	        if (this.props.isExpanded(this.props.focused) && this.props.getChildren(this.props.focused).length) {
	          this._onCollapse(this.props.focused);
	        } else {
	          this._focusParentNode();
	        }
	        return;

	      case "ArrowRight":
	        if (!this.props.isExpanded(this.props.focused)) {
	          this._onExpand(this.props.focused);
	        }
	        return;
	    }
	  },

	  /**
	   * Sets the previous node relative to the currently focused item, to focused.
	   */
	  _focusPrevNode: oncePerAnimationFrame(function () {
	    // Start a depth first search and keep going until we reach the currently
	    // focused node. Focus the previous node in the DFS, if it exists. If it
	    // doesn't exist, we're at the first node already.

	    var prev = void 0;
	    var prevIndex = void 0;

	    var traversal = this._dfsFromRoots();
	    var length = traversal.length;
	    for (var i = 0; i < length; i++) {
	      var item = traversal[i].item;
	      if (item === this.props.focused) {
	        break;
	      }
	      prev = item;
	      prevIndex = i;
	    }

	    if (prev === undefined) {
	      return;
	    }

	    this._focus(prevIndex, prev);
	  }),

	  /**
	   * Handles the down arrow key which will focus either the next child
	   * or sibling row.
	   */
	  _focusNextNode: oncePerAnimationFrame(function () {
	    // Start a depth first search and keep going until we reach the currently
	    // focused node. Focus the next node in the DFS, if it exists. If it
	    // doesn't exist, we're at the last node already.

	    var traversal = this._dfsFromRoots();
	    var length = traversal.length;
	    var i = 0;

	    while (i < length) {
	      if (traversal[i].item === this.props.focused) {
	        break;
	      }
	      i++;
	    }

	    if (i + 1 < traversal.length) {
	      this._focus(i + 1, traversal[i + 1].item);
	    }
	  }),

	  /**
	   * Handles the left arrow key, going back up to the current rows'
	   * parent row.
	   */
	  _focusParentNode: oncePerAnimationFrame(function () {
	    var parent = this.props.getParent(this.props.focused);
	    if (!parent) {
	      return;
	    }

	    var traversal = this._dfsFromRoots();
	    var length = traversal.length;
	    var parentIndex = 0;
	    for (; parentIndex < length; parentIndex++) {
	      if (traversal[parentIndex].item === parent) {
	        break;
	      }
	    }

	    this._focus(parentIndex, parent);
	  })
	});

/***/ },
/* 858 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var EventEmitter = __webpack_require__(844);

	function WebSocketDebuggerTransport(socket) {
	  EventEmitter.decorate(this);

	  this.active = false;
	  this.hooks = null;
	  this.socket = socket;
	}

	WebSocketDebuggerTransport.prototype = {
	  ready() {
	    if (this.active) {
	      return;
	    }

	    this.socket.addEventListener("message", this);
	    this.socket.addEventListener("close", this);

	    this.active = true;
	  },

	  send(object) {
	    this.emit("send", object);
	    if (this.socket) {
	      this.socket.send(JSON.stringify(object));
	    }
	  },

	  startBulkSend() {
	    throw new Error("Bulk send is not supported by WebSocket transport");
	  },

	  close() {
	    this.emit("close");
	    this.active = false;

	    this.socket.removeEventListener("message", this);
	    this.socket.removeEventListener("close", this);
	    this.socket.close();
	    this.socket = null;

	    if (this.hooks) {
	      this.hooks.onClosed();
	      this.hooks = null;
	    }
	  },

	  handleEvent(event) {
	    switch (event.type) {
	      case "message":
	        this.onMessage(event);
	        break;
	      case "close":
	        this.close();
	        break;
	    }
	  },

	  onMessage(_ref) {
	    var data = _ref.data;

	    if (typeof data !== "string") {
	      throw new Error("Binary messages are not supported by WebSocket transport");
	    }

	    var object = JSON.parse(data);
	    this.emit("packet", object);
	    if (this.hooks) {
	      this.hooks.onPacket(object);
	    }
	  }
	};

	module.exports = WebSocketDebuggerTransport;

/***/ },
/* 859 */
/***/ function(module, exports) {

	"use strict";

	var msgId = 1;
	function workerTask(worker, method) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return new Promise((resolve, reject) => {
	      var id = msgId++;
	      worker.postMessage({ id, method, args });

	      var listener = (_ref) => {
	        var result = _ref.data;

	        if (result.id !== id) {
	          return;
	        }

	        worker.removeEventListener("message", listener);
	        if (result.error) {
	          reject(result.error);
	        } else {
	          resolve(result.response);
	        }
	      };

	      worker.addEventListener("message", listener);
	    });
	  };
	}

	module.exports = {
	  workerTask
	};

/***/ },
/* 860 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var NET_STRINGS_URI = "devtools/client/locales/netmonitor.properties";
	var SVG_NS = "http://www.w3.org/2000/svg";
	var PI = Math.PI;
	var TAU = PI * 2;
	var EPSILON = 0.0000001;
	var NAMED_SLICE_MIN_ANGLE = TAU / 8;
	var NAMED_SLICE_TEXT_DISTANCE_RATIO = 1.9;
	var HOVERED_SLICE_TRANSLATE_DISTANCE_RATIO = 20;

	var EventEmitter = __webpack_require__(844);

	/**
	 * A factory for creating charts.
	 * Example usage: let myChart = Chart.Pie(document, { ... });
	 */
	var Chart = {
	  Pie: createPieChart,
	  Table: createTableChart,
	  PieTable: createPieTableChart
	};

	/**
	 * A simple pie chart proxy for the underlying view.
	 * Each item in the `slices` property represents a [data, node] pair containing
	 * the data used to create the slice and the nsIDOMNode displaying it.
	 *
	 * @param nsIDOMNode node
	 *        The node representing the view for this chart.
	 */
	function PieChart(node) {
	  this.node = node;
	  this.slices = new WeakMap();
	  EventEmitter.decorate(this);
	}

	/**
	 * A simple table chart proxy for the underlying view.
	 * Each item in the `rows` property represents a [data, node] pair containing
	 * the data used to create the row and the nsIDOMNode displaying it.
	 *
	 * @param nsIDOMNode node
	 *        The node representing the view for this chart.
	 */
	function TableChart(node) {
	  this.node = node;
	  this.rows = new WeakMap();
	  EventEmitter.decorate(this);
	}

	/**
	 * A simple pie+table chart proxy for the underlying view.
	 *
	 * @param nsIDOMNode node
	 *        The node representing the view for this chart.
	 * @param PieChart pie
	 *        The pie chart proxy.
	 * @param TableChart table
	 *        The table chart proxy.
	 */
	function PieTableChart(node, pie, table) {
	  this.node = node;
	  this.pie = pie;
	  this.table = table;
	  EventEmitter.decorate(this);
	}

	/**
	 * Creates the DOM for a pie+table chart.
	 *
	 * @param nsIDocument document
	 *        The document responsible with creating the DOM.
	 * @param object
	 *        An object containing all or some of the following properties:
	 *          - title: a string displayed as the table chart's (description)/local
	 *          - diameter: the diameter of the pie chart, in pixels
	 *          - data: an array of items used to display each slice in the pie
	 *                  and each row in the table;
	 *                  @see `createPieChart` and `createTableChart` for details.
	 *          - strings: @see `createTableChart` for details.
	 *          - totals: @see `createTableChart` for details.
	 *          - sorted: a flag specifying if the `data` should be sorted
	 *                    ascending by `size`.
	 * @return PieTableChart
	 *         A pie+table chart proxy instance, which emits the following events:
	 *           - "mouseover", when the mouse enters a slice or a row
	 *           - "mouseout", when the mouse leaves a slice or a row
	 *           - "click", when the mouse enters a slice or a row
	 */
	function createPieTableChart(document, _ref) {
	  var title = _ref.title,
	      diameter = _ref.diameter,
	      data = _ref.data,
	      strings = _ref.strings,
	      totals = _ref.totals,
	      sorted = _ref.sorted,
	      header = _ref.header;

	  if (data && sorted) {
	    data = data.slice().sort((a, b) => +(a.size < b.size));
	  }

	  var pie = Chart.Pie(document, {
	    width: diameter,
	    data: data
	  });

	  var table = Chart.Table(document, {
	    title: title,
	    data: data,
	    strings: strings,
	    totals: totals,
	    header: header
	  });

	  var container = document.createElement("div");
	  container.className = "pie-table-chart-container";
	  container.appendChild(pie.node);
	  container.appendChild(table.node);

	  var proxy = new PieTableChart(container, pie, table);

	  pie.on("click", (event, item) => {
	    proxy.emit(event, item);
	  });

	  table.on("click", (event, item) => {
	    proxy.emit(event, item);
	  });

	  pie.on("mouseover", (event, item) => {
	    proxy.emit(event, item);
	    if (table.rows.has(item)) {
	      table.rows.get(item).setAttribute("focused", "");
	    }
	  });

	  pie.on("mouseout", (event, item) => {
	    proxy.emit(event, item);
	    if (table.rows.has(item)) {
	      table.rows.get(item).removeAttribute("focused");
	    }
	  });

	  table.on("mouseover", (event, item) => {
	    proxy.emit(event, item);
	    if (pie.slices.has(item)) {
	      pie.slices.get(item).setAttribute("focused", "");
	    }
	  });

	  table.on("mouseout", (event, item) => {
	    proxy.emit(event, item);
	    if (pie.slices.has(item)) {
	      pie.slices.get(item).removeAttribute("focused");
	    }
	  });

	  return proxy;
	}

	/**
	 * Creates the DOM for a pie chart based on the specified properties.
	 *
	 * @param nsIDocument document
	 *        The document responsible with creating the DOM.
	 * @param object
	 *        An object containing all or some of the following properties:
	 *          - data: an array of items used to display each slice; all the items
	 *                  should be objects containing a `size` and a `label` property.
	 *                  e.g: [{
	 *                    size: 1,
	 *                    label: "foo"
	 *                  }, {
	 *                    size: 2,
	 *                    label: "bar"
	 *                  }];
	 *          - width: the width of the chart, in pixels
	 *          - height: optional, the height of the chart, in pixels.
	 *          - centerX: optional, the X-axis center of the chart, in pixels.
	 *          - centerY: optional, the Y-axis center of the chart, in pixels.
	 *          - radius: optional, the radius of the chart, in pixels.
	 * @return PieChart
	 *         A pie chart proxy instance, which emits the following events:
	 *           - "mouseover", when the mouse enters a slice
	 *           - "mouseout", when the mouse leaves a slice
	 *           - "click", when the mouse clicks a slice
	 */
	function createPieChart(document, _ref2) {
	  var data = _ref2.data,
	      width = _ref2.width,
	      height = _ref2.height,
	      centerX = _ref2.centerX,
	      centerY = _ref2.centerY,
	      radius = _ref2.radius;

	  height = height || width;
	  centerX = centerX || width / 2;
	  centerY = centerY || height / 2;
	  radius = radius || (width + height) / 4;
	  var isPlaceholder = false;

	  // Filter out very small sizes, as they'll just render invisible slices.
	  data = data ? data.filter(e => e.size > EPSILON) : null;

	  // If there's no data available, display an empty placeholder.
	  if (!data) {
	    data = loadingPieChartData();
	    isPlaceholder = true;
	  }
	  if (!data.length) {
	    data = emptyPieChartData();
	    isPlaceholder = true;
	  }

	  var container = document.createElementNS(SVG_NS, "svg");
	  container.setAttribute("class", "generic-chart-container pie-chart-container");
	  container.setAttribute("pack", "center");
	  container.setAttribute("flex", "1");
	  container.setAttribute("width", width);
	  container.setAttribute("height", height);
	  container.setAttribute("viewBox", "0 0 " + width + " " + height);
	  container.setAttribute("slices", data.length);
	  container.setAttribute("placeholder", isPlaceholder);

	  var proxy = new PieChart(container);

	  var total = data.reduce((acc, e) => acc + e.size, 0);
	  var angles = data.map(e => e.size / total * (TAU - EPSILON));
	  var largest = data.reduce((a, b) => a.size > b.size ? a : b);
	  var smallest = data.reduce((a, b) => a.size < b.size ? a : b);

	  var textDistance = radius / NAMED_SLICE_TEXT_DISTANCE_RATIO;
	  var translateDistance = radius / HOVERED_SLICE_TRANSLATE_DISTANCE_RATIO;
	  var startAngle = TAU;
	  var endAngle = 0;
	  var midAngle = 0;
	  radius -= translateDistance;

	  for (var i = data.length - 1; i >= 0; i--) {
	    var sliceInfo = data[i];
	    var sliceAngle = angles[i];
	    if (!sliceInfo.size || sliceAngle < EPSILON) {
	      continue;
	    }

	    endAngle = startAngle - sliceAngle;
	    midAngle = (startAngle + endAngle) / 2;

	    var x1 = centerX + radius * Math.sin(startAngle);
	    var y1 = centerY - radius * Math.cos(startAngle);
	    var x2 = centerX + radius * Math.sin(endAngle);
	    var y2 = centerY - radius * Math.cos(endAngle);
	    var largeArcFlag = Math.abs(startAngle - endAngle) > PI ? 1 : 0;

	    var pathNode = document.createElementNS(SVG_NS, "path");
	    pathNode.setAttribute("class", "pie-chart-slice chart-colored-blob");
	    pathNode.setAttribute("name", sliceInfo.label);
	    pathNode.setAttribute("d", " M " + centerX + "," + centerY + " L " + x2 + "," + y2 + " A " + radius + "," + radius + " 0 " + largeArcFlag + " 1 " + x1 + "," + y1 + " Z");

	    if (sliceInfo == largest) {
	      pathNode.setAttribute("largest", "");
	    }
	    if (sliceInfo == smallest) {
	      pathNode.setAttribute("smallest", "");
	    }

	    var hoverX = translateDistance * Math.sin(midAngle);
	    var hoverY = -translateDistance * Math.cos(midAngle);
	    var hoverTransform = "transform: translate(" + hoverX + "px, " + hoverY + "px)";
	    pathNode.setAttribute("style", data.length > 1 ? hoverTransform : "");

	    proxy.slices.set(sliceInfo, pathNode);
	    delegate(proxy, ["click", "mouseover", "mouseout"], pathNode, sliceInfo);
	    container.appendChild(pathNode);

	    if (sliceInfo.label && sliceAngle > NAMED_SLICE_MIN_ANGLE) {
	      var textX = centerX + textDistance * Math.sin(midAngle);
	      var textY = centerY - textDistance * Math.cos(midAngle);
	      var label = document.createElementNS(SVG_NS, "text");
	      label.appendChild(document.createTextNode(sliceInfo.label));
	      label.setAttribute("class", "pie-chart-label");
	      label.setAttribute("style", data.length > 1 ? hoverTransform : "");
	      label.setAttribute("x", data.length > 1 ? textX : centerX);
	      label.setAttribute("y", data.length > 1 ? textY : centerY);
	      container.appendChild(label);
	    }

	    startAngle = endAngle;
	  }

	  return proxy;
	}

	/**
	 * Creates the DOM for a table chart based on the specified properties.
	 *
	 * @param nsIDocument document
	 *        The document responsible with creating the DOM.
	 * @param object
	 *        An object containing all or some of the following properties:
	 *          - title: a string displayed as the chart's (description)/local
	 *          - data: an array of items used to display each row; all the items
	 *                  should be objects representing columns, for which the
	 *                  properties' values will be displayed in each cell of a row.
	 *                  e.g: [{
	 *                    label1: 1,
	 *                    label2: 3,
	 *                    label3: "foo"
	 *                  }, {
	 *                    label1: 4,
	 *                    label2: 6,
	 *                    label3: "bar
	 *                  }];
	 *          - strings: an object specifying for which rows in the `data` array
	 *                     their cell values should be stringified and localized
	 *                     based on a predicate function;
	 *                     e.g: {
	 *                       label1: value => l10n.getFormatStr("...", value)
	 *                     }
	 *          - totals: an object specifying for which rows in the `data` array
	 *                    the sum of their cells is to be displayed in the chart;
	 *                    e.g: {
	 *                      label1: total => l10n.getFormatStr("...", total),  // 5
	 *                      label2: total => l10n.getFormatStr("...", total),  // 9
	 *                    }
	 * @return TableChart
	 *         A table chart proxy instance, which emits the following events:
	 *           - "mouseover", when the mouse enters a row
	 *           - "mouseout", when the mouse leaves a row
	 *           - "click", when the mouse clicks a row
	 */
	function createTableChart(document, _ref3) {
	  var title = _ref3.title,
	      data = _ref3.data,
	      strings = _ref3.strings,
	      totals = _ref3.totals,
	      header = _ref3.header;

	  strings = strings || {};
	  totals = totals || {};
	  var isPlaceholder = false;

	  // If there's no data available, display an empty placeholder.
	  if (!data) {
	    data = loadingTableChartData();
	    isPlaceholder = true;
	  }
	  if (!data.length) {
	    data = emptyTableChartData();
	    isPlaceholder = true;
	  }

	  var container = document.createElement("div");
	  container.className = "generic-chart-container table-chart-container";
	  container.setAttribute("pack", "center");
	  container.setAttribute("flex", "1");
	  container.setAttribute("rows", data.length);
	  container.setAttribute("placeholder", isPlaceholder);
	  container.setAttribute("style", "-moz-box-orient: vertical");

	  var proxy = new TableChart(container);

	  var titleNode = document.createElement("span");
	  titleNode.className = "plain table-chart-title";
	  titleNode.textContent = title;
	  container.appendChild(titleNode);

	  var tableNode = document.createElement("div");
	  tableNode.className = "plain table-chart-grid";
	  tableNode.setAttribute("style", "-moz-box-orient: vertical");
	  container.appendChild(tableNode);

	  var headerNode = document.createElement("div");
	  headerNode.className = "table-chart-row";

	  var headerBoxNode = document.createElement("div");
	  headerBoxNode.className = "table-chart-row-box";
	  headerNode.appendChild(headerBoxNode);

	  for (var _ref4 of Object.entries(header)) {
	    var _ref5 = _slicedToArray(_ref4, 2);

	    var key = _ref5[0];
	    var value = _ref5[1];

	    var headerLabelNode = document.createElement("span");
	    headerLabelNode.className = "plain table-chart-row-label";
	    headerLabelNode.setAttribute("name", key);
	    headerLabelNode.textContent = value;

	    headerNode.appendChild(headerLabelNode);
	  }

	  tableNode.appendChild(headerNode);

	  for (var rowInfo of data) {
	    var rowNode = document.createElement("div");
	    rowNode.className = "table-chart-row";
	    rowNode.setAttribute("align", "center");

	    var boxNode = document.createElement("div");
	    boxNode.className = "table-chart-row-box chart-colored-blob";
	    boxNode.setAttribute("name", rowInfo.label);
	    rowNode.appendChild(boxNode);

	    for (var _ref6 of Object.entries(rowInfo)) {
	      var _ref7 = _slicedToArray(_ref6, 2);

	      var _key = _ref7[0];
	      var _value = _ref7[1];

	      var index = data.indexOf(rowInfo);
	      var stringified = strings[_key] ? strings[_key](_value, index) : _value;
	      var labelNode = document.createElement("span");
	      labelNode.className = "plain table-chart-row-label";
	      labelNode.setAttribute("name", _key);
	      labelNode.textContent = stringified;
	      rowNode.appendChild(labelNode);
	    }

	    proxy.rows.set(rowInfo, rowNode);
	    delegate(proxy, ["click", "mouseover", "mouseout"], rowNode, rowInfo);
	    tableNode.appendChild(rowNode);
	  }

	  var totalsNode = document.createElement("div");
	  totalsNode.className = "table-chart-totals";
	  totalsNode.setAttribute("style", "-moz-box-orient: vertical");

	  var _loop = function (_key2, _value2) {
	    var total = data.reduce((acc, e) => acc + e[_key2], 0);
	    var stringified = _value2 ? _value2(total || 0) : total;
	    var labelNode = document.createElement("span");
	    labelNode.className = "plain table-chart-summary-label";
	    labelNode.setAttribute("name", _key2);
	    labelNode.textContent = stringified;
	    totalsNode.appendChild(labelNode);
	  };

	  for (var _ref8 of Object.entries(totals)) {
	    var _ref9 = _slicedToArray(_ref8, 2);

	    var _key2 = _ref9[0];
	    var _value2 = _ref9[1];

	    _loop(_key2, _value2);
	  }

	  container.appendChild(totalsNode);

	  return proxy;
	}

	function loadingPieChartData() {
	  return [{ size: 1, label: "Loading" }];
	}

	function emptyPieChartData() {
	  return [{ size: 1, label: "Empty" }];
	}

	function loadingTableChartData() {
	  return [{ size: "", label: "Please wait…" }];
	}

	function emptyTableChartData() {
	  return [{ size: "", label: "No data available" }];
	}

	/**
	 * Delegates DOM events emitted by an nsIDOMNode to an EventEmitter proxy.
	 *
	 * @param EventEmitter emitter
	 *        The event emitter proxy instance.
	 * @param array events
	 *        An array of events, e.g. ["mouseover", "mouseout"].
	 * @param nsIDOMNode node
	 *        The element firing the DOM events.
	 * @param any args
	 *        The arguments passed when emitting events through the proxy.
	 */
	function delegate(emitter, events, node, args) {
	  for (var event of events) {
	    node.addEventListener(event, emitter.emit.bind(emitter, event, args));
	  }
	}

	exports.Chart = Chart;

/***/ },
/* 861 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/*
	 * Copyright (C) 2007, 2008 Apple Inc.  All rights reserved.
	 * Copyright (C) 2008, 2009 Anthony Ricaud <rik@webkit.org>
	 * Copyright (C) 2011 Google Inc. All rights reserved.
	 * Copyright (C) 2009 Mozilla Foundation. All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 *
	 * 1.  Redistributions of source code must retain the above copyright
	 *     notice, this list of conditions and the following disclaimer.
	 * 2.  Redistributions in binary form must reproduce the above copyright
	 *     notice, this list of conditions and the following disclaimer in the
	 *     documentation and/or other materials provided with the distribution.
	 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
	 *     its contributors may be used to endorse or promote products derived
	 *     from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	"use strict";

	var _require = __webpack_require__(29),
	    Services = _require.Services;

	var DEFAULT_HTTP_VERSION = "HTTP/1.1";

	var Curl = {
	  /**
	   * Generates a cURL command string which can be used from the command line etc.
	   *
	   * @param object data
	   *        Datasource to create the command from.
	   *        The object must contain the following properties:
	   *        - url:string, the URL of the request.
	   *        - method:string, the request method upper cased. HEAD / GET / POST etc.
	   *        - headers:array, an array of request headers {name:x, value:x} tuples.
	   *        - httpVersion:string, http protocol version rfc2616 formatted. Eg. "HTTP/1.1"
	   *        - postDataText:string, optional - the request payload.
	   *
	   * @return string
	   *         A cURL command.
	   */
	  generateCommand: function (data) {
	    var utils = CurlUtils;

	    var command = ["curl"];
	    var ignoredHeaders = new Set();

	    // The cURL command is expected to run on the same platform that Firefox runs
	    // (it may be different from the inspected page platform).
	    var escapeString = Services.appinfo.OS == "WINNT" ? utils.escapeStringWin : utils.escapeStringPosix;

	    // Add URL.
	    command.push(escapeString(data.url));

	    var postDataText = null;
	    var multipartRequest = utils.isMultipartRequest(data);

	    // Create post data.
	    var postData = [];
	    if (utils.isUrlEncodedRequest(data) || data.method == "PUT" || data.method == "POST") {
	      postDataText = data.postDataText;
	      postData.push("--data");
	      postData.push(escapeString(utils.writePostDataTextParams(postDataText)));
	      ignoredHeaders.add("Content-Length");
	    } else if (multipartRequest) {
	      postDataText = data.postDataText;
	      postData.push("--data-binary");
	      var boundary = utils.getMultipartBoundary(data);
	      var text = utils.removeBinaryDataFromMultipartText(postDataText, boundary);
	      postData.push(escapeString(text));
	      ignoredHeaders.add("Content-Length");
	    }

	    // Add method.
	    // For GET and POST requests this is not necessary as GET is the
	    // default. If --data or --binary is added POST is the default.
	    if (!(data.method == "GET" || data.method == "POST")) {
	      command.push("-X");
	      command.push(data.method);
	    }

	    // Add -I (HEAD)
	    // For servers that supports HEAD.
	    // This will fetch the header of a document only.
	    if (data.method == "HEAD") {
	      command.push("-I");
	    }

	    // Add http version.
	    if (data.httpVersion && data.httpVersion != DEFAULT_HTTP_VERSION) {
	      command.push("--" + data.httpVersion.split("/")[1]);
	    }

	    // Add request headers.
	    var headers = data.headers;
	    if (multipartRequest) {
	      var multipartHeaders = utils.getHeadersFromMultipartText(postDataText);
	      headers = headers.concat(multipartHeaders);
	    }
	    for (var i = 0; i < headers.length; i++) {
	      var header = headers[i];
	      if (header.name === "Accept-Encoding") {
	        command.push("--compressed");
	        continue;
	      }
	      if (ignoredHeaders.has(header.name)) {
	        continue;
	      }
	      command.push("-H");
	      command.push(escapeString(header.name + ": " + header.value));
	    }

	    // Add post data.
	    command = command.concat(postData);

	    return command.join(" ");
	  }
	};

	exports.Curl = Curl;

	/**
	 * Utility functions for the Curl command generator.
	 */
	var CurlUtils = {
	  /**
	   * Check if the request is an URL encoded request.
	   *
	   * @param object data
	   *        The data source. See the description in the Curl object.
	   * @return boolean
	   *         True if the request is URL encoded, false otherwise.
	   */
	  isUrlEncodedRequest: function (data) {
	    var postDataText = data.postDataText;
	    if (!postDataText) {
	      return false;
	    }

	    postDataText = postDataText.toLowerCase();
	    if (postDataText.includes("content-type: application/x-www-form-urlencoded")) {
	      return true;
	    }

	    var contentType = this.findHeader(data.headers, "content-type");

	    return contentType && contentType.toLowerCase().includes("application/x-www-form-urlencoded");
	  },

	  /**
	   * Check if the request is a multipart request.
	   *
	   * @param object data
	   *        The data source.
	   * @return boolean
	   *         True if the request is multipart reqeust, false otherwise.
	   */
	  isMultipartRequest: function (data) {
	    var postDataText = data.postDataText;
	    if (!postDataText) {
	      return false;
	    }

	    postDataText = postDataText.toLowerCase();
	    if (postDataText.includes("content-type: multipart/form-data")) {
	      return true;
	    }

	    var contentType = this.findHeader(data.headers, "content-type");

	    return contentType && contentType.toLowerCase().includes("multipart/form-data;");
	  },

	  /**
	   * Write out paramters from post data text.
	   *
	   * @param object postDataText
	   *        Post data text.
	   * @return string
	   *         Post data parameters.
	   */
	  writePostDataTextParams: function (postDataText) {
	    var lines = postDataText.split("\r\n");
	    return lines[lines.length - 1];
	  },

	  /**
	   * Finds the header with the given name in the headers array.
	   *
	   * @param array headers
	   *        Array of headers info {name:x, value:x}.
	   * @param string name
	   *        The header name to find.
	   * @return string
	   *         The found header value or null if not found.
	   */
	  findHeader: function (headers, name) {
	    if (!headers) {
	      return null;
	    }

	    name = name.toLowerCase();
	    for (var header of headers) {
	      if (name == header.name.toLowerCase()) {
	        return header.value;
	      }
	    }

	    return null;
	  },

	  /**
	   * Returns the boundary string for a multipart request.
	   *
	   * @param string data
	   *        The data source. See the description in the Curl object.
	   * @return string
	   *         The boundary string for the request.
	   */
	  getMultipartBoundary: function (data) {
	    var boundaryRe = /\bboundary=(-{3,}\w+)/i;

	    // Get the boundary string from the Content-Type request header.
	    var contentType = this.findHeader(data.headers, "Content-Type");
	    if (boundaryRe.test(contentType)) {
	      return contentType.match(boundaryRe)[1];
	    }
	    // Temporary workaround. As of 2014-03-11 the requestHeaders array does not
	    // always contain the Content-Type header for mulitpart requests. See bug 978144.
	    // Find the header from the request payload.
	    var boundaryString = data.postDataText.match(boundaryRe)[1];
	    if (boundaryString) {
	      return boundaryString;
	    }

	    return null;
	  },

	  /**
	   * Removes the binary data from multipart text.
	   *
	   * @param string multipartText
	   *        Multipart form data text.
	   * @param string boundary
	   *        The boundary string.
	   * @return string
	   *         The multipart text without the binary data.
	   */
	  removeBinaryDataFromMultipartText: function (multipartText, boundary) {
	    var result = "";
	    boundary = "--" + boundary;
	    var parts = multipartText.split(boundary);
	    for (var part of parts) {
	      // Each part is expected to have a content disposition line.
	      var contentDispositionLine = part.trimLeft().split("\r\n")[0];
	      if (!contentDispositionLine) {
	        continue;
	      }
	      contentDispositionLine = contentDispositionLine.toLowerCase();
	      if (contentDispositionLine.includes("content-disposition: form-data")) {
	        if (contentDispositionLine.includes("filename=")) {
	          // The header lines and the binary blob is separated by 2 CRLF's.
	          // Add only the headers to the result.
	          var headers = part.split("\r\n\r\n")[0];
	          result += boundary + "\r\n" + headers + "\r\n\r\n";
	        } else {
	          result += boundary + "\r\n" + part;
	        }
	      }
	    }
	    result += boundary + "--\r\n";

	    return result;
	  },

	  /**
	   * Get the headers from a multipart post data text.
	   *
	   * @param string multipartText
	   *        Multipart post text.
	   * @return array
	   *         An array of header objects {name:x, value:x}
	   */
	  getHeadersFromMultipartText: function (multipartText) {
	    var headers = [];
	    if (!multipartText || multipartText.startsWith("---")) {
	      return headers;
	    }

	    // Get the header section.
	    var index = multipartText.indexOf("\r\n\r\n");
	    if (index == -1) {
	      return headers;
	    }

	    // Parse the header lines.
	    var headersText = multipartText.substring(0, index);
	    var headerLines = headersText.split("\r\n");
	    var lastHeaderName = null;

	    for (var line of headerLines) {
	      // Create a header for each line in fields that spans across multiple lines.
	      // Subsquent lines always begins with at least one space or tab character.
	      // (rfc2616)
	      if (lastHeaderName && /^\s+/.test(line)) {
	        headers.push({ name: lastHeaderName, value: line.trim() });
	        continue;
	      }

	      var indexOfColon = line.indexOf(":");
	      if (indexOfColon == -1) {
	        continue;
	      }

	      var header = [line.slice(0, indexOfColon), line.slice(indexOfColon + 1)];
	      if (header.length != 2) {
	        continue;
	      }
	      lastHeaderName = header[0].trim();
	      headers.push({ name: lastHeaderName, value: header[1].trim() });
	    }

	    return headers;
	  },

	  /**
	   * Escape util function for POSIX oriented operating systems.
	   * Credit: Google DevTools
	   */
	  escapeStringPosix: function (str) {
	    function escapeCharacter(x) {
	      var code = x.charCodeAt(0);
	      if (code < 256) {
	        // Add leading zero when needed to not care about the next character.
	        return code < 16 ? "\\x0" + code.toString(16) : "\\x" + code.toString(16);
	      }
	      code = code.toString(16);
	      return "\\u" + ("0000" + code).substr(code.length, 4);
	    }

	    if (/[^\x20-\x7E]|\'/.test(str)) {
	      // Use ANSI-C quoting syntax.
	      return "$\'" + str.replace(/\\/g, "\\\\").replace(/\'/g, "\\\'").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[^\x20-\x7E]/g, escapeCharacter) + "'";
	    }

	    // Use single quote syntax.
	    return "'" + str + "'";
	  },

	  /**
	   * Escape util function for Windows systems.
	   * Credit: Google DevTools
	   */
	  escapeStringWin: function (str) {
	    /* Replace quote by double quote (but not by \") because it is
	       recognized by both cmd.exe and MS Crt arguments parser.
	        Replace % by "%" because it could be expanded to an environment
	       variable value. So %% becomes "%""%". Even if an env variable ""
	       (2 doublequotes) is declared, the cmd.exe will not
	       substitute it with its value.
	        Replace each backslash with double backslash to make sure
	       MS Crt arguments parser won't collapse them.
	        Replace new line outside of quotes since cmd.exe doesn't let
	       to do it inside.
	    */
	    return "\"" + str.replace(/"/g, "\"\"").replace(/%/g, "\"%\"").replace(/\\/g, "\\\\").replace(/[\r\n]+/g, "\"^$&\"") + "\"";
	  }
	};

	exports.CurlUtils = CurlUtils;

/***/ },
/* 862 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var _require = __webpack_require__(834),
	    Ci = _require.Ci,
	    Cu = _require.Cu,
	    components = _require.components;

	var Services = __webpack_require__(29);
	var DevToolsUtils = __webpack_require__(833);

	// WARNING I swapped the sync one for the async one here
	// const promise = require("resource://devtools/shared/deprecated-sync-thenables.js", {}).Promise;
	var promise = __webpack_require__(839);

	var events = __webpack_require__(863);

	var _require2 = __webpack_require__(865),
	    WebConsoleClient = _require2.WebConsoleClient;
	/* const { DebuggerSocket } = require("../shared/security/socket");*/
	/* const Authentication = require("../shared/security/auth");*/

	var noop = () => {};

	/**
	 * TODO: Get rid of this API in favor of EventTarget (bug 1042642)
	 *
	 * Add simple event notification to a prototype object. Any object that has
	 * some use for event notifications or the observer pattern in general can be
	 * augmented with the necessary facilities by passing its prototype to this
	 * function.
	 *
	 * @param aProto object
	 *        The prototype object that will be modified.
	 */
	function eventSource(aProto) {
	  /**
	   * Add a listener to the event source for a given event.
	   *
	   * @param aName string
	   *        The event to listen for.
	   * @param aListener function
	   *        Called when the event is fired. If the same listener
	   *        is added more than once, it will be called once per
	   *        addListener call.
	   */
	  aProto.addListener = function (aName, aListener) {
	    if (typeof aListener != "function") {
	      throw TypeError("Listeners must be functions.");
	    }

	    if (!this._listeners) {
	      this._listeners = {};
	    }

	    this._getListeners(aName).push(aListener);
	  };

	  /**
	   * Add a listener to the event source for a given event. The
	   * listener will be removed after it is called for the first time.
	   *
	   * @param aName string
	   *        The event to listen for.
	   * @param aListener function
	   *        Called when the event is fired.
	   */
	  aProto.addOneTimeListener = function (aName, aListener) {
	    var _this = this;

	    var l = function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      _this.removeListener(aName, l);
	      aListener.apply(null, args);
	    };
	    this.addListener(aName, l);
	  };

	  /**
	   * Remove a listener from the event source previously added with
	   * addListener().
	   *
	   * @param aName string
	   *        The event name used during addListener to add the listener.
	   * @param aListener function
	   *        The callback to remove. If addListener was called multiple
	   *        times, all instances will be removed.
	   */
	  aProto.removeListener = function (aName, aListener) {
	    if (!this._listeners || aListener && !this._listeners[aName]) {
	      return;
	    }

	    if (!aListener) {
	      this._listeners[aName] = [];
	    } else {
	      this._listeners[aName] = this._listeners[aName].filter(function (l) {
	        return l != aListener;
	      });
	    }
	  };

	  /**
	   * Returns the listeners for the specified event name. If none are defined it
	   * initializes an empty list and returns that.
	   *
	   * @param aName string
	   *        The event name.
	   */
	  aProto._getListeners = function (aName) {
	    if (aName in this._listeners) {
	      return this._listeners[aName];
	    }
	    this._listeners[aName] = [];
	    return this._listeners[aName];
	  };

	  /**
	   * Notify listeners of an event.
	   *
	   * @param aName string
	   *        The event to fire.
	   * @param arguments
	   *        All arguments will be passed along to the listeners,
	   *        including the name argument.
	   */
	  aProto.emit = function () {
	    if (!this._listeners) {
	      return;
	    }

	    var name = arguments[0];
	    var listeners = this._getListeners(name).slice(0);

	    for (var listener of listeners) {
	      try {
	        listener.apply(null, arguments);
	      } catch (e) {
	        // Prevent a bad listener from interfering with the others.
	        DevToolsUtils.reportException(`notify event '${name}'`, e);
	      }
	    }
	  };
	}

	/**
	 * Set of protocol messages that affect thread state, and the
	 * state the actor is in after each message.
	 */
	var ThreadStateTypes = {
	  "paused": "paused",
	  "resumed": "attached",
	  "detached": "detached"
	};

	/**
	 * Set of protocol messages that are sent by the server without a prior request
	 * by the client.
	 */
	var UnsolicitedNotifications = {
	  "consoleAPICall": "consoleAPICall",
	  "eventNotification": "eventNotification",
	  "fileActivity": "fileActivity",
	  "lastPrivateContextExited": "lastPrivateContextExited",
	  "logMessage": "logMessage",
	  "networkEvent": "networkEvent",
	  "networkEventUpdate": "networkEventUpdate",
	  "newGlobal": "newGlobal",
	  "newScript": "newScript",
	  "tabDetached": "tabDetached",
	  "tabListChanged": "tabListChanged",
	  "reflowActivity": "reflowActivity",
	  "addonListChanged": "addonListChanged",
	  "workerListChanged": "workerListChanged",
	  "serviceWorkerRegistrationListChanged": "serviceWorkerRegistrationList",
	  "tabNavigated": "tabNavigated",
	  "frameUpdate": "frameUpdate",
	  "pageError": "pageError",
	  "documentLoad": "documentLoad",
	  "enteredFrame": "enteredFrame",
	  "exitedFrame": "exitedFrame",
	  "appOpen": "appOpen",
	  "appClose": "appClose",
	  "appInstall": "appInstall",
	  "appUninstall": "appUninstall",
	  "evaluationResult": "evaluationResult",
	  "newSource": "newSource",
	  "updatedSource": "updatedSource"
	};

	/**
	 * Set of pause types that are sent by the server and not as an immediate
	 * response to a client request.
	 */
	var UnsolicitedPauses = {
	  "resumeLimit": "resumeLimit",
	  "debuggerStatement": "debuggerStatement",
	  "breakpoint": "breakpoint",
	  "DOMEvent": "DOMEvent",
	  "watchpoint": "watchpoint",
	  "exception": "exception"
	};

	/**
	 * Creates a client for the remote debugging protocol server. This client
	 * provides the means to communicate with the server and exchange the messages
	 * required by the protocol in a traditional JavaScript API.
	 */
	var DebuggerClient = exports.DebuggerClient = function (aTransport) {
	  this._transport = aTransport;
	  this._transport.hooks = this;

	  // Map actor ID to client instance for each actor type.
	  this._clients = new Map();

	  this._pendingRequests = new Map();
	  this._activeRequests = new Map();
	  this._eventsEnabled = true;

	  this.traits = {};

	  this.request = this.request.bind(this);
	  this.localTransport = this._transport.onOutputStreamReady === undefined;

	  /*
	   * As the first thing on the connection, expect a greeting packet from
	   * the connection's root actor.
	   */
	  this.mainRoot = null;
	  this.expectReply("root", aPacket => {
	    this.mainRoot = new RootClient(this, aPacket);
	    this.emit("connected", aPacket.applicationType, aPacket.traits);
	  });
	};

	/**
	 * A declarative helper for defining methods that send requests to the server.
	 *
	 * @param aPacketSkeleton
	 *        The form of the packet to send. Can specify fields to be filled from
	 *        the parameters by using the |args| function.
	 * @param telemetry
	 *        The unique suffix of the telemetry histogram id.
	 * @param before
	 *        The function to call before sending the packet. Is passed the packet,
	 *        and the return value is used as the new packet. The |this| context is
	 *        the instance of the client object we are defining a method for.
	 * @param after
	 *        The function to call after the response is received. It is passed the
	 *        response, and the return value is considered the new response that
	 *        will be passed to the callback. The |this| context is the instance of
	 *        the client object we are defining a method for.
	 * @return Request
	 *         The `Request` object that is a Promise object and resolves once
	 *         we receive the response. (See request method for more details)
	 */
	DebuggerClient.requester = function (aPacketSkeleton) {
	  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var telemetry = config.telemetry,
	      before = config.before,
	      after = config.after;

	  return DevToolsUtils.makeInfallible(function () {
	    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }

	    var histogram = void 0,
	        startTime = void 0;
	    if (telemetry) {
	      var transportType = this._transport.onOutputStreamReady === undefined ? "LOCAL_" : "REMOTE_";
	      var histogramId = `DEVTOOLS_DEBUGGER_RDP_${transportType}${telemetry}_MS`;
	      histogram = Services.telemetry.getHistogramById(histogramId);
	      startTime = +new Date();
	    }
	    var outgoingPacket = {
	      to: aPacketSkeleton.to || this.actor
	    };

	    var maxPosition = -1;
	    for (var k of Object.keys(aPacketSkeleton)) {
	      if (aPacketSkeleton[k] instanceof DebuggerClient.Argument) {
	        var position = aPacketSkeleton[k].position;

	        outgoingPacket[k] = aPacketSkeleton[k].getArgument(args);
	        maxPosition = Math.max(position, maxPosition);
	      } else {
	        outgoingPacket[k] = aPacketSkeleton[k];
	      }
	    }

	    if (before) {
	      outgoingPacket = before.call(this, outgoingPacket);
	    }

	    return this.request(outgoingPacket, DevToolsUtils.makeInfallible(aResponse => {
	      if (after) {
	        var _aResponse = aResponse,
	            from = _aResponse.from;

	        aResponse = after.call(this, aResponse);
	        if (!aResponse.from) {
	          aResponse.from = from;
	        }
	      }

	      // The callback is always the last parameter.
	      var thisCallback = args[maxPosition + 1];
	      if (thisCallback) {
	        thisCallback(aResponse);
	      }

	      if (histogram) {
	        histogram.add(+new Date() - startTime);
	      }
	    }, "DebuggerClient.requester request callback"));
	  }, "DebuggerClient.requester");
	};

	function args(aPos) {
	  return new DebuggerClient.Argument(aPos);
	}

	DebuggerClient.Argument = function (aPosition) {
	  this.position = aPosition;
	};

	DebuggerClient.Argument.prototype.getArgument = function (aParams) {
	  if (!(this.position in aParams)) {
	    throw new Error(`Bad index into params: ${this.position}`);
	  }
	  return aParams[this.position];
	};

	// Expose these to save callers the trouble of importing DebuggerSocket
	DebuggerClient.socketConnect = function (options) {
	  // Defined here instead of just copying the function to allow lazy-load
	  return DebuggerSocket.connect(options);
	};
	DevToolsUtils.defineLazyGetter(DebuggerClient, "Authenticators", () => {
	  return Authentication.Authenticators;
	});
	DevToolsUtils.defineLazyGetter(DebuggerClient, "AuthenticationResult", () => {
	  return Authentication.AuthenticationResult;
	});

	DebuggerClient.prototype = {
	  /**
	   * Connect to the server and start exchanging protocol messages.
	   *
	   * @param aOnConnected function
	   *        If specified, will be called when the greeting packet is
	   *        received from the debugging server.
	   *
	   * @return Promise
	   *         Resolves once connected with an array whose first element
	   *         is the application type, by default "browser", and the second
	   *         element is the traits object (help figure out the features
	   *         and behaviors of the server we connect to. See RootActor).
	   */
	  connect: function (aOnConnected) {
	    return Promise.race([new Promise((resolve, reject) => {
	      this.emit("connect");

	      // Also emit the event on the |DebuggerClient| object (not on the instance),
	      // so it's possible to track all instances.
	      events.emit(DebuggerClient, "connect", this);

	      this.addOneTimeListener("connected", (aName, aApplicationType, aTraits) => {
	        this.traits = aTraits;
	        if (aOnConnected) {
	          aOnConnected(aApplicationType, aTraits);
	        }
	        resolve([aApplicationType, aTraits]);
	      });

	      this._transport.ready();
	    }), new Promise((resolve, reject) => {
	      setTimeout(() => reject(new Error("Connect timeout error")), 6000);
	    })]);
	  },

	  /**
	   * Shut down communication with the debugging server.
	   *
	   * @param aOnClosed function
	   *        If specified, will be called when the debugging connection
	   *        has been closed.
	   */
	  close: function (aOnClosed) {
	    // Disable detach event notifications, because event handlers will be in a
	    // cleared scope by the time they run.
	    this._eventsEnabled = false;

	    var cleanup = () => {
	      this._transport.close();
	      this._transport = null;
	    };

	    // If the connection is already closed,
	    // there is no need to detach client
	    // as we won't be able to send any message.
	    if (this._closed) {
	      cleanup();
	      if (aOnClosed) {
	        aOnClosed();
	      }
	      return;
	    }

	    if (aOnClosed) {
	      this.addOneTimeListener("closed", function (aEvent) {
	        aOnClosed();
	      });
	    }

	    // Call each client's `detach` method by calling
	    // lastly registered ones first to give a chance
	    // to detach child clients first.
	    var clients = [].concat(_toConsumableArray(this._clients.values()));
	    this._clients.clear();
	    var detachClients = () => {
	      var client = clients.pop();
	      if (!client) {
	        // All clients detached.
	        cleanup();
	        return;
	      }
	      if (client.detach) {
	        client.detach(detachClients);
	        return;
	      }
	      detachClients();
	    };
	    detachClients();
	  },

	  /*
	   * This function exists only to preserve DebuggerClient's interface;
	   * new code should say 'client.mainRoot.listTabs()'.
	   */
	  listTabs: function (aOnResponse) {
	    return this.mainRoot.listTabs(aOnResponse);
	  },

	  /*
	   * This function exists only to preserve DebuggerClient's interface;
	   * new code should say 'client.mainRoot.listAddons()'.
	   */
	  listAddons: function (aOnResponse) {
	    return this.mainRoot.listAddons(aOnResponse);
	  },

	  getTab: function (aFilter) {
	    return this.mainRoot.getTab(aFilter);
	  },

	  /**
	   * Attach to a tab actor.
	   *
	   * @param string aTabActor
	   *        The actor ID for the tab to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a TabClient
	   *        (which will be undefined on error).
	   */
	  attachTab: function (aTabActor) {
	    var aOnResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

	    if (this._clients.has(aTabActor)) {
	      var cachedTab = this._clients.get(aTabActor);
	      var cachedResponse = {
	        cacheDisabled: cachedTab.cacheDisabled,
	        javascriptEnabled: cachedTab.javascriptEnabled,
	        traits: cachedTab.traits
	      };
	      DevToolsUtils.executeSoon(() => aOnResponse(cachedResponse, cachedTab));
	      return promise.resolve([cachedResponse, cachedTab]);
	    }

	    var packet = {
	      to: aTabActor,
	      type: "attach"
	    };
	    return this.request(packet).then(aResponse => {
	      var tabClient = void 0;
	      if (!aResponse.error) {
	        tabClient = new TabClient(this, aResponse);
	        this.registerClient(tabClient);
	      }
	      aOnResponse(aResponse, tabClient);
	      return [aResponse, tabClient];
	    });
	  },

	  attachWorker: function DC_attachWorker(aWorkerActor) {
	    var aOnResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

	    var workerClient = this._clients.get(aWorkerActor);
	    if (workerClient !== undefined) {
	      var response = {
	        from: workerClient.actor,
	        type: "attached",
	        url: workerClient.url
	      };
	      DevToolsUtils.executeSoon(() => aOnResponse(response, workerClient));
	      return promise.resolve([response, workerClient]);
	    }

	    return this.request({ to: aWorkerActor, type: "attach" }).then(aResponse => {
	      if (aResponse.error) {
	        aOnResponse(aResponse, null);
	        return [aResponse, null];
	      }

	      var workerClient = new WorkerClient(this, aResponse);
	      this.registerClient(workerClient);
	      aOnResponse(aResponse, workerClient);
	      return [aResponse, workerClient];
	    });
	  },

	  /**
	   * Attach to an addon actor.
	   *
	   * @param string aAddonActor
	   *        The actor ID for the addon to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a AddonClient
	   *        (which will be undefined on error).
	   */
	  attachAddon: function DC_attachAddon(aAddonActor) {
	    var aOnResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

	    var packet = {
	      to: aAddonActor,
	      type: "attach"
	    };
	    return this.request(packet).then(aResponse => {
	      var addonClient = void 0;
	      if (!aResponse.error) {
	        addonClient = new AddonClient(this, aAddonActor);
	        this.registerClient(addonClient);
	        this.activeAddon = addonClient;
	      }
	      aOnResponse(aResponse, addonClient);
	      return [aResponse, addonClient];
	    });
	  },

	  /**
	   * Attach to a Web Console actor.
	   *
	   * @param string aConsoleActor
	   *        The ID for the console actor to attach to.
	   * @param array aListeners
	   *        The console listeners you want to start.
	   * @param function aOnResponse
	   *        Called with the response packet and a WebConsoleClient
	   *        instance (which will be undefined on error).
	   */
	  attachConsole: function (aConsoleActor, aListeners) {
	    var aOnResponse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

	    var packet = {
	      to: aConsoleActor,
	      type: "startListeners",
	      listeners: aListeners
	    };

	    return this.request(packet).then(aResponse => {
	      var consoleClient = void 0;
	      if (!aResponse.error) {
	        if (this._clients.has(aConsoleActor)) {
	          consoleClient = this._clients.get(aConsoleActor);
	        } else {
	          consoleClient = new WebConsoleClient(this, aResponse, LongStringClient);
	          this.registerClient(consoleClient);
	        }
	      }
	      aOnResponse(aResponse, consoleClient);
	      return [aResponse, consoleClient];
	    });
	  },

	  /**
	   * Attach to a global-scoped thread actor for chrome debugging.
	   *
	   * @param string aThreadActor
	   *        The actor ID for the thread to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a ThreadClient
	   *        (which will be undefined on error).
	   * @param object aOptions
	   *        Configuration options.
	   *        - useSourceMaps: whether to use source maps or not.
	   */
	  attachThread: function (aThreadActor) {
	    var aOnResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
	    var aOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    if (this._clients.has(aThreadActor)) {
	      var client = this._clients.get(aThreadActor);
	      DevToolsUtils.executeSoon(() => aOnResponse({}, client));
	      return promise.resolve([{}, client]);
	    }

	    var packet = {
	      to: aThreadActor,
	      type: "attach",
	      options: aOptions
	    };
	    return this.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        var threadClient = new ThreadClient(this, aThreadActor);
	        this.registerClient(threadClient);
	      }
	      aOnResponse(aResponse, threadClient);
	      return [aResponse, threadClient];
	    });
	  },

	  /**
	   * Attach to a trace actor.
	   *
	   * @param string aTraceActor
	   *        The actor ID for the tracer to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a TraceClient
	   *        (which will be undefined on error).
	   */
	  attachTracer: function (aTraceActor) {
	    var aOnResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

	    if (this._clients.has(aTraceActor)) {
	      var client = this._clients.get(aTraceActor);
	      DevToolsUtils.executeSoon(() => aOnResponse({}, client));
	      return promise.resolve([{}, client]);
	    }

	    var packet = {
	      to: aTraceActor,
	      type: "attach"
	    };
	    return this.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        var traceClient = new TraceClient(this, aTraceActor);
	        this.registerClient(traceClient);
	      }
	      aOnResponse(aResponse, traceClient);
	      return [aResponse, traceClient];
	    });
	  },

	  /**
	   * Fetch the ChromeActor for the main process or ChildProcessActor for a
	   * a given child process ID.
	   *
	   * @param number aId
	   *        The ID for the process to attach (returned by `listProcesses`).
	   *        Connected to the main process if omitted, or is 0.
	   */
	  getProcess: function (aId) {
	    var packet = {
	      to: "root",
	      type: "getProcess"
	    };
	    if (typeof aId == "number") {
	      packet.id = aId;
	    }
	    return this.request(packet);
	  },

	  /**
	   * Release an object actor.
	   *
	   * @param string aActor
	   *        The actor ID to send the request to.
	   * @param aOnResponse function
	   *        If specified, will be called with the response packet when
	   *        debugging server responds.
	   */
	  release: DebuggerClient.requester({
	    to: args(0),
	    type: "release"
	  }, {
	    telemetry: "RELEASE"
	  }),

	  /**
	   * Send a request to the debugging server.
	   *
	   * @param aRequest object
	   *        A JSON packet to send to the debugging server.
	   * @param aOnResponse function
	   *        If specified, will be called with the JSON response packet when
	   *        debugging server responds.
	   * @return Request
	   *         This object emits a number of events to allow you to respond to
	   *         different parts of the request lifecycle.
	   *         It is also a Promise object, with a `then` method, that is resolved
	   *         whenever a JSON or a Bulk response is received; and is rejected
	   *         if the response is an error.
	   *         Note: This return value can be ignored if you are using JSON alone,
	   *         because the callback provided in |aOnResponse| will be bound to the
	   *         "json-reply" event automatically.
	   *
	   *         Events emitted:
	   *         * json-reply: The server replied with a JSON packet, which is
	   *           passed as event data.
	   *         * bulk-reply: The server replied with bulk data, which you can read
	   *           using the event data object containing:
	   *           * actor:  Name of actor that received the packet
	   *           * type:   Name of actor's method that was called on receipt
	   *           * length: Size of the data to be read
	   *           * stream: This input stream should only be used directly if you
	   *                     can ensure that you will read exactly |length| bytes
	   *                     and will not close the stream when reading is complete
	   *           * done:   If you use the stream directly (instead of |copyTo|
	   *                     below), you must signal completion by resolving /
	   *                     rejecting this deferred.  If it's rejected, the
	   *                     transport will be closed.  If an Error is supplied as a
	   *                     rejection value, it will be logged via |dumpn|.  If you
	   *                     do use |copyTo|, resolving is taken care of for you
	   *                     when copying completes.
	   *           * copyTo: A helper function for getting your data out of the
	   *                     stream that meets the stream handling requirements
	   *                     above, and has the following signature:
	   *             @param  output nsIAsyncOutputStream
	   *                     The stream to copy to.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  request: function (aRequest, aOnResponse) {
	    if (!this.mainRoot) {
	      throw Error("Have not yet received a hello packet from the server.");
	    }
	    var type = aRequest.type || "";
	    if (!aRequest.to) {
	      throw Error(`'${type}' request packet has no destination.`);
	    }
	    if (this._closed) {
	      var msg = `'${type}' request packet to ` + `'${aRequest.to}' ` + "can't be sent as the connection is closed.";
	      var resp = { error: "connectionClosed", message: msg };
	      if (aOnResponse) {
	        aOnResponse(resp);
	      }
	      return promise.reject(resp);
	    }

	    var request = new Request(aRequest);
	    request.format = "json";
	    request.stack = components.stack;
	    if (aOnResponse) {
	      request.on("json-reply", aOnResponse);
	    }

	    this._sendOrQueueRequest(request);

	    // Implement a Promise like API on the returned object
	    // that resolves/rejects on request response
	    var deferred = promise.defer();
	    function listenerJson(resp) {
	      request.off("json-reply", listenerJson);
	      request.off("bulk-reply", listenerBulk);
	      if (resp.error) {
	        deferred.reject(resp);
	      } else {
	        deferred.resolve(resp);
	      }
	    }
	    function listenerBulk(resp) {
	      request.off("json-reply", listenerJson);
	      request.off("bulk-reply", listenerBulk);
	      deferred.resolve(resp);
	    }
	    request.on("json-reply", listenerJson);
	    request.on("bulk-reply", listenerBulk);
	    request.then = deferred.promise.then.bind(deferred.promise);

	    return request;
	  },

	  /**
	   * Transmit streaming data via a bulk request.
	   *
	   * This method initiates the bulk send process by queuing up the header data.
	   * The caller receives eventual access to a stream for writing.
	   *
	   * Since this opens up more options for how the server might respond (it could
	   * send back either JSON or bulk data), and the returned Request object emits
	   * events for different stages of the request process that you may want to
	   * react to.
	   *
	   * @param request Object
	   *        This is modeled after the format of JSON packets above, but does not
	   *        actually contain the data, but is instead just a routing header:
	   *          * actor:  Name of actor that will receive the packet
	   *          * type:   Name of actor's method that should be called on receipt
	   *          * length: Size of the data to be sent
	   * @return Request
	   *         This object emits a number of events to allow you to respond to
	   *         different parts of the request lifecycle.
	   *
	   *         Events emitted:
	   *         * bulk-send-ready: Ready to send bulk data to the server, using the
	   *           event data object containing:
	   *           * stream:   This output stream should only be used directly if
	   *                       you can ensure that you will write exactly |length|
	   *                       bytes and will not close the stream when writing is
	   *                       complete
	   *           * done:     If you use the stream directly (instead of |copyFrom|
	   *                       below), you must signal completion by resolving /
	   *                       rejecting this deferred.  If it's rejected, the
	   *                       transport will be closed.  If an Error is supplied as
	   *                       a rejection value, it will be logged via |dumpn|.  If
	   *                       you do use |copyFrom|, resolving is taken care of for
	   *                       you when copying completes.
	   *           * copyFrom: A helper function for getting your data onto the
	   *                       stream that meets the stream handling requirements
	   *                       above, and has the following signature:
	   *             @param  input nsIAsyncInputStream
	   *                     The stream to copy from.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   *         * json-reply: The server replied with a JSON packet, which is
	   *           passed as event data.
	   *         * bulk-reply: The server replied with bulk data, which you can read
	   *           using the event data object containing:
	   *           * actor:  Name of actor that received the packet
	   *           * type:   Name of actor's method that was called on receipt
	   *           * length: Size of the data to be read
	   *           * stream: This input stream should only be used directly if you
	   *                     can ensure that you will read exactly |length| bytes
	   *                     and will not close the stream when reading is complete
	   *           * done:   If you use the stream directly (instead of |copyTo|
	   *                     below), you must signal completion by resolving /
	   *                     rejecting this deferred.  If it's rejected, the
	   *                     transport will be closed.  If an Error is supplied as a
	   *                     rejection value, it will be logged via |dumpn|.  If you
	   *                     do use |copyTo|, resolving is taken care of for you
	   *                     when copying completes.
	   *           * copyTo: A helper function for getting your data out of the
	   *                     stream that meets the stream handling requirements
	   *                     above, and has the following signature:
	   *             @param  output nsIAsyncOutputStream
	   *                     The stream to copy to.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  startBulkRequest: function (request) {
	    if (!this.traits.bulk) {
	      throw Error("Server doesn't support bulk transfers");
	    }
	    if (!this.mainRoot) {
	      throw Error("Have not yet received a hello packet from the server.");
	    }
	    if (!request.type) {
	      throw Error("Bulk packet is missing the required 'type' field.");
	    }
	    if (!request.actor) {
	      throw Error(`'${request.type}' bulk packet has no destination.`);
	    }
	    if (!request.length) {
	      throw Error(`'${request.type}' bulk packet has no length.`);
	    }

	    request = new Request(request);
	    request.format = "bulk";

	    this._sendOrQueueRequest(request);

	    return request;
	  },

	  /**
	   * If a new request can be sent immediately, do so.  Otherwise, queue it.
	   */
	  _sendOrQueueRequest(request) {
	    var actor = request.actor;
	    if (!this._activeRequests.has(actor)) {
	      this._sendRequest(request);
	    } else {
	      this._queueRequest(request);
	    }
	  },

	  /**
	   * Send a request.
	   * @throws Error if there is already an active request in flight for the same
	   *         actor.
	   */
	  _sendRequest(request) {
	    var actor = request.actor;
	    this.expectReply(actor, request);

	    if (request.format === "json") {
	      this._transport.send(request.request);
	      return false;
	    }

	    this._transport.startBulkSend(request.request).then(function () {
	      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }

	      request.emit.apply(request, ["bulk-send-ready"].concat(args));
	    });
	  },

	  /**
	   * Queue a request to be sent later.  Queues are only drained when an in
	   * flight request to a given actor completes.
	   */
	  _queueRequest(request) {
	    var actor = request.actor;
	    var queue = this._pendingRequests.get(actor) || [];
	    queue.push(request);
	    this._pendingRequests.set(actor, queue);
	  },

	  /**
	   * Attempt the next request to a given actor (if any).
	   */
	  _attemptNextRequest(actor) {
	    if (this._activeRequests.has(actor)) {
	      return;
	    }
	    var queue = this._pendingRequests.get(actor);
	    if (!queue) {
	      return;
	    }
	    var request = queue.shift();
	    if (queue.length === 0) {
	      this._pendingRequests.delete(actor);
	    }
	    this._sendRequest(request);
	  },

	  /**
	   * Arrange to hand the next reply from |aActor| to the handler bound to
	   * |aRequest|.
	   *
	   * DebuggerClient.prototype.request / startBulkRequest usually takes care of
	   * establishing the handler for a given request, but in rare cases (well,
	   * greetings from new root actors, is the only case at the moment) we must be
	   * prepared for a "reply" that doesn't correspond to any request we sent.
	   */
	  expectReply: function (aActor, aRequest) {
	    if (this._activeRequests.has(aActor)) {
	      throw Error(`clashing handlers for next reply from ${uneval(aActor)}`);
	    }

	    // If a handler is passed directly (as it is with the handler for the root
	    // actor greeting), create a dummy request to bind this to.
	    if (typeof aRequest === "function") {
	      var handler = aRequest;
	      aRequest = new Request();
	      aRequest.on("json-reply", handler);
	    }

	    this._activeRequests.set(aActor, aRequest);
	  },

	  // Transport hooks.

	  /**
	   * Called by DebuggerTransport to dispatch incoming packets as appropriate.
	   *
	   * @param aPacket object
	   *        The incoming packet.
	   */
	  onPacket: function (aPacket) {
	    if (!aPacket.from) {
	      DevToolsUtils.reportException("onPacket", new Error(`Server did not specify an actor, dropping packet: ${JSON.stringify(aPacket)}`));
	      return;
	    }

	    // If we have a registered Front for this actor, let it handle the packet
	    // and skip all the rest of this unpleasantness.
	    var front = this.getActor(aPacket.from);
	    if (front) {
	      front.onPacket(aPacket);
	      return;
	    }

	    if (this._clients.has(aPacket.from) && aPacket.type) {
	      var client = this._clients.get(aPacket.from);
	      var type = aPacket.type;
	      if (client.events.indexOf(type) != -1) {
	        client.emit(type, aPacket);
	        // we ignore the rest, as the client is expected to handle this packet.
	        return;
	      }
	    }

	    var activeRequest = void 0;
	    // See if we have a handler function waiting for a reply from this
	    // actor. (Don't count unsolicited notifications or pauses as
	    // replies.)
	    if (this._activeRequests.has(aPacket.from) && !(aPacket.type in UnsolicitedNotifications) && !(aPacket.type == ThreadStateTypes.paused && aPacket.why.type in UnsolicitedPauses)) {
	      activeRequest = this._activeRequests.get(aPacket.from);
	      this._activeRequests.delete(aPacket.from);
	    }

	    // If there is a subsequent request for the same actor, hand it off to the
	    // transport.  Delivery of packets on the other end is always async, even
	    // in the local transport case.
	    this._attemptNextRequest(aPacket.from);

	    // Packets that indicate thread state changes get special treatment.
	    if (aPacket.type in ThreadStateTypes && this._clients.has(aPacket.from) && typeof this._clients.get(aPacket.from)._onThreadState == "function") {
	      this._clients.get(aPacket.from)._onThreadState(aPacket);
	    }

	    // TODO: Bug 1151156 - Remove once Gecko 40 is on b2g-stable.
	    if (!this.traits.noNeedToFakeResumptionOnNavigation) {
	      // On navigation the server resumes, so the client must resume as well.
	      // We achieve that by generating a fake resumption packet that triggers
	      // the client's thread state change listeners.
	      if (aPacket.type == UnsolicitedNotifications.tabNavigated && this._clients.has(aPacket.from) && this._clients.get(aPacket.from).thread) {
	        var thread = this._clients.get(aPacket.from).thread;
	        var resumption = { from: thread._actor, type: "resumed" };
	        thread._onThreadState(resumption);
	      }
	    }

	    // Only try to notify listeners on events, not responses to requests
	    // that lack a packet type.
	    if (aPacket.type) {
	      this.emit(aPacket.type, aPacket);
	    }

	    if (activeRequest) {
	      var emitReply = () => activeRequest.emit("json-reply", aPacket);
	      if (activeRequest.stack) {
	        Cu.callFunctionWithAsyncStack(emitReply, activeRequest.stack, "DevTools RDP");
	      } else {
	        emitReply();
	      }
	    }
	  },

	  /**
	   * Called by the DebuggerTransport to dispatch incoming bulk packets as
	   * appropriate.
	   *
	   * @param packet object
	   *        The incoming packet, which contains:
	   *        * actor:  Name of actor that will receive the packet
	   *        * type:   Name of actor's method that should be called on receipt
	   *        * length: Size of the data to be read
	   *        * stream: This input stream should only be used directly if you can
	   *                  ensure that you will read exactly |length| bytes and will
	   *                  not close the stream when reading is complete
	   *        * done:   If you use the stream directly (instead of |copyTo|
	   *                  below), you must signal completion by resolving /
	   *                  rejecting this deferred.  If it's rejected, the transport
	   *                  will be closed.  If an Error is supplied as a rejection
	   *                  value, it will be logged via |dumpn|.  If you do use
	   *                  |copyTo|, resolving is taken care of for you when copying
	   *                  completes.
	   *        * copyTo: A helper function for getting your data out of the stream
	   *                  that meets the stream handling requirements above, and has
	   *                  the following signature:
	   *          @param  output nsIAsyncOutputStream
	   *                  The stream to copy to.
	   *          @return Promise
	   *                  The promise is resolved when copying completes or rejected
	   *                  if any (unexpected) errors occur.
	   *                  This object also emits "progress" events for each chunk
	   *                  that is copied.  See stream-utils.js.
	   */
	  onBulkPacket: function (packet) {
	    var actor = packet.actor,
	        type = packet.type,
	        length = packet.length;


	    if (!actor) {
	      DevToolsUtils.reportException("onBulkPacket", new Error(`Server did not specify an actor, dropping bulk packet: ${JSON.stringify(packet)}`));
	      return;
	    }

	    // See if we have a handler function waiting for a reply from this
	    // actor.
	    if (!this._activeRequests.has(actor)) {
	      return;
	    }

	    var activeRequest = this._activeRequests.get(actor);
	    this._activeRequests.delete(actor);

	    // If there is a subsequent request for the same actor, hand it off to the
	    // transport.  Delivery of packets on the other end is always async, even
	    // in the local transport case.
	    this._attemptNextRequest(actor);

	    activeRequest.emit("bulk-reply", packet);
	  },

	  /**
	   * Called by DebuggerTransport when the underlying stream is closed.
	   *
	   * @param aStatus nsresult
	   *        The status code that corresponds to the reason for closing
	   *        the stream.
	   */
	  onClosed: function (aStatus) {
	    this._closed = true;
	    this.emit("closed");

	    // Reject all pending and active requests
	    var reject = function (type, request, actor) {
	      // Server can send packets on its own and client only pass a callback
	      // to expectReply, so that there is no request object.
	      var msg = void 0;
	      if (request.request) {
	        msg = `'${request.request.type}' ${type} request packet` + ` to '${actor}' ` + "can't be sent as the connection just closed.";
	      } else {
	        msg = `server side packet from '${actor}' can't be received ` + "as the connection just closed.";
	      }
	      var packet = { error: "connectionClosed", message: msg };
	      request.emit("json-reply", packet);
	    };

	    var pendingRequests = new Map(this._pendingRequests);
	    this._pendingRequests.clear();
	    pendingRequests.forEach((list, actor) => {
	      list.forEach(request => reject("pending", request, actor));
	    });
	    var activeRequests = new Map(this._activeRequests);
	    this._activeRequests.clear();
	    activeRequests.forEach(reject.bind(null, "active"));

	    // The |_pools| array on the client-side currently is used only by
	    // protocol.js to store active fronts, mirroring the actor pools found in
	    // the server.  So, read all usages of "pool" as "protocol.js front".
	    //
	    // In the normal case where we shutdown cleanly, the toolbox tells each tool
	    // to close, and they each call |destroy| on any fronts they were using.
	    // When |destroy| or |cleanup| is called on a protocol.js front, it also
	    // removes itself from the |_pools| array.  Once the toolbox has shutdown,
	    // the connection is closed, and we reach here.  All fronts (should have
	    // been) |destroy|ed, so |_pools| should empty.
	    //
	    // If the connection instead aborts unexpectedly, we may end up here with
	    // all fronts used during the life of the connection.  So, we call |cleanup|
	    // on them clear their state, reject pending requests, and remove themselves
	    // from |_pools|.  This saves the toolbox from hanging indefinitely, in case
	    // it waits for some server response before shutdown that will now never
	    // arrive.
	    for (var pool of this._pools) {
	      pool.cleanup();
	    }
	  },

	  registerClient: function (client) {
	    var actorID = client.actor;
	    if (!actorID) {
	      throw new Error("DebuggerServer.registerClient expects " + "a client instance with an `actor` attribute.");
	    }
	    if (!Array.isArray(client.events)) {
	      throw new Error("DebuggerServer.registerClient expects " + "a client instance with an `events` attribute " + "that is an array.");
	    }
	    if (client.events.length > 0 && typeof client.emit != "function") {
	      throw new Error("DebuggerServer.registerClient expects " + "a client instance with non-empty `events` array to" + "have an `emit` function.");
	    }
	    if (this._clients.has(actorID)) {
	      throw new Error("DebuggerServer.registerClient already registered " + "a client for this actor.");
	    }
	    this._clients.set(actorID, client);
	  },

	  unregisterClient: function (client) {
	    var actorID = client.actor;
	    if (!actorID) {
	      throw new Error("DebuggerServer.unregisterClient expects " + "a Client instance with a `actor` attribute.");
	    }
	    this._clients.delete(actorID);
	  },

	  /**
	   * Actor lifetime management, echos the server's actor pools.
	   */
	  __pools: null,
	  get _pools() {
	    if (this.__pools) {
	      return this.__pools;
	    }
	    this.__pools = new Set();
	    return this.__pools;
	  },

	  addActorPool: function (pool) {
	    this._pools.add(pool);
	  },
	  removeActorPool: function (pool) {
	    this._pools.delete(pool);
	  },
	  getActor: function (actorID) {
	    var pool = this.poolFor(actorID);
	    return pool ? pool.get(actorID) : null;
	  },

	  poolFor: function (actorID) {
	    for (var pool of this._pools) {
	      if (pool.has(actorID)) {
	        return pool;
	      }
	    }
	    return null;
	  },

	  /**
	   * Currently attached addon.
	   */
	  activeAddon: null
	};

	eventSource(DebuggerClient.prototype);

	function Request(request) {
	  this.request = request;
	}

	Request.prototype = {

	  on: function (type, listener) {
	    events.on(this, type, listener);
	  },

	  off: function (type, listener) {
	    events.off(this, type, listener);
	  },

	  once: function (type, listener) {
	    events.once(this, type, listener);
	  },

	  emit: function (type) {
	    for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	      args[_key4 - 1] = arguments[_key4];
	    }

	    events.emit.apply(events, [this, type].concat(args));
	  },

	  get actor() {
	    return this.request.to || this.request.actor;
	  }

	};

	/**
	 * Creates a tab client for the remote debugging protocol server. This client
	 * is a front to the tab actor created in the server side, hiding the protocol
	 * details in a traditional JavaScript API.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aForm object
	 *        The protocol form for this tab.
	 */
	function TabClient(aClient, aForm) {
	  this.client = aClient;
	  this._actor = aForm.from;
	  this._threadActor = aForm.threadActor;
	  this.javascriptEnabled = aForm.javascriptEnabled;
	  this.cacheDisabled = aForm.cacheDisabled;
	  this.thread = null;
	  this.request = this.client.request;
	  this.traits = aForm.traits || {};
	  this.events = ["workerListChanged"];
	}

	TabClient.prototype = {
	  get actor() {
	    return this._actor;
	  },
	  get _transport() {
	    return this.client._transport;
	  },

	  /**
	   * Attach to a thread actor.
	   *
	   * @param object aOptions
	   *        Configuration options.
	   *        - useSourceMaps: whether to use source maps or not.
	   * @param function aOnResponse
	   *        Called with the response packet and a ThreadClient
	   *        (which will be undefined on error).
	   */
	  attachThread: function () {
	    var aOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var aOnResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

	    if (this.thread) {
	      DevToolsUtils.executeSoon(() => aOnResponse({}, this.thread));
	      return promise.resolve([{}, this.thread]);
	    }

	    var packet = {
	      to: this._threadActor,
	      type: "attach",
	      options: aOptions
	    };
	    return this.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        this.thread = new ThreadClient(this, this._threadActor);
	        this.client.registerClient(this.thread);
	      }
	      aOnResponse(aResponse, this.thread);
	      return [aResponse, this.thread];
	    });
	  },

	  /**
	   * Detach the client from the tab actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    before: function (aPacket) {
	      if (this.thread) {
	        this.thread.detach();
	      }
	      return aPacket;
	    },
	    after: function (aResponse) {
	      this.client.unregisterClient(this);
	      return aResponse;
	    },
	    telemetry: "TABDETACH"
	  }),

	  /**
	   * Bring the window to the front.
	   */
	  focus: DebuggerClient.requester({
	    type: "focus"
	  }, {}),

	  /**
	   * Reload the page in this tab.
	   *
	   * @param [optional] object options
	   *        An object with a `force` property indicating whether or not
	   *        this reload should skip the cache
	   */
	  reload: function () {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { force: false };

	    return this._reload(options);
	  },
	  _reload: DebuggerClient.requester({
	    type: "reload",
	    options: args(0)
	  }, {
	    telemetry: "RELOAD"
	  }),

	  /**
	   * Navigate to another URL.
	   *
	   * @param string url
	   *        The URL to navigate to.
	   */
	  navigateTo: DebuggerClient.requester({
	    type: "navigateTo",
	    url: args(0)
	  }, {
	    telemetry: "NAVIGATETO"
	  }),

	  /**
	   * Reconfigure the tab actor.
	   *
	   * @param object aOptions
	   *        A dictionary object of the new options to use in the tab actor.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  reconfigure: DebuggerClient.requester({
	    type: "reconfigure",
	    options: args(0)
	  }, {
	    telemetry: "RECONFIGURETAB"
	  }),

	  listWorkers: DebuggerClient.requester({
	    type: "listWorkers"
	  }, {
	    telemetry: "LISTWORKERS"
	  }),

	  attachWorker: function (aWorkerActor, aOnResponse) {
	    this.client.attachWorker(aWorkerActor, aOnResponse);
	  },

	  /**
	   * Resolve a location ({ url, line, column }) to its current
	   * source mapping location.
	   *
	   * @param {String} arg[0].url
	   * @param {Number} arg[0].line
	   * @param {Number?} arg[0].column
	   */
	  resolveLocation: DebuggerClient.requester({
	    type: "resolveLocation",
	    location: args(0)
	  })
	};

	eventSource(TabClient.prototype);

	function WorkerClient(aClient, aForm) {
	  this.client = aClient;
	  this._actor = aForm.from;
	  this._isClosed = false;
	  this._url = aForm.url;

	  this._onClose = this._onClose.bind(this);

	  this.addListener("close", this._onClose);

	  this.traits = {};
	}

	WorkerClient.prototype = {
	  get _transport() {
	    return this.client._transport;
	  },

	  get request() {
	    return this.client.request;
	  },

	  get actor() {
	    return this._actor;
	  },

	  get url() {
	    return this._url;
	  },

	  get isClosed() {
	    return this._isClosed;
	  },

	  detach: DebuggerClient.requester({ type: "detach" }, {
	    after: function (aResponse) {
	      if (this.thread) {
	        this.client.unregisterClient(this.thread);
	      }
	      this.client.unregisterClient(this);
	      return aResponse;
	    },

	    telemetry: "WORKERDETACH"
	  }),

	  attachThread: function () {
	    var aOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var aOnResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

	    if (this.thread) {
	      var response = [{
	        type: "connected",
	        threadActor: this.thread._actor,
	        consoleActor: this.consoleActor
	      }, this.thread];
	      DevToolsUtils.executeSoon(() => aOnResponse(response));
	      return response;
	    }

	    // The connect call on server doesn't attach the thread as of version 44.
	    return this.request({
	      to: this._actor,
	      type: "connect",
	      options: aOptions
	    }).then(connectReponse => {
	      if (connectReponse.error) {
	        aOnResponse(connectReponse, null);
	        return [connectResponse, null];
	      }

	      return this.request({
	        to: connectReponse.threadActor,
	        type: "attach",
	        options: aOptions
	      }).then(attachResponse => {
	        if (attachResponse.error) {
	          aOnResponse(attachResponse, null);
	        }

	        this.thread = new ThreadClient(this, connectReponse.threadActor);
	        this.consoleActor = connectReponse.consoleActor;
	        this.client.registerClient(this.thread);

	        aOnResponse(connectReponse, this.thread);
	        return [connectResponse, this.thread];
	      });
	    });
	  },

	  _onClose: function () {
	    this.removeListener("close", this._onClose);

	    if (this.thread) {
	      this.client.unregisterClient(this.thread);
	    }
	    this.client.unregisterClient(this);
	    this._isClosed = true;
	  },

	  reconfigure: function () {
	    return Promise.resolve();
	  },

	  events: ["close"]
	};

	eventSource(WorkerClient.prototype);

	function AddonClient(aClient, aActor) {
	  this._client = aClient;
	  this._actor = aActor;
	  this.request = this._client.request;
	  this.events = [];
	}

	AddonClient.prototype = {
	  get actor() {
	    return this._actor;
	  },
	  get _transport() {
	    return this._client._transport;
	  },

	  /**
	   * Detach the client from the addon actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function (aResponse) {
	      if (this._client.activeAddon === this) {
	        this._client.activeAddon = null;
	      }
	      this._client.unregisterClient(this);
	      return aResponse;
	    },
	    telemetry: "ADDONDETACH"
	  })
	};

	/**
	 * A RootClient object represents a root actor on the server. Each
	 * DebuggerClient keeps a RootClient instance representing the root actor
	 * for the initial connection; DebuggerClient's 'listTabs' and
	 * 'listChildProcesses' methods forward to that root actor.
	 *
	 * @param aClient object
	 *      The client connection to which this actor belongs.
	 * @param aGreeting string
	 *      The greeting packet from the root actor we're to represent.
	 *
	 * Properties of a RootClient instance:
	 *
	 * @property actor string
	 *      The name of this child's root actor.
	 * @property applicationType string
	 *      The application type, as given in the root actor's greeting packet.
	 * @property traits object
	 *      The traits object, as given in the root actor's greeting packet.
	 */
	function RootClient(aClient, aGreeting) {
	  this._client = aClient;
	  this.actor = aGreeting.from;
	  this.applicationType = aGreeting.applicationType;
	  this.traits = aGreeting.traits;
	}
	exports.RootClient = RootClient;

	RootClient.prototype = {
	  constructor: RootClient,

	  /**
	   * List the open tabs.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listTabs: DebuggerClient.requester({ type: "listTabs" }, { telemetry: "LISTTABS" }),

	  /**
	   * List the installed addons.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listAddons: DebuggerClient.requester({ type: "listAddons" }, { telemetry: "LISTADDONS" }),

	  /**
	   * List the registered workers.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listWorkers: DebuggerClient.requester({ type: "listWorkers" }, { telemetry: "LISTWORKERS" }),

	  /**
	   * List the registered service workers.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listServiceWorkerRegistrations: DebuggerClient.requester({ type: "listServiceWorkerRegistrations" }, { telemetry: "LISTSERVICEWORKERREGISTRATIONS" }),

	  /**
	   * List the running processes.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listProcesses: DebuggerClient.requester({ type: "listProcesses" }, { telemetry: "LISTPROCESSES" }),

	  /**
	   * Fetch the TabActor for the currently selected tab, or for a specific
	   * tab given as first parameter.
	   *
	   * @param [optional] object aFilter
	   *        A dictionary object with following optional attributes:
	   *         - outerWindowID: used to match tabs in parent process
	   *         - tabId: used to match tabs in child processes
	   *         - tab: a reference to xul:tab element
	   *        If nothing is specified, returns the actor for the currently
	   *        selected tab.
	   */
	  getTab: function (aFilter) {
	    var packet = {
	      to: this.actor,
	      type: "getTab"
	    };

	    if (aFilter) {
	      if (typeof aFilter.outerWindowID == "number") {
	        packet.outerWindowID = aFilter.outerWindowID;
	      } else if (typeof aFilter.tabId == "number") {
	        packet.tabId = aFilter.tabId;
	      } else if ("tab" in aFilter) {
	        var browser = aFilter.tab.linkedBrowser;
	        if (browser.frameLoader.tabParent) {
	          // Tabs in child process
	          packet.tabId = browser.frameLoader.tabParent.tabId;
	        } else {
	          // Tabs in parent process
	          var windowUtils = browser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
	          packet.outerWindowID = windowUtils.outerWindowID;
	        }
	      } else {
	        // Throw if a filter object have been passed but without
	        // any clearly idenfified filter.
	        throw new Error("Unsupported argument given to getTab request");
	      }
	    }

	    return this.request(packet);
	  },

	  /**
	   * Description of protocol's actors and methods.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  protocolDescription: DebuggerClient.requester({ type: "protocolDescription" }, { telemetry: "PROTOCOLDESCRIPTION" }),

	  /*
	   * Methods constructed by DebuggerClient.requester require these forwards
	   * on their 'this'.
	   */
	  get _transport() {
	    return this._client._transport;
	  },
	  get request() {
	    return this._client.request;
	  }
	};

	/**
	 * Creates a thread client for the remote debugging protocol server. This client
	 * is a front to the thread actor created in the server side, hiding the
	 * protocol details in a traditional JavaScript API.
	 *
	 * @param aClient DebuggerClient|TabClient
	 *        The parent of the thread (tab for tab-scoped debuggers, DebuggerClient
	 *        for chrome debuggers).
	 * @param aActor string
	 *        The actor ID for this thread.
	 */
	function ThreadClient(aClient, aActor) {
	  this._parent = aClient;
	  this.client = aClient instanceof DebuggerClient ? aClient : aClient.client;
	  this._actor = aActor;
	  this._frameCache = [];
	  this._scriptCache = {};
	  this._pauseGrips = {};
	  this._threadGrips = {};
	  this.request = this.client.request;
	}

	ThreadClient.prototype = {
	  _state: "paused",
	  get state() {
	    return this._state;
	  },
	  get paused() {
	    return this._state === "paused";
	  },

	  _pauseOnExceptions: false,
	  _ignoreCaughtExceptions: false,
	  _pauseOnDOMEvents: null,

	  _actor: null,
	  get actor() {
	    return this._actor;
	  },

	  get _transport() {
	    return this.client._transport;
	  },

	  _assertPaused: function (aCommand) {
	    if (!this.paused) {
	      throw Error(`${aCommand} command sent while not paused. Currently ${this._state}`);
	    }
	  },

	  /**
	   * Resume a paused thread. If the optional aLimit parameter is present, then
	   * the thread will also pause when that limit is reached.
	   *
	   * @param [optional] object aLimit
	   *        An object with a type property set to the appropriate limit (next,
	   *        step, or finish) per the remote debugging protocol specification.
	   *        Use null to specify no limit.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  _doResume: DebuggerClient.requester({
	    type: "resume",
	    resumeLimit: args(0)
	  }, {
	    before: function (aPacket) {
	      this._assertPaused("resume");

	      // Put the client in a tentative "resuming" state so we can prevent
	      // further requests that should only be sent in the paused state.
	      this._state = "resuming";

	      if (this._pauseOnExceptions) {
	        aPacket.pauseOnExceptions = this._pauseOnExceptions;
	      }
	      if (this._ignoreCaughtExceptions) {
	        aPacket.ignoreCaughtExceptions = this._ignoreCaughtExceptions;
	      }
	      if (this._pauseOnDOMEvents) {
	        aPacket.pauseOnDOMEvents = this._pauseOnDOMEvents;
	      }
	      return aPacket;
	    },
	    after: function (aResponse) {
	      if (aResponse.error) {
	        // There was an error resuming, back to paused state.
	        this._state = "paused";
	      }
	      return aResponse;
	    },
	    telemetry: "RESUME"
	  }),

	  /**
	   * Reconfigure the thread actor.
	   *
	   * @param object aOptions
	   *        A dictionary object of the new options to use in the thread actor.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  reconfigure: DebuggerClient.requester({
	    type: "reconfigure",
	    options: args(0)
	  }, {
	    telemetry: "RECONFIGURETHREAD"
	  }),

	  /**
	   * Resume a paused thread.
	   */
	  resume: function (aOnResponse) {
	    return this._doResume(null, aOnResponse);
	  },

	  /**
	   * Resume then pause without stepping.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  resumeThenPause: function (aOnResponse) {
	    return this._doResume({ type: "break" }, aOnResponse);
	  },

	  /**
	   * Step over a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepOver: function (aOnResponse) {
	    return this._doResume({ type: "next" }, aOnResponse);
	  },

	  /**
	   * Step into a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepIn: function (aOnResponse) {
	    return this._doResume({ type: "step" }, aOnResponse);
	  },

	  /**
	   * Step out of a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepOut: function (aOnResponse) {
	    return this._doResume({ type: "finish" }, aOnResponse);
	  },

	  /**
	   * Immediately interrupt a running thread.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  interrupt: function (aOnResponse) {
	    return this._doInterrupt(null, aOnResponse);
	  },

	  /**
	   * Pause execution right before the next JavaScript bytecode is executed.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  breakOnNext: function (aOnResponse) {
	    return this._doInterrupt("onNext", aOnResponse);
	  },

	  /**
	   * Interrupt a running thread.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  _doInterrupt: DebuggerClient.requester({
	    type: "interrupt",
	    when: args(0)
	  }, {
	    telemetry: "INTERRUPT"
	  }),

	  /**
	   * Enable or disable pausing when an exception is thrown.
	   *
	   * @param boolean aFlag
	   *        Enables pausing if true, disables otherwise.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  pauseOnExceptions: function (aPauseOnExceptions, aIgnoreCaughtExceptions) {
	    var aOnResponse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

	    this._pauseOnExceptions = aPauseOnExceptions;
	    this._ignoreCaughtExceptions = aIgnoreCaughtExceptions;

	    // Otherwise send the flag using a standard resume request.
	    if (!this.paused) {
	      return this.interrupt(aResponse => {
	        if (aResponse.error) {
	          // Can't continue if pausing failed.
	          aOnResponse(aResponse);
	          return aResponse;
	        }
	        return this.resume(aOnResponse);
	      });
	    }

	    aOnResponse();
	    return promise.resolve();
	  },

	  /**
	   * Enable pausing when the specified DOM events are triggered. Disabling
	   * pausing on an event can be realized by calling this method with the updated
	   * array of events that doesn't contain it.
	   *
	   * @param array|string events
	   *        An array of strings, representing the DOM event types to pause on,
	   *        or "*" to pause on all DOM events. Pass an empty array to
	   *        completely disable pausing on DOM events.
	   * @param function onResponse
	   *        Called with the response packet in a future turn of the event loop.
	   */
	  pauseOnDOMEvents: function (events) {
	    var onResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

	    this._pauseOnDOMEvents = events;
	    // If the debuggee is paused, the value of the array will be communicated in
	    // the next resumption. Otherwise we have to force a pause in order to send
	    // the array.
	    if (this.paused) {
	      DevToolsUtils.executeSoon(() => onResponse({}));
	      return {};
	    }
	    return this.interrupt(response => {
	      // Can't continue if pausing failed.
	      if (response.error) {
	        onResponse(response);
	        return response;
	      }
	      return this.resume(onResponse);
	    });
	  },

	  /**
	   * Send a clientEvaluate packet to the debuggee. Response
	   * will be a resume packet.
	   *
	   * @param string aFrame
	   *        The actor ID of the frame where the evaluation should take place.
	   * @param string aExpression
	   *        The expression that will be evaluated in the scope of the frame
	   *        above.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  eval: DebuggerClient.requester({
	    type: "clientEvaluate",
	    frame: args(0),
	    expression: args(1)
	  }, {
	    before: function (aPacket) {
	      this._assertPaused("eval");
	      // Put the client in a tentative "resuming" state so we can prevent
	      // further requests that should only be sent in the paused state.
	      this._state = "resuming";
	      return aPacket;
	    },
	    after: function (aResponse) {
	      if (aResponse.error) {
	        // There was an error resuming, back to paused state.
	        this._state = "paused";
	      }
	      return aResponse;
	    },
	    telemetry: "CLIENTEVALUATE"
	  }),

	  /**
	   * Detach from the thread actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function (aResponse) {
	      this.client.unregisterClient(this);
	      this._parent.thread = null;
	      return aResponse;
	    },
	    telemetry: "THREADDETACH"
	  }),

	  /**
	   * Release multiple thread-lifetime object actors. If any pause-lifetime
	   * actors are included in the request, a |notReleasable| error will return,
	   * but all the thread-lifetime ones will have been released.
	   *
	   * @param array actors
	   *        An array with actor IDs to release.
	   */
	  releaseMany: DebuggerClient.requester({
	    type: "releaseMany",
	    actors: args(0)
	  }, {
	    telemetry: "RELEASEMANY"
	  }),

	  /**
	   * Promote multiple pause-lifetime object actors to thread-lifetime ones.
	   *
	   * @param array actors
	   *        An array with actor IDs to promote.
	   */
	  threadGrips: DebuggerClient.requester({
	    type: "threadGrips",
	    actors: args(0)
	  }, {
	    telemetry: "THREADGRIPS"
	  }),

	  /**
	   * Return the event listeners defined on the page.
	   *
	   * @param aOnResponse Function
	   *        Called with the thread's response.
	   */
	  eventListeners: DebuggerClient.requester({
	    type: "eventListeners"
	  }, {
	    telemetry: "EVENTLISTENERS"
	  }),

	  /**
	   * Request the loaded sources for the current thread.
	   *
	   * @param aOnResponse Function
	   *        Called with the thread's response.
	   */
	  getSources: DebuggerClient.requester({
	    type: "sources"
	  }, {
	    telemetry: "SOURCES"
	  }),

	  /**
	   * Clear the thread's source script cache. A scriptscleared event
	   * will be sent.
	   */
	  _clearScripts: function () {
	    if (Object.keys(this._scriptCache).length > 0) {
	      this._scriptCache = {};
	      this.emit("scriptscleared");
	    }
	  },

	  /**
	   * Request frames from the callstack for the current thread.
	   *
	   * @param aStart integer
	   *        The number of the youngest stack frame to return (the youngest
	   *        frame is 0).
	   * @param aCount integer
	   *        The maximum number of frames to return, or null to return all
	   *        frames.
	   * @param aOnResponse function
	   *        Called with the thread's response.
	   */
	  getFrames: DebuggerClient.requester({
	    type: "frames",
	    start: args(0),
	    count: args(1)
	  }, {
	    telemetry: "FRAMES"
	  }),

	  /**
	   * An array of cached frames. Clients can observe the framesadded and
	   * framescleared event to keep up to date on changes to this cache,
	   * and can fill it using the fillFrames method.
	   */
	  get cachedFrames() {
	    return this._frameCache;
	  },

	  /**
	   * true if there are more stack frames available on the server.
	   */
	  get moreFrames() {
	    return this.paused && (!this._frameCache || this._frameCache.length == 0 || !this._frameCache[this._frameCache.length - 1].oldest);
	  },

	  /**
	   * Ensure that at least aTotal stack frames have been loaded in the
	   * ThreadClient's stack frame cache. A framesadded event will be
	   * sent when the stack frame cache is updated.
	   *
	   * @param aTotal number
	   *        The minimum number of stack frames to be included.
	   * @param aCallback function
	   *        Optional callback function called when frames have been loaded
	   * @returns true if a framesadded notification should be expected.
	   */
	  fillFrames: function (aTotal) {
	    var aCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

	    this._assertPaused("fillFrames");
	    if (this._frameCache.length >= aTotal) {
	      return false;
	    }

	    var numFrames = this._frameCache.length;

	    this.getFrames(numFrames, aTotal - numFrames, aResponse => {
	      if (aResponse.error) {
	        aCallback(aResponse);
	        return;
	      }

	      var threadGrips = DevToolsUtils.values(this._threadGrips);

	      for (var i in aResponse.frames) {
	        var frame = aResponse.frames[i];
	        if (!frame.where.source) {
	          // Older servers use urls instead, so we need to resolve
	          // them to source actors
	          for (var grip of threadGrips) {
	            if (grip instanceof SourceClient && grip.url === frame.url) {
	              frame.where.source = grip._form;
	            }
	          }
	        }

	        this._frameCache[frame.depth] = frame;
	      }

	      // If we got as many frames as we asked for, there might be more
	      // frames available.
	      this.emit("framesadded");

	      aCallback(aResponse);
	    });

	    return true;
	  },

	  /**
	   * Clear the thread's stack frame cache. A framescleared event
	   * will be sent.
	   */
	  _clearFrames: function () {
	    if (this._frameCache.length > 0) {
	      this._frameCache = [];
	      this.emit("framescleared");
	    }
	  },

	  /**
	   * Return a ObjectClient object for the given object grip.
	   *
	   * @param aGrip object
	   *        A pause-lifetime object grip returned by the protocol.
	   */
	  pauseGrip: function (aGrip) {
	    if (aGrip.actor in this._pauseGrips) {
	      return this._pauseGrips[aGrip.actor];
	    }

	    var client = new ObjectClient(this.client, aGrip);
	    this._pauseGrips[aGrip.actor] = client;
	    return client;
	  },

	  /**
	   * Get or create a long string client, checking the grip client cache if it
	   * already exists.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   * @param aGripCacheName String
	   *        The property name of the grip client cache to check for existing
	   *        clients in.
	   */
	  _longString: function (aGrip, aGripCacheName) {
	    if (aGrip.actor in this[aGripCacheName]) {
	      return this[aGripCacheName][aGrip.actor];
	    }

	    var client = new LongStringClient(this.client, aGrip);
	    this[aGripCacheName][aGrip.actor] = client;
	    return client;
	  },

	  /**
	   * Return an instance of LongStringClient for the given long string grip that
	   * is scoped to the current pause.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   */
	  pauseLongString: function (aGrip) {
	    return this._longString(aGrip, "_pauseGrips");
	  },

	  /**
	   * Return an instance of LongStringClient for the given long string grip that
	   * is scoped to the thread lifetime.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   */
	  threadLongString: function (aGrip) {
	    return this._longString(aGrip, "_threadGrips");
	  },

	  /**
	   * Clear and invalidate all the grip clients from the given cache.
	   *
	   * @param aGripCacheName
	   *        The property name of the grip cache we want to clear.
	   */
	  _clearObjectClients: function (aGripCacheName) {
	    for (var id in this[aGripCacheName]) {
	      this[aGripCacheName][id].valid = false;
	    }
	    this[aGripCacheName] = {};
	  },

	  /**
	   * Invalidate pause-lifetime grip clients and clear the list of current grip
	   * clients.
	   */
	  _clearPauseGrips: function () {
	    this._clearObjectClients("_pauseGrips");
	  },

	  /**
	   * Invalidate thread-lifetime grip clients and clear the list of current grip
	   * clients.
	   */
	  _clearThreadGrips: function () {
	    this._clearObjectClients("_threadGrips");
	  },

	  /**
	   * Handle thread state change by doing necessary cleanup and notifying all
	   * registered listeners.
	   */
	  _onThreadState: function (aPacket) {
	    this._state = ThreadStateTypes[aPacket.type];
	    // The debugger UI may not be initialized yet so we want to keep
	    // the packet around so it knows what to pause state to display
	    // when it's initialized
	    this._lastPausePacket = aPacket.type === "resumed" ? null : aPacket;
	    this._clearFrames();
	    this._clearPauseGrips();
	    aPacket.type === ThreadStateTypes.detached && this._clearThreadGrips();
	    this.client._eventsEnabled && this.emit(aPacket.type, aPacket);
	  },

	  getLastPausePacket: function () {
	    return this._lastPausePacket;
	  },

	  /**
	   * Return an EnvironmentClient instance for the given environment actor form.
	   */
	  environment: function (aForm) {
	    return new EnvironmentClient(this.client, aForm);
	  },

	  /**
	   * Return an instance of SourceClient for the given source actor form.
	   */
	  source: function (aForm) {
	    if (aForm.actor in this._threadGrips) {
	      return this._threadGrips[aForm.actor];
	    }

	    return this._threadGrips[aForm.actor] = new SourceClient(this, aForm);
	  },

	  /**
	   * Request the prototype and own properties of mutlipleObjects.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   * @param actors [string]
	   *        List of actor ID of the queried objects.
	   */
	  getPrototypesAndProperties: DebuggerClient.requester({
	    type: "prototypesAndProperties",
	    actors: args(0)
	  }, {
	    telemetry: "PROTOTYPESANDPROPERTIES"
	  }),

	  events: ["newSource"]
	};

	eventSource(ThreadClient.prototype);

	/**
	 * Creates a tracing profiler client for the remote debugging protocol
	 * server. This client is a front to the trace actor created on the
	 * server side, hiding the protocol details in a traditional
	 * JavaScript API.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aActor string
	 *        The actor ID for this thread.
	 */
	function TraceClient(aClient, aActor) {
	  this._client = aClient;
	  this._actor = aActor;
	  this._activeTraces = new Set();
	  this._waitingPackets = new Map();
	  this._expectedPacket = 0;
	  this.request = this._client.request;
	  this.events = [];
	}

	TraceClient.prototype = {
	  get actor() {
	    return this._actor;
	  },
	  get tracing() {
	    return this._activeTraces.size > 0;
	  },

	  get _transport() {
	    return this._client._transport;
	  },

	  /**
	   * Detach from the trace actor.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function (aResponse) {
	      this._client.unregisterClient(this);
	      return aResponse;
	    },
	    telemetry: "TRACERDETACH"
	  }),

	  /**
	   * Start a new trace.
	   *
	   * @param aTrace [string]
	   *        An array of trace types to be recorded by the new trace.
	   *
	   * @param aName string
	   *        The name of the new trace.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   */
	  startTrace: DebuggerClient.requester({
	    type: "startTrace",
	    name: args(1),
	    trace: args(0)
	  }, {
	    after: function (aResponse) {
	      if (aResponse.error) {
	        return aResponse;
	      }

	      if (!this.tracing) {
	        this._waitingPackets.clear();
	        this._expectedPacket = 0;
	      }
	      this._activeTraces.add(aResponse.name);

	      return aResponse;
	    },
	    telemetry: "STARTTRACE"
	  }),

	  /**
	   * End a trace. If a name is provided, stop the named
	   * trace. Otherwise, stop the most recently started trace.
	   *
	   * @param aName string
	   *        The name of the trace to stop.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   */
	  stopTrace: DebuggerClient.requester({
	    type: "stopTrace",
	    name: args(0)
	  }, {
	    after: function (aResponse) {
	      if (aResponse.error) {
	        return aResponse;
	      }

	      this._activeTraces.delete(aResponse.name);

	      return aResponse;
	    },
	    telemetry: "STOPTRACE"
	  })
	};

	/**
	 * Grip clients are used to retrieve information about the relevant object.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip object
	 *        A pause-lifetime object grip returned by the protocol.
	 */
	function ObjectClient(aClient, aGrip) {
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}
	exports.ObjectClient = ObjectClient;

	ObjectClient.prototype = {
	  get actor() {
	    return this._grip.actor;
	  },
	  get _transport() {
	    return this._client._transport;
	  },

	  valid: true,

	  get isFrozen() {
	    return this._grip.frozen;
	  },
	  get isSealed() {
	    return this._grip.sealed;
	  },
	  get isExtensible() {
	    return this._grip.extensible;
	  },

	  getDefinitionSite: DebuggerClient.requester({
	    type: "definitionSite"
	  }, {
	    before: function (aPacket) {
	      if (this._grip.class != "Function") {
	        throw new Error("getDefinitionSite is only valid for function grips.");
	      }
	      return aPacket;
	    }
	  }),

	  /**
	   * Request the names of a function's formal parameters.
	   *
	   * @param aOnResponse function
	   *        Called with an object of the form:
	   *        { parameterNames:[<parameterName>, ...] }
	   *        where each <parameterName> is the name of a parameter.
	   */
	  getParameterNames: DebuggerClient.requester({
	    type: "parameterNames"
	  }, {
	    before: function (aPacket) {
	      if (this._grip.class !== "Function") {
	        throw new Error("getParameterNames is only valid for function grips.");
	      }
	      return aPacket;
	    },
	    telemetry: "PARAMETERNAMES"
	  }),

	  /**
	   * Request the names of the properties defined on the object and not its
	   * prototype.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getOwnPropertyNames: DebuggerClient.requester({
	    type: "ownPropertyNames"
	  }, {
	    telemetry: "OWNPROPERTYNAMES"
	  }),

	  /**
	   * Request the prototype and own properties of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getPrototypeAndProperties: DebuggerClient.requester({
	    type: "prototypeAndProperties"
	  }, {
	    telemetry: "PROTOTYPEANDPROPERTIES"
	  }),

	  /**
	   * Request a PropertyIteratorClient instance to ease listing
	   * properties for this object.
	   *
	   * @param options Object
	   *        A dictionary object with various boolean attributes:
	   *        - ignoreSafeGetters Boolean
	   *          If true, do not iterate over safe getters.
	   *        - ignoreIndexedProperties Boolean
	   *          If true, filters out Array items.
	   *          e.g. properties names between `0` and `object.length`.
	   *        - ignoreNonIndexedProperties Boolean
	   *          If true, filters out items that aren't array items
	   *          e.g. properties names that are not a number between `0`
	   *          and `object.length`.
	   *        - sort Boolean
	   *          If true, the iterator will sort the properties by name
	   *          before dispatching them.
	   * @param aOnResponse function Called with the client instance.
	   */
	  enumProperties: DebuggerClient.requester({
	    type: "enumProperties",
	    options: args(0)
	  }, {
	    after: function (aResponse) {
	      if (aResponse.iterator) {
	        return { iterator: new PropertyIteratorClient(this._client, aResponse.iterator) };
	      }
	      return aResponse;
	    },
	    telemetry: "ENUMPROPERTIES"
	  }),

	  /**
	   * Request a PropertyIteratorClient instance to enumerate entries in a
	   * Map/Set-like object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  enumEntries: DebuggerClient.requester({
	    type: "enumEntries"
	  }, {
	    before: function (packet) {
	      if (!["Map", "WeakMap", "Set", "WeakSet"].includes(this._grip.class)) {
	        throw new Error("enumEntries is only valid for Map/Set-like grips.");
	      }
	      return packet;
	    },
	    after: function (response) {
	      if (response.iterator) {
	        return {
	          iterator: new PropertyIteratorClient(this._client, response.iterator)
	        };
	      }
	      return response;
	    }
	  }),

	  /**
	   * Request the property descriptor of the object's specified property.
	   *
	   * @param aName string The name of the requested property.
	   * @param aOnResponse function Called with the request's response.
	   */
	  getProperty: DebuggerClient.requester({
	    type: "property",
	    name: args(0)
	  }, {
	    telemetry: "PROPERTY"
	  }),

	  /**
	   * Request the prototype of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getPrototype: DebuggerClient.requester({
	    type: "prototype"
	  }, {
	    telemetry: "PROTOTYPE"
	  }),

	  /**
	   * Request the display string of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getDisplayString: DebuggerClient.requester({
	    type: "displayString"
	  }, {
	    telemetry: "DISPLAYSTRING"
	  }),

	  /**
	   * Request the scope of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getScope: DebuggerClient.requester({
	    type: "scope"
	  }, {
	    before: function (aPacket) {
	      if (this._grip.class !== "Function") {
	        throw new Error("scope is only valid for function grips.");
	      }
	      return aPacket;
	    },
	    telemetry: "SCOPE"
	  }),

	  /**
	   * Request the promises directly depending on the current promise.
	   */
	  getDependentPromises: DebuggerClient.requester({
	    type: "dependentPromises"
	  }, {
	    before: function (aPacket) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getDependentPromises is only valid for promise " + "grips.");
	      }
	      return aPacket;
	    }
	  }),

	  /**
	   * Request the stack to the promise's allocation point.
	   */
	  getPromiseAllocationStack: DebuggerClient.requester({
	    type: "allocationStack"
	  }, {
	    before: function (aPacket) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getAllocationStack is only valid for promise grips.");
	      }
	      return aPacket;
	    }
	  }),

	  /**
	   * Request the stack to the promise's fulfillment point.
	   */
	  getPromiseFulfillmentStack: DebuggerClient.requester({
	    type: "fulfillmentStack"
	  }, {
	    before: function (packet) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getPromiseFulfillmentStack is only valid for " + "promise grips.");
	      }
	      return packet;
	    }
	  }),

	  /**
	   * Request the stack to the promise's rejection point.
	   */
	  getPromiseRejectionStack: DebuggerClient.requester({
	    type: "rejectionStack"
	  }, {
	    before: function (packet) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getPromiseRejectionStack is only valid for " + "promise grips.");
	      }
	      return packet;
	    }
	  })
	};

	/**
	 * A PropertyIteratorClient provides a way to access to property names and
	 * values of an object efficiently, slice by slice.
	 * Note that the properties can be sorted in the backend,
	 * this is controled while creating the PropertyIteratorClient
	 * from ObjectClient.enumProperties.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip Object
	 *        A PropertyIteratorActor grip returned by the protocol via
	 *        TabActor.enumProperties request.
	 */
	function PropertyIteratorClient(aClient, aGrip) {
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}

	PropertyIteratorClient.prototype = {
	  get actor() {
	    return this._grip.actor;
	  },

	  /**
	   * Get the total number of properties available in the iterator.
	   */
	  get count() {
	    return this._grip.count;
	  },

	  /**
	   * Get one or more property names that correspond to the positions in the
	   * indexes parameter.
	   *
	   * @param indexes Array
	   *        An array of property indexes.
	   * @param aCallback Function
	   *        The function called when we receive the property names.
	   */
	  names: DebuggerClient.requester({
	    type: "names",
	    indexes: args(0)
	  }, {}),

	  /**
	   * Get a set of following property value(s).
	   *
	   * @param start Number
	   *        The index of the first property to fetch.
	   * @param count Number
	   *        The number of properties to fetch.
	   * @param aCallback Function
	   *        The function called when we receive the property values.
	   */
	  slice: DebuggerClient.requester({
	    type: "slice",
	    start: args(0),
	    count: args(1)
	  }, {}),

	  /**
	   * Get all the property values.
	   *
	   * @param aCallback Function
	   *        The function called when we receive the property values.
	   */
	  all: DebuggerClient.requester({
	    type: "all"
	  }, {})
	};

	/**
	 * A LongStringClient provides a way to access "very long" strings from the
	 * debugger server.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip Object
	 *        A pause-lifetime long string grip returned by the protocol.
	 */
	function LongStringClient(aClient, aGrip) {
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}
	exports.LongStringClient = LongStringClient;

	LongStringClient.prototype = {
	  get actor() {
	    return this._grip.actor;
	  },
	  get length() {
	    return this._grip.length;
	  },
	  get initial() {
	    return this._grip.initial;
	  },
	  get _transport() {
	    return this._client._transport;
	  },

	  valid: true,

	  /**
	   * Get the substring of this LongString from aStart to aEnd.
	   *
	   * @param aStart Number
	   *        The starting index.
	   * @param aEnd Number
	   *        The ending index.
	   * @param aCallback Function
	   *        The function called when we receive the substring.
	   */
	  substring: DebuggerClient.requester({
	    type: "substring",
	    start: args(0),
	    end: args(1)
	  }, {
	    telemetry: "SUBSTRING"
	  })
	};

	/**
	 * A SourceClient provides a way to access the source text of a script.
	 *
	 * @param aClient ThreadClient
	 *        The thread client parent.
	 * @param aForm Object
	 *        The form sent across the remote debugging protocol.
	 */
	function SourceClient(aClient, aForm) {
	  this._form = aForm;
	  this._isBlackBoxed = aForm.isBlackBoxed;
	  this._isPrettyPrinted = aForm.isPrettyPrinted;
	  this._activeThread = aClient;
	  this._client = aClient.client;
	}

	SourceClient.prototype = {
	  get _transport() {
	    return this._client._transport;
	  },
	  get isBlackBoxed() {
	    return this._isBlackBoxed;
	  },
	  get isPrettyPrinted() {
	    return this._isPrettyPrinted;
	  },
	  get actor() {
	    return this._form.actor;
	  },
	  get request() {
	    return this._client.request;
	  },
	  get url() {
	    return this._form.url;
	  },

	  /**
	   * Black box this SourceClient's source.
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  blackBox: DebuggerClient.requester({
	    type: "blackbox"
	  }, {
	    telemetry: "BLACKBOX",
	    after: function (aResponse) {
	      if (!aResponse.error) {
	        this._isBlackBoxed = true;
	        if (this._activeThread) {
	          this._activeThread.emit("blackboxchange", this);
	        }
	      }
	      return aResponse;
	    }
	  }),

	  /**
	   * Un-blackbox this SourceClient's source.
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  unblackBox: DebuggerClient.requester({
	    type: "unblackbox"
	  }, {
	    telemetry: "UNBLACKBOX",
	    after: function (aResponse) {
	      if (!aResponse.error) {
	        this._isBlackBoxed = false;
	        if (this._activeThread) {
	          this._activeThread.emit("blackboxchange", this);
	        }
	      }
	      return aResponse;
	    }
	  }),

	  /**
	   * Get Executable Lines from a source
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  getExecutableLines: function () {
	    var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;

	    var packet = {
	      to: this._form.actor,
	      type: "getExecutableLines"
	    };

	    return this._client.request(packet).then(res => {
	      cb(res.lines);
	      return res.lines;
	    });
	  },

	  /**
	   * Get a long string grip for this SourceClient's source.
	   */
	  source: function () {
	    var aCallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;

	    var packet = {
	      to: this._form.actor,
	      type: "source"
	    };
	    return this._client.request(packet).then(aResponse => {
	      return this._onSourceResponse(aResponse, aCallback);
	    });
	  },

	  /**
	   * Pretty print this source's text.
	   */
	  prettyPrint: function (aIndent) {
	    var aCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

	    var packet = {
	      to: this._form.actor,
	      type: "prettyPrint",
	      indent: aIndent
	    };
	    return this._client.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        this._isPrettyPrinted = true;
	        this._activeThread._clearFrames();
	        this._activeThread.emit("prettyprintchange", this);
	      }
	      return this._onSourceResponse(aResponse, aCallback);
	    });
	  },

	  /**
	   * Stop pretty printing this source's text.
	   */
	  disablePrettyPrint: function () {
	    var aCallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;

	    var packet = {
	      to: this._form.actor,
	      type: "disablePrettyPrint"
	    };
	    return this._client.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        this._isPrettyPrinted = false;
	        this._activeThread._clearFrames();
	        this._activeThread.emit("prettyprintchange", this);
	      }
	      return this._onSourceResponse(aResponse, aCallback);
	    });
	  },

	  _onSourceResponse: function (aResponse, aCallback) {
	    if (aResponse.error) {
	      aCallback(aResponse);
	      return aResponse;
	    }

	    if (typeof aResponse.source === "string") {
	      aCallback(aResponse);
	      return aResponse;
	    }

	    var contentType = aResponse.contentType,
	        source = aResponse.source;

	    var longString = this._activeThread.threadLongString(source);
	    return longString.substring(0, longString.length).then(function (aResponse) {
	      if (aResponse.error) {
	        aCallback(aResponse);
	        return aReponse;
	      }

	      var response = {
	        source: aResponse.substring,
	        contentType: contentType
	      };
	      aCallback(response);
	      return response;
	    });
	  },

	  /**
	   * Request to set a breakpoint in the specified location.
	   *
	   * @param object aLocation
	   *        The location and condition of the breakpoint in
	   *        the form of { line[, column, condition] }.
	   * @param function aOnResponse
	   *        Called with the thread's response.
	   */
	  setBreakpoint: function (_ref) {
	    var line = _ref.line,
	        column = _ref.column,
	        condition = _ref.condition,
	        noSliding = _ref.noSliding;
	    var onResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

	    // A helper function that sets the breakpoint.
	    var doSetBreakpoint = aCallback => {
	      var root = this._client.mainRoot;
	      var location = {
	        line: line,
	        column: column
	      };

	      var packet = {
	        to: this.actor,
	        type: "setBreakpoint",
	        location: location,
	        condition: condition,
	        noSliding: noSliding
	      };

	      // Backwards compatibility: send the breakpoint request to the
	      // thread if the server doesn't support Debugger.Source actors.
	      if (!root.traits.debuggerSourceActors) {
	        packet.to = this._activeThread.actor;
	        packet.location.url = this.url;
	      }

	      return this._client.request(packet).then(response => {
	        // Ignoring errors, since the user may be setting a breakpoint in a
	        // dead script that will reappear on a page reload.
	        var bpClient = void 0;
	        if (response.actor) {
	          bpClient = new BreakpointClient(this._client, this, response.actor, location, root.traits.conditionalBreakpoints ? condition : undefined);
	        }
	        onResponse(response, bpClient);
	        if (aCallback) {
	          aCallback();
	        }
	        return [response, bpClient];
	      });
	    };

	    // If the debuggee is paused, just set the breakpoint.
	    if (this._activeThread.paused) {
	      return doSetBreakpoint();
	    }
	    // Otherwise, force a pause in order to set the breakpoint.
	    return this._activeThread.interrupt().then(aResponse => {
	      if (aResponse.error) {
	        // Can't set the breakpoint if pausing failed.
	        onResponse(aResponse);
	        return aResponse;
	      }

	      var type = aResponse.type,
	          why = aResponse.why;

	      var cleanUp = type == "paused" && why.type == "interrupted" ? () => this._activeThread.resume() : noop;

	      return doSetBreakpoint(cleanUp);
	    });
	  }
	};

	/**
	 * Breakpoint clients are used to remove breakpoints that are no longer used.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aSourceClient SourceClient
	 *        The source where this breakpoint exists
	 * @param aActor string
	 *        The actor ID for this breakpoint.
	 * @param aLocation object
	 *        The location of the breakpoint. This is an object with two properties:
	 *        url and line.
	 * @param aCondition string
	 *        The conditional expression of the breakpoint
	 */
	function BreakpointClient(aClient, aSourceClient, aActor, aLocation, aCondition) {
	  this._client = aClient;
	  this._actor = aActor;
	  this.location = aLocation;
	  this.location.actor = aSourceClient.actor;
	  this.location.url = aSourceClient.url;
	  this.source = aSourceClient;
	  this.request = this._client.request;

	  // The condition property should only exist if it's a truthy value
	  if (aCondition) {
	    this.condition = aCondition;
	  }
	}

	BreakpointClient.prototype = {

	  _actor: null,
	  get actor() {
	    return this._actor;
	  },
	  get _transport() {
	    return this._client._transport;
	  },

	  /**
	   * Remove the breakpoint from the server.
	   */
	  remove: DebuggerClient.requester({
	    type: "delete"
	  }, {
	    telemetry: "DELETE"
	  }),

	  /**
	   * Determines if this breakpoint has a condition
	   */
	  hasCondition: function () {
	    var root = this._client.mainRoot;
	    // XXX bug 990137: We will remove support for client-side handling of
	    // conditional breakpoints
	    if (root.traits.conditionalBreakpoints) {
	      return "condition" in this;
	    } else {
	      return "conditionalExpression" in this;
	    }
	  },

	  /**
	   * Get the condition of this breakpoint. Currently we have to
	   * support locally emulated conditional breakpoints until the
	   * debugger servers are updated (see bug 990137). We used a
	   * different property when moving it server-side to ensure that we
	   * are testing the right code.
	   */
	  getCondition: function () {
	    var root = this._client.mainRoot;
	    if (root.traits.conditionalBreakpoints) {
	      return this.condition;
	    } else {
	      return this.conditionalExpression;
	    }
	  },

	  /**
	   * Set the condition of this breakpoint
	   */
	  setCondition: function (gThreadClient, aCondition, noSliding) {
	    var root = this._client.mainRoot;
	    var deferred = promise.defer();

	    if (root.traits.conditionalBreakpoints) {
	      var info = {
	        line: this.location.line,
	        column: this.location.column,
	        condition: aCondition,
	        noSliding
	      };

	      // Remove the current breakpoint and add a new one with the
	      // condition.
	      this.remove(aResponse => {
	        if (aResponse && aResponse.error) {
	          deferred.reject(aResponse);
	          return;
	        }

	        this.source.setBreakpoint(info, (aResponse, aNewBreakpoint) => {
	          if (aResponse && aResponse.error) {
	            deferred.reject(aResponse);
	          } else {
	            deferred.resolve(aNewBreakpoint);
	          }
	        });
	      });
	    } else {
	      // The property shouldn't even exist if the condition is blank
	      if (aCondition === "") {
	        delete this.conditionalExpression;
	      } else {
	        this.conditionalExpression = aCondition;
	      }
	      deferred.resolve(this);
	    }

	    return deferred.promise;
	  }
	};

	eventSource(BreakpointClient.prototype);

	/**
	 * Environment clients are used to manipulate the lexical environment actors.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aForm Object
	 *        The form sent across the remote debugging protocol.
	 */
	function EnvironmentClient(aClient, aForm) {
	  this._client = aClient;
	  this._form = aForm;
	  this.request = this._client.request;
	}
	exports.EnvironmentClient = EnvironmentClient;

	EnvironmentClient.prototype = {

	  get actor() {
	    return this._form.actor;
	  },
	  get _transport() {
	    return this._client._transport;
	  },

	  /**
	   * Fetches the bindings introduced by this lexical environment.
	   */
	  getBindings: DebuggerClient.requester({
	    type: "bindings"
	  }, {
	    telemetry: "BINDINGS"
	  }),

	  /**
	   * Changes the value of the identifier whose name is name (a string) to that
	   * represented by value (a grip).
	   */
	  assign: DebuggerClient.requester({
	    type: "assign",
	    name: args(0),
	    value: args(1)
	  }, {
	    telemetry: "ASSIGN"
	  })
	};

	eventSource(EnvironmentClient.prototype);

/***/ },
/* 863 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	var UNCAUGHT_ERROR = 'An error event was emitted for which there was no listener.';
	var BAD_LISTENER = 'The event listener must be a function.';

	var _require = __webpack_require__(864),
	    ns = _require.ns;

	var event = ns();

	var EVENT_TYPE_PATTERN = /^on([A-Z]\w+$)/;
	exports.EVENT_TYPE_PATTERN = EVENT_TYPE_PATTERN;

	// Utility function to access given event `target` object's event listeners for
	// the specific event `type`. If listeners for this type does not exists they
	// will be created.
	var observers = function observers(target, type) {
	  if (!target) throw TypeError("Event target must be an object");
	  var listeners = event(target);
	  return type in listeners ? listeners[type] : listeners[type] = [];
	};

	/**
	 * Registers an event `listener` that is called every time events of
	 * specified `type` is emitted on the given event `target`.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function on(target, type, listener) {
	  if (typeof listener !== 'function') throw new Error(BAD_LISTENER);

	  var listeners = observers(target, type);
	  if (!~listeners.indexOf(listener)) listeners.push(listener);
	}
	exports.on = on;

	var onceWeakMap = new WeakMap();

	/**
	 * Registers an event `listener` that is called only the next time an event
	 * of the specified `type` is emitted on the given event `target`.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of the event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function once(target, type, listener) {
	  var replacement = function observer() {
	    off(target, type, observer);
	    onceWeakMap.delete(listener);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    listener.apply(target, args);
	  };
	  onceWeakMap.set(listener, replacement);
	  on(target, type, replacement);
	}
	exports.once = once;

	/**
	 * Execute each of the listeners in order with the supplied arguments.
	 * All the exceptions that are thrown by listeners during the emit
	 * are caught and can be handled by listeners of 'error' event. Thrown
	 * exceptions are passed as an argument to an 'error' event listener.
	 * If no 'error' listener is registered exception will be logged into an
	 * error console.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of event.
	 * @params {Object|Number|String|Boolean} args
	 *    Arguments that will be passed to listeners.
	 */
	function emit(target, type) {
	  for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	    args[_key2 - 2] = arguments[_key2];
	  }

	  emitOnObject.apply(undefined, [target, type, target].concat(args));
	}
	exports.emit = emit;

	/**
	 * A variant of emit that allows setting the this property for event listeners
	 */
	function emitOnObject(target, type, thisArg) {
	  var all = observers(target, '*').length;
	  var state = observers(target, type);
	  var listeners = state.slice();
	  var count = listeners.length;
	  var index = 0;

	  // If error event and there are no handlers (explicit or catch-all)
	  // then print error message to the console.

	  for (var _len3 = arguments.length, args = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
	    args[_key3 - 3] = arguments[_key3];
	  }

	  if (count === 0 && type === 'error' && all === 0) console.exception(args[0]);
	  while (index < count) {
	    try {
	      var listener = listeners[index];
	      // Dispatch only if listener is still registered.
	      if (~state.indexOf(listener)) listener.apply(thisArg, args);
	    } catch (error) {
	      // If exception is not thrown by a error listener and error listener is
	      // registered emit `error` event. Otherwise dump exception to the console.
	      if (type !== 'error') emit(target, 'error', error);else console.exception(error);
	    }
	    index++;
	  }
	  // Also emit on `"*"` so that one could listen for all events.
	  if (type !== '*') emit.apply(undefined, [target, '*', type].concat(args));
	}
	exports.emitOnObject = emitOnObject;

	/**
	 * Removes an event `listener` for the given event `type` on the given event
	 * `target`. If no `listener` is passed removes all listeners of the given
	 * `type`. If `type` is not passed removes all the listeners of the given
	 * event `target`.
	 * @param {Object} target
	 *    The event target object.
	 * @param {String} type
	 *    The type of event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function off(target, type, listener) {
	  var length = arguments.length;
	  if (length === 3) {
	    if (onceWeakMap.has(listener)) {
	      listener = onceWeakMap.get(listener);
	      onceWeakMap.delete(listener);
	    }

	    var listeners = observers(target, type);
	    var index = listeners.indexOf(listener);
	    if (~index) listeners.splice(index, 1);
	  } else if (length === 2) {
	    observers(target, type).splice(0);
	  } else if (length === 1) {
	    var _listeners = event(target);
	    Object.keys(_listeners).forEach(type => delete _listeners[type]);
	  }
	}
	exports.off = off;

	/**
	 * Returns a number of event listeners registered for the given event `type`
	 * on the given event `target`.
	 */
	function count(target, type) {
	  return observers(target, type).length;
	}
	exports.count = count;

	/**
	 * Registers listeners on the given event `target` from the given `listeners`
	 * dictionary. Iterates over the listeners and if property name matches name
	 * pattern `onEventType` and property is a function, then registers it as
	 * an `eventType` listener on `target`.
	 *
	 * @param {Object} target
	 *    The type of event.
	 * @param {Object} listeners
	 *    Dictionary of listeners.
	 */
	function setListeners(target, listeners) {
	  Object.keys(listeners || {}).forEach(key => {
	    var match = EVENT_TYPE_PATTERN.exec(key);
	    var type = match && match[1].toLowerCase();
	    if (!type) return;

	    var listener = listeners[key];
	    if (typeof listener === 'function') on(target, type, listener);
	  });
	}
	exports.setListeners = setListeners;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module)))

/***/ },
/* 864 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	var create = Object.create;
	var prototypeOf = Object.getPrototypeOf;

	/**
	 * Returns a new namespace, function that may can be used to access an
	 * namespaced object of the argument argument. Namespaced object are associated
	 * with owner objects via weak references. Namespaced objects inherit from the
	 * owners ancestor namespaced object. If owner's ancestor is `null` then
	 * namespaced object inherits from given `prototype`. Namespaces can be used
	 * to define internal APIs that can be shared via enclosing `namespace`
	 * function.
	 * @examples
	 *    const internals = ns();
	 *    internals(object).secret = secret;
	 */
	function ns() {
	  var map = new WeakMap();
	  return function namespace(target) {
	    if (!target) // If `target` is not an object return `target` itself.
	      return target;
	    // If target has no namespaced object yet, create one that inherits from
	    // the target prototype's namespaced object.
	    if (!map.has(target)) map.set(target, create(namespace(prototypeOf(target) || null)));

	    return map.get(target);
	  };
	};

	// `Namespace` is a e4x function in the scope, so we export the function also as
	// `ns` as alias to avoid clashing.
	exports.ns = ns;
	exports.Namespace = ns;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module)))

/***/ },
/* 865 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- js-indent-level: 2; indent-tabs-mode: nil -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(834),
	    Cc = _require.Cc,
	    Ci = _require.Ci,
	    Cu = _require.Cu;

	var DevToolsUtils = __webpack_require__(833);
	var EventEmitter = __webpack_require__(844);
	var promise = __webpack_require__(839);

	/**
	 * A WebConsoleClient is used as a front end for the WebConsoleActor that is
	 * created on the server, hiding implementation details.
	 *
	 * @param object aDebuggerClient
	 *        The DebuggerClient instance we live for.
	 * @param object aResponse
	 *        The response packet received from the "startListeners" request sent to
	 *        the WebConsoleActor.
	 * @param object LongStringClient
	 *        LongStringClient constructor to get full string from server
	 */
	function WebConsoleClient(aDebuggerClient, aResponse, LongStringClient) {
	  this._actor = aResponse.from;
	  this._client = aDebuggerClient;
	  this.LongStringClient = LongStringClient;
	  this._longStrings = {};
	  this.traits = aResponse.traits || {};
	  this.events = [];
	  this._networkRequests = new Map();

	  this.pendingEvaluationResults = new Map();
	  this.onEvaluationResult = this.onEvaluationResult.bind(this);
	  this.onNetworkEvent = this._onNetworkEvent.bind(this);
	  this.onNetworkEventUpdate = this._onNetworkEventUpdate.bind(this);

	  this._client.addListener("evaluationResult", this.onEvaluationResult);
	  this._client.addListener("networkEvent", this.onNetworkEvent);
	  this._client.addListener("networkEventUpdate", this.onNetworkEventUpdate);
	  EventEmitter.decorate(this);
	}

	exports.WebConsoleClient = WebConsoleClient;

	WebConsoleClient.prototype = {
	  _longStrings: null,
	  traits: null,

	  /**
	   * Holds the network requests currently displayed by the Web Console. Each key
	   * represents the connection ID and the value is network request information.
	   * @private
	   * @type object
	   */
	  _networkRequests: null,

	  getNetworkRequest(actorId) {
	    return this._networkRequests.get(actorId);
	  },

	  hasNetworkRequest(actorId) {
	    return this._networkRequests.has(actorId);
	  },

	  removeNetworkRequest(actorId) {
	    this._networkRequests.delete(actorId);
	  },

	  getNetworkEvents() {
	    return this._networkRequests.values();
	  },

	  get actor() {
	    return this._actor;
	  },

	  /**
	   * The "networkEvent" message type handler. We redirect any message to
	   * the UI for displaying.
	   *
	   * @private
	   * @param string type
	   *        Message type.
	   * @param object packet
	   *        The message received from the server.
	   */
	  _onNetworkEvent: function (type, packet) {
	    if (packet.from == this._actor) {
	      var actor = packet.eventActor;
	      var networkInfo = {
	        _type: "NetworkEvent",
	        timeStamp: actor.timeStamp,
	        node: null,
	        actor: actor.actor,
	        discardRequestBody: true,
	        discardResponseBody: true,
	        startedDateTime: actor.startedDateTime,
	        request: {
	          url: actor.url,
	          method: actor.method
	        },
	        isXHR: actor.isXHR,
	        response: {},
	        timings: {},
	        updates: [], // track the list of network event updates
	        private: actor.private,
	        fromCache: actor.fromCache
	      };
	      this._networkRequests.set(actor.actor, networkInfo);

	      this.emit("networkEvent", networkInfo);
	    }
	  },

	  /**
	   * The "networkEventUpdate" message type handler. We redirect any message to
	   * the UI for displaying.
	   *
	   * @private
	   * @param string type
	   *        Message type.
	   * @param object packet
	   *        The message received from the server.
	   */
	  _onNetworkEventUpdate: function (type, packet) {
	    var networkInfo = this.getNetworkRequest(packet.from);
	    if (!networkInfo) {
	      return;
	    }

	    networkInfo.updates.push(packet.updateType);

	    switch (packet.updateType) {
	      case "requestHeaders":
	        networkInfo.request.headersSize = packet.headersSize;
	        break;
	      case "requestPostData":
	        networkInfo.discardRequestBody = packet.discardRequestBody;
	        networkInfo.request.bodySize = packet.dataSize;
	        break;
	      case "responseStart":
	        networkInfo.response.httpVersion = packet.response.httpVersion;
	        networkInfo.response.status = packet.response.status;
	        networkInfo.response.statusText = packet.response.statusText;
	        networkInfo.response.headersSize = packet.response.headersSize;
	        networkInfo.response.remoteAddress = packet.response.remoteAddress;
	        networkInfo.response.remotePort = packet.response.remotePort;
	        networkInfo.discardResponseBody = packet.response.discardResponseBody;
	        break;
	      case "responseContent":
	        networkInfo.response.content = {
	          mimeType: packet.mimeType
	        };
	        networkInfo.response.bodySize = packet.contentSize;
	        networkInfo.response.transferredSize = packet.transferredSize;
	        networkInfo.discardResponseBody = packet.discardResponseBody;
	        break;
	      case "eventTimings":
	        networkInfo.totalTime = packet.totalTime;
	        break;
	      case "securityInfo":
	        networkInfo.securityInfo = packet.state;
	        break;
	    }

	    this.emit("networkEventUpdate", {
	      packet: packet,
	      networkInfo
	    });
	  },

	  /**
	   * Retrieve the cached messages from the server.
	   *
	   * @see this.CACHED_MESSAGES
	   * @param array types
	   *        The array of message types you want from the server. See
	   *        this.CACHED_MESSAGES for known types.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getCachedMessages: function WCC_getCachedMessages(types, aOnResponse) {
	    var packet = {
	      to: this._actor,
	      type: "getCachedMessages",
	      messageTypes: types
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Inspect the properties of an object.
	   *
	   * @param string aActor
	   *        The WebConsoleObjectActor ID to send the request to.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  inspectObjectProperties: function WCC_inspectObjectProperties(aActor, aOnResponse) {
	    var packet = {
	      to: aActor,
	      type: "inspectProperties"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Evaluate a JavaScript expression.
	   *
	   * @param string aString
	   *        The code you want to evaluate.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   * @param object [aOptions={}]
	   *        Options for evaluation:
	   *
	   *        - bindObjectActor: an ObjectActor ID. The OA holds a reference to
	   *        a Debugger.Object that wraps a content object. This option allows
	   *        you to bind |_self| to the D.O of the given OA, during string
	   *        evaluation.
	   *
	   *        See: Debugger.Object.executeInGlobalWithBindings() for information
	   *        about bindings.
	   *
	   *        Use case: the variable view needs to update objects and it does so
	   *        by knowing the ObjectActor it inspects and binding |_self| to the
	   *        D.O of the OA. As such, variable view sends strings like these for
	   *        eval:
	   *          _self["prop"] = value;
	   *
	   *        - frameActor: a FrameActor ID. The FA holds a reference to
	   *        a Debugger.Frame. This option allows you to evaluate the string in
	   *        the frame of the given FA.
	   *
	   *        - url: the url to evaluate the script as. Defaults to
	   *        "debugger eval code".
	   *
	   *        - selectedNodeActor: the NodeActor ID of the current selection in the
	   *        Inspector, if such a selection exists. This is used by helper functions
	   *        that can reference the currently selected node in the Inspector, like
	   *        $0.
	   */
	  evaluateJS: function WCC_evaluateJS(aString, aOnResponse) {
	    var aOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    var packet = {
	      to: this._actor,
	      type: "evaluateJS",
	      text: aString,
	      bindObjectActor: aOptions.bindObjectActor,
	      frameActor: aOptions.frameActor,
	      url: aOptions.url,
	      selectedNodeActor: aOptions.selectedNodeActor,
	      selectedObjectActor: aOptions.selectedObjectActor
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Evaluate a JavaScript expression asynchronously.
	   * See evaluateJS for parameter and response information.
	   */
	  evaluateJSAsync: function (aString, aOnResponse) {
	    var aOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    // Pre-37 servers don't support async evaluation.
	    if (!this.traits.evaluateJSAsync) {
	      this.evaluateJS(aString, aOnResponse, aOptions);
	      return;
	    }

	    var packet = {
	      to: this._actor,
	      type: "evaluateJSAsync",
	      text: aString,
	      bindObjectActor: aOptions.bindObjectActor,
	      frameActor: aOptions.frameActor,
	      url: aOptions.url,
	      selectedNodeActor: aOptions.selectedNodeActor,
	      selectedObjectActor: aOptions.selectedObjectActor
	    };

	    this._client.request(packet, response => {
	      // Null check this in case the client has been detached while waiting
	      // for a response.
	      if (this.pendingEvaluationResults) {
	        this.pendingEvaluationResults.set(response.resultID, aOnResponse);
	      }
	    });
	  },

	  /**
	   * Handler for the actors's unsolicited evaluationResult packet.
	   */
	  onEvaluationResult: function (aNotification, aPacket) {
	    // The client on the main thread can receive notification packets from
	    // multiple webconsole actors: the one on the main thread and the ones
	    // on worker threads.  So make sure we should be handling this request.
	    if (aPacket.from !== this._actor) {
	      return;
	    }

	    // Find the associated callback based on this ID, and fire it.
	    // In a sync evaluation, this would have already been called in
	    // direct response to the client.request function.
	    var onResponse = this.pendingEvaluationResults.get(aPacket.resultID);
	    if (onResponse) {
	      onResponse(aPacket);
	      this.pendingEvaluationResults.delete(aPacket.resultID);
	    } else {
	      DevToolsUtils.reportException("onEvaluationResult", "No response handler for an evaluateJSAsync result (resultID: " + aPacket.resultID + ")");
	    }
	  },

	  /**
	   * Autocomplete a JavaScript expression.
	   *
	   * @param string aString
	   *        The code you want to autocomplete.
	   * @param number aCursor
	   *        Cursor location inside the string. Index starts from 0.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   * @param string aFrameActor
	   *        The id of the frame actor that made the call.
	   */
	  autocomplete: function WCC_autocomplete(aString, aCursor, aOnResponse, aFrameActor) {
	    var packet = {
	      to: this._actor,
	      type: "autocomplete",
	      text: aString,
	      cursor: aCursor,
	      frameActor: aFrameActor
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Clear the cache of messages (page errors and console API calls).
	   */
	  clearMessagesCache: function WCC_clearMessagesCache() {
	    var packet = {
	      to: this._actor,
	      type: "clearMessagesCache"
	    };
	    this._client.request(packet);
	  },

	  /**
	   * Get Web Console-related preferences on the server.
	   *
	   * @param array aPreferences
	   *        An array with the preferences you want to retrieve.
	   * @param function [aOnResponse]
	   *        Optional function to invoke when the response is received.
	   */
	  getPreferences: function WCC_getPreferences(aPreferences, aOnResponse) {
	    var packet = {
	      to: this._actor,
	      type: "getPreferences",
	      preferences: aPreferences
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Set Web Console-related preferences on the server.
	   *
	   * @param object aPreferences
	   *        An object with the preferences you want to change.
	   * @param function [aOnResponse]
	   *        Optional function to invoke when the response is received.
	   */
	  setPreferences: function WCC_setPreferences(aPreferences, aOnResponse) {
	    var packet = {
	      to: this._actor,
	      type: "setPreferences",
	      preferences: aPreferences
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the request headers from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getRequestHeaders: function WCC_getRequestHeaders(aActor, aOnResponse) {
	    var packet = {
	      to: aActor,
	      type: "getRequestHeaders"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the request cookies from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getRequestCookies: function WCC_getRequestCookies(aActor, aOnResponse) {
	    var packet = {
	      to: aActor,
	      type: "getRequestCookies"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the request post data from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getRequestPostData: function WCC_getRequestPostData(aActor, aOnResponse) {
	    var packet = {
	      to: aActor,
	      type: "getRequestPostData"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the response headers from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getResponseHeaders: function WCC_getResponseHeaders(aActor, aOnResponse) {
	    var packet = {
	      to: aActor,
	      type: "getResponseHeaders"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the response cookies from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getResponseCookies: function WCC_getResponseCookies(aActor, aOnResponse) {
	    var packet = {
	      to: aActor,
	      type: "getResponseCookies"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the response content from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getResponseContent: function WCC_getResponseContent(aActor, aOnResponse) {
	    var packet = {
	      to: aActor,
	      type: "getResponseContent"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the timing information for the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getEventTimings: function WCC_getEventTimings(aActor, aOnResponse) {
	    var packet = {
	      to: aActor,
	      type: "getEventTimings"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Retrieve the security information for the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getSecurityInfo: function WCC_getSecurityInfo(aActor, aOnResponse) {
	    var packet = {
	      to: aActor,
	      type: "getSecurityInfo"
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Send a HTTP request with the given data.
	   *
	   * @param string aData
	   *        The details of the HTTP request.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  sendHTTPRequest: function WCC_sendHTTPRequest(aData, aOnResponse) {
	    var packet = {
	      to: this._actor,
	      type: "sendHTTPRequest",
	      request: aData
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Start the given Web Console listeners.
	   *
	   * @see this.LISTENERS
	   * @param array aListeners
	   *        Array of listeners you want to start. See this.LISTENERS for
	   *        known listeners.
	   * @param function aOnResponse
	   *        Function to invoke when the server response is received.
	   */
	  startListeners: function WCC_startListeners(aListeners, aOnResponse) {
	    var packet = {
	      to: this._actor,
	      type: "startListeners",
	      listeners: aListeners
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Stop the given Web Console listeners.
	   *
	   * @see this.LISTENERS
	   * @param array aListeners
	   *        Array of listeners you want to stop. See this.LISTENERS for
	   *        known listeners.
	   * @param function aOnResponse
	   *        Function to invoke when the server response is received.
	   */
	  stopListeners: function WCC_stopListeners(aListeners, aOnResponse) {
	    var packet = {
	      to: this._actor,
	      type: "stopListeners",
	      listeners: aListeners
	    };
	    this._client.request(packet, aOnResponse);
	  },

	  /**
	   * Return an instance of LongStringClient for the given long string grip.
	   *
	   * @param object aGrip
	   *        The long string grip returned by the protocol.
	   * @return object
	   *         The LongStringClient for the given long string grip.
	   */
	  longString: function WCC_longString(aGrip) {
	    if (aGrip.actor in this._longStrings) {
	      return this._longStrings[aGrip.actor];
	    }

	    var LongStringClient = this.LongStringClient.bind(this);
	    var client = new LongStringClient(this._client, aGrip);
	    this._longStrings[aGrip.actor] = client;
	    return client;
	  },

	  /**
	   * Close the WebConsoleClient. This stops all the listeners on the server and
	   * detaches from the console actor.
	   *
	   * @param function aOnResponse
	   *        Function to invoke when the server response is received.
	   */
	  detach: function WCC_detach(aOnResponse) {
	    this._client.removeListener("evaluationResult", this.onEvaluationResult);
	    this._client.removeListener("networkEvent", this.onNetworkEvent);
	    this._client.removeListener("networkEventUpdate", this.onNetworkEventUpdate);
	    this.stopListeners(null, aOnResponse);
	    this._longStrings = null;
	    this._client = null;
	    this.pendingEvaluationResults.clear();
	    this.pendingEvaluationResults = null;
	    this.clearNetworkRequests();
	    this._networkRequests = null;
	  },

	  clearNetworkRequests: function () {
	    this._networkRequests.clear();
	  },

	  /**
	   * Fetches the full text of a LongString.
	   *
	   * @param object | string stringGrip
	   *        The long string grip containing the corresponding actor.
	   *        If you pass in a plain string (by accident or because you're lazy),
	   *        then a promise of the same string is simply returned.
	   * @return object Promise
	   *         A promise that is resolved when the full string contents
	   *         are available, or rejected if something goes wrong.
	   */
	  getString: function (stringGrip) {
	    // Make sure this is a long string.
	    if (typeof stringGrip != "object" || stringGrip.type != "longString") {
	      return promise.resolve(stringGrip); // Go home string, you're drunk.
	    }

	    // Fetch the long string only once.
	    if (stringGrip._fullText) {
	      return stringGrip._fullText.promise;
	    }

	    var deferred = stringGrip._fullText = promise.defer();
	    var actor = stringGrip.actor,
	        initial = stringGrip.initial,
	        length = stringGrip.length;

	    var longStringClient = this.longString(stringGrip);

	    longStringClient.substring(initial.length, length, aResponse => {
	      if (aResponse.error) {
	        DevToolsUtils.reportException("getString", aResponse.error + ": " + aResponse.message);

	        deferred.reject(aResponse);
	        return;
	      }
	      deferred.resolve(initial + aResponse.substring);
	    });

	    return deferred.promise;
	  }
	};

/***/ },
/* 866 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env browser */
	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// TODO: Get rid of this code once the marionette server loads transport.js as
	// an SDK module (see bug 1000814)

	"use strict";

	var DevToolsUtils = __webpack_require__(833);
	var dumpn = DevToolsUtils.dumpn,
	    dumpv = DevToolsUtils.dumpv;

	var StreamUtils = __webpack_require__(867);

	var _require = __webpack_require__(868),
	    Packet = _require.Packet,
	    JSONPacket = _require.JSONPacket,
	    BulkPacket = _require.BulkPacket;

	var promise = __webpack_require__(839);
	var EventEmitter = __webpack_require__(844);
	var utf8 = __webpack_require__(870);

	var PACKET_HEADER_MAX = 200;

	/**
	 * An adapter that handles data transfers between the debugger client and
	 * server. It can work with both nsIPipe and nsIServerSocket transports so
	 * long as the properly created input and output streams are specified.
	 * (However, for intra-process connections, LocalDebuggerTransport, below,
	 * is more efficient than using an nsIPipe pair with DebuggerTransport.)
	 *
	 * @param input nsIAsyncInputStream
	 *        The input stream.
	 * @param output nsIAsyncOutputStream
	 *        The output stream.
	 *
	 * Given a DebuggerTransport instance dt:
	 * 1) Set dt.hooks to a packet handler object (described below).
	 * 2) Call dt.ready() to begin watching for input packets.
	 * 3) Call dt.send() / dt.startBulkSend() to send packets.
	 * 4) Call dt.close() to close the connection, and disengage from the event
	 *    loop.
	 *
	 * A packet handler is an object with the following methods:
	 *
	 * - onPacket(packet) - called when we have received a complete packet.
	 *   |packet| is the parsed form of the packet --- a JavaScript value, not
	 *   a JSON-syntax string.
	 *
	 * - onBulkPacket(packet) - called when we have switched to bulk packet
	 *   receiving mode. |packet| is an object containing:
	 *   * actor:  Name of actor that will receive the packet
	 *   * type:   Name of actor's method that should be called on receipt
	 *   * length: Size of the data to be read
	 *   * stream: This input stream should only be used directly if you can ensure
	 *             that you will read exactly |length| bytes and will not close the
	 *             stream when reading is complete
	 *   * done:   If you use the stream directly (instead of |copyTo| below), you
	 *             must signal completion by resolving / rejecting this deferred.
	 *             If it's rejected, the transport will be closed.  If an Error is
	 *             supplied as a rejection value, it will be logged via |dumpn|.
	 *             If you do use |copyTo|, resolving is taken care of for you when
	 *             copying completes.
	 *   * copyTo: A helper function for getting your data out of the stream that
	 *             meets the stream handling requirements above, and has the
	 *             following signature:
	 *     @param  output nsIAsyncOutputStream
	 *             The stream to copy to.
	 *     @return Promise
	 *             The promise is resolved when copying completes or rejected if any
	 *             (unexpected) errors occur.
	 *             This object also emits "progress" events for each chunk that is
	 *             copied.  See stream-utils.js.
	 *
	 * - onClosed(reason) - called when the connection is closed. |reason| is
	 *   an optional nsresult or object, typically passed when the transport is
	 *   closed due to some error in a underlying stream.
	 *
	 * See ./packets.js and the Remote Debugging Protocol specification for more
	 * details on the format of these packets.
	 */
	function DebuggerTransport(socket) {
	  EventEmitter.decorate(this);

	  this._socket = socket;

	  // The current incoming (possibly partial) header, which will determine which
	  // type of Packet |_incoming| below will become.
	  this._incomingHeader = "";
	  // The current incoming Packet object
	  this._incoming = null;
	  // A queue of outgoing Packet objects
	  this._outgoing = [];

	  this.hooks = null;
	  this.active = false;

	  this._incomingEnabled = true;
	  this._outgoingEnabled = true;

	  this.close = this.close.bind(this);
	}

	DebuggerTransport.prototype = {
	  /**
	   * Transmit an object as a JSON packet.
	   *
	   * This method returns immediately, without waiting for the entire
	   * packet to be transmitted, registering event handlers as needed to
	   * transmit the entire packet. Packets are transmitted in the order
	   * they are passed to this method.
	   */
	  send: function (object) {
	    this.emit("send", object);

	    var packet = new JSONPacket(this);
	    packet.object = object;
	    this._outgoing.push(packet);
	    this._flushOutgoing();
	  },

	  /**
	   * Transmit streaming data via a bulk packet.
	   *
	   * This method initiates the bulk send process by queuing up the header data.
	   * The caller receives eventual access to a stream for writing.
	   *
	   * N.B.: Do *not* attempt to close the stream handed to you, as it will
	   * continue to be used by this transport afterwards.  Most users should
	   * instead use the provided |copyFrom| function instead.
	   *
	   * @param header Object
	   *        This is modeled after the format of JSON packets above, but does not
	   *        actually contain the data, but is instead just a routing header:
	   *          * actor:  Name of actor that will receive the packet
	   *          * type:   Name of actor's method that should be called on receipt
	   *          * length: Size of the data to be sent
	   * @return Promise
	   *         The promise will be resolved when you are allowed to write to the
	   *         stream with an object containing:
	   *           * stream:   This output stream should only be used directly if
	   *                       you can ensure that you will write exactly |length|
	   *                       bytes and will not close the stream when writing is
	   *                       complete
	   *           * done:     If you use the stream directly (instead of |copyFrom|
	   *                       below), you must signal completion by resolving /
	   *                       rejecting this deferred.  If it's rejected, the
	   *                       transport will be closed.  If an Error is supplied as
	   *                       a rejection value, it will be logged via |dumpn|.  If
	   *                       you do use |copyFrom|, resolving is taken care of for
	   *                       you when copying completes.
	   *           * copyFrom: A helper function for getting your data onto the
	   *                       stream that meets the stream handling requirements
	   *                       above, and has the following signature:
	   *             @param  input nsIAsyncInputStream
	   *                     The stream to copy from.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  startBulkSend: function (header) {
	    this.emit("startBulkSend", header);

	    var packet = new BulkPacket(this);
	    packet.header = header;
	    this._outgoing.push(packet);
	    this._flushOutgoing();
	    return packet.streamReadyForWriting;
	  },

	  /**
	   * Close the transport.
	   * @param reason nsresult / object (optional)
	   *        The status code or error message that corresponds to the reason for
	   *        closing the transport (likely because a stream closed or failed).
	   */
	  close: function (reason) {
	    this.emit("onClosed", reason);

	    this.active = false;
	    this._socket.close();
	    this._destroyIncoming();
	    this._destroyAllOutgoing();
	    if (this.hooks) {
	      this.hooks.onClosed(reason);
	      this.hooks = null;
	    }
	    if (reason) {
	      dumpn("Transport closed: " + DevToolsUtils.safeErrorString(reason));
	    } else {
	      dumpn("Transport closed.");
	    }
	  },

	  /**
	   * The currently outgoing packet (at the top of the queue).
	   */
	  get _currentOutgoing() {
	    return this._outgoing[0];
	  },

	  /**
	   * Flush data to the outgoing stream.  Waits until the output stream notifies
	   * us that it is ready to be written to (via onOutputStreamReady).
	   */
	  _flushOutgoing: function () {
	    if (!this._outgoingEnabled || this._outgoing.length === 0) {
	      return;
	    }

	    // If the top of the packet queue has nothing more to send, remove it.
	    if (this._currentOutgoing.done) {
	      this._finishCurrentOutgoing();
	    }

	    if (this._outgoing.length > 0) {
	      setTimeout(this.onOutputStreamReady.bind(this), 0);
	    }
	  },

	  /**
	   * Pause this transport's attempts to write to the output stream.  This is
	   * used when we've temporarily handed off our output stream for writing bulk
	   * data.
	   */
	  pauseOutgoing: function () {
	    this._outgoingEnabled = false;
	  },

	  /**
	   * Resume this transport's attempts to write to the output stream.
	   */
	  resumeOutgoing: function () {
	    this._outgoingEnabled = true;
	    this._flushOutgoing();
	  },

	  // nsIOutputStreamCallback
	  /**
	   * This is called when the output stream is ready for more data to be written.
	   * The current outgoing packet will attempt to write some amount of data, but
	   * may not complete.
	   */
	  onOutputStreamReady: DevToolsUtils.makeInfallible(function () {
	    if (!this._outgoingEnabled || this._outgoing.length === 0) {
	      return;
	    }

	    try {
	      this._currentOutgoing.write({
	        write: data => {
	          var count = data.length;
	          this._socket.send(data);
	          return count;
	        }
	      });
	    } catch (e) {
	      if (e.result != Cr.NS_BASE_STREAM_WOULD_BLOCK) {
	        this.close(e.result);
	        return;
	      } else {
	        throw e;
	      }
	    }

	    this._flushOutgoing();
	  }, "DebuggerTransport.prototype.onOutputStreamReady"),

	  /**
	   * Remove the current outgoing packet from the queue upon completion.
	   */
	  _finishCurrentOutgoing: function () {
	    if (this._currentOutgoing) {
	      this._currentOutgoing.destroy();
	      this._outgoing.shift();
	    }
	  },

	  /**
	   * Clear the entire outgoing queue.
	   */
	  _destroyAllOutgoing: function () {
	    for (var packet of this._outgoing) {
	      packet.destroy();
	    }
	    this._outgoing = [];
	  },

	  /**
	   * Initialize the input stream for reading. Once this method has been called,
	   * we watch for packets on the input stream, and pass them to the appropriate
	   * handlers via this.hooks.
	   */
	  ready: function () {
	    this.active = true;
	    this._waitForIncoming();
	  },

	  /**
	   * Asks the input stream to notify us (via onInputStreamReady) when it is
	   * ready for reading.
	   */
	  _waitForIncoming: function () {
	    if (this._incomingEnabled && !this._socket.onmessage) {
	      this._socket.onmessage = this.onInputStreamReady.bind(this);
	    }
	  },

	  /**
	   * Pause this transport's attempts to read from the input stream.  This is
	   * used when we've temporarily handed off our input stream for reading bulk
	   * data.
	   */
	  pauseIncoming: function () {
	    this._incomingEnabled = false;
	  },

	  /**
	   * Resume this transport's attempts to read from the input stream.
	   */
	  resumeIncoming: function () {
	    this._incomingEnabled = true;
	    this._flushIncoming();
	    this._waitForIncoming();
	  },

	  // nsIInputStreamCallback
	  /**
	   * Called when the stream is either readable or closed.
	   */
	  onInputStreamReady: DevToolsUtils.makeInfallible(function (event) {
	    var data = event.data;
	    // TODO: ws-tcp-proxy decodes utf-8, but the transport expects to see the
	    // encoded bytes.  Simplest step is to re-encode for now.
	    data = utf8.encode(data);
	    var stream = {
	      available() {
	        return data.length;
	      },
	      readBytes(count) {
	        var result = data.slice(0, count);
	        data = data.slice(count);
	        return result;
	      }
	    };

	    try {
	      while (data && this._incomingEnabled && this._processIncoming(stream, stream.available())) {}
	      this._waitForIncoming();
	    } catch (e) {
	      if (e.result != Cr.NS_BASE_STREAM_WOULD_BLOCK) {
	        this.close(e.result);
	      } else {
	        throw e;
	      }
	    }
	  }, "DebuggerTransport.prototype.onInputStreamReady"),

	  /**
	   * Process the incoming data.  Will create a new currently incoming Packet if
	   * needed.  Tells the incoming Packet to read as much data as it can, but
	   * reading may not complete.  The Packet signals that its data is ready for
	   * delivery by calling one of this transport's _on*Ready methods (see
	   * ./packets.js and the _on*Ready methods below).
	   * @return boolean
	   *         Whether incoming stream processing should continue for any
	   *         remaining data.
	   */
	  _processIncoming: function (stream, count) {
	    dumpv("Data available: " + count);

	    if (!count) {
	      dumpv("Nothing to read, skipping");
	      return false;
	    }

	    try {
	      if (!this._incoming) {
	        dumpv("Creating a new packet from incoming");

	        if (!this._readHeader(stream)) {
	          return false; // Not enough data to read packet type
	        }

	        // Attempt to create a new Packet by trying to parse each possible
	        // header pattern.
	        this._incoming = Packet.fromHeader(this._incomingHeader, this);
	        if (!this._incoming) {
	          throw new Error("No packet types for header: " + this._incomingHeader);
	        }
	      }

	      if (!this._incoming.done) {
	        // We have an incomplete packet, keep reading it.
	        dumpv("Existing packet incomplete, keep reading");
	        this._incoming.read(stream);
	      }
	    } catch (e) {
	      var msg = "Error reading incoming packet: (" + e + " - " + e.stack + ")";
	      dumpn(msg);

	      // Now in an invalid state, shut down the transport.
	      this.close();
	      return false;
	    }

	    if (!this._incoming.done) {
	      // Still not complete, we'll wait for more data.
	      dumpv("Packet not done, wait for more");
	      return true;
	    }

	    // Ready for next packet
	    this._flushIncoming();
	    return true;
	  },

	  /**
	   * Read as far as we can into the incoming data, attempting to build up a
	   * complete packet header (which terminates with ":").  We'll only read up to
	   * PACKET_HEADER_MAX characters.
	   * @return boolean
	   *         True if we now have a complete header.
	   */
	  _readHeader: function (stream) {
	    var amountToRead = PACKET_HEADER_MAX - this._incomingHeader.length;
	    this._incomingHeader += StreamUtils.delimitedRead(stream, ":", amountToRead);
	    if (dumpv.wantVerbose) {
	      dumpv("Header read: " + this._incomingHeader);
	    }

	    if (this._incomingHeader.endsWith(":")) {
	      if (dumpv.wantVerbose) {
	        dumpv("Found packet header successfully: " + this._incomingHeader);
	      }
	      return true;
	    }

	    if (this._incomingHeader.length >= PACKET_HEADER_MAX) {
	      throw new Error("Failed to parse packet header!");
	    }

	    // Not enough data yet.
	    return false;
	  },

	  /**
	   * If the incoming packet is done, log it as needed and clear the buffer.
	   */
	  _flushIncoming: function () {
	    if (!this._incoming.done) {
	      return;
	    }
	    if (dumpn.wantLogging) {
	      dumpn("Got: " + this._incoming);
	    }
	    this._destroyIncoming();
	  },

	  /**
	   * Handler triggered by an incoming JSONPacket completing it's |read| method.
	   * Delivers the packet to this.hooks.onPacket.
	   */
	  _onJSONObjectReady: function (object) {
	    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {
	      // Ensure the transport is still alive by the time this runs.
	      if (this.active) {
	        this.emit("onPacket", object);
	        this.hooks.onPacket(object);
	      }
	    }, "DebuggerTransport instance's this.hooks.onPacket"));
	  },

	  /**
	   * Handler triggered by an incoming BulkPacket entering the |read| phase for
	   * the stream portion of the packet.  Delivers info about the incoming
	   * streaming data to this.hooks.onBulkPacket.  See the main comment on the
	   * transport at the top of this file for more details.
	   */
	  _onBulkReadReady: function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {
	      // Ensure the transport is still alive by the time this runs.
	      if (this.active) {
	        var _hooks;

	        this.emit.apply(this, ["onBulkPacket"].concat(args));
	        (_hooks = this.hooks).onBulkPacket.apply(_hooks, args);
	      }
	    }, "DebuggerTransport instance's this.hooks.onBulkPacket"));
	  },

	  /**
	   * Remove all handlers and references related to the current incoming packet,
	   * either because it is now complete or because the transport is closing.
	   */
	  _destroyIncoming: function () {
	    if (this._incoming) {
	      this._incoming.destroy();
	    }
	    this._incomingHeader = "";
	    this._incoming = null;
	  }

	};

	exports.DebuggerTransport = DebuggerTransport;

	/**
	 * An adapter that handles data transfers between the debugger client and
	 * server when they both run in the same process. It presents the same API as
	 * DebuggerTransport, but instead of transmitting serialized messages across a
	 * connection it merely calls the packet dispatcher of the other side.
	 *
	 * @param other LocalDebuggerTransport
	 *        The other endpoint for this debugger connection.
	 *
	 * @see DebuggerTransport
	 */
	function LocalDebuggerTransport(other) {
	  EventEmitter.decorate(this);

	  this.other = other;
	  this.hooks = null;

	  /*
	   * A packet number, shared between this and this.other. This isn't used
	   * by the protocol at all, but it makes the packet traces a lot easier to
	   * follow.
	   */
	  this._serial = this.other ? this.other._serial : { count: 0 };
	  this.close = this.close.bind(this);
	}

	LocalDebuggerTransport.prototype = {
	  /**
	   * Transmit a message by directly calling the onPacket handler of the other
	   * endpoint.
	   */
	  send: function (packet) {
	    this.emit("send", packet);

	    var serial = this._serial.count++;
	    if (dumpn.wantLogging) {
	      /* Check 'from' first, as 'echo' packets have both. */
	      if (packet.from) {
	        dumpn("Packet " + serial + " sent from " + uneval(packet.from));
	      } else if (packet.to) {
	        dumpn("Packet " + serial + " sent to " + uneval(packet.to));
	      }
	    }
	    this._deepFreeze(packet);
	    var other = this.other;
	    if (other) {
	      DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {
	        // Avoid the cost of JSON.stringify() when logging is disabled.
	        if (dumpn.wantLogging) {
	          dumpn("Received packet " + serial + ": " + JSON.stringify(packet, null, 2));
	        }
	        if (other.hooks) {
	          other.emit("onPacket", packet);
	          other.hooks.onPacket(packet);
	        }
	      }, "LocalDebuggerTransport instance's this.other.hooks.onPacket"));
	    }
	  },

	  /**
	   * Send a streaming bulk packet directly to the onBulkPacket handler of the
	   * other endpoint.
	   *
	   * This case is much simpler than the full DebuggerTransport, since there is
	   * no primary stream we have to worry about managing while we hand it off to
	   * others temporarily.  Instead, we can just make a single use pipe and be
	   * done with it.
	   */
	  startBulkSend: function (_ref) {
	    var actor = _ref.actor,
	        type = _ref.type,
	        length = _ref.length;

	    this.emit("startBulkSend", { actor, type, length });

	    var serial = this._serial.count++;

	    dumpn("Sent bulk packet " + serial + " for actor " + actor);
	    if (!this.other) {
	      return;
	    }

	    var pipe = new Pipe(true, true, 0, 0, null);

	    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {
	      dumpn("Received bulk packet " + serial);
	      if (!this.other.hooks) {
	        return;
	      }

	      // Receiver
	      var deferred = promise.defer();
	      var packet = {
	        actor: actor,
	        type: type,
	        length: length,
	        copyTo: output => {
	          var copying = StreamUtils.copyStream(pipe.inputStream, output, length);
	          deferred.resolve(copying);
	          return copying;
	        },
	        stream: pipe.inputStream,
	        done: deferred
	      };

	      this.other.emit("onBulkPacket", packet);
	      this.other.hooks.onBulkPacket(packet);

	      // Await the result of reading from the stream
	      deferred.promise.then(() => pipe.inputStream.close(), this.close);
	    }, "LocalDebuggerTransport instance's this.other.hooks.onBulkPacket"));

	    // Sender
	    var sendDeferred = promise.defer();

	    // The remote transport is not capable of resolving immediately here, so we
	    // shouldn't be able to either.
	    DevToolsUtils.executeSoon(() => {
	      var copyDeferred = promise.defer();

	      sendDeferred.resolve({
	        copyFrom: input => {
	          var copying = StreamUtils.copyStream(input, pipe.outputStream, length);
	          copyDeferred.resolve(copying);
	          return copying;
	        },
	        stream: pipe.outputStream,
	        done: copyDeferred
	      });

	      // Await the result of writing to the stream
	      copyDeferred.promise.then(() => pipe.outputStream.close(), this.close);
	    });

	    return sendDeferred.promise;
	  },

	  /**
	   * Close the transport.
	   */
	  close: function () {
	    this.emit("close");

	    if (this.other) {
	      // Remove the reference to the other endpoint before calling close(), to
	      // avoid infinite recursion.
	      var other = this.other;
	      this.other = null;
	      other.close();
	    }
	    if (this.hooks) {
	      try {
	        this.hooks.onClosed();
	      } catch (ex) {
	        console.error(ex);
	      }
	      this.hooks = null;
	    }
	  },

	  /**
	   * An empty method for emulating the DebuggerTransport API.
	   */
	  ready: function () {},

	  /**
	   * Helper function that makes an object fully immutable.
	   */
	  _deepFreeze: function (object) {
	    Object.freeze(object);
	    for (var prop in object) {
	      // Freeze the properties that are objects, not on the prototype, and not
	      // already frozen. Note that this might leave an unfrozen reference
	      // somewhere in the object if there is an already frozen object containing
	      // an unfrozen object.
	      if (object.hasOwnProperty(prop) && typeof object === "object" && !Object.isFrozen(object)) {
	        this._deepFreeze(o[prop]);
	      }
	    }
	  }
	};

	exports.LocalDebuggerTransport = LocalDebuggerTransport;

	/**
	 * A transport for the debugging protocol that uses nsIMessageSenders to
	 * exchange packets with servers running in child processes.
	 *
	 * In the parent process, |sender| should be the nsIMessageSender for the
	 * child process. In a child process, |sender| should be the child process
	 * message manager, which sends packets to the parent.
	 *
	 * |prefix| is a string included in the message names, to distinguish
	 * multiple servers running in the same child process.
	 *
	 * This transport exchanges messages named 'debug:<prefix>:packet', where
	 * <prefix> is |prefix|, whose data is the protocol packet.
	 */
	function ChildDebuggerTransport(sender, prefix) {
	  EventEmitter.decorate(this);

	  this._sender = sender.QueryInterface(Ci.nsIMessageSender);
	  this._messageName = "debug:" + prefix + ":packet";
	}

	/*
	 * To avoid confusion, we use 'message' to mean something that
	 * nsIMessageSender conveys, and 'packet' to mean a remote debugging
	 * protocol packet.
	 */
	ChildDebuggerTransport.prototype = {
	  constructor: ChildDebuggerTransport,

	  hooks: null,

	  ready: function () {
	    this._sender.addMessageListener(this._messageName, this);
	  },

	  close: function () {
	    this._sender.removeMessageListener(this._messageName, this);
	    this.emit("onClosed");
	    this.hooks.onClosed();
	  },

	  receiveMessage: function (_ref2) {
	    var data = _ref2.data;

	    this.emit("onPacket", data);
	    this.hooks.onPacket(data);
	  },

	  send: function (packet) {
	    this.emit("send", packet);
	    this._sender.sendAsyncMessage(this._messageName, packet);
	  },

	  startBulkSend: function () {
	    throw new Error("Can't send bulk data to child processes.");
	  }
	};

	exports.ChildDebuggerTransport = ChildDebuggerTransport;

	// WorkerDebuggerTransport is defined differently depending on whether we are
	// on the main thread or a worker thread. In the former case, we are required
	// by the devtools loader, and isWorker will be false. Otherwise, we are
	// required by the worker loader, and isWorker will be true.
	//
	// Each worker debugger supports only a single connection to the main thread.
	// However, its theoretically possible for multiple servers to connect to the
	// same worker. Consequently, each transport has a connection id, to allow
	// messages from multiple connections to be multiplexed on a single channel.

	if (typeof WorkerGlobalScope === 'undefined') {
	  // i.e. not in a worker
	  (function () {
	    // Main thread
	    /**
	     * A transport that uses a WorkerDebugger to send packets from the main
	     * thread to a worker thread.
	     */
	    function WorkerDebuggerTransport(dbg, id) {
	      this._dbg = dbg;
	      this._id = id;
	      this.onMessage = this._onMessage.bind(this);
	    }

	    WorkerDebuggerTransport.prototype = {
	      constructor: WorkerDebuggerTransport,

	      ready: function () {
	        this._dbg.addListener(this);
	      },

	      close: function () {
	        this._dbg.removeListener(this);
	        if (this.hooks) {
	          this.hooks.onClosed();
	        }
	      },

	      send: function (packet) {
	        this._dbg.postMessage(JSON.stringify({
	          type: "message",
	          id: this._id,
	          message: packet
	        }));
	      },

	      startBulkSend: function () {
	        throw new Error("Can't send bulk data from worker threads!");
	      },

	      _onMessage: function (message) {
	        var packet = JSON.parse(message);
	        if (packet.type !== "message" || packet.id !== this._id) {
	          return;
	        }

	        if (this.hooks) {
	          this.hooks.onPacket(packet.message);
	        }
	      }
	    };

	    exports.WorkerDebuggerTransport = WorkerDebuggerTransport;
	  }).call(undefined);
	} else {
	  (function () {
	    // Worker thread
	    /*
	     * A transport that uses a WorkerDebuggerGlobalScope to send packets from a
	     * worker thread to the main thread.
	     */
	    function WorkerDebuggerTransport(scope, id) {
	      this._scope = scope;
	      this._id = id;
	      this._onMessage = this._onMessage.bind(this);
	    }

	    WorkerDebuggerTransport.prototype = {
	      constructor: WorkerDebuggerTransport,

	      ready: function () {
	        this._scope.addEventListener("message", this._onMessage);
	      },

	      close: function () {
	        this._scope.removeEventListener("message", this._onMessage);
	        if (this.hooks) {
	          this.hooks.onClosed();
	        }
	      },

	      send: function (packet) {
	        this._scope.postMessage(JSON.stringify({
	          type: "message",
	          id: this._id,
	          message: packet
	        }));
	      },

	      startBulkSend: function () {
	        throw new Error("Can't send bulk data from worker threads!");
	      },

	      _onMessage: function (event) {
	        var packet = JSON.parse(event.data);
	        if (packet.type !== "message" || packet.id !== this._id) {
	          return;
	        }

	        if (this.hooks) {
	          this.hooks.onPacket(packet.message);
	        }
	      }
	    };

	    exports.WorkerDebuggerTransport = WorkerDebuggerTransport;
	  }).call(undefined);
	}

/***/ },
/* 867 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var _require = __webpack_require__(834),
	    Ci = _require.Ci,
	    Cc = _require.Cc,
	    Cr = _require.Cr,
	    CC = _require.CC;

	var _require2 = __webpack_require__(29),
	    Services = _require2.Services;

	var _require3 = __webpack_require__(833),
	    dumpv = _require3.dumpv;

	var EventEmitter = __webpack_require__(844);
	var promise = __webpack_require__(839);

	var IOUtil = Cc("@mozilla.org/io-util;1").getService(Ci.nsIIOUtil);

	var ScriptableInputStream = CC("@mozilla.org/scriptableinputstream;1", "nsIScriptableInputStream", "init");

	var BUFFER_SIZE = 0x8000;

	/**
	 * This helper function (and its companion object) are used by bulk senders and
	 * receivers to read and write data in and out of other streams.  Functions that
	 * make use of this tool are passed to callers when it is time to read or write
	 * bulk data.  It is highly recommended to use these copier functions instead of
	 * the stream directly because the copier enforces the agreed upon length.
	 * Since bulk mode reuses an existing stream, the sender and receiver must write
	 * and read exactly the agreed upon amount of data, or else the entire transport
	 * will be left in a invalid state.  Additionally, other methods of stream
	 * copying (such as NetUtil.asyncCopy) close the streams involved, which would
	 * terminate the debugging transport, and so it is avoided here.
	 *
	 * Overall, this *works*, but clearly the optimal solution would be able to just
	 * use the streams directly.  If it were possible to fully implement
	 * nsIInputStream / nsIOutputStream in JS, wrapper streams could be created to
	 * enforce the length and avoid closing, and consumers could use familiar stream
	 * utilities like NetUtil.asyncCopy.
	 *
	 * The function takes two async streams and copies a precise number of bytes
	 * from one to the other.  Copying begins immediately, but may complete at some
	 * future time depending on data size.  Use the returned promise to know when
	 * it's complete.
	 *
	 * @param input nsIAsyncInputStream
	 *        The stream to copy from.
	 * @param output nsIAsyncOutputStream
	 *        The stream to copy to.
	 * @param length Integer
	 *        The amount of data that needs to be copied.
	 * @return Promise
	 *         The promise is resolved when copying completes or rejected if any
	 *         (unexpected) errors occur.
	 */
	function copyStream(input, output, length) {
	  var copier = new StreamCopier(input, output, length);
	  return copier.copy();
	}

	function StreamCopier(input, output, length) {
	  EventEmitter.decorate(this);
	  this._id = StreamCopier._nextId++;
	  this.input = input;
	  // Save off the base output stream, since we know it's async as we've required
	  this.baseAsyncOutput = output;
	  if (IOUtil.outputStreamIsBuffered(output)) {
	    this.output = output;
	  } else {
	    this.output = Cc("@mozilla.org/network/buffered-output-stream;1").createInstance(Ci.nsIBufferedOutputStream);
	    this.output.init(output, BUFFER_SIZE);
	  }
	  this._length = length;
	  this._amountLeft = length;
	  this._deferred = promise.defer();

	  this._copy = this._copy.bind(this);
	  this._flush = this._flush.bind(this);
	  this._destroy = this._destroy.bind(this);

	  // Copy promise's then method up to this object.
	  // Allows the copier to offer a promise interface for the simple succeed or
	  // fail scenarios, but also emit events (due to the EventEmitter) for other
	  // states, like progress.
	  this.then = this._deferred.promise.then.bind(this._deferred.promise);
	  this.then(this._destroy, this._destroy);

	  // Stream ready callback starts as |_copy|, but may switch to |_flush| at end
	  // if flushing would block the output stream.
	  this._streamReadyCallback = this._copy;
	}
	StreamCopier._nextId = 0;

	StreamCopier.prototype = {

	  copy: function () {
	    // Dispatch to the next tick so that it's possible to attach a progress
	    // event listener, even for extremely fast copies (like when testing).
	    Services.tm.dispatchToMainThread(() => {
	      try {
	        this._copy();
	      } catch (e) {
	        this._deferred.reject(e);
	      }
	    });
	    return this;
	  },

	  _copy: function () {
	    var bytesAvailable = this.input.available();
	    var amountToCopy = Math.min(bytesAvailable, this._amountLeft);
	    this._debug("Trying to copy: " + amountToCopy);

	    var bytesCopied = void 0;
	    try {
	      bytesCopied = this.output.writeFrom(this.input, amountToCopy);
	    } catch (e) {
	      if (e.result == Cr.NS_BASE_STREAM_WOULD_BLOCK) {
	        this._debug("Base stream would block, will retry");
	        this._debug("Waiting for output stream");
	        this.baseAsyncOutput.asyncWait(this, 0, 0, Services.tm.currentThread);
	        return;
	      } else {
	        throw e;
	      }
	    }

	    this._amountLeft -= bytesCopied;
	    this._debug("Copied: " + bytesCopied + ", Left: " + this._amountLeft);
	    this._emitProgress();

	    if (this._amountLeft === 0) {
	      this._debug("Copy done!");
	      this._flush();
	      return;
	    }

	    this._debug("Waiting for input stream");
	    this.input.asyncWait(this, 0, 0, Services.tm.currentThread);
	  },

	  _emitProgress: function () {
	    this.emit("progress", {
	      bytesSent: this._length - this._amountLeft,
	      totalBytes: this._length
	    });
	  },

	  _flush: function () {
	    try {
	      this.output.flush();
	    } catch (e) {
	      if (e.result == Cr.NS_BASE_STREAM_WOULD_BLOCK || e.result == Cr.NS_ERROR_FAILURE) {
	        this._debug("Flush would block, will retry");
	        this._streamReadyCallback = this._flush;
	        this._debug("Waiting for output stream");
	        this.baseAsyncOutput.asyncWait(this, 0, 0, Services.tm.currentThread);
	        return;
	      } else {
	        throw e;
	      }
	    }
	    this._deferred.resolve();
	  },

	  _destroy: function () {
	    this._destroy = null;
	    this._copy = null;
	    this._flush = null;
	    this.input = null;
	    this.output = null;
	  },

	  // nsIInputStreamCallback
	  onInputStreamReady: function () {
	    this._streamReadyCallback();
	  },

	  // nsIOutputStreamCallback
	  onOutputStreamReady: function () {
	    this._streamReadyCallback();
	  },

	  _debug: function (msg) {
	    // Prefix logs with the copier ID, which makes logs much easier to
	    // understand when several copiers are running simultaneously
	    dumpv("Copier: " + this._id + " " + msg);
	  }

	};

	/**
	 * Read from a stream, one byte at a time, up to the next |delimiter|
	 * character, but stopping if we've read |count| without finding it.  Reading
	 * also terminates early if there are less than |count| bytes available on the
	 * stream.  In that case, we only read as many bytes as the stream currently has
	 * to offer.
	 * TODO: This implementation could be removed if bug 984651 is fixed, which
	 *       provides a native version of the same idea.
	 * @param stream nsIInputStream
	 *        The input stream to read from.
	 * @param delimiter string
	 *        The character we're trying to find.
	 * @param count integer
	 *        The max number of characters to read while searching.
	 * @return string
	 *         The data collected.  If the delimiter was found, this string will
	 *         end with it.
	 */
	function delimitedRead(stream, delimiter, count) {
	  dumpv("Starting delimited read for " + delimiter + " up to " + count + " bytes");

	  var scriptableStream = void 0;
	  if (stream.readBytes) {
	    scriptableStream = stream;
	  } else {
	    scriptableStream = new ScriptableInputStream(stream);
	  }

	  var data = "";

	  // Don't exceed what's available on the stream
	  count = Math.min(count, stream.available());

	  if (count <= 0) {
	    return data;
	  }

	  var char = void 0;
	  while (char !== delimiter && count > 0) {
	    char = scriptableStream.readBytes(1);
	    count--;
	    data += char;
	  }

	  return data;
	}

	module.exports = {
	  copyStream: copyStream,
	  delimitedRead: delimitedRead
	};

/***/ },
/* 868 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * Packets contain read / write functionality for the different packet types
	 * supported by the debugging protocol, so that a transport can focus on
	 * delivery and queue management without worrying too much about the specific
	 * packet types.
	 *
	 * They are intended to be "one use only", so a new packet should be
	 * instantiated for each incoming or outgoing packet.
	 *
	 * A complete Packet type should expose at least the following:
	 *   * read(stream, scriptableStream)
	 *     Called when the input stream has data to read
	 *   * write(stream)
	 *     Called when the output stream is ready to write
	 *   * get done()
	 *     Returns true once the packet is done being read / written
	 *   * destroy()
	 *     Called to clean up at the end of use
	 */

	var _require = __webpack_require__(834),
	    Cc = _require.Cc,
	    Ci = _require.Ci,
	    Cu = _require.Cu;

	var DevToolsUtils = __webpack_require__(833);
	var dumpn = DevToolsUtils.dumpn,
	    dumpv = DevToolsUtils.dumpv;

	var StreamUtils = __webpack_require__(867);
	var promise = __webpack_require__(839);

	/*DevToolsUtils.defineLazyGetter(this, "unicodeConverter", () => {
	  const unicodeConverter = Cc("@mozilla.org/intl/scriptableunicodeconverter")
	                           .createInstance(Ci.nsIScriptableUnicodeConverter);
	  unicodeConverter.charset = "UTF-8";
	  return unicodeConverter;
	});*/
	var utf8 = __webpack_require__(869);

	// The transport's previous check ensured the header length did not exceed 20
	// characters.  Here, we opt for the somewhat smaller, but still large limit of
	// 1 TiB.
	var PACKET_LENGTH_MAX = Math.pow(2, 40);

	/**
	 * A generic Packet processing object (extended by two subtypes below).
	 */
	function Packet(transport) {
	  this._transport = transport;
	  this._length = 0;
	}

	/**
	 * Attempt to initialize a new Packet based on the incoming packet header we've
	 * received so far.  We try each of the types in succession, trying JSON packets
	 * first since they are much more common.
	 * @param header string
	 *        The packet header string to attempt parsing.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @return Packet
	 *         The parsed packet of the matching type, or null if no types matched.
	 */
	Packet.fromHeader = function (header, transport) {
	  return JSONPacket.fromHeader(header, transport) || BulkPacket.fromHeader(header, transport);
	};

	Packet.prototype = {

	  get length() {
	    return this._length;
	  },

	  set length(length) {
	    if (length > PACKET_LENGTH_MAX) {
	      throw Error("Packet length " + length + " exceeds the max length of " + PACKET_LENGTH_MAX);
	    }
	    this._length = length;
	  },

	  destroy: function () {
	    this._transport = null;
	  }

	};

	exports.Packet = Packet;

	/**
	 * With a JSON packet (the typical packet type sent via the transport), data is
	 * transferred as a JSON packet serialized into a string, with the string length
	 * prepended to the packet, followed by a colon ([length]:[packet]). The
	 * contents of the JSON packet are specified in the Remote Debugging Protocol
	 * specification.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 */
	function JSONPacket(transport) {
	  Packet.call(this, transport);
	  this._data = "";
	  this._done = false;
	}

	/**
	 * Attempt to initialize a new JSONPacket based on the incoming packet header
	 * we've received so far.
	 * @param header string
	 *        The packet header string to attempt parsing.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @return JSONPacket
	 *         The parsed packet, or null if it's not a match.
	 */
	JSONPacket.fromHeader = function (header, transport) {
	  var match = this.HEADER_PATTERN.exec(header);

	  if (!match) {
	    return null;
	  }

	  dumpv("Header matches JSON packet");
	  var packet = new JSONPacket(transport);
	  packet.length = +match[1];
	  return packet;
	};

	JSONPacket.HEADER_PATTERN = /^(\d+):$/;

	JSONPacket.prototype = Object.create(Packet.prototype);

	Object.defineProperty(JSONPacket.prototype, "object", {
	  /**
	   * Gets the object (not the serialized string) being read or written.
	   */
	  get: function () {
	    return this._object;
	  },

	  /**
	   * Sets the object to be sent when write() is called.
	   */
	  set: function (object) {
	    this._object = object;
	    var data = JSON.stringify(object);
	    this._data = data;
	    this.length = this._data.length;
	  }
	});

	JSONPacket.prototype.read = function (stream, scriptableStream) {
	  dumpv("Reading JSON packet");

	  // Read in more packet data.
	  this._readData(stream, scriptableStream);

	  if (!this.done) {
	    // Don't have a complete packet yet.
	    return;
	  }

	  var json = this._data;
	  try {
	    json = utf8.decode(json);
	    this._object = JSON.parse(json);
	  } catch (e) {
	    var msg = "Error parsing incoming packet: " + json + " (" + e + " - " + e.stack + ")";
	    if (console.error) {
	      console.error(msg);
	    }
	    dumpn(msg);
	    return;
	  }

	  this._transport._onJSONObjectReady(this._object);
	};

	JSONPacket.prototype._readData = function (stream, scriptableStream) {
	  if (!scriptableStream) {
	    scriptableStream = stream;
	  }
	  if (dumpv.wantVerbose) {
	    dumpv("Reading JSON data: _l: " + this.length + " dL: " + this._data.length + " sA: " + stream.available());
	  }
	  var bytesToRead = Math.min(this.length - this._data.length, stream.available());
	  this._data += scriptableStream.readBytes(bytesToRead);
	  this._done = this._data.length === this.length;
	};

	JSONPacket.prototype.write = function (stream) {
	  dumpv("Writing JSON packet");

	  if (this._outgoing === undefined) {
	    // Format the serialized packet to a buffer
	    this._outgoing = this.length + ":" + this._data;
	  }

	  var written = stream.write(this._outgoing, this._outgoing.length);
	  this._outgoing = this._outgoing.slice(written);
	  this._done = !this._outgoing.length;
	};

	Object.defineProperty(JSONPacket.prototype, "done", {
	  get: function () {
	    return this._done;
	  }
	});

	JSONPacket.prototype.toString = function () {
	  return JSON.stringify(this._object, null, 2);
	};

	exports.JSONPacket = JSONPacket;

	/**
	 * With a bulk packet, data is transferred by temporarily handing over the
	 * transport's input or output stream to the application layer for writing data
	 * directly.  This can be much faster for large data sets, and avoids various
	 * stages of copies and data duplication inherent in the JSON packet type.  The
	 * bulk packet looks like:
	 *
	 * bulk [actor] [type] [length]:[data]
	 *
	 * The interpretation of the data portion depends on the kind of actor and the
	 * packet's type.  See the Remote Debugging Protocol Stream Transport spec for
	 * more details.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 */
	function BulkPacket(transport) {
	  Packet.call(this, transport);
	  this._done = false;
	  this._readyForWriting = promise.defer();
	}

	/**
	 * Attempt to initialize a new BulkPacket based on the incoming packet header
	 * we've received so far.
	 * @param header string
	 *        The packet header string to attempt parsing.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @return BulkPacket
	 *         The parsed packet, or null if it's not a match.
	 */
	BulkPacket.fromHeader = function (header, transport) {
	  var match = this.HEADER_PATTERN.exec(header);

	  if (!match) {
	    return null;
	  }

	  dumpv("Header matches bulk packet");
	  var packet = new BulkPacket(transport);
	  packet.header = {
	    actor: match[1],
	    type: match[2],
	    length: +match[3]
	  };
	  return packet;
	};

	BulkPacket.HEADER_PATTERN = /^bulk ([^: ]+) ([^: ]+) (\d+):$/;

	BulkPacket.prototype = Object.create(Packet.prototype);

	BulkPacket.prototype.read = function (stream) {
	  dumpv("Reading bulk packet, handing off input stream");

	  // Temporarily pause monitoring of the input stream
	  this._transport.pauseIncoming();

	  var deferred = promise.defer();

	  this._transport._onBulkReadReady({
	    actor: this.actor,
	    type: this.type,
	    length: this.length,
	    copyTo: output => {
	      dumpv("CT length: " + this.length);
	      var copying = StreamUtils.copyStream(stream, output, this.length);
	      deferred.resolve(copying);
	      return copying;
	    },
	    stream: stream,
	    done: deferred
	  });

	  // Await the result of reading from the stream
	  deferred.promise.then(() => {
	    dumpv("onReadDone called, ending bulk mode");
	    this._done = true;
	    this._transport.resumeIncoming();
	  }, this._transport.close);

	  // Ensure this is only done once
	  this.read = () => {
	    throw new Error("Tried to read() a BulkPacket's stream multiple times.");
	  };
	};

	BulkPacket.prototype.write = function (stream) {
	  dumpv("Writing bulk packet");

	  if (this._outgoingHeader === undefined) {
	    dumpv("Serializing bulk packet header");
	    // Format the serialized packet header to a buffer
	    this._outgoingHeader = "bulk " + this.actor + " " + this.type + " " + this.length + ":";
	  }

	  // Write the header, or whatever's left of it to write.
	  if (this._outgoingHeader.length) {
	    dumpv("Writing bulk packet header");
	    var written = stream.write(this._outgoingHeader, this._outgoingHeader.length);
	    this._outgoingHeader = this._outgoingHeader.slice(written);
	    return;
	  }

	  dumpv("Handing off output stream");

	  // Temporarily pause the monitoring of the output stream
	  this._transport.pauseOutgoing();

	  var deferred = promise.defer();

	  this._readyForWriting.resolve({
	    copyFrom: input => {
	      dumpv("CF length: " + this.length);
	      var copying = StreamUtils.copyStream(input, stream, this.length);
	      deferred.resolve(copying);
	      return copying;
	    },
	    stream: stream,
	    done: deferred
	  });

	  // Await the result of writing to the stream
	  deferred.promise.then(() => {
	    dumpv("onWriteDone called, ending bulk mode");
	    this._done = true;
	    this._transport.resumeOutgoing();
	  }, this._transport.close);

	  // Ensure this is only done once
	  this.write = () => {
	    throw new Error("Tried to write() a BulkPacket's stream multiple times.");
	  };
	};

	Object.defineProperty(BulkPacket.prototype, "streamReadyForWriting", {
	  get: function () {
	    return this._readyForWriting.promise;
	  }
	});

	Object.defineProperty(BulkPacket.prototype, "header", {
	  get: function () {
	    return {
	      actor: this.actor,
	      type: this.type,
	      length: this.length
	    };
	  },

	  set: function (header) {
	    this.actor = header.actor;
	    this.type = header.type;
	    this.length = header.length;
	  }
	});

	Object.defineProperty(BulkPacket.prototype, "done", {
	  get: function () {
	    return this._done;
	  }
	});

	BulkPacket.prototype.toString = function () {
	  return "Bulk: " + JSON.stringify(this.header, null, 2);
	};

	exports.BulkPacket = BulkPacket;

	/**
	 * RawPacket is used to test the transport's error handling of malformed
	 * packets, by writing data directly onto the stream.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @param data string
	 *        The raw string to send out onto the stream.
	 */
	function RawPacket(transport, data) {
	  Packet.call(this, transport);
	  this._data = data;
	  this.length = data.length;
	  this._done = false;
	}

	RawPacket.prototype = Object.create(Packet.prototype);

	RawPacket.prototype.read = function (stream) {
	  // This hasn't yet been needed for testing.
	  throw Error("Not implmented.");
	};

	RawPacket.prototype.write = function (stream) {
	  var written = stream.write(this._data, this._data.length);
	  this._data = this._data.slice(written);
	  this._done = !this._data.length;
	};

	Object.defineProperty(RawPacket.prototype, "done", {
	  get: function () {
	    return this._done;
	  }
	});

	exports.RawPacket = RawPacket;

/***/ },
/* 869 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';

	/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function (root) {

		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;

		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;

		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}

		/*--------------------------------------------------------------------------*/

		var stringFromCharCode = String.fromCharCode;

		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) {
						// low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}

		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
			}
		}
		/*--------------------------------------------------------------------------*/

		function createByte(codePoint, shift) {
			return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
		}

		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) {
				// 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) {
				// 2-byte sequence
				symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
			} else if ((codePoint & 0xFFFF0000) == 0) {
				// 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
				symbol += createByte(codePoint, 6);
			} else if ((codePoint & 0xFFE00000) == 0) {
				// 4-byte sequence
				symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
			return symbol;
		}

		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}

		/*--------------------------------------------------------------------------*/

		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}

			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}

			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}

		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;

			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}

			if (byteIndex == byteCount) {
				return false;
			}

			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}

			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = (byte1 & 0x1F) << 6 | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = (byte1 & 0x0F) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}

			throw Error('Invalid UTF-8 detected');
		}

		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}

		/*--------------------------------------------------------------------------*/

		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};

		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (true) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && !freeExports.nodeType) {
			if (freeModule) {
				// in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.utf8 = utf8;
		}
	})(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module), (function() { return this; }())))

/***/ },
/* 870 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';

	/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function (root) {

		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;

		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;

		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}

		/*--------------------------------------------------------------------------*/

		var stringFromCharCode = String.fromCharCode;

		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) {
						// low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}

		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
			}
		}
		/*--------------------------------------------------------------------------*/

		function createByte(codePoint, shift) {
			return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
		}

		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) {
				// 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) {
				// 2-byte sequence
				symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
			} else if ((codePoint & 0xFFFF0000) == 0) {
				// 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
				symbol += createByte(codePoint, 6);
			} else if ((codePoint & 0xFFE00000) == 0) {
				// 4-byte sequence
				symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
			return symbol;
		}

		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}

		/*--------------------------------------------------------------------------*/

		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}

			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}

			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}

		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;

			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}

			if (byteIndex == byteCount) {
				return false;
			}

			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}

			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = (byte1 & 0x1F) << 6 | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = (byte1 & 0x0F) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}

			throw Error('Invalid UTF-8 detected');
		}

		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}

		/*--------------------------------------------------------------------------*/

		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};

		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (true) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && !freeExports.nodeType) {
			if (freeModule) {
				// in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.utf8 = utf8;
		}
	})(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module), (function() { return this; }())))

/***/ },
/* 871 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	// See bug 1273941 to understand this choice of promise.

	var Promise = __webpack_require__(839);

	/**
	 * Returns a deferred object, with a resolve and reject property.
	 * https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred
	 */
	module.exports = function defer() {
	  var resolve = void 0,
	      reject = void 0;
	  var promise = new Promise(function () {
	    resolve = arguments[0];
	    reject = arguments[1];
	  });
	  return {
	    resolve: resolve,
	    reject: reject,
	    promise: promise
	  };
	};

/***/ },
/* 872 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * DevTools is a class that represents a set of developer tools, it holds a
	 * set of tools and keeps track of open toolboxes in the browser.
	 */

	var DevTools = {
	  chromeWindowType: "navigator:browser"
	};

	exports.gDevTools = DevTools;

/***/ },
/* 873 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var EventEmitter = __webpack_require__(844);

	var _require = __webpack_require__(874),
	    listenOnce = _require.listenOnce;

	var _require2 = __webpack_require__(875),
	    Task = _require2.Task;

	var _require3 = __webpack_require__(876),
	    TooltipToggle = _require3.TooltipToggle;

	var XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
	var XHTML_NS = "http://www.w3.org/1999/xhtml";

	var POSITION = {
	  TOP: "top",
	  BOTTOM: "bottom"
	};

	module.exports.POSITION = POSITION;

	var TYPE = {
	  NORMAL: "normal",
	  ARROW: "arrow"
	};

	module.exports.TYPE = TYPE;

	var ARROW_WIDTH = 32;

	// Default offset between the tooltip's left edge and the tooltip arrow.
	var ARROW_OFFSET = 20;

	var EXTRA_HEIGHT = {
	  "normal": 0,
	  // The arrow is 16px tall, but merges on 3px with the panel border
	  "arrow": 13
	};

	var EXTRA_BORDER = {
	  "normal": 0,
	  "arrow": 3
	};

	/**
	 * Calculate the vertical position & offsets to use for the tooltip. Will attempt to
	 * respect the provided height and position preferences, unless the available height
	 * prevents this.
	 *
	 * @param {DOMRect} anchorRect
	 *        Bounding rectangle for the anchor, relative to the tooltip document.
	 * @param {DOMRect} viewportRect
	 *        Bounding rectangle for the viewport. top/left can be different from 0 if some
	 *        space should not be used by tooltips (for instance OS toolbars, taskbars etc.).
	 * @param {Number} height
	 *        Preferred height for the tooltip.
	 * @param {String} pos
	 *        Preferred position for the tooltip. Possible values: "top" or "bottom".
	 * @return {Object}
	 *         - {Number} top: the top offset for the tooltip.
	 *         - {Number} height: the height to use for the tooltip container.
	 *         - {String} computedPosition: Can differ from the preferred position depending
	 *           on the available height). "top" or "bottom"
	 */
	var calculateVerticalPosition = function (anchorRect, viewportRect, height, pos, offset) {
	  var TOP = POSITION.TOP,
	      BOTTOM = POSITION.BOTTOM;
	  var anchorTop = anchorRect.top,
	      anchorHeight = anchorRect.height;

	  // Translate to the available viewport space before calculating dimensions and position.

	  anchorTop -= viewportRect.top;

	  // Calculate available space for the tooltip.
	  var availableTop = anchorTop;
	  var availableBottom = viewportRect.height - (anchorTop + anchorHeight);

	  // Find POSITION
	  var keepPosition = false;
	  if (pos === TOP) {
	    keepPosition = availableTop >= height + offset;
	  } else if (pos === BOTTOM) {
	    keepPosition = availableBottom >= height + offset;
	  }
	  if (!keepPosition) {
	    pos = availableTop > availableBottom ? TOP : BOTTOM;
	  }

	  // Calculate HEIGHT.
	  var availableHeight = pos === TOP ? availableTop : availableBottom;
	  height = Math.min(height, availableHeight - offset);
	  height = Math.floor(height);

	  // Calculate TOP.
	  var top = pos === TOP ? anchorTop - height - offset : anchorTop + anchorHeight + offset;

	  // Translate back to absolute coordinates by re-including viewport top margin.
	  top += viewportRect.top;

	  return { top, height, computedPosition: pos };
	};

	/**
	 * Calculate the vertical position & offsets to use for the tooltip. Will attempt to
	 * respect the provided height and position preferences, unless the available height
	 * prevents this.
	 *
	 * @param {DOMRect} anchorRect
	 *        Bounding rectangle for the anchor, relative to the tooltip document.
	 * @param {DOMRect} viewportRect
	 *        Bounding rectangle for the viewport. top/left can be different from 0 if some
	 *        space should not be used by tooltips (for instance OS toolbars, taskbars etc.).
	 * @param {Number} width
	 *        Preferred width for the tooltip.
	 * @param {String} type
	 *        The tooltip type (e.g. "arrow").
	 * @param {Number} offset
	 *        Horizontal offset in pixels.
	 * @param {Boolean} isRtl
	 *        If the anchor is in RTL, the tooltip should be aligned to the right.
	 * @return {Object}
	 *         - {Number} left: the left offset for the tooltip.
	 *         - {Number} width: the width to use for the tooltip container.
	 *         - {Number} arrowLeft: the left offset to use for the arrow element.
	 */
	var calculateHorizontalPosition = function (anchorRect, viewportRect, width, type, offset, isRtl) {
	  var anchorWidth = anchorRect.width;
	  var anchorStart = isRtl ? anchorRect.right : anchorRect.left;

	  // Translate to the available viewport space before calculating dimensions and position.
	  anchorStart -= viewportRect.left;

	  // Calculate WIDTH.
	  width = Math.min(width, viewportRect.width);

	  // Calculate LEFT.
	  // By default the tooltip is aligned with the anchor left edge. Unless this
	  // makes it overflow the viewport, in which case is shifts to the left.
	  var left = anchorStart + offset - (isRtl ? width : 0);
	  left = Math.min(left, viewportRect.width - width);
	  left = Math.max(0, left);

	  // Calculate ARROW LEFT (tooltip's LEFT might be updated)
	  var arrowLeft = void 0;
	  // Arrow style tooltips may need to be shifted to the left
	  if (type === TYPE.ARROW) {
	    var arrowCenter = left + ARROW_OFFSET + ARROW_WIDTH / 2;
	    var anchorCenter = anchorStart + anchorWidth / 2;
	    // If the anchor is too narrow, align the arrow and the anchor center.
	    if (arrowCenter > anchorCenter) {
	      left = Math.max(0, left - (arrowCenter - anchorCenter));
	    }
	    // Arrow's left offset relative to the anchor.
	    arrowLeft = Math.min(ARROW_OFFSET, (anchorWidth - ARROW_WIDTH) / 2) | 0;
	    // Translate the coordinate to tooltip container
	    arrowLeft += anchorStart - left;
	    // Make sure the arrow remains in the tooltip container.
	    arrowLeft = Math.min(arrowLeft, width - ARROW_WIDTH);
	    arrowLeft = Math.max(arrowLeft, 0);
	  }

	  // Translate back to absolute coordinates by re-including viewport left margin.
	  left += viewportRect.left;

	  return { left, width, arrowLeft };
	};

	/**
	 * Get the bounding client rectangle for a given node, relative to a custom
	 * reference element (instead of the default for getBoundingClientRect which
	 * is always the element's ownerDocument).
	 */
	var getRelativeRect = function (node, relativeTo) {
	  // Width and Height can be taken from the rect.
	  var _node$getBoundingClie = node.getBoundingClientRect(),
	      width = _node$getBoundingClie.width,
	      height = _node$getBoundingClie.height;

	  var quads = node.getBoxQuads({ relativeTo });
	  var top = quads[0].bounds.top;
	  var left = quads[0].bounds.left;

	  // Compute right and bottom coordinates using the rest of the data.
	  var right = left + width;
	  var bottom = top + height;

	  return { top, right, bottom, left, width, height };
	};

	/**
	 * The HTMLTooltip can display HTML content in a tooltip popup.
	 *
	 * @param {Document} toolboxDoc
	 *        The toolbox document to attach the HTMLTooltip popup.
	 * @param {Object}
	 *        - {String} type
	 *          Display type of the tooltip. Possible values: "normal", "arrow"
	 *        - {Boolean} autofocus
	 *          Defaults to false. Should the tooltip be focused when opening it.
	 *        - {Boolean} consumeOutsideClicks
	 *          Defaults to true. The tooltip is closed when clicking outside.
	 *          Should this event be stopped and consumed or not.
	 *        - {Boolean} useXulWrapper
	 *          Defaults to false. If the tooltip is hosted in a XUL document, use a XUL panel
	 *          in order to use all the screen viewport available.
	 *        - {String} stylesheet
	 *          Style sheet URL to apply to the tooltip content.
	 */
	function HTMLTooltip(toolboxDoc) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$type = _ref.type,
	      type = _ref$type === undefined ? "normal" : _ref$type,
	      _ref$autofocus = _ref.autofocus,
	      autofocus = _ref$autofocus === undefined ? false : _ref$autofocus,
	      _ref$consumeOutsideCl = _ref.consumeOutsideClicks,
	      consumeOutsideClicks = _ref$consumeOutsideCl === undefined ? true : _ref$consumeOutsideCl,
	      _ref$useXulWrapper = _ref.useXulWrapper,
	      useXulWrapper = _ref$useXulWrapper === undefined ? false : _ref$useXulWrapper,
	      _ref$stylesheet = _ref.stylesheet,
	      stylesheet = _ref$stylesheet === undefined ? "" : _ref$stylesheet;

	  EventEmitter.decorate(this);

	  this.doc = toolboxDoc;
	  this.type = type;
	  this.autofocus = autofocus;
	  this.consumeOutsideClicks = consumeOutsideClicks;
	  this.useXulWrapper = this._isXUL() && useXulWrapper;

	  // The top window is used to attach click event listeners to close the tooltip if the
	  // user clicks on the content page.
	  this.topWindow = this._getTopWindow();

	  this._position = null;

	  this._onClick = this._onClick.bind(this);
	  this._onXulPanelHidden = this._onXulPanelHidden.bind(this);

	  this._toggle = new TooltipToggle(this);
	  this.startTogglingOnHover = this._toggle.start.bind(this._toggle);
	  this.stopTogglingOnHover = this._toggle.stop.bind(this._toggle);

	  this.container = this._createContainer();

	  if (stylesheet) {
	    this._applyStylesheet(stylesheet);
	  }
	  if (this.useXulWrapper) {
	    // When using a XUL panel as the wrapper, the actual markup for the tooltip is as
	    // follows :
	    // <panel> <!-- XUL panel used to position the tooltip anywhere on screen -->
	    //   <div> <!-- div wrapper used to isolate the tooltip container -->
	    //     <div> <! the actual tooltip.container element -->
	    this.xulPanelWrapper = this._createXulPanelWrapper();
	    var inner = this.doc.createElementNS(XHTML_NS, "div");
	    inner.classList.add("tooltip-xul-wrapper-inner");

	    this.doc.documentElement.appendChild(this.xulPanelWrapper);
	    this.xulPanelWrapper.appendChild(inner);
	    inner.appendChild(this.container);
	  } else if (this._isXUL()) {
	    this.doc.documentElement.appendChild(this.container);
	  } else {
	    // In non-XUL context the container is ready to use as is.
	    this.doc.body.appendChild(this.container);
	  }
	}

	module.exports.HTMLTooltip = HTMLTooltip;

	HTMLTooltip.prototype = {
	  /**
	   * The tooltip panel is the parentNode of the tooltip content provided in
	   * setContent().
	   */
	  get panel() {
	    return this.container.querySelector(".tooltip-panel");
	  },

	  /**
	   * The arrow element. Might be null depending on the tooltip type.
	   */
	  get arrow() {
	    return this.container.querySelector(".tooltip-arrow");
	  },

	  /**
	   * Retrieve the displayed position used for the tooltip. Null if the tooltip is hidden.
	   */
	  get position() {
	    return this.isVisible() ? this._position : null;
	  },

	  /**
	   * Set the tooltip content element. The preferred width/height should also be
	   * specified here.
	   *
	   * @param {Element} content
	   *        The tooltip content, should be a HTML element.
	   * @param {Object}
	   *        - {Number} width: preferred width for the tooltip container. If not specified
	   *          the tooltip container will be measured before being displayed, and the
	   *          measured width will be used as preferred width.
	   *        - {Number} height: optional, preferred height for the tooltip container. If
	   *          not specified, the tooltip will be able to use all the height available.
	   */
	  setContent: function (content) {
	    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        _ref2$width = _ref2.width,
	        width = _ref2$width === undefined ? "auto" : _ref2$width,
	        _ref2$height = _ref2.height,
	        height = _ref2$height === undefined ? Infinity : _ref2$height;

	    this.preferredWidth = width;
	    this.preferredHeight = height;

	    this.panel.innerHTML = "";
	    this.panel.appendChild(content);
	  },

	  /**
	   * Show the tooltip next to the provided anchor element. A preferred position
	   * can be set. The event "shown" will be fired after the tooltip is displayed.
	   *
	   * @param {Element} anchor
	   *        The reference element with which the tooltip should be aligned
	   * @param {Object}
	   *        - {String} position: optional, possible values: top|bottom
	   *          If layout permits, the tooltip will be displayed on top/bottom
	   *          of the anchor. If ommitted, the tooltip will be displayed where
	   *          more space is available.
	   *        - {Number} x: optional, horizontal offset between the anchor and the tooltip
	   *        - {Number} y: optional, vertical offset between the anchor and the tooltip
	   */
	  show: Task.async(function* (anchor) {
	    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        position = _ref3.position,
	        _ref3$x = _ref3.x,
	        x = _ref3$x === undefined ? 0 : _ref3$x,
	        _ref3$y = _ref3.y,
	        y = _ref3$y === undefined ? 0 : _ref3$y;

	    // Get anchor geometry
	    var anchorRect = getRelativeRect(anchor, this.doc);
	    if (this.useXulWrapper) {
	      anchorRect = this._convertToScreenRect(anchorRect);
	    }

	    // Get viewport size
	    var viewportRect = this._getViewportRect();

	    var themeHeight = EXTRA_HEIGHT[this.type] + 2 * EXTRA_BORDER[this.type];
	    var preferredHeight = this.preferredHeight + themeHeight;

	    var _calculateVerticalPos = calculateVerticalPosition(anchorRect, viewportRect, preferredHeight, position, y),
	        top = _calculateVerticalPos.top,
	        height = _calculateVerticalPos.height,
	        computedPosition = _calculateVerticalPos.computedPosition;

	    this._position = computedPosition;
	    // Apply height before measuring the content width (if width="auto").
	    var isTop = computedPosition === POSITION.TOP;
	    this.container.classList.toggle("tooltip-top", isTop);
	    this.container.classList.toggle("tooltip-bottom", !isTop);

	    // If the preferred height is set to Infinity, the tooltip container should grow based
	    // on its content's height and use as much height as possible.
	    this.container.classList.toggle("tooltip-flexible-height", this.preferredHeight === Infinity);

	    this.container.style.height = height + "px";

	    var preferredWidth = void 0;
	    if (this.preferredWidth === "auto") {
	      preferredWidth = this._measureContainerWidth();
	    } else {
	      var themeWidth = 2 * EXTRA_BORDER[this.type];
	      preferredWidth = this.preferredWidth + themeWidth;
	    }

	    var anchorWin = anchor.ownerDocument.defaultView;
	    var isRtl = anchorWin.getComputedStyle(anchor).direction === "rtl";

	    var _calculateHorizontalP = calculateHorizontalPosition(anchorRect, viewportRect, preferredWidth, this.type, x, isRtl),
	        left = _calculateHorizontalP.left,
	        width = _calculateHorizontalP.width,
	        arrowLeft = _calculateHorizontalP.arrowLeft;

	    this.container.style.width = width + "px";

	    if (this.type === TYPE.ARROW) {
	      this.arrow.style.left = arrowLeft + "px";
	    }

	    if (this.useXulWrapper) {
	      yield this._showXulWrapperAt(left, top);
	    } else {
	      this.container.style.left = left + "px";
	      this.container.style.top = top + "px";
	    }

	    this.container.classList.add("tooltip-visible");

	    // Keep a pointer on the focused element to refocus it when hiding the tooltip.
	    this._focusedElement = this.doc.activeElement;

	    this.doc.defaultView.clearTimeout(this.attachEventsTimer);
	    this.attachEventsTimer = this.doc.defaultView.setTimeout(() => {
	      this._maybeFocusTooltip();
	      // Updated the top window reference each time in case the host changes.
	      this.topWindow = this._getTopWindow();
	      this.topWindow.addEventListener("click", this._onClick, true);
	      this.emit("shown");
	    }, 0);
	  }),

	  /**
	   * Calculate the rect of the viewport that limits the tooltip dimensions. When using a
	   * XUL panel wrapper, the viewport will be able to use the whole screen (excluding space
	   * reserved by the OS for toolbars etc.). Otherwise, the viewport is limited to the
	   * tooltip's document.
	   *
	   * @return {Object} DOMRect-like object with the Number properties: top, right, bottom,
	   *         left, width, height
	   */
	  _getViewportRect: function () {
	    if (this.useXulWrapper) {
	      // availLeft/Top are the coordinates first pixel available on the screen for
	      // applications (excluding space dedicated for OS toolbars, menus etc...)
	      // availWidth/Height are the dimensions available to applications excluding all
	      // the OS reserved space
	      var _doc$defaultView$scre = this.doc.defaultView.screen,
	          availLeft = _doc$defaultView$scre.availLeft,
	          availTop = _doc$defaultView$scre.availTop,
	          availHeight = _doc$defaultView$scre.availHeight,
	          availWidth = _doc$defaultView$scre.availWidth;

	      return {
	        top: availTop,
	        right: availLeft + availWidth,
	        bottom: availTop + availHeight,
	        left: availLeft,
	        width: availWidth,
	        height: availHeight
	      };
	    }

	    return this.doc.documentElement.getBoundingClientRect();
	  },

	  _measureContainerWidth: function () {
	    var xulParent = this.container.parentNode;
	    if (this.useXulWrapper && !this.isVisible()) {
	      // Move the container out of the XUL Panel to measure it.
	      this.doc.documentElement.appendChild(this.container);
	    }

	    this.container.classList.add("tooltip-hidden");
	    this.container.style.width = "auto";
	    var width = this.container.getBoundingClientRect().width;
	    this.container.classList.remove("tooltip-hidden");

	    if (this.useXulWrapper && !this.isVisible()) {
	      xulParent.appendChild(this.container);
	    }

	    return width;
	  },

	  /**
	   * Hide the current tooltip. The event "hidden" will be fired when the tooltip
	   * is hidden.
	   */
	  hide: Task.async(function* () {
	    this.doc.defaultView.clearTimeout(this.attachEventsTimer);
	    if (!this.isVisible()) {
	      this.emit("hidden");
	      return;
	    }

	    this.topWindow.removeEventListener("click", this._onClick, true);
	    this.container.classList.remove("tooltip-visible");
	    if (this.useXulWrapper) {
	      yield this._hideXulWrapper();
	    }

	    this.emit("hidden");

	    var tooltipHasFocus = this.container.contains(this.doc.activeElement);
	    if (tooltipHasFocus && this._focusedElement) {
	      this._focusedElement.focus();
	      this._focusedElement = null;
	    }
	  }),

	  /**
	   * Check if the tooltip is currently displayed.
	   * @return {Boolean} true if the tooltip is visible
	   */
	  isVisible: function () {
	    return this.container.classList.contains("tooltip-visible");
	  },

	  /**
	   * Destroy the tooltip instance. Hide the tooltip if displayed, remove the
	   * tooltip container from the document.
	   */
	  destroy: function () {
	    this.hide();
	    this.container.remove();
	    if (this.xulPanelWrapper) {
	      this.xulPanelWrapper.remove();
	    }
	  },

	  _createContainer: function () {
	    var container = this.doc.createElementNS(XHTML_NS, "div");
	    container.setAttribute("type", this.type);
	    container.classList.add("tooltip-container");

	    var html = '<div class="tooltip-filler"></div>';
	    html += '<div class="tooltip-panel"></div>';

	    if (this.type === TYPE.ARROW) {
	      html += '<div class="tooltip-arrow"></div>';
	    }
	    container.innerHTML = html;
	    return container;
	  },

	  _onClick: function (e) {
	    if (this._isInTooltipContainer(e.target)) {
	      return;
	    }

	    this.hide();
	    if (this.consumeOutsideClicks && e.button === 0) {
	      // Consume only left click events (button === 0).
	      e.preventDefault();
	      e.stopPropagation();
	    }
	  },

	  _isInTooltipContainer: function (node) {
	    // Check if the target is the tooltip arrow.
	    if (this.arrow && this.arrow === node) {
	      return true;
	    }

	    var tooltipWindow = this.panel.ownerDocument.defaultView;
	    var win = node.ownerDocument.defaultView;

	    // Check if the tooltip panel contains the node if they live in the same document.
	    if (win === tooltipWindow) {
	      return this.panel.contains(node);
	    }

	    // Check if the node window is in the tooltip container.
	    while (win.parent && win.parent !== win) {
	      if (win.parent === tooltipWindow) {
	        // If the parent window is the tooltip window, check if the tooltip contains
	        // the current frame element.
	        return this.panel.contains(win.frameElement);
	      }
	      win = win.parent;
	    }

	    return false;
	  },

	  _onXulPanelHidden: function () {
	    if (this.isVisible()) {
	      this.hide();
	    }
	  },

	  /**
	   * If the tootlip is configured to autofocus and a focusable element can be found,
	   * focus it.
	   */
	  _maybeFocusTooltip: function () {
	    // Simplied selector targetting elements that can receive the focus, full version at
	    // http://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus .
	    var focusableSelector = "a, button, iframe, input, select, textarea";
	    var focusableElement = this.panel.querySelector(focusableSelector);
	    if (this.autofocus && focusableElement) {
	      focusableElement.focus();
	    }
	  },

	  _getTopWindow: function () {
	    return this.doc.defaultView.top;
	  },

	  /**
	   * Check if the tooltip's owner document is a XUL document.
	   */
	  _isXUL: function () {
	    return this.doc.documentElement.namespaceURI === XUL_NS;
	  },

	  _createXulPanelWrapper: function () {
	    var panel = this.doc.createElementNS(XUL_NS, "panel");

	    // XUL panel is only a way to display DOM elements outside of the document viewport,
	    // so disable all features that impact the behavior.
	    panel.setAttribute("animate", false);
	    panel.setAttribute("consumeoutsideclicks", false);
	    panel.setAttribute("noautofocus", true);
	    panel.setAttribute("ignorekeys", true);
	    panel.setAttribute("tooltip", "aHTMLTooltip");

	    // Use type="arrow" to prevent side effects (see Bug 1285206)
	    panel.setAttribute("type", "arrow");

	    panel.setAttribute("level", "top");
	    panel.setAttribute("class", "tooltip-xul-wrapper");

	    return panel;
	  },

	  _showXulWrapperAt: function (left, top) {
	    this.xulPanelWrapper.addEventListener("popuphidden", this._onXulPanelHidden);
	    var onPanelShown = listenOnce(this.xulPanelWrapper, "popupshown");
	    this.xulPanelWrapper.openPopupAtScreen(left, top, false);
	    return onPanelShown;
	  },

	  _hideXulWrapper: function () {
	    this.xulPanelWrapper.removeEventListener("popuphidden", this._onXulPanelHidden);

	    if (this.xulPanelWrapper.state === "closed") {
	      // XUL panel is already closed, resolve immediately.
	      return Promise.resolve();
	    }

	    var onPanelHidden = listenOnce(this.xulPanelWrapper, "popuphidden");
	    this.xulPanelWrapper.hidePopup();
	    return onPanelHidden;
	  },

	  /**
	   * Convert from coordinates relative to the tooltip's document, to coordinates relative
	   * to the "available" screen. By "available" we mean the screen, excluding the OS bars
	   * display on screen edges.
	   */
	  _convertToScreenRect: function (_ref4) {
	    var left = _ref4.left,
	        top = _ref4.top,
	        width = _ref4.width,
	        height = _ref4.height;

	    // mozInnerScreenX/Y are the coordinates of the top left corner of the window's
	    // viewport, excluding chrome UI.
	    left += this.doc.defaultView.mozInnerScreenX;
	    top += this.doc.defaultView.mozInnerScreenY;
	    return { top, right: left + width, bottom: top + height, left, width, height };
	  },

	  /**
	   * Apply a scoped stylesheet to the container so that this css file only
	   * applies to it.
	   */
	  _applyStylesheet: function (url) {
	    var style = this.doc.createElementNS(XHTML_NS, "style");
	    style.setAttribute("scoped", "true");
	    url = url.replace(/"/g, "\\\"");
	    style.textContent = `@import url("${url}");`;
	    this.container.appendChild(style);
	  }
	};

/***/ },
/* 874 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * Helpers for async functions. Async functions are generator functions that are
	 * run by Tasks. An async function returns a Promise for the resolution of the
	 * function. When the function returns, the promise is resolved with the
	 * returned value. If it throws the promise rejects with the thrown error.
	 *
	 * See Task documentation at https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Task.jsm.
	 */

	var _require = __webpack_require__(875),
	    Task = _require.Task;

	var Promise = __webpack_require__(839);

	/**
	 * Create an async function that only executes once per instance of an object.
	 * Once called on a given object, the same promise will be returned for any
	 * future calls for that object.
	 *
	 * @param Function func
	 *        The generator function that to wrap as an async function.
	 * @return Function
	 *         The async function.
	 */
	exports.asyncOnce = function asyncOnce(func) {
	  var promises = new WeakMap();
	  return function () {
	    var promise = promises.get(this);
	    if (!promise) {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      promise = Task.spawn(func.apply(this, args));
	      promises.set(this, promise);
	    }
	    return promise;
	  };
	};

	/**
	 * Adds an event listener to the given element, and then removes its event
	 * listener once the event is called, returning the event object as a promise.
	 * @param  nsIDOMElement element
	 *         The DOM element to listen on
	 * @param  String event
	 *         The name of the event type to listen for
	 * @param  Boolean useCapture
	 *         Should we initiate the capture phase?
	 * @return Promise
	 *         The promise resolved with the event object when the event first
	 *         happens
	 */
	exports.listenOnce = function listenOnce(element, event, useCapture) {
	  return new Promise(function (resolve, reject) {
	    var onEvent = function (ev) {
	      element.removeEventListener(event, onEvent, useCapture);
	      resolve(ev);
	    };
	    element.addEventListener(event, onEvent, useCapture);
	  });
	};

	/**
	 * Call a function that expects a callback as the last argument and returns a
	 * promise for the result. This simplifies using callback APIs from tasks and
	 * async functions.
	 *
	 * @param Any obj
	 *        The |this| value to call the function on.
	 * @param Function func
	 *        The callback-expecting function to call.
	 * @param Array args
	 *        Additional arguments to pass to the method.
	 * @return Promise
	 *         The promise for the result. If the callback is called with only one
	 *         argument, it is used as the resolution value. If there's multiple
	 *         arguments, an array containing the arguments is the resolution value.
	 *         If the method throws, the promise is rejected with the thrown value.
	 */
	function promisify(obj, func, args) {
	  return new Promise(resolve => {
	    args.push(function () {
	      for (var _len2 = arguments.length, results = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        results[_key2] = arguments[_key2];
	      }

	      resolve(results.length > 1 ? results : results[0]);
	    });
	    func.apply(obj, args);
	  });
	}

	/**
	 * Call a method that expects a callback as the last argument and returns a
	 * promise for the result.
	 *
	 * @see promisify
	 */
	exports.promiseInvoke = function promiseInvoke(obj, func) {
	  for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
	    args[_key3 - 2] = arguments[_key3];
	  }

	  return promisify(obj, func, args);
	};

	/**
	 * Call a function that expects a callback as the last argument.
	 *
	 * @see promisify
	 */
	exports.promiseCall = function promiseCall(func) {
	  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	    args[_key4 - 1] = arguments[_key4];
	  }

	  return promisify(undefined, func, args);
	};

/***/ },
/* 875 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80 filetype=javascript: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/* eslint-disable spaced-comment */
	/* globals StopIteration */

	/**
	 * This module implements a subset of "Task.js" <http://taskjs.org/>.
	 * It is a copy of toolkit/modules/Task.jsm.  Please try not to
	 * diverge the API here.
	 *
	 * Paraphrasing from the Task.js site, tasks make sequential, asynchronous
	 * operations simple, using the power of JavaScript's "yield" operator.
	 *
	 * Tasks are built upon generator functions and promises, documented here:
	 *
	 * <https://developer.mozilla.org/en/JavaScript/Guide/Iterators_and_Generators>
	 * <http://wiki.commonjs.org/wiki/Promises/A>
	 *
	 * The "Task.spawn" function takes a generator function and starts running it as
	 * a task.  Every time the task yields a promise, it waits until the promise is
	 * fulfilled.  "Task.spawn" returns a promise that is resolved when the task
	 * completes successfully, or is rejected if an exception occurs.
	 *
	 * -----------------------------------------------------------------------------
	 *
	 * const {Task} = require("devtools/shared/task");
	 *
	 * Task.spawn(function* () {
	 *
	 *   // This is our task. Let's create a promise object, wait on it and capture
	 *   // its resolution value.
	 *   let myPromise = getPromiseResolvedOnTimeoutWithValue(1000, "Value");
	 *   let result = yield myPromise;
	 *
	 *   // This part is executed only after the promise above is fulfilled (after
	 *   // one second, in this imaginary example).  We can easily loop while
	 *   // calling asynchronous functions, and wait multiple times.
	 *   for (let i = 0; i < 3; i++) {
	 *     result += yield getPromiseResolvedOnTimeoutWithValue(50, "!");
	 *   }
	 *
	 *   return "Resolution result for the task: " + result;
	 * }).then(function (result) {
	 *
	 *   // result == "Resolution result for the task: Value!!!"
	 *
	 *   // The result is undefined if no value was returned.
	 *
	 * }, function (exception) {
	 *
	 *   // Failure!  We can inspect or report the exception.
	 *
	 * });
	 *
	 * -----------------------------------------------------------------------------
	 *
	 * This module implements only the "Task.js" interfaces described above, with no
	 * additional features to control the task externally, or do custom scheduling.
	 * It also provides the following extensions that simplify task usage in the
	 * most common cases:
	 *
	 * - The "Task.spawn" function also accepts an iterator returned by a generator
	 *   function, in addition to a generator function.  This way, you can call into
	 *   the generator function with the parameters you want, and with "this" bound
	 *   to the correct value.  Also, "this" is never bound to the task object when
	 *   "Task.spawn" calls the generator function.
	 *
	 * - In addition to a promise object, a task can yield the iterator returned by
	 *   a generator function.  The iterator is turned into a task automatically.
	 *   This reduces the syntax overhead of calling "Task.spawn" explicitly when
	 *   you want to recurse into other task functions.
	 *
	 * - The "Task.spawn" function also accepts a primitive value, or a function
	 *   returning a primitive value, and treats the value as the result of the
	 *   task.  This makes it possible to call an externally provided function and
	 *   spawn a task from it, regardless of whether it is an asynchronous generator
	 *   or a synchronous function.  This comes in handy when iterating over
	 *   function lists where some items have been converted to tasks and some not.
	 */

	////////////////////////////////////////////////////////////////////////////////
	//// Globals

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var Promise = __webpack_require__(839);
	var defer = __webpack_require__(871);

	// The following error types are considered programmer errors, which should be
	// reported (possibly redundantly) so as to let programmers fix their code.
	var ERRORS_TO_REPORT = ["EvalError", "RangeError", "ReferenceError", "TypeError"];

	/**
	 * The Task currently being executed
	 */
	var gCurrentTask = null;

	/**
	 * If `true`, capture stacks whenever entering a Task and rewrite the
	 * stack any exception thrown through a Task.
	 */
	var gMaintainStack = false;

	/**
	 * Iterate through the lines of a string.
	 *
	 * @return Iterator<string>
	 */
	function* linesOf(string) {
	  var reLine = /([^\r\n])+/g;
	  var match = void 0;
	  while (match = reLine.exec(string)) {
	    yield [match[0], match.index];
	  }
	}

	/**
	 * Detect whether a value is a generator.
	 *
	 * @param aValue
	 *        The value to identify.
	 * @return A boolean indicating whether the value is a generator.
	 */
	function isGenerator(value) {
	  return Object.prototype.toString.call(value) == "[object Generator]";
	}

	////////////////////////////////////////////////////////////////////////////////
	//// Task

	/**
	 * This object provides the public module functions.
	 */
	var Task = {
	  /**
	   * Creates and starts a new task.
	   *
	   * @param task
	   *        - If you specify a generator function, it is called with no
	   *          arguments to retrieve the associated iterator.  The generator
	   *          function is a task, that is can yield promise objects to wait
	   *          upon.
	   *        - If you specify the iterator returned by a generator function you
	   *          called, the generator function is also executed as a task.  This
	   *          allows you to call the function with arguments.
	   *        - If you specify a function that is not a generator, it is called
	   *          with no arguments, and its return value is used to resolve the
	   *          returned promise.
	   *        - If you specify anything else, you get a promise that is already
	   *          resolved with the specified value.
	   *
	   * @return A promise object where you can register completion callbacks to be
	   *         called when the task terminates.
	   */
	  spawn: function (task) {
	    return createAsyncFunction(task)();
	  },

	  /**
	   * Create and return an 'async function' that starts a new task.
	   *
	   * This is similar to 'spawn' except that it doesn't immediately start
	   * the task, it binds the task to the async function's 'this' object and
	   * arguments, and it requires the task to be a function.
	   *
	   * It simplifies the common pattern of implementing a method via a task,
	   * like this simple object with a 'greet' method that has a 'name' parameter
	   * and spawns a task to send a greeting and return its reply:
	   *
	   * let greeter = {
	   *   message: "Hello, NAME!",
	   *   greet: function(name) {
	   *     return Task.spawn((function* () {
	   *       return yield sendGreeting(this.message.replace(/NAME/, name));
	   *     }).bind(this);
	   *   })
	   * };
	   *
	   * With Task.async, the method can be declared succinctly:
	   *
	   * let greeter = {
	   *   message: "Hello, NAME!",
	   *   greet: Task.async(function* (name) {
	   *     return yield sendGreeting(this.message.replace(/NAME/, name));
	   *   })
	   * };
	   *
	   * While maintaining identical semantics:
	   *
	   * greeter.greet("Mitchell").then((reply) => { ... }); // behaves the same
	   *
	   * @param task
	   *        The task function to start.
	   *
	   * @return A function that starts the task function and returns its promise.
	   */
	  async: function (task) {
	    if (typeof task != "function") {
	      throw new TypeError("task argument must be a function");
	    }

	    return createAsyncFunction(task);
	  },

	  /**
	   * Constructs a special exception that, when thrown inside a legacy generator
	   * function (non-star generator), allows the associated task to be resolved
	   * with a specific value.
	   *
	   * Example: throw new Task.Result("Value");
	   */
	  Result: function (value) {
	    this.value = value;
	  }
	};

	function createAsyncFunction(task) {
	  var asyncFunction = function () {
	    var result = task;
	    if (task && typeof task == "function") {
	      if (task.isAsyncFunction) {
	        throw new TypeError("Cannot use an async function in place of a promise. " + "You should either invoke the async function first " + "or use 'Task.spawn' instead of 'Task.async' to start " + "the Task and return its promise.");
	      }

	      try {
	        // Let's call into the function ourselves.
	        result = task.apply(this, arguments);
	      } catch (ex) {
	        if (ex instanceof Task.Result) {
	          return Promise.resolve(ex.value);
	        }
	        return Promise.reject(ex);
	      }
	    }

	    if (isGenerator(result)) {
	      // This is an iterator resulting from calling a generator function.
	      return new TaskImpl(result).deferred.promise;
	    }

	    // Just propagate the given value to the caller as a resolved promise.
	    return Promise.resolve(result);
	  };

	  asyncFunction.isAsyncFunction = true;

	  return asyncFunction;
	}

	////////////////////////////////////////////////////////////////////////////////
	//// TaskImpl

	/**
	 * Executes the specified iterator as a task, and gives access to the promise
	 * that is fulfilled when the task terminates.
	 */
	function TaskImpl(iterator) {
	  if (gMaintainStack) {
	    this._stack = new Error().stack;
	  }
	  this.deferred = defer();
	  this._iterator = iterator;
	  this._isStarGenerator = !("send" in iterator);
	  this._run(true);
	}

	TaskImpl.prototype = {
	  /**
	   * Includes the promise object where task completion callbacks are registered,
	   * and methods to resolve or reject the promise at task completion.
	   */
	  deferred: null,

	  /**
	   * The iterator returned by the generator function associated with this task.
	   */
	  _iterator: null,

	  /**
	   * Whether this Task is using a star generator.
	   */
	  _isStarGenerator: false,

	  /**
	   * Main execution routine, that calls into the generator function.
	   *
	   * @param sendResolved
	   *        If true, indicates that we should continue into the generator
	   *        function regularly (if we were waiting on a promise, it was
	   *        resolved). If true, indicates that we should cause an exception to
	   *        be thrown into the generator function (if we were waiting on a
	   *        promise, it was rejected).
	   * @param sendValue
	   *        Resolution result or rejection exception, if any.
	   */
	  _run: function (sendResolved, sendValue) {
	    try {
	      gCurrentTask = this;

	      if (this._isStarGenerator) {
	        try {
	          var result = sendResolved ? this._iterator.next(sendValue) : this._iterator.throw(sendValue);

	          if (result.done) {
	            // The generator function returned.
	            this.deferred.resolve(result.value);
	          } else {
	            // The generator function yielded.
	            this._handleResultValue(result.value);
	          }
	        } catch (ex) {
	          // The generator function failed with an uncaught exception.
	          this._handleException(ex);
	        }
	      } else {
	        try {
	          var yielded = sendResolved ? this._iterator.send(sendValue) : this._iterator.throw(sendValue);
	          this._handleResultValue(yielded);
	        } catch (ex) {
	          if (ex instanceof Task.Result) {
	            // The generator function threw the special exception that
	            // allows it to return a specific value on resolution.
	            this.deferred.resolve(ex.value);
	          } else if (ex instanceof StopIteration) {
	            // The generator function terminated with no specific result.
	            this.deferred.resolve(undefined);
	          } else {
	            // The generator function failed with an uncaught exception.
	            this._handleException(ex);
	          }
	        }
	      }
	    } finally {
	      //
	      // At this stage, the Task may have finished executing, or have
	      // walked through a `yield` or passed control to a sub-Task.
	      // Regardless, if we still own `gCurrentTask`, reset it. If we
	      // have not finished execution of this Task, re-entering `_run`
	      // will set `gCurrentTask` to `this` as needed.
	      //
	      // We just need to be careful here in case we hit the following
	      // pattern:
	      //
	      //   Task.spawn(foo);
	      //   Task.spawn(bar);
	      //
	      // Here, `foo` and `bar` may be interleaved, so when we finish
	      // executing `foo`, `gCurrentTask` may actually either `foo` or
	      // `bar`. If `gCurrentTask` has already been set to `bar`, leave
	      // it be and it will be reset to `null` once `bar` is complete.
	      //
	      if (gCurrentTask == this) {
	        gCurrentTask = null;
	      }
	    }
	  },

	  /**
	   * Handle a value yielded by a generator.
	   *
	   * @param value
	   *        The yielded value to handle.
	   */
	  _handleResultValue: function (value) {
	    // If our task yielded an iterator resulting from calling another
	    // generator function, automatically spawn a task from it, effectively
	    // turning it into a promise that is fulfilled on task completion.
	    if (isGenerator(value)) {
	      value = Task.spawn(value);
	    }

	    if (value && typeof value.then == "function") {
	      // We have a promise object now. When fulfilled, call again into this
	      // function to continue the task, with either a resolution or rejection
	      // condition.
	      value.then(this._run.bind(this, true), this._run.bind(this, false));
	    } else {
	      // If our task yielded a value that is not a promise, just continue and
	      // pass it directly as the result of the yield statement.
	      this._run(true, value);
	    }
	  },

	  /**
	   * Handle an uncaught exception thrown from a generator.
	   *
	   * @param exception
	   *        The uncaught exception to handle.
	   */
	  _handleException: function (exception) {
	    gCurrentTask = this;

	    if (exception && typeof exception == "object" && "stack" in exception) {
	      var stack = exception.stack;

	      if (gMaintainStack && exception._capturedTaskStack != this._stack && typeof stack == "string") {
	        // Rewrite the stack for more readability.

	        var bottomStack = this._stack;

	        stack = Task.Debugging.generateReadableStack(stack);

	        exception.stack = stack;

	        // If exception is reinjected in the same task and rethrown,
	        // we don't want to perform the rewrite again.
	        exception._capturedTaskStack = bottomStack;
	      } else if (!stack) {
	        stack = "Not available";
	      }

	      if ("name" in exception && ERRORS_TO_REPORT.indexOf(exception.name) != -1) {
	        // We suspect that the exception is a programmer error, so we now
	        // display it using dump().  Note that we do not use Cu.reportError as
	        // we assume that this is a programming error, so we do not want end
	        // users to see it. Also, if the programmer handles errors correctly,
	        // they will either treat the error or log them somewhere.

	        dump("*************************\n");
	        dump("A coding exception was thrown and uncaught in a Task.\n\n");
	        dump("Full message: " + exception + "\n");
	        dump("Full stack: " + exception.stack + "\n");
	        dump("*************************\n");
	      }
	    }

	    this.deferred.reject(exception);
	  },

	  get callerStack() {
	    // Cut `this._stack` at the last line of the first block that
	    for (var _ref of linesOf(this._stack || "")) {
	      var _ref2 = _slicedToArray(_ref, 2);

	      var line = _ref2[0];
	      var index = _ref2[1];

	      if (line.indexOf("/task.js:") == -1) {
	        return this._stack.substring(index);
	      }
	    }
	    return "";
	  }
	};

	Task.Debugging = {

	  /**
	   * Control stack rewriting.
	   *
	   * If `true`, any exception thrown from a Task will be rewritten to
	   * provide a human-readable stack trace. Otherwise, stack traces will
	   * be left unchanged.
	   *
	   * There is a (small but existing) runtime cost associated to stack
	   * rewriting, so you should probably not activate this in production
	   * code.
	   *
	   * @type {bool}
	   */
	  get maintainStack() {
	    return gMaintainStack;
	  },
	  set maintainStack(x) {
	    if (!x) {
	      gCurrentTask = null;
	    }
	    gMaintainStack = x;
	    return x;
	  },

	  /**
	   * Generate a human-readable stack for an error raised in
	   * a Task.
	   *
	   * @param {string} topStack The stack provided by the error.
	   * @param {string=} prefix Optionally, a prefix for each line.
	   */
	  generateReadableStack: function (topStack) {
	    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

	    if (!gCurrentTask) {
	      return topStack;
	    }

	    // Cut `topStack` at the first line that contains task.js, keep the head.
	    var lines = [];
	    for (var _ref3 of linesOf(topStack)) {
	      var _ref4 = _slicedToArray(_ref3, 1);

	      var line = _ref4[0];

	      if (line.indexOf("/task.js:") != -1) {
	        break;
	      }
	      lines.push(prefix + line);
	    }
	    if (!prefix) {
	      lines.push(gCurrentTask.callerStack);
	    } else {
	      for (var _ref5 of linesOf(gCurrentTask.callerStack)) {
	        var _ref6 = _slicedToArray(_ref5, 1);

	        var _line = _ref6[0];

	        lines.push(prefix + _line);
	      }
	    }

	    return lines.join("\n");
	  }
	};

	exports.Task = Task;

/***/ },
/* 876 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var _require = __webpack_require__(875),
	    Task = _require.Task;

	var DEFAULT_TOGGLE_DELAY = 50;

	/**
	 * Tooltip helper designed to show/hide the tooltip when the mouse hovers over
	 * particular nodes.
	 *
	 * This works by tracking mouse movements on a base container node (baseNode)
	 * and showing the tooltip when the mouse stops moving. A callback can be
	 * provided to the start() method to know whether or not the node being
	 * hovered over should indeed receive the tooltip.
	 */
	function TooltipToggle(tooltip) {
	  this.tooltip = tooltip;
	  this.win = tooltip.doc.defaultView;

	  this._onMouseMove = this._onMouseMove.bind(this);
	  this._onMouseOut = this._onMouseOut.bind(this);

	  this._onTooltipMouseOver = this._onTooltipMouseOver.bind(this);
	  this._onTooltipMouseOut = this._onTooltipMouseOut.bind(this);
	}

	module.exports.TooltipToggle = TooltipToggle;

	TooltipToggle.prototype = {
	  /**
	   * Start tracking mouse movements on the provided baseNode to show the
	   * tooltip.
	   *
	   * 2 Ways to make this work:
	   * - Provide a single node to attach the tooltip to, as the baseNode, and
	   *   omit the second targetNodeCb argument
	   * - Provide a baseNode that is the container of possibly numerous children
	   *   elements that may receive a tooltip. In this case, provide the second
	   *   targetNodeCb argument to decide wether or not a child should receive
	   *   a tooltip.
	   *
	   * Note that if you call this function a second time, it will itself call
	   * stop() before adding mouse tracking listeners again.
	   *
	   * @param {node} baseNode
	   *        The container for all target nodes
	   * @param {Function} targetNodeCb
	   *        A function that accepts a node argument and that checks if a tooltip
	   *        should be displayed. Possible return values are:
	   *        - false (or a falsy value) if the tooltip should not be displayed
	   *        - true if the tooltip should be displayed
	   *        - a DOM node to display the tooltip on the returned anchor
	   *        The function can also return a promise that will resolve to one of
	   *        the values listed above.
	   *        If omitted, the tooltip will be shown everytime.
	   * @param {Object} options
	            Set of optional arguments:
	   *        - {Number} toggleDelay
	   *          An optional delay (in ms) that will be observed before showing
	   *          and before hiding the tooltip. Defaults to DEFAULT_TOGGLE_DELAY.
	   *        - {Boolean} interactive
	   *          If enabled, the tooltip is not hidden when mouse leaves the
	   *          target element and enters the tooltip. Allows the tooltip
	   *          content to be interactive.
	   */
	  start: function (baseNode, targetNodeCb) {
	    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
	        _ref$toggleDelay = _ref.toggleDelay,
	        toggleDelay = _ref$toggleDelay === undefined ? DEFAULT_TOGGLE_DELAY : _ref$toggleDelay,
	        _ref$interactive = _ref.interactive,
	        interactive = _ref$interactive === undefined ? false : _ref$interactive;

	    this.stop();

	    if (!baseNode) {
	      // Calling tool is in the process of being destroyed.
	      return;
	    }

	    this._baseNode = baseNode;
	    this._targetNodeCb = targetNodeCb || (() => true);
	    this._toggleDelay = toggleDelay;
	    this._interactive = interactive;

	    baseNode.addEventListener("mousemove", this._onMouseMove);
	    baseNode.addEventListener("mouseout", this._onMouseOut);

	    if (this._interactive) {
	      this.tooltip.container.addEventListener("mouseover", this._onTooltipMouseOver);
	      this.tooltip.container.addEventListener("mouseout", this._onTooltipMouseOut);
	    }
	  },

	  /**
	   * If the start() function has been used previously, and you want to get rid
	   * of this behavior, then call this function to remove the mouse movement
	   * tracking
	   */
	  stop: function () {
	    this.win.clearTimeout(this.toggleTimer);

	    if (!this._baseNode) {
	      return;
	    }

	    this._baseNode.removeEventListener("mousemove", this._onMouseMove);
	    this._baseNode.removeEventListener("mouseout", this._onMouseOut);

	    if (this._interactive) {
	      this.tooltip.container.removeEventListener("mouseover", this._onTooltipMouseOver);
	      this.tooltip.container.removeEventListener("mouseout", this._onTooltipMouseOut);
	    }

	    this._baseNode = null;
	    this._targetNodeCb = null;
	    this._lastHovered = null;
	  },

	  _onMouseMove: function (event) {
	    if (event.target !== this._lastHovered) {
	      this._lastHovered = event.target;

	      this.win.clearTimeout(this.toggleTimer);
	      this.toggleTimer = this.win.setTimeout(() => {
	        this.tooltip.hide();
	        this.isValidHoverTarget(event.target).then(target => {
	          if (target === null) {
	            return;
	          }
	          this.tooltip.show(target);
	        }, reason => {
	          console.error("isValidHoverTarget rejected with unexpected reason:");
	          console.error(reason);
	        });
	      }, this._toggleDelay);
	    }
	  },

	  /**
	   * Is the given target DOMNode a valid node for toggling the tooltip on hover.
	   * This delegates to the user-defined _targetNodeCb callback.
	   * @return {Promise} a promise that will resolve the anchor to use for the
	   *         tooltip or null if no valid target was found.
	   */
	  isValidHoverTarget: Task.async(function* (target) {
	    var res = yield this._targetNodeCb(target, this.tooltip);
	    if (res) {
	      return res.nodeName ? res : target;
	    }

	    return null;
	  }),

	  _onMouseOut: function (event) {
	    // Only hide the tooltip if the mouse leaves baseNode.
	    if (event && this._baseNode && !this._baseNode.contains(event.relatedTarget)) {
	      return;
	    }

	    this._lastHovered = null;
	    this.win.clearTimeout(this.toggleTimer);
	    this.toggleTimer = this.win.setTimeout(() => {
	      this.tooltip.hide();
	    }, this._toggleDelay);
	  },

	  _onTooltipMouseOver() {
	    this.win.clearTimeout(this.toggleTimer);
	  },

	  _onTooltipMouseOut() {
	    this.win.clearTimeout(this.toggleTimer);
	    this.toggleTimer = this.win.setTimeout(() => {
	      this.tooltip.hide();
	    }, this._toggleDelay);
	  },

	  destroy: function () {
	    this.stop();
	  }
	};

/***/ },
/* 877 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	// This was copied (and slightly modified) from
	// devtools/shared/gcli/source/lib/gcli/util/util.js, which in turn
	// says:

	/**
	 * Keyboard handling is a mess. http://unixpapa.com/js/key.html
	 * It would be good to use DOM L3 Keyboard events,
	 * http://www.w3.org/TR/2010/WD-DOM-Level-3-Events-20100907/#events-keyboardevents
	 * however only Webkit supports them, and there isn't a shim on Modernizr:
	 * https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills
	 * and when the code that uses this KeyEvent was written, nothing was clear,
	 * so instead, we're using this unmodern shim:
	 * http://stackoverflow.com/questions/5681146/chrome-10-keyevent-or-something-similar-to-firefoxs-keyevent
	 * See BUG 664991: GCLI's keyboard handling should be updated to use DOM-L3
	 * https://bugzilla.mozilla.org/show_bug.cgi?id=664991
	 */

	exports.KeyCodes = {
	  DOM_VK_CANCEL: 3,
	  DOM_VK_HELP: 6,
	  DOM_VK_BACK_SPACE: 8,
	  DOM_VK_TAB: 9,
	  DOM_VK_CLEAR: 12,
	  DOM_VK_RETURN: 13,
	  DOM_VK_SHIFT: 16,
	  DOM_VK_CONTROL: 17,
	  DOM_VK_ALT: 18,
	  DOM_VK_PAUSE: 19,
	  DOM_VK_CAPS_LOCK: 20,
	  DOM_VK_ESCAPE: 27,
	  DOM_VK_SPACE: 32,
	  DOM_VK_PAGE_UP: 33,
	  DOM_VK_PAGE_DOWN: 34,
	  DOM_VK_END: 35,
	  DOM_VK_HOME: 36,
	  DOM_VK_LEFT: 37,
	  DOM_VK_UP: 38,
	  DOM_VK_RIGHT: 39,
	  DOM_VK_DOWN: 40,
	  DOM_VK_PRINTSCREEN: 44,
	  DOM_VK_INSERT: 45,
	  DOM_VK_DELETE: 46,
	  DOM_VK_0: 48,
	  DOM_VK_1: 49,
	  DOM_VK_2: 50,
	  DOM_VK_3: 51,
	  DOM_VK_4: 52,
	  DOM_VK_5: 53,
	  DOM_VK_6: 54,
	  DOM_VK_7: 55,
	  DOM_VK_8: 56,
	  DOM_VK_9: 57,
	  DOM_VK_SEMICOLON: 59,
	  DOM_VK_EQUALS: 61,
	  DOM_VK_A: 65,
	  DOM_VK_B: 66,
	  DOM_VK_C: 67,
	  DOM_VK_D: 68,
	  DOM_VK_E: 69,
	  DOM_VK_F: 70,
	  DOM_VK_G: 71,
	  DOM_VK_H: 72,
	  DOM_VK_I: 73,
	  DOM_VK_J: 74,
	  DOM_VK_K: 75,
	  DOM_VK_L: 76,
	  DOM_VK_M: 77,
	  DOM_VK_N: 78,
	  DOM_VK_O: 79,
	  DOM_VK_P: 80,
	  DOM_VK_Q: 81,
	  DOM_VK_R: 82,
	  DOM_VK_S: 83,
	  DOM_VK_T: 84,
	  DOM_VK_U: 85,
	  DOM_VK_V: 86,
	  DOM_VK_W: 87,
	  DOM_VK_X: 88,
	  DOM_VK_Y: 89,
	  DOM_VK_Z: 90,
	  DOM_VK_CONTEXT_MENU: 93,
	  DOM_VK_NUMPAD0: 96,
	  DOM_VK_NUMPAD1: 97,
	  DOM_VK_NUMPAD2: 98,
	  DOM_VK_NUMPAD3: 99,
	  DOM_VK_NUMPAD4: 100,
	  DOM_VK_NUMPAD5: 101,
	  DOM_VK_NUMPAD6: 102,
	  DOM_VK_NUMPAD7: 103,
	  DOM_VK_NUMPAD8: 104,
	  DOM_VK_NUMPAD9: 105,
	  DOM_VK_MULTIPLY: 106,
	  DOM_VK_ADD: 107,
	  DOM_VK_SEPARATOR: 108,
	  DOM_VK_SUBTRACT: 109,
	  DOM_VK_DECIMAL: 110,
	  DOM_VK_DIVIDE: 111,
	  DOM_VK_F1: 112,
	  DOM_VK_F2: 113,
	  DOM_VK_F3: 114,
	  DOM_VK_F4: 115,
	  DOM_VK_F5: 116,
	  DOM_VK_F6: 117,
	  DOM_VK_F7: 118,
	  DOM_VK_F8: 119,
	  DOM_VK_F9: 120,
	  DOM_VK_F10: 121,
	  DOM_VK_F11: 122,
	  DOM_VK_F12: 123,
	  DOM_VK_F13: 124,
	  DOM_VK_F14: 125,
	  DOM_VK_F15: 126,
	  DOM_VK_F16: 127,
	  DOM_VK_F17: 128,
	  DOM_VK_F18: 129,
	  DOM_VK_F19: 130,
	  DOM_VK_F20: 131,
	  DOM_VK_F21: 132,
	  DOM_VK_F22: 133,
	  DOM_VK_F23: 134,
	  DOM_VK_F24: 135,
	  DOM_VK_NUM_LOCK: 144,
	  DOM_VK_SCROLL_LOCK: 145,
	  DOM_VK_COMMA: 188,
	  DOM_VK_PERIOD: 190,
	  DOM_VK_SLASH: 191,
	  DOM_VK_BACK_QUOTE: 192,
	  DOM_VK_OPEN_BRACKET: 219,
	  DOM_VK_BACK_SLASH: 220,
	  DOM_VK_CLOSE_BRACKET: 221,
	  DOM_VK_QUOTE: 222,
	  DOM_VK_META: 224,

	  // A few that did not appear in gcli, but that are apparently used
	  // in devtools.
	  DOM_VK_COLON: 58,
	  DOM_VK_VOLUME_MUTE: 181,
	  DOM_VK_VOLUME_DOWN: 182,
	  DOM_VK_VOLUME_UP: 183
	};

/***/ },
/* 878 */
/***/ function(module, exports) {

	"use strict";

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/*
	 * The code below is mostly is a slight modification of
	 * intl/locale/PluralForm.jsm that removes dependencies on chrome privileged
	 * APIs.
	 * To make maintenance easier, this file is kept as close as possible to the
	 * original in terms of implementation.
	 * The modified methods here are
	 * - makeGetter (remove code adding the caller name to the log)
	 * - get ruleNum() (rely on LocalizationHelper instead of String.services)
	 * - log() (rely on console.log)
	 *
	 * Disable eslint warnings to preserve original code style.
	 */

	/* eslint-disable */

	// ONLY SUPPORT ENGLISH PLURAL FORM NOW,NEED L10N SUPPORT

	/**
	 * This module provides the PluralForm object which contains a method to figure
	 * out which plural form of a word to use for a given number based on the
	 * current localization. There is also a makeGetter method that creates a get
	 * function for the desired plural rule. This is useful for extensions that
	 * specify their own plural rule instead of relying on the browser default.
	 * (I.e., the extension hasn't been localized to the browser's locale.)
	 *
	 * See: http://developer.mozilla.org/en/docs/Localization_and_Plurals
	 *
	 * List of methods:
	 *
	 * string pluralForm
	 * get(int aNum, string aWords)
	 *
	 * int numForms
	 * numForms()
	 *
	 * [string pluralForm get(int aNum, string aWords), int numForms numForms()]
	 * makeGetter(int aRuleNum)
	 * Note: Basically, makeGetter returns 2 functions that do "get" and "numForm"
	 */

	// These are the available plural functions that give the appropriate index
	// based on the plural rule number specified. The first element is the number
	// of plural forms and the second is the function to figure out the index.
	var gFunctions = [
	// 0: Chinese
	[1, n => 0],
	// 1: English
	[2, n => n != 1 ? 1 : 0],
	// 2: French
	[2, n => n > 1 ? 1 : 0],
	// 3: Latvian
	[3, n => n % 10 == 1 && n % 100 != 11 ? 1 : n != 0 ? 2 : 0],
	// 4: Scottish Gaelic
	[4, n => n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 0 && n < 20 ? 2 : 3],
	// 5: Romanian
	[3, n => n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2],
	// 6: Lithuanian
	[3, n => n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 2 : 1],
	// 7: Russian
	[3, n => n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2],
	// 8: Slovak
	[3, n => n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2],
	// 9: Polish
	[3, n => n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2],
	// 10: Slovenian
	[4, n => n % 100 == 1 ? 0 : n % 100 == 2 ? 1 : n % 100 == 3 || n % 100 == 4 ? 2 : 3],
	// 11: Irish Gaeilge
	[5, n => n == 1 ? 0 : n == 2 ? 1 : n >= 3 && n <= 6 ? 2 : n >= 7 && n <= 10 ? 3 : 4],
	// 12: Arabic
	[6, n => n == 0 ? 5 : n == 1 ? 0 : n == 2 ? 1 : n % 100 >= 3 && n % 100 <= 10 ? 2 : n % 100 >= 11 && n % 100 <= 99 ? 3 : 4],
	// 13: Maltese
	[4, n => n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 <= 10 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3],
	// 14: Macedonian
	[3, n => n % 10 == 1 ? 0 : n % 10 == 2 ? 1 : 2],
	// 15: Icelandic
	[2, n => n % 10 == 1 && n % 100 != 11 ? 0 : 1],
	// 16: Breton
	[5, n => n % 10 == 1 && n % 100 != 11 && n % 100 != 71 && n % 100 != 91 ? 0 : n % 10 == 2 && n % 100 != 12 && n % 100 != 72 && n % 100 != 92 ? 1 : (n % 10 == 3 || n % 10 == 4 || n % 10 == 9) && n % 100 != 13 && n % 100 != 14 && n % 100 != 19 && n % 100 != 73 && n % 100 != 74 && n % 100 != 79 && n % 100 != 93 && n % 100 != 94 && n % 100 != 99 ? 2 : n % 1000000 == 0 && n != 0 ? 3 : 4]];

	var PluralForm = {
	  /**
	   * Get the correct plural form of a word based on the number
	   *
	   * @param aNum
	   *        The number to decide which plural form to use
	   * @param aWords
	   *        A semi-colon (;) separated string of words to pick the plural form
	   * @return The appropriate plural form of the word
	   */
	  get get() {
	    // This method will lazily load to avoid perf when it is first needed and
	    // creates getPluralForm function. The function it creates is based on the
	    // value of pluralRule specified in the intl stringbundle.
	    // See: http://developer.mozilla.org/en/docs/Localization_and_Plurals

	    // Delete the getters to be overwritten
	    delete this.numForms;
	    delete this.get;

	    // Make the plural form get function and set it as the default get

	    var _makeGetter = this.makeGetter(this.ruleNum);

	    var _makeGetter2 = _slicedToArray(_makeGetter, 2);

	    this.get = _makeGetter2[0];
	    this.numForms = _makeGetter2[1];

	    return this.get;
	  },

	  /**
	   * Create a pair of plural form functions for the given plural rule number.
	   *
	   * @param aRuleNum
	   *        The plural rule number to create functions
	   * @return A pair: [function that gets the right plural form,
	   *                  function that returns the number of plural forms]
	   */
	  makeGetter: function (aRuleNum) {
	    // Default to "all plural" if the value is out of bounds or invalid
	    if (aRuleNum < 0 || aRuleNum >= gFunctions.length || isNaN(aRuleNum)) {
	      log(["Invalid rule number: ", aRuleNum, " -- defaulting to 0"]);
	      aRuleNum = 0;
	    }

	    // Get the desired pluralRule function

	    var _gFunctions$aRuleNum = _slicedToArray(gFunctions[aRuleNum], 2),
	        numForms = _gFunctions$aRuleNum[0],
	        pluralFunc = _gFunctions$aRuleNum[1];

	    // Return functions that give 1) the number of forms and 2) gets the right
	    // plural form


	    return [function (aNum, aWords) {
	      // Figure out which index to use for the semi-colon separated words
	      var index = pluralFunc(aNum ? Number(aNum) : 0);
	      var words = aWords ? aWords.split(/;/) : [""];

	      // Explicitly check bounds to avoid strict warnings
	      var ret = index < words.length ? words[index] : undefined;

	      // Check for array out of bounds or empty strings
	      if (ret == undefined || ret == "") {
	        // Display a message in the error console
	        log(["Index #", index, " of '", aWords, "' for value ", aNum, " is invalid -- plural rule #", aRuleNum, ";"]);

	        // Default to the first entry (which might be empty, but not undefined)
	        ret = words[0];
	      }

	      return ret;
	    }, () => numForms];
	  },

	  /**
	   * Get the number of forms for the current plural rule
	   *
	   * @return The number of forms
	   */
	  get numForms() {
	    // We lazily load numForms, so trigger the init logic with get()
	    this.get();
	    return this.numForms;
	  },

	  /**
	   * Get the plural rule number from the intl stringbundle
	   *
	   * @return The plural rule number
	   */
	  get ruleNum() {
	    // Fallback to English if the pluralRule property is not available.
	    return 1;
	  }
	};

	/**
	 * Private helper function to log errors to the error console and command line
	 *
	 * @param aMsg
	 *        Error message to log or an array of strings to concat
	 */
	function log(aMsg) {
	  var msg = "plural-form.js: " + (aMsg.join ? aMsg.join("") : aMsg);
	  console.log(msg + "\n");
	}

	exports.PluralForm = PluralForm;

	/* eslint-ensable */

/***/ },
/* 879 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _require = __webpack_require__(877),
	    KeyCodes = _require.KeyCodes;

	var PANE_APPEARANCE_DELAY = 50;
	var PAGE_SIZE_ITEM_COUNT_RATIO = 5;
	var WIDGET_FOCUSABLE_NODES = new Set(["vbox", "hbox"]);

	var namedTimeoutsStore = new Map();

	/**
	 * Inheritance helpers from the addon SDK's core/heritage.
	 * Remove these when all devtools are loadered.
	 */
	exports.Heritage = {
	  /**
	   * @see extend in sdk/core/heritage.
	   */
	  extend: function (prototype) {
	    var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    return Object.create(prototype, this.getOwnPropertyDescriptors(properties));
	  },

	  /**
	   * @see getOwnPropertyDescriptors in sdk/core/heritage.
	   */
	  getOwnPropertyDescriptors: function (object) {
	    return Object.getOwnPropertyNames(object).reduce((descriptor, name) => {
	      descriptor[name] = Object.getOwnPropertyDescriptor(object, name);
	      return descriptor;
	    }, {});
	  }
	};

	/**
	 * Helper for draining a rapid succession of events and invoking a callback
	 * once everything settles down.
	 *
	 * @param string id
	 *        A string identifier for the named timeout.
	 * @param number wait
	 *        The amount of milliseconds to wait after no more events are fired.
	 * @param function callback
	 *        Invoked when no more events are fired after the specified time.
	 */
	var setNamedTimeout = function setNamedTimeout(id, wait, callback) {
	  clearNamedTimeout(id);

	  namedTimeoutsStore.set(id, setTimeout(() => namedTimeoutsStore.delete(id) && callback(), wait));
	};
	exports.setNamedTimeout = setNamedTimeout;

	/**
	 * Clears a named timeout.
	 * @see setNamedTimeout
	 *
	 * @param string id
	 *        A string identifier for the named timeout.
	 */
	var clearNamedTimeout = function clearNamedTimeout(id) {
	  if (!namedTimeoutsStore) {
	    return;
	  }
	  clearTimeout(namedTimeoutsStore.get(id));
	  namedTimeoutsStore.delete(id);
	};
	exports.clearNamedTimeout = clearNamedTimeout;

	/**
	 * Same as `setNamedTimeout`, but invokes the callback only if the provided
	 * predicate function returns true. Otherwise, the timeout is re-triggered.
	 *
	 * @param string id
	 *        A string identifier for the conditional timeout.
	 * @param number wait
	 *        The amount of milliseconds to wait after no more events are fired.
	 * @param function predicate
	 *        The predicate function used to determine whether the timeout restarts.
	 * @param function callback
	 *        Invoked when no more events are fired after the specified time, and
	 *        the provided predicate function returns true.
	 */
	var setConditionalTimeout = function setConditionalTimeout(id, wait, predicate, callback) {
	  setNamedTimeout(id, wait, function maybeCallback() {
	    if (predicate()) {
	      callback();
	      return;
	    }
	    setConditionalTimeout(id, wait, predicate, callback);
	  });
	};
	exports.setConditionalTimeout = setConditionalTimeout;

	/**
	 * Clears a conditional timeout.
	 * @see setConditionalTimeout
	 *
	 * @param string id
	 *        A string identifier for the conditional timeout.
	 */
	var clearConditionalTimeout = function clearConditionalTimeout(id) {
	  clearNamedTimeout(id);
	};
	exports.clearConditionalTimeout = clearConditionalTimeout;

	/**
	 * Helpers for creating and messaging between UI components.
	 */
	var ViewHelpers = exports.ViewHelpers = {
	  /**
	   * Convenience method, dispatching a custom event.
	   *
	   * @param nsIDOMNode target
	   *        A custom target element to dispatch the event from.
	   * @param string type
	   *        The name of the event.
	   * @param any detail
	   *        The data passed when initializing the event.
	   * @return boolean
	   *         True if the event was cancelled or a registered handler
	   *         called preventDefault.
	   */
	  dispatchEvent: function (target, type, detail) {
	    if (!(target instanceof Node)) {
	      // Event cancelled.
	      return true;
	    }
	    var document = target.ownerDocument || target;
	    var dispatcher = target.ownerDocument ? target : document.documentElement;

	    var event = document.createEvent("CustomEvent");
	    event.initCustomEvent(type, true, true, detail);
	    return dispatcher.dispatchEvent(event);
	  },

	  /**
	   * Helper delegating some of the DOM attribute methods of a node to a widget.
	   *
	   * @param object widget
	   *        The widget to assign the methods to.
	   * @param nsIDOMNode node
	   *        A node to delegate the methods to.
	   */
	  delegateWidgetAttributeMethods: function (widget, node) {
	    widget.getAttribute = widget.getAttribute || node.getAttribute.bind(node);
	    widget.setAttribute = widget.setAttribute || node.setAttribute.bind(node);
	    widget.removeAttribute = widget.removeAttribute || node.removeAttribute.bind(node);
	  },

	  /**
	   * Helper delegating some of the DOM event methods of a node to a widget.
	   *
	   * @param object widget
	   *        The widget to assign the methods to.
	   * @param nsIDOMNode node
	   *        A node to delegate the methods to.
	   */
	  delegateWidgetEventMethods: function (widget, node) {
	    widget.addEventListener = widget.addEventListener || node.addEventListener.bind(node);
	    widget.removeEventListener = widget.removeEventListener || node.removeEventListener.bind(node);
	  },

	  /**
	   * Checks if the specified object looks like it's been decorated by an
	   * event emitter.
	   *
	   * @return boolean
	   *         True if it looks, walks and quacks like an event emitter.
	   */
	  isEventEmitter: function (object) {
	    return object && object.on && object.off && object.once && object.emit;
	  },

	  /**
	   * Checks if the specified object is an instance of a DOM node.
	   *
	   * @return boolean
	   *         True if it's a node, false otherwise.
	   */
	  isNode: function (object) {
	    return object instanceof Node || object instanceof Element || object instanceof DocumentFragment;
	  },

	  /**
	   * Prevents event propagation when navigation keys are pressed.
	   *
	   * @param Event e
	   *        The event to be prevented.
	   */
	  preventScrolling: function (e) {
	    switch (e.keyCode) {
	      case KeyCodes.DOM_VK_UP:
	      case KeyCodes.DOM_VK_DOWN:
	      case KeyCodes.DOM_VK_LEFT:
	      case KeyCodes.DOM_VK_RIGHT:
	      case KeyCodes.DOM_VK_PAGE_UP:
	      case KeyCodes.DOM_VK_PAGE_DOWN:
	      case KeyCodes.DOM_VK_HOME:
	      case KeyCodes.DOM_VK_END:
	        e.preventDefault();
	        e.stopPropagation();
	    }
	  },

	  /**
	   * Check if the enter key or space was pressed
	   *
	   * @param event event
	   *        The event triggered by a keypress on an element
	   */
	  isSpaceOrReturn: function (event) {
	    return event.keyCode === KeyCodes.DOM_VK_SPACE || event.keyCode === KeyCodes.DOM_VK_RETURN;
	  },

	  /**
	   * Sets a toggled pane hidden or visible. The pane can either be displayed on
	   * the side (right or left depending on the locale) or at the bottom.
	   *
	   * @param object flags
	   *        An object containing some of the following properties:
	   *        - visible: true if the pane should be shown, false to hide
	   *        - animated: true to display an animation on toggle
	   *        - delayed: true to wait a few cycles before toggle
	   *        - callback: a function to invoke when the toggle finishes
	   * @param nsIDOMNode pane
	   *        The element representing the pane to toggle.
	   */
	  togglePane: function (flags, pane) {
	    // Make sure a pane is actually available first.
	    if (!pane) {
	      return;
	    }

	    // Hiding is always handled via margins, not the hidden attribute.
	    pane.removeAttribute("hidden");

	    // Add a class to the pane to handle min-widths, margins and animations.
	    pane.classList.add("generic-toggled-pane");

	    // Avoid toggles in the middle of animation.
	    if (pane.hasAttribute("animated")) {
	      return;
	    }

	    // Avoid useless toggles.
	    if (flags.visible == !pane.classList.contains("pane-collapsed")) {
	      if (flags.callback) {
	        flags.callback();
	      }
	      return;
	    }

	    // The "animated" attributes enables animated toggles (slide in-out).
	    if (flags.animated) {
	      pane.setAttribute("animated", "");
	    } else {
	      pane.removeAttribute("animated");
	    }

	    // Computes and sets the pane margins in order to hide or show it.
	    var doToggle = () => {
	      // Negative margins are applied to "right" and "left" to support RTL and
	      // LTR directions, as well as to "bottom" to support vertical layouts.
	      // Unnecessary negative margins are forced to 0 via CSS in widgets.css.
	      if (flags.visible) {
	        pane.style.marginLeft = "0";
	        pane.style.marginRight = "0";
	        pane.style.marginBottom = "0";
	        pane.classList.remove("pane-collapsed");
	      } else {
	        var width = Math.floor(pane.getAttribute("width")) + 1;
	        var height = Math.floor(pane.getAttribute("height")) + 1;
	        pane.style.marginLeft = -width + "px";
	        pane.style.marginRight = -width + "px";
	        pane.style.marginBottom = -height + "px";
	      }

	      // Wait for the animation to end before calling afterToggle()
	      if (flags.animated) {
	        var options = {
	          useCapture: false,
	          once: true
	        };

	        pane.addEventListener("transitionend", () => {
	          // Prevent unwanted transitions: if the panel is hidden and the layout
	          // changes margins will be updated and the panel will pop out.
	          pane.removeAttribute("animated");

	          if (!flags.visible) {
	            pane.classList.add("pane-collapsed");
	          }
	          if (flags.callback) {
	            flags.callback();
	          }
	        }, options);
	      } else {
	        if (!flags.visible) {
	          pane.classList.add("pane-collapsed");
	        }

	        // Invoke the callback immediately since there's no transition.
	        if (flags.callback) {
	          flags.callback();
	        }
	      }
	    };

	    // Sometimes it's useful delaying the toggle a few ticks to ensure
	    // a smoother slide in-out animation.
	    if (flags.delayed) {
	      pane.ownerDocument.defaultView.setTimeout(doToggle, PANE_APPEARANCE_DELAY);
	    } else {
	      doToggle();
	    }
	  }
	};

	/**
	 * A generic Item is used to describe children present in a Widget.
	 *
	 * This is basically a very thin wrapper around an nsIDOMNode, with a few
	 * characteristics, like a `value` and an `attachment`.
	 *
	 * The characteristics are optional, and their meaning is entirely up to you.
	 * - The `value` should be a string, passed as an argument.
	 * - The `attachment` is any kind of primitive or object, passed as an argument.
	 *
	 * Iterable via "for (let childItem of parentItem) { }".
	 *
	 * @param object ownerView
	 *        The owner view creating this item.
	 * @param nsIDOMNode element
	 *        A prebuilt node to be wrapped.
	 * @param string value
	 *        A string identifying the node.
	 * @param any attachment
	 *        Some attached primitive/object.
	 */
	function Item(ownerView, element, value, attachment) {
	  this.ownerView = ownerView;
	  this.attachment = attachment;
	  this._value = value + "";
	  this._prebuiltNode = element;
	  this._itemsByElement = new Map();
	}

	Item.prototype = {
	  get value() {
	    return this._value;
	  },
	  get target() {
	    return this._target;
	  },
	  get prebuiltNode() {
	    return this._prebuiltNode;
	  },

	  /**
	   * Immediately appends a child item to this item.
	   *
	   * @param nsIDOMNode element
	   *        An nsIDOMNode representing the child element to append.
	   * @param object options [optional]
	   *        Additional options or flags supported by this operation:
	   *          - attachment: some attached primitive/object for the item
	   *          - attributes: a batch of attributes set to the displayed element
	   *          - finalize: function invoked when the child item is removed
	   * @return Item
	   *         The item associated with the displayed element.
	   */
	  append: function (element) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    var item = new Item(this, element, "", options.attachment);

	    // Entangle the item with the newly inserted child node.
	    // Make sure this is done with the value returned by appendChild(),
	    // to avoid storing a potential DocumentFragment.
	    this._entangleItem(item, this._target.appendChild(element));

	    // Handle any additional options after entangling the item.
	    if (options.attributes) {
	      options.attributes.forEach(e => item._target.setAttribute(e[0], e[1]));
	    }
	    if (options.finalize) {
	      item.finalize = options.finalize;
	    }

	    // Return the item associated with the displayed element.
	    return item;
	  },

	  /**
	   * Immediately removes the specified child item from this item.
	   *
	   * @param Item item
	   *        The item associated with the element to remove.
	   */
	  remove: function (item) {
	    if (!item) {
	      return;
	    }
	    this._target.removeChild(item._target);
	    this._untangleItem(item);
	  },

	  /**
	   * Entangles an item (model) with a displayed node element (view).
	   *
	   * @param Item item
	   *        The item describing a target element.
	   * @param nsIDOMNode element
	   *        The element displaying the item.
	   */
	  _entangleItem: function (item, element) {
	    this._itemsByElement.set(element, item);
	    item._target = element;
	  },

	  /**
	   * Untangles an item (model) from a displayed node element (view).
	   *
	   * @param Item item
	   *        The item describing a target element.
	   */
	  _untangleItem: function (item) {
	    if (item.finalize) {
	      item.finalize(item);
	    }
	    for (var childItem of item) {
	      item.remove(childItem);
	    }

	    this._unlinkItem(item);
	    item._target = null;
	  },

	  /**
	   * Deletes an item from the its parent's storage maps.
	   *
	   * @param Item item
	   *        The item describing a target element.
	   */
	  _unlinkItem: function (item) {
	    this._itemsByElement.delete(item._target);
	  },

	  /**
	   * Returns a string representing the object.
	   * Avoid using `toString` to avoid accidental JSONification.
	   * @return string
	   */
	  stringify: function () {
	    return JSON.stringify({
	      value: this._value,
	      target: this._target + "",
	      prebuiltNode: this._prebuiltNode + "",
	      attachment: this.attachment
	    }, null, 2);
	  },

	  _value: "",
	  _target: null,
	  _prebuiltNode: null,
	  finalize: null,
	  attachment: null
	};

	/**
	 * Some generic Widget methods handling Item instances.
	 * Iterable via "for (let childItem of wrappedView) { }".
	 *
	 * Usage:
	 *   function MyView() {
	 *     this.widget = new MyWidget(document.querySelector(".my-node"));
	 *   }
	 *
	 *   MyView.prototype = Heritage.extend(WidgetMethods, {
	 *     myMethod: function() {},
	 *     ...
	 *   });
	 *
	 * See https://gist.github.com/victorporof/5749386 for more details.
	 * The devtools/shared/widgets/SimpleListWidget.jsm is an implementation
	 * example.
	 *
	 * Language:
	 *   - An "item" is an instance of an Item.
	 *   - An "element" or "node" is a nsIDOMNode.
	 *
	 * The supplied widget can be any object implementing the following
	 * methods:
	 *   - function:nsIDOMNode insertItemAt(aIndex:number, aNode:nsIDOMNode,
	 *                                      aValue:string)
	 *   - function:nsIDOMNode getItemAtIndex(aIndex:number)
	 *   - function removeChild(aChild:nsIDOMNode)
	 *   - function removeAllItems()
	 *   - get:nsIDOMNode selectedItem()
	 *   - set selectedItem(aChild:nsIDOMNode)
	 *   - function getAttribute(aName:string)
	 *   - function setAttribute(aName:string, aValue:string)
	 *   - function removeAttribute(aName:string)
	 *   - function addEventListener(aName:string, aCallback:function,
	 *                               aBubbleFlag:boolean)
	 *   - function removeEventListener(aName:string, aCallback:function,
	 *                                  aBubbleFlag:boolean)
	 *
	 * Optional methods that can be implemented by the widget:
	 *   - function ensureElementIsVisible(aChild:nsIDOMNode)
	 *
	 * Optional attributes that may be handled (when calling
	 * get/set/removeAttribute):
	 *   - "emptyText": label temporarily added when there are no items present
	 *   - "headerText": label permanently added as a header
	 *
	 * For automagical keyboard and mouse accessibility, the widget should be an
	 * event emitter with the following events:
	 *   - "keyPress" -> (aName:string, aEvent:KeyboardEvent)
	 *   - "mousePress" -> (aName:string, aEvent:MouseEvent)
	 */
	var WidgetMethods = exports.WidgetMethods = {
	  /**
	   * Sets the element node or widget associated with this container.
	   * @param nsIDOMNode | object widget
	   */
	  set widget(widget) {
	    this._widget = widget;

	    // Can't use a WeakMap for _itemsByValue because keys are strings, and
	    // can't use one for _itemsByElement either, since it needs to be iterable.
	    this._itemsByValue = new Map();
	    this._itemsByElement = new Map();
	    this._stagedItems = [];

	    // Handle internal events emitted by the widget if necessary.
	    if (ViewHelpers.isEventEmitter(widget)) {
	      widget.on("keyPress", this._onWidgetKeyPress.bind(this));
	      widget.on("mousePress", this._onWidgetMousePress.bind(this));
	    }
	  },

	  /**
	   * Gets the element node or widget associated with this container.
	   * @return nsIDOMNode | object
	   */
	  get widget() {
	    return this._widget;
	  },

	  /**
	   * Prepares an item to be added to this container. This allows, for example,
	   * for a large number of items to be batched up before being sorted & added.
	   *
	   * If the "staged" flag is *not* set to true, the item will be immediately
	   * inserted at the correct position in this container, so that all the items
	   * still remain sorted. This can (possibly) be much slower than batching up
	   * multiple items.
	   *
	   * By default, this container assumes that all the items should be displayed
	   * sorted by their value. This can be overridden with the "index" flag,
	   * specifying on which position should an item be appended. The "staged" and
	   * "index" flags are mutually exclusive, meaning that all staged items
	   * will always be appended.
	   *
	   * @param nsIDOMNode element
	   *        A prebuilt node to be wrapped.
	   * @param string value
	   *        A string identifying the node.
	   * @param object options [optional]
	   *        Additional options or flags supported by this operation:
	   *          - attachment: some attached primitive/object for the item
	   *          - staged: true to stage the item to be appended later
	   *          - index: specifies on which position should the item be appended
	   *          - attributes: a batch of attributes set to the displayed element
	   *          - finalize: function invoked when the item is removed
	   * @return Item
	   *         The item associated with the displayed element if an unstaged push,
	   *         undefined if the item was staged for a later commit.
	   */
	  push: function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 2),
	        element = _ref2[0],
	        value = _ref2[1];

	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    var item = new Item(this, element, value, options.attachment);

	    // Batch the item to be added later.
	    if (options.staged) {
	      // An ulterior commit operation will ignore any specified index, so
	      // no reason to keep it around.
	      options.index = undefined;
	      return void this._stagedItems.push({ item: item, options: options });
	    }
	    // Find the target position in this container and insert the item there.
	    if (!("index" in options)) {
	      return this._insertItemAt(this._findExpectedIndexFor(item), item, options);
	    }
	    // Insert the item at the specified index. If negative or out of bounds,
	    // the item will be simply appended.
	    return this._insertItemAt(options.index, item, options);
	  },

	  /**
	   * Flushes all the prepared items into this container.
	   * Any specified index on the items will be ignored. Everything is appended.
	   *
	   * @param object options [optional]
	   *        Additional options or flags supported by this operation:
	   *          - sorted: true to sort all the items before adding them
	   */
	  commit: function () {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    var stagedItems = this._stagedItems;

	    // Sort the items before adding them to this container, if preferred.
	    if (options.sorted) {
	      stagedItems.sort((a, b) => this._currentSortPredicate(a.item, b.item));
	    }
	    // Append the prepared items to this container.
	    for (var _ref3 of stagedItems) {
	      var item = _ref3.item;
	      var opt = _ref3.opt;

	      this._insertItemAt(-1, item, opt);
	    }
	    // Recreate the temporary items list for ulterior pushes.
	    this._stagedItems.length = 0;
	  },

	  /**
	   * Immediately removes the specified item from this container.
	   *
	   * @param Item item
	   *        The item associated with the element to remove.
	   */
	  remove: function (item) {
	    if (!item) {
	      return;
	    }
	    this._widget.removeChild(item._target);
	    this._untangleItem(item);

	    if (!this._itemsByElement.size) {
	      this._preferredValue = this.selectedValue;
	      this._widget.selectedItem = null;
	      this._widget.setAttribute("emptyText", this._emptyText);
	    }
	  },

	  /**
	   * Removes the item at the specified index from this container.
	   *
	   * @param number index
	   *        The index of the item to remove.
	   */
	  removeAt: function (index) {
	    this.remove(this.getItemAtIndex(index));
	  },

	  /**
	   * Removes the items in this container based on a predicate.
	   */
	  removeForPredicate: function (predicate) {
	    var item = void 0;
	    while (item = this.getItemForPredicate(predicate)) {
	      this.remove(item);
	    }
	  },

	  /**
	   * Removes all items from this container.
	   */
	  empty: function () {
	    this._preferredValue = this.selectedValue;
	    this._widget.selectedItem = null;
	    this._widget.removeAllItems();
	    this._widget.setAttribute("emptyText", this._emptyText);

	    for (var _ref4 of this._itemsByElement) {
	      var _ref5 = _slicedToArray(_ref4, 2);

	      var item = _ref5[1];

	      this._untangleItem(item);
	    }

	    this._itemsByValue.clear();
	    this._itemsByElement.clear();
	    this._stagedItems.length = 0;
	  },

	  /**
	   * Ensures the specified item is visible in this container.
	   *
	   * @param Item item
	   *        The item to bring into view.
	   */
	  ensureItemIsVisible: function (item) {
	    this._widget.ensureElementIsVisible(item._target);
	  },

	  /**
	   * Ensures the item at the specified index is visible in this container.
	   *
	   * @param number index
	   *        The index of the item to bring into view.
	   */
	  ensureIndexIsVisible: function (index) {
	    this.ensureItemIsVisible(this.getItemAtIndex(index));
	  },

	  /**
	   * Sugar for ensuring the selected item is visible in this container.
	   */
	  ensureSelectedItemIsVisible: function () {
	    this.ensureItemIsVisible(this.selectedItem);
	  },

	  /**
	   * If supported by the widget, the label string temporarily added to this
	   * container when there are no child items present.
	   */
	  set emptyText(value) {
	    this._emptyText = value;

	    // Apply the emptyText attribute right now if there are no child items.
	    if (!this._itemsByElement.size) {
	      this._widget.setAttribute("emptyText", value);
	    }
	  },

	  /**
	   * If supported by the widget, the label string permanently added to this
	   * container as a header.
	   * @param string value
	   */
	  set headerText(value) {
	    this._headerText = value;
	    this._widget.setAttribute("headerText", value);
	  },

	  /**
	   * Toggles all the items in this container hidden or visible.
	   *
	   * This does not change the default filtering predicate, so newly inserted
	   * items will always be visible. Use WidgetMethods.filterContents if you care.
	   *
	   * @param boolean visibleFlag
	   *        Specifies the intended visibility.
	   */
	  toggleContents: function (visibleFlag) {
	    for (var _ref6 of this._itemsByElement) {
	      var _ref7 = _slicedToArray(_ref6, 1);

	      var element = _ref7[0];

	      element.hidden = !visibleFlag;
	    }
	  },

	  /**
	   * Toggles all items in this container hidden or visible based on a predicate.
	   *
	   * @param function predicate [optional]
	   *        Items are toggled according to the return value of this function,
	   *        which will become the new default filtering predicate in this
	   *        container.
	   *        If unspecified, all items will be toggled visible.
	   */
	  filterContents: function () {
	    var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFilterPredicate;

	    this._currentFilterPredicate = predicate;

	    for (var _ref8 of this._itemsByElement) {
	      var _ref9 = _slicedToArray(_ref8, 2);

	      var element = _ref9[0];
	      var item = _ref9[1];

	      element.hidden = !predicate(item);
	    }
	  },

	  /**
	   * Sorts all the items in this container based on a predicate.
	   *
	   * @param function predicate [optional]
	   *        Items are sorted according to the return value of the function,
	   *        which will become the new default sorting predicate in this
	   *        container. If unspecified, all items will be sorted by their value.
	   */
	  sortContents: function () {
	    var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentSortPredicate;

	    var sortedItems = this.items.sort(this._currentSortPredicate = predicate);

	    for (var i = 0, len = sortedItems.length; i < len; i++) {
	      this.swapItems(this.getItemAtIndex(i), sortedItems[i]);
	    }
	  },

	  /**
	   * Visually swaps two items in this container.
	   *
	   * @param Item first
	   *        The first item to be swapped.
	   * @param Item second
	   *        The second item to be swapped.
	   */
	  swapItems: function (first, second) {
	    if (first == second) {
	      // We're just dandy, thank you.
	      return;
	    }
	    var firstPrebuiltTarget = first._prebuiltNode,
	        firstTarget = first._target;
	    var secondPrebuiltTarget = second._prebuiltNode,
	        secondTarget = second._target;

	    // If the two items were constructed with prebuilt nodes as
	    // DocumentFragments, then those DocumentFragments are now
	    // empty and need to be reassembled.

	    if (firstPrebuiltTarget instanceof DocumentFragment) {
	      for (var node of firstTarget.childNodes) {
	        firstPrebuiltTarget.appendChild(node.cloneNode(true));
	      }
	    }
	    if (secondPrebuiltTarget instanceof DocumentFragment) {
	      for (var _node of secondTarget.childNodes) {
	        secondPrebuiltTarget.appendChild(_node.cloneNode(true));
	      }
	    }

	    // 1. Get the indices of the two items to swap.
	    var i = this._indexOfElement(firstTarget);
	    var j = this._indexOfElement(secondTarget);

	    // 2. Remeber the selection index, to reselect an item, if necessary.
	    var selectedTarget = this._widget.selectedItem;
	    var selectedIndex = -1;
	    if (selectedTarget == firstTarget) {
	      selectedIndex = i;
	    } else if (selectedTarget == secondTarget) {
	      selectedIndex = j;
	    }

	    // 3. Silently nuke both items, nobody needs to know about this.
	    this._widget.removeChild(firstTarget);
	    this._widget.removeChild(secondTarget);
	    this._unlinkItem(first);
	    this._unlinkItem(second);

	    // 4. Add the items again, but reversing their indices.
	    this._insertItemAt.apply(this, i < j ? [i, second] : [j, first]);
	    this._insertItemAt.apply(this, i < j ? [j, first] : [i, second]);

	    // 5. Restore the previous selection, if necessary.
	    if (selectedIndex == i) {
	      this._widget.selectedItem = first._target;
	    } else if (selectedIndex == j) {
	      this._widget.selectedItem = second._target;
	    }

	    // 6. Let the outside world know that these two items were swapped.
	    ViewHelpers.dispatchEvent(first.target, "swap", [second, first]);
	  },

	  /**
	   * Visually swaps two items in this container at specific indices.
	   *
	   * @param number first
	   *        The index of the first item to be swapped.
	   * @param number second
	   *        The index of the second item to be swapped.
	   */
	  swapItemsAtIndices: function (first, second) {
	    this.swapItems(this.getItemAtIndex(first), this.getItemAtIndex(second));
	  },

	  /**
	   * Checks whether an item with the specified value is among the elements
	   * shown in this container.
	   *
	   * @param string value
	   *        The item's value.
	   * @return boolean
	   *         True if the value is known, false otherwise.
	   */
	  containsValue: function (value) {
	    return this._itemsByValue.has(value) || this._stagedItems.some((_ref10) => {
	      var item = _ref10.item;
	      return item._value == value;
	    });
	  },

	  /**
	   * Gets the "preferred value". This is the latest selected item's value,
	   * remembered just before emptying this container.
	   * @return string
	   */
	  get preferredValue() {
	    return this._preferredValue;
	  },

	  /**
	   * Retrieves the item associated with the selected element.
	   * @return Item | null
	   */
	  get selectedItem() {
	    var selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._itemsByElement.get(selectedElement);
	    }
	    return null;
	  },

	  /**
	   * Retrieves the selected element's index in this container.
	   * @return number
	   */
	  get selectedIndex() {
	    var selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._indexOfElement(selectedElement);
	    }
	    return -1;
	  },

	  /**
	   * Retrieves the value of the selected element.
	   * @return string
	   */
	  get selectedValue() {
	    var selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._itemsByElement.get(selectedElement)._value;
	    }
	    return "";
	  },

	  /**
	   * Retrieves the attachment of the selected element.
	   * @return object | null
	   */
	  get selectedAttachment() {
	    var selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._itemsByElement.get(selectedElement).attachment;
	    }
	    return null;
	  },

	  _selectItem: function (item) {
	    // A falsy item is allowed to invalidate the current selection.
	    var targetElement = item ? item._target : null;
	    var prevElement = this._widget.selectedItem;

	    // Make sure the selected item's target element is focused and visible.
	    if (this.autoFocusOnSelection && targetElement) {
	      targetElement.focus();
	    }

	    if (targetElement != prevElement) {
	      this._widget.selectedItem = targetElement;
	    }
	  },

	  /**
	   * Selects the element with the entangled item in this container.
	   * @param Item | function item
	   */
	  set selectedItem(item) {
	    // A predicate is allowed to select a specific item.
	    // If no item is matched, then the current selection is removed.
	    if (typeof item == "function") {
	      item = this.getItemForPredicate(item);
	    }

	    var targetElement = item ? item._target : null;
	    var prevElement = this._widget.selectedItem;

	    if (this.maintainSelectionVisible && targetElement) {
	      // Some methods are optional. See the WidgetMethods object documentation
	      // for a comprehensive list.
	      if ("ensureElementIsVisible" in this._widget) {
	        this._widget.ensureElementIsVisible(targetElement);
	      }
	    }

	    this._selectItem(item);

	    // Prevent selecting the same item again and avoid dispatching
	    // a redundant selection event, so return early.
	    if (targetElement != prevElement) {
	      var dispTarget = targetElement || prevElement;
	      var dispName = this.suppressSelectionEvents ? "suppressed-select" : "select";
	      ViewHelpers.dispatchEvent(dispTarget, dispName, item);
	    }
	  },

	  /**
	   * Selects the element at the specified index in this container.
	   * @param number index
	   */
	  set selectedIndex(index) {
	    var targetElement = this._widget.getItemAtIndex(index);
	    if (targetElement) {
	      this.selectedItem = this._itemsByElement.get(targetElement);
	      return;
	    }
	    this.selectedItem = null;
	  },

	  /**
	   * Selects the element with the specified value in this container.
	   * @param string value
	   */
	  set selectedValue(value) {
	    this.selectedItem = this._itemsByValue.get(value);
	  },

	  /**
	   * Deselects and re-selects an item in this container.
	   *
	   * Useful when you want a "select" event to be emitted, even though
	   * the specified item was already selected.
	   *
	   * @param Item | function item
	   * @see `set selectedItem`
	   */
	  forceSelect: function (item) {
	    this.selectedItem = null;
	    this.selectedItem = item;
	  },

	  /**
	   * Specifies if this container should try to keep the selected item visible.
	   * (For example, when new items are added the selection is brought into view).
	   */
	  maintainSelectionVisible: true,

	  /**
	   * Specifies if "select" events dispatched from the elements in this container
	   * when their respective items are selected should be suppressed or not.
	   *
	   * If this flag is set to true, then consumers of this container won't
	   * be normally notified when items are selected.
	   */
	  suppressSelectionEvents: false,

	  /**
	   * Focus this container the first time an element is inserted?
	   *
	   * If this flag is set to true, then when the first item is inserted in
	   * this container (and thus it's the only item available), its corresponding
	   * target element is focused as well.
	   */
	  autoFocusOnFirstItem: true,

	  /**
	   * Focus on selection?
	   *
	   * If this flag is set to true, then whenever an item is selected in
	   * this container (e.g. via the selectedIndex or selectedItem setters),
	   * its corresponding target element is focused as well.
	   *
	   * You can disable this flag, for example, to maintain a certain node
	   * focused but visually indicate a different selection in this container.
	   */
	  autoFocusOnSelection: true,

	  /**
	   * Focus on input (e.g. mouse click)?
	   *
	   * If this flag is set to true, then whenever an item receives user input in
	   * this container, its corresponding target element is focused as well.
	   */
	  autoFocusOnInput: true,

	  /**
	   * When focusing on input, allow right clicks?
	   * @see WidgetMethods.autoFocusOnInput
	   */
	  allowFocusOnRightClick: false,

	  /**
	   * The number of elements in this container to jump when Page Up or Page Down
	   * keys are pressed. If falsy, then the page size will be based on the
	   * number of visible items in the container.
	   */
	  pageSize: 0,

	  /**
	   * Focuses the first visible item in this container.
	   */
	  focusFirstVisibleItem: function () {
	    this.focusItemAtDelta(-this.itemCount);
	  },

	  /**
	   * Focuses the last visible item in this container.
	   */
	  focusLastVisibleItem: function () {
	    this.focusItemAtDelta(+this.itemCount);
	  },

	  /**
	   * Focuses the next item in this container.
	   */
	  focusNextItem: function () {
	    this.focusItemAtDelta(+1);
	  },

	  /**
	   * Focuses the previous item in this container.
	   */
	  focusPrevItem: function () {
	    this.focusItemAtDelta(-1);
	  },

	  /**
	   * Focuses another item in this container based on the index distance
	   * from the currently focused item.
	   *
	   * @param number delta
	   *        A scalar specifying by how many items should the selection change.
	   */
	  focusItemAtDelta: function (delta) {
	    // Make sure the currently selected item is also focused, so that the
	    // command dispatcher mechanism has a relative node to work with.
	    // If there's no selection, just select an item at a corresponding index
	    // (e.g. the first item in this container if delta <= 1).
	    var selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      selectedElement.focus();
	    } else {
	      this.selectedIndex = Math.max(0, delta - 1);
	      return;
	    }

	    var direction = delta > 0 ? "advanceFocus" : "rewindFocus";
	    var distance = Math.abs(Math[delta > 0 ? "ceil" : "floor"](delta));
	    while (distance--) {
	      if (!this._focusChange(direction)) {
	        // Out of bounds.
	        break;
	      }
	    }

	    // Synchronize the selected item as being the currently focused element.
	    this.selectedItem = this.getItemForElement(this._focusedElement);
	  },

	  /**
	   * Focuses the next or previous item in this container.
	   *
	   * @param string direction
	   *        Either "advanceFocus" or "rewindFocus".
	   * @return boolean
	   *         False if the focus went out of bounds and the first or last item
	   *         in this container was focused instead.
	   */
	  _focusChange: function (direction) {
	    var commandDispatcher = this._commandDispatcher;
	    var prevFocusedElement = commandDispatcher.focusedElement;
	    var currFocusedElement = void 0;

	    do {
	      commandDispatcher.suppressFocusScroll = true;
	      commandDispatcher[direction]();
	      currFocusedElement = commandDispatcher.focusedElement;

	      // Make sure the newly focused item is a part of this container. If the
	      // focus goes out of bounds, revert the previously focused item.
	      if (!this.getItemForElement(currFocusedElement)) {
	        prevFocusedElement.focus();
	        return false;
	      }
	    } while (!WIDGET_FOCUSABLE_NODES.has(currFocusedElement.tagName));

	    // Focus remained within bounds.
	    return true;
	  },

	  /**
	   * Gets the command dispatcher instance associated with this container's DOM.
	   * If there are no items displayed in this container, null is returned.
	   * @return nsIDOMXULCommandDispatcher | null
	   */
	  get _commandDispatcher() {
	    if (this._cachedCommandDispatcher) {
	      return this._cachedCommandDispatcher;
	    }
	    var someElement = this._widget.getItemAtIndex(0);
	    if (someElement) {
	      var commandDispatcher = someElement.ownerDocument.commandDispatcher;
	      this._cachedCommandDispatcher = commandDispatcher;
	      return commandDispatcher;
	    }
	    return null;
	  },

	  /**
	   * Gets the currently focused element in this container.
	   *
	   * @return nsIDOMNode
	   *         The focused element, or null if nothing is found.
	   */
	  get _focusedElement() {
	    var commandDispatcher = this._commandDispatcher;
	    if (commandDispatcher) {
	      return commandDispatcher.focusedElement;
	    }
	    return null;
	  },

	  /**
	   * Gets the item in the container having the specified index.
	   *
	   * @param number index
	   *        The index used to identify the element.
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemAtIndex: function (index) {
	    return this.getItemForElement(this._widget.getItemAtIndex(index));
	  },

	  /**
	   * Gets the item in the container having the specified value.
	   *
	   * @param string value
	   *        The value used to identify the element.
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemByValue: function (value) {
	    return this._itemsByValue.get(value);
	  },

	  /**
	   * Gets the item in the container associated with the specified element.
	   *
	   * @param nsIDOMNode element
	   *        The element used to identify the item.
	   * @param object flags [optional]
	   *        Additional options for showing the source. Supported options:
	   *          - noSiblings: if siblings shouldn't be taken into consideration
	   *                        when searching for the associated item.
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemForElement: function (element) {
	    var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    while (element) {
	      var item = this._itemsByElement.get(element);

	      // Also search the siblings if allowed.
	      if (!flags.noSiblings) {
	        item = item || this._itemsByElement.get(element.nextElementSibling) || this._itemsByElement.get(element.previousElementSibling);
	      }
	      if (item) {
	        return item;
	      }
	      element = element.parentNode;
	    }
	    return null;
	  },

	  /**
	   * Gets a visible item in this container validating a specified predicate.
	   *
	   * @param function predicate
	   *        The first item which validates this predicate is returned
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemForPredicate: function (predicate) {
	    var owner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;

	    // Recursively check the items in this widget for a predicate match.
	    for (var _ref11 of owner._itemsByElement) {
	      var _ref12 = _slicedToArray(_ref11, 2);

	      var element = _ref12[0];
	      var item = _ref12[1];

	      var match = void 0;
	      if (predicate(item) && !element.hidden) {
	        match = item;
	      } else {
	        match = this.getItemForPredicate(predicate, item);
	      }
	      if (match) {
	        return match;
	      }
	    }
	    // Also check the staged items. No need to do this recursively since
	    // they're not even appended to the view yet.
	    for (var _ref13 of this._stagedItems) {
	      var _item = _ref13.item;

	      if (predicate(_item)) {
	        return _item;
	      }
	    }
	    return null;
	  },

	  /**
	   * Shortcut function for getItemForPredicate which works on item attachments.
	   * @see getItemForPredicate
	   */
	  getItemForAttachment: function (predicate) {
	    var owner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;

	    return this.getItemForPredicate(e => predicate(e.attachment));
	  },

	  /**
	   * Finds the index of an item in the container.
	   *
	   * @param Item item
	   *        The item get the index for.
	   * @return number
	   *         The index of the matched item, or -1 if nothing is found.
	   */
	  indexOfItem: function (item) {
	    return this._indexOfElement(item._target);
	  },

	  /**
	   * Finds the index of an element in the container.
	   *
	   * @param nsIDOMNode element
	   *        The element get the index for.
	   * @return number
	   *         The index of the matched element, or -1 if nothing is found.
	   */
	  _indexOfElement: function (element) {
	    for (var i = 0; i < this._itemsByElement.size; i++) {
	      if (this._widget.getItemAtIndex(i) == element) {
	        return i;
	      }
	    }
	    return -1;
	  },

	  /**
	   * Gets the total number of items in this container.
	   * @return number
	   */
	  get itemCount() {
	    return this._itemsByElement.size;
	  },

	  /**
	   * Returns a list of items in this container, in the displayed order.
	   * @return array
	   */
	  get items() {
	    var store = [];
	    var itemCount = this.itemCount;
	    for (var i = 0; i < itemCount; i++) {
	      store.push(this.getItemAtIndex(i));
	    }
	    return store;
	  },

	  /**
	   * Returns a list of values in this container, in the displayed order.
	   * @return array
	   */
	  get values() {
	    return this.items.map(e => e._value);
	  },

	  /**
	   * Returns a list of attachments in this container, in the displayed order.
	   * @return array
	   */
	  get attachments() {
	    return this.items.map(e => e.attachment);
	  },

	  /**
	   * Returns a list of all the visible (non-hidden) items in this container,
	   * in the displayed order
	   * @return array
	   */
	  get visibleItems() {
	    return this.items.filter(e => !e._target.hidden);
	  },

	  /**
	   * Checks if an item is unique in this container. If an item's value is an
	   * empty string, "undefined" or "null", it is considered unique.
	   *
	   * @param Item item
	   *        The item for which to verify uniqueness.
	   * @return boolean
	   *         True if the item is unique, false otherwise.
	   */
	  isUnique: function (item) {
	    var value = item._value;
	    if (value == "" || value == "undefined" || value == "null") {
	      return true;
	    }
	    return !this._itemsByValue.has(value);
	  },

	  /**
	   * Checks if an item is eligible for this container. By default, this checks
	   * whether an item is unique and has a prebuilt target node.
	   *
	   * @param Item item
	   *        The item for which to verify eligibility.
	   * @return boolean
	   *         True if the item is eligible, false otherwise.
	   */
	  isEligible: function (item) {
	    return this.isUnique(item) && item._prebuiltNode;
	  },

	  /**
	   * Finds the expected item index in this container based on the default
	   * sort predicate.
	   *
	   * @param Item item
	   *        The item for which to get the expected index.
	   * @return number
	   *         The expected item index.
	   */
	  _findExpectedIndexFor: function (item) {
	    var itemCount = this.itemCount;
	    for (var i = 0; i < itemCount; i++) {
	      if (this._currentSortPredicate(this.getItemAtIndex(i), item) > 0) {
	        return i;
	      }
	    }
	    return itemCount;
	  },

	  /**
	   * Immediately inserts an item in this container at the specified index.
	   *
	   * @param number index
	   *        The position in the container intended for this item.
	   * @param Item item
	   *        The item describing a target element.
	   * @param object options [optional]
	   *        Additional options or flags supported by this operation:
	   *          - attributes: a batch of attributes set to the displayed element
	   *          - finalize: function when the item is untangled (removed)
	   * @return Item
	   *         The item associated with the displayed element, null if rejected.
	   */
	  _insertItemAt: function (index, item) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    if (!this.isEligible(item)) {
	      return null;
	    }

	    // Entangle the item with the newly inserted node.
	    // Make sure this is done with the value returned by insertItemAt(),
	    // to avoid storing a potential DocumentFragment.
	    var node = item._prebuiltNode;
	    var attachment = item.attachment;
	    this._entangleItem(item, this._widget.insertItemAt(index, node, attachment));

	    // Handle any additional options after entangling the item.
	    if (!this._currentFilterPredicate(item)) {
	      item._target.hidden = true;
	    }
	    if (this.autoFocusOnFirstItem && this._itemsByElement.size == 1) {
	      item._target.focus();
	    }
	    if (options.attributes) {
	      options.attributes.forEach(e => item._target.setAttribute(e[0], e[1]));
	    }
	    if (options.finalize) {
	      item.finalize = options.finalize;
	    }

	    // Hide the empty text if the selection wasn't lost.
	    this._widget.removeAttribute("emptyText");

	    // Return the item associated with the displayed element.
	    return item;
	  },

	  /**
	   * Entangles an item (model) with a displayed node element (view).
	   *
	   * @param Item item
	   *        The item describing a target element.
	   * @param nsIDOMNode element
	   *        The element displaying the item.
	   */
	  _entangleItem: function (item, element) {
	    this._itemsByValue.set(item._value, item);
	    this._itemsByElement.set(element, item);
	    item._target = element;
	  },

	  /**
	   * Untangles an item (model) from a displayed node element (view).
	   *
	   * @param Item item
	   *        The item describing a target element.
	   */
	  _untangleItem: function (item) {
	    if (item.finalize) {
	      item.finalize(item);
	    }
	    for (var childItem of item) {
	      item.remove(childItem);
	    }

	    this._unlinkItem(item);
	    item._target = null;
	  },

	  /**
	   * Deletes an item from the its parent's storage maps.
	   *
	   * @param Item item
	   *        The item describing a target element.
	   */
	  _unlinkItem: function (item) {
	    this._itemsByValue.delete(item._value);
	    this._itemsByElement.delete(item._target);
	  },

	  /**
	   * The keyPress event listener for this container.
	   * @param string name
	   * @param KeyboardEvent event
	   */
	  _onWidgetKeyPress: function (name, event) {
	    // Prevent scrolling when pressing navigation keys.
	    ViewHelpers.preventScrolling(event);

	    switch (event.keyCode) {
	      case KeyCodes.DOM_VK_UP:
	      case KeyCodes.DOM_VK_LEFT:
	        this.focusPrevItem();
	        break;
	      case KeyCodes.DOM_VK_DOWN:
	      case KeyCodes.DOM_VK_RIGHT:
	        this.focusNextItem();
	        break;
	      case KeyCodes.DOM_VK_PAGE_UP:
	        this.focusItemAtDelta(-(this.pageSize || this.itemCount / PAGE_SIZE_ITEM_COUNT_RATIO));
	        break;
	      case KeyCodes.DOM_VK_PAGE_DOWN:
	        this.focusItemAtDelta(+(this.pageSize || this.itemCount / PAGE_SIZE_ITEM_COUNT_RATIO));
	        break;
	      case KeyCodes.DOM_VK_HOME:
	        this.focusFirstVisibleItem();
	        break;
	      case KeyCodes.DOM_VK_END:
	        this.focusLastVisibleItem();
	        break;
	    }
	  },

	  /**
	   * The mousePress event listener for this container.
	   * @param string name
	   * @param MouseEvent event
	   */
	  _onWidgetMousePress: function (name, event) {
	    if (event.button != 0 && !this.allowFocusOnRightClick) {
	      // Only allow left-click to trigger this event.
	      return;
	    }

	    var item = this.getItemForElement(event.target);
	    if (item) {
	      // The container is not empty and we clicked on an actual item.
	      this.selectedItem = item;
	      // Make sure the current event's target element is also focused.
	      this.autoFocusOnInput && item._target.focus();
	    }
	  },

	  /**
	   * The predicate used when filtering items. By default, all items in this
	   * view are visible.
	   *
	   * @param Item item
	   *        The item passing through the filter.
	   * @return boolean
	   *         True if the item should be visible, false otherwise.
	   */
	  _currentFilterPredicate: function (item) {
	    return true;
	  },

	  /**
	   * The predicate used when sorting items. By default, items in this view
	   * are sorted by their label.
	   *
	   * @param Item first
	   *        The first item used in the comparison.
	   * @param Item second
	   *        The second item used in the comparison.
	   * @return number
	   *         -1 to sort first to a lower index than second
	   *          0 to leave first and second unchanged with respect to each other
	   *          1 to sort second to a lower index than first
	   */
	  _currentSortPredicate: function (first, second) {
	    return +(first._value.toLowerCase() > second._value.toLowerCase());
	  },

	  /**
	   * Call a method on this widget named `methodName`. Any further arguments are
	   * passed on to the method. Returns the result of the method call.
	   *
	   * @param String methodName
	   *        The name of the method you want to call.
	   * @param args
	   *        Optional. Any arguments you want to pass through to the method.
	   */
	  callMethod: function (methodName) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    return this._widget[methodName].apply(this._widget, args);
	  },

	  _widget: null,
	  _emptyText: "",
	  _headerText: "",
	  _preferredValue: "",
	  _cachedCommandDispatcher: null
	};

	/**
	 * A generator-iterator over all the items in this container.
	 */
	Item.prototype[Symbol.iterator] = WidgetMethods[Symbol.iterator] = function* () {
	  yield* this._itemsByElement.values();
	};

/***/ },
/* 880 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	var promise = __webpack_require__(839);
	var EventEmitter = __webpack_require__(844);

	/* const { DebuggerServer } = require("../../server/main");*/

	var _require = __webpack_require__(862),
	    DebuggerClient = _require.DebuggerClient;

	var targets = new WeakMap();
	var promiseTargets = new WeakMap();

	/**
	 * Functions for creating Targets
	 */
	exports.TargetFactory = {
	  /**
	   * Construct a Target
	   * @param {XULTab} tab
	   *        The tab to use in creating a new target.
	   *
	   * @return A target object
	   */
	  forTab: function (tab) {
	    var target = targets.get(tab);
	    if (target == null) {
	      target = new TabTarget(tab);
	      targets.set(tab, target);
	    }
	    return target;
	  },

	  /**
	   * Return a promise of a Target for a remote tab.
	   * @param {Object} options
	   *        The options object has the following properties:
	   *        {
	   *          form: the remote protocol form of a tab,
	   *          client: a DebuggerClient instance
	   *                  (caller owns this and is responsible for closing),
	   *          chrome: true if the remote target is the whole process
	   *        }
	   *
	   * @return A promise of a target object
	   */
	  forRemoteTab: function (options) {
	    var targetPromise = promiseTargets.get(options);
	    if (targetPromise == null) {
	      var target = new TabTarget(options);
	      targetPromise = target.makeRemote().then(() => target);
	      promiseTargets.set(options, targetPromise);
	    }
	    return targetPromise;
	  },

	  forWorker: function (workerClient) {
	    var target = targets.get(workerClient);
	    if (target == null) {
	      target = new WorkerTarget(workerClient);
	      targets.set(workerClient, target);
	    }
	    return target;
	  },

	  /**
	   * Creating a target for a tab that is being closed is a problem because it
	   * allows a leak as a result of coming after the close event which normally
	   * clears things up. This function allows us to ask if there is a known
	   * target for a tab without creating a target
	   * @return true/false
	   */
	  isKnownTab: function (tab) {
	    return targets.has(tab);
	  }
	};

	/**
	 * A Target represents something that we can debug. Targets are generally
	 * read-only. Any changes that you wish to make to a target should be done via
	 * a Tool that attaches to the target. i.e. a Target is just a pointer saying
	 * "the thing to debug is over there".
	 *
	 * Providing a generalized abstraction of a web-page or web-browser (available
	 * either locally or remotely) is beyond the scope of this class (and maybe
	 * also beyond the scope of this universe) However Target does attempt to
	 * abstract some common events and read-only properties common to many Tools.
	 *
	 * Supported read-only properties:
	 * - name, isRemote, url
	 *
	 * Target extends EventEmitter and provides support for the following events:
	 * - close: The target window has been closed. All tools attached to this
	 *          target should close. This event is not currently cancelable.
	 * - navigate: The target window has navigated to a different URL
	 *
	 * Optional events:
	 * - will-navigate: The target window will navigate to a different URL
	 * - hidden: The target is not visible anymore (for TargetTab, another tab is
	 *           selected)
	 * - visible: The target is visible (for TargetTab, tab is selected)
	 *
	 * Comparing Targets: 2 instances of a Target object can point at the same
	 * thing, so t1 !== t2 and t1 != t2 even when they represent the same object.
	 * To compare to targets use 't1.equals(t2)'.
	 */

	/**
	 * A TabTarget represents a page living in a browser tab. Generally these will
	 * be web pages served over http(s), but they don't have to be.
	 */
	function TabTarget(tab) {
	  EventEmitter.decorate(this);
	  this.destroy = this.destroy.bind(this);
	  this._handleThreadState = this._handleThreadState.bind(this);
	  this.on("thread-resumed", this._handleThreadState);
	  this.on("thread-paused", this._handleThreadState);
	  this.activeTab = this.activeConsole = null;
	  // Only real tabs need initialization here. Placeholder objects for remote
	  // targets will be initialized after a makeRemote method call.
	  if (tab && !["client", "form", "chrome"].every(tab.hasOwnProperty, tab)) {
	    this._tab = tab;
	    this._setupListeners();
	  } else {
	    this._form = tab.form;
	    this._client = tab.client;
	    this._chrome = tab.chrome;
	  }
	  // Default isTabActor to true if not explicitly specified
	  if (typeof tab.isTabActor == "boolean") {
	    this._isTabActor = tab.isTabActor;
	  } else {
	    this._isTabActor = true;
	  }
	}

	TabTarget.prototype = {
	  _webProgressListener: null,

	  /**
	   * Returns a promise for the protocol description from the root actor. Used
	   * internally with `target.actorHasMethod`. Takes advantage of caching if
	   * definition was fetched previously with the corresponding actor information.
	   * Actors are lazily loaded, so not only must the tool using a specific actor
	   * be in use, the actors are only registered after invoking a method (for
	   * performance reasons, added in bug 988237), so to use these actor detection
	   * methods, one must already be communicating with a specific actor of that
	   * type.
	   *
	   * Must be a remote target.
	   *
	   * @return {Promise}
	   * {
	   *   "category": "actor",
	   *   "typeName": "longstractor",
	   *   "methods": [{
	   *     "name": "substring",
	   *     "request": {
	   *       "type": "substring",
	   *       "start": {
	   *         "_arg": 0,
	   *         "type": "primitive"
	   *       },
	   *       "end": {
	   *         "_arg": 1,
	   *         "type": "primitive"
	   *       }
	   *     },
	   *     "response": {
	   *       "substring": {
	   *         "_retval": "primitive"
	   *       }
	   *     }
	   *   }],
	   *  "events": {}
	   * }
	   */
	  getActorDescription: function (actorName) {
	    if (!this.client) {
	      throw new Error("TabTarget#getActorDescription() can only be called on " + "remote tabs.");
	    }

	    var deferred = promise.defer();

	    if (this._protocolDescription && this._protocolDescription.types[actorName]) {
	      deferred.resolve(this._protocolDescription.types[actorName]);
	    } else {
	      this.client.mainRoot.protocolDescription(description => {
	        this._protocolDescription = description;
	        deferred.resolve(description.types[actorName]);
	      });
	    }

	    return deferred.promise;
	  },

	  /**
	   * Returns a boolean indicating whether or not the specific actor
	   * type exists. Must be a remote target.
	   *
	   * @param {String} actorName
	   * @return {Boolean}
	   */
	  hasActor: function (actorName) {
	    if (!this.client) {
	      throw new Error("TabTarget#hasActor() can only be called on remote " + "tabs.");
	    }
	    if (this.form) {
	      return !!this.form[actorName + "Actor"];
	    }
	    return false;
	  },

	  /**
	   * Queries the protocol description to see if an actor has
	   * an available method. The actor must already be lazily-loaded (read
	   * the restrictions in the `getActorDescription` comments),
	   * so this is for use inside of tool. Returns a promise that
	   * resolves to a boolean. Must be a remote target.
	   *
	   * @param {String} actorName
	   * @param {String} methodName
	   * @return {Promise}
	   */
	  actorHasMethod: function (actorName, methodName) {
	    if (!this.client) {
	      throw new Error("TabTarget#actorHasMethod() can only be called on " + "remote tabs.");
	    }
	    return this.getActorDescription(actorName).then(desc => {
	      if (desc && desc.methods) {
	        return !!desc.methods.find(method => method.name === methodName);
	      }
	      return false;
	    });
	  },

	  /**
	   * Returns a trait from the root actor.
	   *
	   * @param {String} traitName
	   * @return {Mixed}
	   */
	  getTrait: function (traitName) {
	    if (!this.client) {
	      throw new Error("TabTarget#getTrait() can only be called on remote " + "tabs.");
	    }

	    // If the targeted actor exposes traits and has a defined value for this
	    // traits, override the root actor traits
	    if (this.form.traits && traitName in this.form.traits) {
	      return this.form.traits[traitName];
	    }

	    return this.client.traits[traitName];
	  },

	  get tab() {
	    return this._tab;
	  },

	  get form() {
	    return this._form;
	  },

	  // Get a promise of the root form returned by a listTabs request. This promise
	  // is cached.
	  get root() {
	    if (!this._root) {
	      this._root = this._getRoot();
	    }
	    return this._root;
	  },

	  _getRoot: function () {
	    return new Promise((resolve, reject) => {
	      this.client.listTabs(response => {
	        if (response.error) {
	          reject(new Error(response.error + ": " + response.message));
	          return;
	        }

	        resolve(response);
	      });
	    });
	  },

	  get client() {
	    return this._client;
	  },

	  // Tells us if we are debugging content document
	  // or if we are debugging chrome stuff.
	  // Allows to controls which features are available against
	  // a chrome or a content document.
	  get chrome() {
	    return this._chrome;
	  },

	  // Tells us if the related actor implements TabActor interface
	  // and requires to call `attach` request before being used
	  // and `detach` during cleanup
	  get isTabActor() {
	    return this._isTabActor;
	  },

	  get window() {
	    // XXX - this is a footgun for e10s - there .contentWindow will be null,
	    // and even though .contentWindowAsCPOW *might* work, it will not work
	    // in all contexts.  Consumers of .window need to be refactored to not
	    // rely on this.
	    // if (Services.appinfo.processType != Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT) {
	    //   console.error("The .window getter on devtools' |target| object isn't " +
	    //                  "e10s friendly!\n" + Error().stack);
	    // }
	    // Be extra careful here, since this may be called by HS_getHudByWindow
	    // during shutdown.
	    if (this._tab && this._tab.linkedBrowser) {
	      return this._tab.linkedBrowser.contentWindow;
	    }
	    return null;
	  },

	  get name() {
	    if (this._tab && this._tab.linkedBrowser.contentDocument) {
	      return this._tab.linkedBrowser.contentDocument.title;
	    }
	    if (this.isAddon) {
	      return this._form.name;
	    }
	    return this._form.title;
	  },

	  get url() {
	    return this._tab ? this._tab.linkedBrowser.currentURI.spec : this._form.url;
	  },

	  get isRemote() {
	    return !this.isLocalTab;
	  },

	  get isAddon() {
	    return !!(this._form && this._form.actor && this._form.actor.match(/conn\d+\.addon\d+/));
	  },

	  get isLocalTab() {
	    return !!this._tab;
	  },

	  get isMultiProcess() {
	    return !this.window;
	  },

	  get isThreadPaused() {
	    return !!this._isThreadPaused;
	  },

	  /**
	   * Adds remote protocol capabilities to the target, so that it can be used
	   * for tools that support the Remote Debugging Protocol even for local
	   * connections.
	   */
	  makeRemote: function () {
	    if (this._remote) {
	      return this._remote.promise;
	    }

	    this._remote = promise.defer();

	    if (this.isLocalTab) {
	      // Since a remote protocol connection will be made, let's start the
	      // DebuggerServer here, once and for all tools.
	      if (!DebuggerServer.initialized) {
	        DebuggerServer.init();
	        DebuggerServer.addBrowserActors();
	      }

	      this._client = new DebuggerClient(DebuggerServer.connectPipe());
	      // A local TabTarget will never perform chrome debugging.
	      this._chrome = false;
	    }

	    this._setupRemoteListeners();

	    var attachTab = () => {
	      this._client.attachTab(this._form.actor, (response, tabClient) => {
	        if (!tabClient) {
	          this._remote.reject("Unable to attach to the tab");
	          return;
	        }
	        this.activeTab = tabClient;
	        this.threadActor = response.threadActor;
	        attachConsole();
	      });
	    };

	    var onConsoleAttached = (response, consoleClient) => {
	      if (!consoleClient) {
	        this._remote.reject("Unable to attach to the console");
	        return;
	      }
	      this.activeConsole = consoleClient;
	      this._remote.resolve(null);
	    };

	    var attachConsole = () => {
	      this._client.attachConsole(this._form.consoleActor, ["NetworkActivity"], onConsoleAttached);
	    };

	    if (this.isLocalTab) {
	      this._client.connect(() => {
	        this._client.getTab({ tab: this.tab }).then(response => {
	          this._form = response.tab;
	          attachTab();
	        });
	      });
	    } else if (this.isTabActor) {
	      // In the remote debugging case, the protocol connection will have been
	      // already initialized in the connection screen code.
	      attachTab();
	    } else {
	      // AddonActor and chrome debugging on RootActor doesn't inherits from
	      // TabActor and doesn't need to be attached.
	      attachConsole();
	    }

	    return this._remote.promise;
	  },

	  /**
	   * Listen to the different events.
	   */
	  _setupListeners: function () {
	    this._webProgressListener = new TabWebProgressListener(this);
	    this.tab.linkedBrowser.addProgressListener(this._webProgressListener);
	    this.tab.addEventListener("TabClose", this);
	    this.tab.parentNode.addEventListener("TabSelect", this);
	    this.tab.ownerDocument.defaultView.addEventListener("unload", this);
	  },

	  /**
	   * Teardown event listeners.
	   */
	  _teardownListeners: function () {
	    if (this._webProgressListener) {
	      this._webProgressListener.destroy();
	    }

	    this._tab.ownerDocument.defaultView.removeEventListener("unload", this);
	    this._tab.removeEventListener("TabClose", this);
	    this._tab.parentNode.removeEventListener("TabSelect", this);
	  },

	  /**
	   * Setup listeners for remote debugging, updating existing ones as necessary.
	   */
	  _setupRemoteListeners: function () {
	    this.client.addListener("closed", this.destroy);

	    this._onTabDetached = (aType, aPacket) => {
	      // We have to filter message to ensure that this detach is for this tab
	      if (aPacket.from == this._form.actor) {
	        this.destroy();
	      }
	    };
	    this.client.addListener("tabDetached", this._onTabDetached);

	    this._onTabNavigated = (aType, aPacket) => {
	      var event = Object.create(null);
	      event.url = aPacket.url;
	      event.title = aPacket.title;
	      event.nativeConsoleAPI = aPacket.nativeConsoleAPI;
	      event.isFrameSwitching = aPacket.isFrameSwitching;
	      // Send any stored event payload (DOMWindow or nsIRequest) for backwards
	      // compatibility with non-remotable tools.
	      if (aPacket.state == "start") {
	        event._navPayload = this._navRequest;
	        this.emit("will-navigate", event);
	        this._navRequest = null;
	      } else {
	        event._navPayload = this._navWindow;
	        this.emit("navigate", event);
	        this._navWindow = null;
	      }
	    };
	    this.client.addListener("tabNavigated", this._onTabNavigated);

	    this._onFrameUpdate = (aType, aPacket) => {
	      this.emit("frame-update", aPacket);
	    };
	    this.client.addListener("frameUpdate", this._onFrameUpdate);
	  },

	  /**
	   * Teardown listeners for remote debugging.
	   */
	  _teardownRemoteListeners: function () {
	    this.client.removeListener("closed", this.destroy);
	    this.client.removeListener("tabNavigated", this._onTabNavigated);
	    this.client.removeListener("tabDetached", this._onTabDetached);
	    this.client.removeListener("frameUpdate", this._onFrameUpdate);
	  },

	  /**
	   * Handle tabs events.
	   */
	  handleEvent: function (event) {
	    switch (event.type) {
	      case "TabClose":
	      case "unload":
	        this.destroy();
	        break;
	      case "TabSelect":
	        if (this.tab.selected) {
	          this.emit("visible", event);
	        } else {
	          this.emit("hidden", event);
	        }
	        break;
	    }
	  },

	  /**
	   * Handle script status.
	   */
	  _handleThreadState: function (event) {
	    switch (event) {
	      case "thread-resumed":
	        this._isThreadPaused = false;
	        break;
	      case "thread-paused":
	        this._isThreadPaused = true;
	        break;
	    }
	  },

	  /**
	   * Target is not alive anymore.
	   */
	  destroy: function () {
	    // If several things call destroy then we give them all the same
	    // destruction promise so we're sure to destroy only once
	    if (this._destroyer) {
	      return this._destroyer.promise;
	    }

	    this._destroyer = promise.defer();

	    // Before taking any action, notify listeners that destruction is imminent.
	    this.emit("close");

	    // First of all, do cleanup tasks that pertain to both remoted and
	    // non-remoted targets.
	    this.off("thread-resumed", this._handleThreadState);
	    this.off("thread-paused", this._handleThreadState);

	    if (this._tab) {
	      this._teardownListeners();
	    }

	    var cleanupAndResolve = () => {
	      this._cleanup();
	      this._destroyer.resolve(null);
	    };
	    // If this target was not remoted, the promise will be resolved before the
	    // function returns.
	    if (this._tab && !this._client) {
	      cleanupAndResolve();
	    } else if (this._client) {
	      // If, on the other hand, this target was remoted, the promise will be
	      // resolved after the remote connection is closed.
	      this._teardownRemoteListeners();

	      if (this.isLocalTab) {
	        // We started with a local tab and created the client ourselves, so we
	        // should close it.
	        this._client.close(cleanupAndResolve);
	      } else if (this.activeTab) {
	        // The client was handed to us, so we are not responsible for closing
	        // it. We just need to detach from the tab, if already attached.
	        // |detach| may fail if the connection is already dead, so proceed with
	        // cleanup directly after this.
	        this.activeTab.detach();
	        cleanupAndResolve();
	      } else {
	        cleanupAndResolve();
	      }
	    }

	    return this._destroyer.promise;
	  },

	  /**
	   * Clean up references to what this target points to.
	   */
	  _cleanup: function () {
	    if (this._tab) {
	      targets.delete(this._tab);
	    } else {
	      promiseTargets.delete(this._form);
	    }
	    this.activeTab = null;
	    this.activeConsole = null;
	    this._client = null;
	    this._tab = null;
	    this._form = null;
	    this._remote = null;
	  },

	  toString: function () {
	    var id = this._tab ? this._tab : this._form && this._form.actor;
	    return `TabTarget:${id}`;
	  }
	};

	function WorkerTarget(workerClient) {
	  EventEmitter.decorate(this);
	  this._workerClient = workerClient;
	}

	/**
	 * A WorkerTarget represents a worker. Unlike TabTarget, which can represent
	 * either a local or remote tab, WorkerTarget always represents a remote worker.
	 * Moreover, unlike TabTarget, which is constructed with a placeholder object
	 * for remote tabs (from which a TabClient can then be lazily obtained),
	 * WorkerTarget is constructed with a WorkerClient directly.
	 *
	 * WorkerClient is designed to mimic the interface of TabClient as closely as
	 * possible. This allows us to debug workers as if they were ordinary tabs,
	 * requiring only minimal changes to the rest of the frontend.
	 */
	WorkerTarget.prototype = {
	  destroy: function () {},

	  get isRemote() {
	    return true;
	  },

	  get isTabActor() {
	    return true;
	  },

	  get url() {
	    return this._workerClient.url;
	  },

	  get isWorkerTarget() {
	    return true;
	  },

	  get form() {
	    return {
	      consoleActor: this._workerClient.consoleActor
	    };
	  },

	  get activeTab() {
	    return this._workerClient;
	  },

	  get client() {
	    return this._workerClient.client;
	  },

	  destroy: function () {},

	  hasActor: function (name) {
	    return false;
	  },

	  getTrait: function () {
	    return undefined;
	  },

	  makeRemote: function () {
	    return Promise.resolve();
	  }
	};

/***/ },
/* 881 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	// MOCK FOR TimelineFront

	class TimelineFront {
	  constructor(client, _ref) {
	    var timelineActor = _ref.timelineActor;
	  }
	  start(_ref2) {
	    var withDocLoadingEvents = _ref2.withDocLoadingEvents;
	  }
	  destroy() {}
	  on(evt, cb) {}
	  off(evt, cb) {}
	};

	exports.TimelineFront = TimelineFront;

/***/ },
/* 882 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * slice() reference.
	 */

	var slice = Array.prototype.slice;

	/**
	 * Expose `co`.
	 */

	module.exports = co['default'] = co.co = co;

	/**
	 * Wrap the given generator `fn` into a
	 * function that returns a promise.
	 * This is a separate function so that
	 * every `co()` call doesn't create a new,
	 * unnecessary closure.
	 *
	 * @param {GeneratorFunction} fn
	 * @return {Function}
	 * @api public
	 */

	co.wrap = function (fn) {
	  createPromise.__generatorFunction__ = fn;
	  return createPromise;
	  function createPromise() {
	    return co.call(this, fn.apply(this, arguments));
	  }
	};

	/**
	 * Execute the generator function or a generator
	 * and return a promise.
	 *
	 * @param {Function} fn
	 * @return {Promise}
	 * @api public
	 */

	function co(gen) {
	  var ctx = this;
	  var args = slice.call(arguments, 1);

	  // we wrap everything in a promise to avoid promise chaining,
	  // which leads to memory leak errors.
	  // see https://github.com/tj/co/issues/180
	  return new Promise(function (resolve, reject) {
	    if (typeof gen === 'function') gen = gen.apply(ctx, args);
	    if (!gen || typeof gen.next !== 'function') return resolve(gen);

	    onFulfilled();

	    /**
	     * @param {Mixed} res
	     * @return {Promise}
	     * @api private
	     */

	    function onFulfilled(res) {
	      var ret;
	      try {
	        ret = gen.next(res);
	      } catch (e) {
	        return reject(e);
	      }
	      next(ret);
	    }

	    /**
	     * @param {Error} err
	     * @return {Promise}
	     * @api private
	     */

	    function onRejected(err) {
	      var ret;
	      try {
	        ret = gen.throw(err);
	      } catch (e) {
	        return reject(e);
	      }
	      next(ret);
	    }

	    /**
	     * Get the next value in the generator,
	     * return a promise.
	     *
	     * @param {Object} ret
	     * @return {Promise}
	     * @api private
	     */

	    function next(ret) {
	      if (ret.done) return resolve(ret.value);
	      var value = toPromise.call(ctx, ret.value);
	      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
	      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: "' + String(ret.value) + '"'));
	    }
	  });
	}

	/**
	 * Convert a `yield`ed value into a promise.
	 *
	 * @param {Mixed} obj
	 * @return {Promise}
	 * @api private
	 */

	function toPromise(obj) {
	  if (!obj) return obj;
	  if (isPromise(obj)) return obj;
	  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
	  if ('function' == typeof obj) return thunkToPromise.call(this, obj);
	  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
	  if (isObject(obj)) return objectToPromise.call(this, obj);
	  return obj;
	}

	/**
	 * Convert a thunk to a promise.
	 *
	 * @param {Function}
	 * @return {Promise}
	 * @api private
	 */

	function thunkToPromise(fn) {
	  var ctx = this;
	  return new Promise(function (resolve, reject) {
	    fn.call(ctx, function (err, res) {
	      if (err) return reject(err);
	      if (arguments.length > 2) res = slice.call(arguments, 1);
	      resolve(res);
	    });
	  });
	}

	/**
	 * Convert an array of "yieldables" to a promise.
	 * Uses `Promise.all()` internally.
	 *
	 * @param {Array} obj
	 * @return {Promise}
	 * @api private
	 */

	function arrayToPromise(obj) {
	  return Promise.all(obj.map(toPromise, this));
	}

	/**
	 * Convert an object of "yieldables" to a promise.
	 * Uses `Promise.all()` internally.
	 *
	 * @param {Object} obj
	 * @return {Promise}
	 * @api private
	 */

	function objectToPromise(obj) {
	  var results = new obj.constructor();
	  var keys = Object.keys(obj);
	  var promises = [];
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var promise = toPromise.call(this, obj[key]);
	    if (promise && isPromise(promise)) defer(promise, key);else results[key] = obj[key];
	  }
	  return Promise.all(promises).then(function () {
	    return results;
	  });

	  function defer(promise, key) {
	    // predefine the key in the result
	    results[key] = undefined;
	    promises.push(promise.then(function (res) {
	      results[key] = res;
	    }));
	  }
	}

	/**
	 * Check if `obj` is a promise.
	 *
	 * @param {Object} obj
	 * @return {Boolean}
	 * @api private
	 */

	function isPromise(obj) {
	  return 'function' == typeof obj.then;
	}

	/**
	 * Check if `obj` is a generator.
	 *
	 * @param {Mixed} obj
	 * @return {Boolean}
	 * @api private
	 */

	function isGenerator(obj) {
	  return 'function' == typeof obj.next && 'function' == typeof obj.throw;
	}

	/**
	 * Check if `obj` is a generator function.
	 *
	 * @param {Mixed} obj
	 * @return {Boolean}
	 * @api private
	 */
	function isGeneratorFunction(obj) {
	  var constructor = obj.constructor;
	  if (!constructor) return false;
	  if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;
	  return isGenerator(constructor.prototype);
	}

	/**
	 * Check for plain object.
	 *
	 * @param {Mixed} val
	 * @return {Boolean}
	 * @api private
	 */

	function isObject(val) {
	  return Object == val.constructor;
	}

/***/ },
/* 883 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(884);
	var fs = __webpack_require__(118);

	function Iterator(text) {
		var pos = 0, length = text.length;

		this.peek = function(num) {
			num = num || 0;
			if(pos + num >= length) { return null; }

			return text.charAt(pos + num);
		};
		this.next = function(inc) {
			inc = inc || 1;

			if(pos >= length) { return null; }

			return text.charAt((pos += inc) - inc);
		};
		this.pos = function() {
			return pos;
		};
	}

	var rWhitespace = /\s/;
	function isWhitespace(chr) {
		return rWhitespace.test(chr);
	}
	function consumeWhiteSpace(iter) {
		var start = iter.pos();

		while(isWhitespace(iter.peek())) { iter.next(); }

		return { type: "whitespace", start: start, end: iter.pos() };
	}

	function startsComment(chr) {
		return chr === "!" || chr === "#";
	}
	function isEOL(chr) {
		return chr == null || chr === "\n" || chr === "\r";
	}
	function consumeComment(iter) {
		var start = iter.pos();

		while(!isEOL(iter.peek())) { iter.next(); }

		return { type: "comment", start: start, end: iter.pos() };
	}

	function startsKeyVal(chr) {
		return !isWhitespace(chr) && !startsComment(chr);
	}
	function startsSeparator(chr) {
		return chr === "=" || chr === ":" || isWhitespace(chr);
	}
	function startsEscapedVal(chr) {
		return chr === "\\";
	}
	function consumeEscapedVal(iter) {
		var start = iter.pos();

		iter.next(); // move past "\"
		var curChar = iter.next();
		if(curChar === "u") { // encoded unicode char
			iter.next(4); // Read in the 4 hex values
		}

		return { type: "escaped-value", start: start, end: iter.pos() };
	}
	function consumeKey(iter) {
		var start = iter.pos(), children = [];

		var curChar;
		while((curChar = iter.peek()) !== null) {
			if(startsSeparator(curChar)) { break; }
			if(startsEscapedVal(curChar)) { children.push(consumeEscapedVal(iter)); continue; }

			iter.next();
		}

		return { type: "key", start: start, end: iter.pos(), children: children };
	}
	function consumeKeyValSeparator(iter) {
		var start = iter.pos();

		var seenHardSep = false, curChar;
		while((curChar = iter.peek()) !== null) {
			if(isEOL(curChar)) { break; }

			if(isWhitespace(curChar)) { iter.next(); continue; }

			if(seenHardSep) { break; }

			seenHardSep = (curChar === ":" || curChar === "=");
			if(seenHardSep) { iter.next(); continue; }

			break; // curChar is a non-separtor char
		}

		return { type: "key-value-separator", start: start, end: iter.pos() };
	}
	function startsLineBreak(iter) {
		return iter.peek() === "\\" && isEOL(iter.peek(1));
	}
	function consumeLineBreak(iter) {
		var start = iter.pos();

		iter.next(); // consume \
		if(iter.peek() === "\r") { iter.next(); }
		iter.next(); // consume \n

		var curChar;
		while((curChar = iter.peek()) !== null) {
			if(isEOL(curChar)) { break; }
			if(!isWhitespace(curChar)) { break; }

			iter.next();
		}

		return { type: "line-break", start: start, end: iter.pos() };
	}
	function consumeVal(iter) {
		var start = iter.pos(), children = [];

		var curChar;
		while((curChar = iter.peek()) !== null) {
			if(startsLineBreak(iter)) { children.push(consumeLineBreak(iter)); continue; }
			if(startsEscapedVal(curChar)) { children.push(consumeEscapedVal(iter)); continue; }
			if(isEOL(curChar)) { break; }

			iter.next();
		}

		return { type: "value", start: start, end: iter.pos(), children: children };
	}
	function consumeKeyVal(iter) {
		return {
			type: "key-value",
			start: iter.pos(),
			children: [
				consumeKey(iter),
				consumeKeyValSeparator(iter),
				consumeVal(iter)
			],
			end: iter.pos()
		};
	}

	var renderChild = {
		"escaped-value": function(child, text) {
			var type = text.charAt(child.start + 1);

			if(type === "t") { return "\t"; }
			if(type === "r") { return "\r"; }
			if(type === "n") { return "\n"; }
			if(type === "f") { return "\f"; }
			if(type !== "u") { return type; }

			return String.fromCharCode(parseInt(text.substr(child.start + 2, 4), 16));
		},
		"line-break": function (child, text) {
			return "";
		}
	};
	function rangeToBuffer(range, text) {
		var start = range.start, buffer = [];

		for(var i = 0; i < range.children.length; i++) {
			var child = range.children[i];

			buffer.push(text.substring(start, child.start));
			buffer.push(renderChild[child.type](child, text));
			start = child.end;
		}
		buffer.push(text.substring(start, range.end));

		return buffer;
	}
	function rangesToObject(ranges, text) {
		var obj = Object.create(null); // Creates to a true hash map

		for(var i = 0; i < ranges.length; i++) {
			var range = ranges[i];

			if(range.type !== "key-value") { continue; }

			var key = rangeToBuffer(range.children[0], text).join("");
			var val = rangeToBuffer(range.children[2], text).join("");
			obj[key] = val;
		}

		return obj;
	}

	function stringToRanges(text) {
		var iter = new Iterator(text), ranges = [];

		var curChar;
		while((curChar = iter.peek()) !== null) {
			if(isWhitespace(curChar)) { ranges.push(consumeWhiteSpace(iter)); continue; }
			if(startsComment(curChar)) { ranges.push(consumeComment(iter)); continue; }
			if(startsKeyVal(curChar)) { ranges.push(consumeKeyVal(iter)); continue; }

			throw Error("Something crazy happened. text: '" + text + "'; curChar: '" + curChar + "'");
		}

		return ranges;
	}

	function isNewLineRange(range) {
		if(!range) { return false; }

		if(range.type === "whitespace") { return true; }

		if(range.type === "literal") {
			return isWhitespace(range.text) && range.text.indexOf("\n") > -1;
		}

		return false;
	}

	function escapeMaker(escapes) {
		return function escapeKey(key) {
			var zeros = [ "", "0", "00", "000" ];
			var buf = [];

			for(var i = 0; i < key.length; i++) {
				var chr = key.charAt(i);

				if(escapes[chr]) { buf.push(escapes[chr]); continue; }

				var code = chr.codePointAt(0);

				if(code <= 0x7F) { buf.push(chr); continue; }

				var hex = code.toString(16);

				buf.push("\\u");
				buf.push(zeros[4 - hex.length]);
				buf.push(hex);
			}

			return buf.join("");
		};
	}

	var escapeKey = escapeMaker({ " ": "\\ ", "\n": "\\n", ":": "\\:", "=": "\\=" });
	var escapeVal = escapeMaker({ "\n": "\\n" });

	function Editor(text, options) {
	    if (typeof text === 'object') {
	        options = text;
	        text = null;
	    }
		text = text || "";
	    var path = options.path;
	    var separator = options.separator || '=';

		var ranges = stringToRanges(text);
		var obj = rangesToObject(ranges, text);
		var keyRange = Object.create(null); // Creates to a true hash map

		for(var i = 0; i < ranges.length; i++) {
			var range = ranges[i];

			if(range.type !== "key-value") { continue; }

			var key = rangeToBuffer(range.children[0], text).join("");
			keyRange[key] = range;
		}

		this.addHeadComment = function(comment) {
			if(comment == null) { return; }

			ranges.unshift({ type: "literal", text: "# " + comment.replace(/\n/g, "\n# ") + "\n" });
		};

		this.get = function(key) { return obj[key]; };
		this.set = function(key, val, comment) {
			if(val == null) { this.unset(key); return; }

			obj[key] = val;
			var escapedKey = escapeKey(key);
			var escapedVal = escapeVal(val);

			var range = keyRange[key];
			if(!range) {
				keyRange[key] = range = {
					type: "literal",
					text: escapedKey + separator + escapedVal
				};

				var prevRange = ranges[ranges.length - 1];
				if(prevRange != null && !isNewLineRange(prevRange)) {
					ranges.push({ type: "literal", text: "\n" });
				}
				ranges.push(range);
			}

			// comment === null deletes comment. if comment === undefined, it's left alone
			if(comment !== undefined) {
				range.comment = comment && "# " + comment.replace(/\n/g, "\n# ") + "\n";
			}

			if(range.type === "literal") {
				range.text = escapedKey + separator + escapedVal;
				if(range.comment != null) { range.text = range.comment + range.text; }
			} else if(range.type === "key-value") {
				range.children[2] = { type: "literal", text: escapedVal };
			} else {
				throw "Unknown node type: " + range.type;
			}
		};
		this.unset = function(key) {
			if(!(key in obj)) { return; }

			var range = keyRange[key];
			var idx = ranges.indexOf(range);

			ranges.splice(idx, (isNewLineRange(ranges[idx + 1]) ? 2 : 1));

			delete keyRange[key];
			delete obj[key];
		};
		this.valueOf = this.toString = function() {
			var buffer = [], stack = [].concat(ranges);

			var node;
			while((node = stack.shift()) != null) {
				switch(node.type) {
					case "literal":
						buffer.push(node.text);
						break;
					case "key":
					case "value":
					case "comment":
					case "whitespace":
					case "key-value-separator":
					case "escaped-value":
					case "line-break":
						buffer.push(text.substring(node.start, node.end));
						break;
					case "key-value":
						Array.prototype.unshift.apply(stack, node.children);
						if(node.comment) { stack.unshift({ type: "literal", text: node.comment }); }
						break;
				}
			}

			return buffer.join("");
		};
		this.save = function(newPath, callback) {
			if(typeof newPath === 'function') {
				callback = newPath;
				newPath = path;
			}
			newPath = newPath || path;

			if(!newPath) {
	            if (callback) {
	                return callback("Unknown path");
	            }
	            throw new Error("Unknown path");
	        }

	        if (callback) {
	            fs.writeFile(newPath, this.toString(), callback);
	        } else {
	            fs.writeFileSync(newPath, this.toString());
	        }

		};
	}
	function createEditor(/*path, options, callback*/) {
	    var path, options, callback;
	    var args = Array.prototype.slice.call(arguments);
	    for (var i = 0; i < args.length; i ++) {
	        var arg = args[i];
	        if (!path && typeof arg === 'string') {
	            path = arg;
	        } else if (!options && typeof arg === 'object') {
	            options = arg;
	        } else if (!callback && typeof arg === 'function') {
	            callback = arg;
	        }
	    }
	    options = options || {};
	    path = path || options.path;
	    callback = callback || options.callback;
	    options.path = path;

		if(!path) { return new Editor(options); }

		if(!callback) { return new Editor(fs.readFileSync(path).toString(), options); }

		return fs.readFile(path, function(err, text) {
			if(err) { return callback(err, null); }

			text = text.toString();
			return callback(null, new Editor(text, options));
		});
	}

	function parse(text) {
		text = text.toString();
		var ranges = stringToRanges(text);
		return rangesToObject(ranges, text);
	}

	function read(path, callback) {
		if(!callback) { return parse(fs.readFileSync(path)); }

		return fs.readFile(path, function(err, data) {
			if(err) { return callback(err, null); }

			return callback(null, parse(data));
		});
	}

	module.exports = { parse: parse, read: read, createEditor: createEditor };


/***/ },
/* 884 */
/***/ function(module, exports) {

	/*! http://mths.be/codepointat v0.2.0 by @mathias */
	if (!String.prototype.codePointAt) {
		(function() {
			'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
			var defineProperty = (function() {
				// IE 8 only supports `Object.defineProperty` on DOM elements
				try {
					var object = {};
					var $defineProperty = Object.defineProperty;
					var result = $defineProperty(object, object, object) && $defineProperty;
				} catch(error) {}
				return result;
			}());
			var codePointAt = function(position) {
				if (this == null) {
					throw TypeError();
				}
				var string = String(this);
				var size = string.length;
				// `ToInteger`
				var index = position ? Number(position) : 0;
				if (index != index) { // better `isNaN`
					index = 0;
				}
				// Account for out-of-bounds indices:
				if (index < 0 || index >= size) {
					return undefined;
				}
				// Get the first code unit
				var first = string.charCodeAt(index);
				var second;
				if ( // check if it’s the start of a surrogate pair
					first >= 0xD800 && first <= 0xDBFF && // high surrogate
					size > index + 1 // there is a next code unit
				) {
					second = string.charCodeAt(index + 1);
					if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
						// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
						return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
					}
				}
				return first;
			};
			if (defineProperty) {
				defineProperty(String.prototype, 'codePointAt', {
					'value': codePointAt,
					'configurable': true,
					'writable': true
				});
			} else {
				String.prototype.codePointAt = codePointAt;
			}
		}());
	}


/***/ },
/* 885 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var startDebuggingNode = (() => {
	  var _ref = _asyncToGenerator(function* (tabId) {
	    var clientType = "node";
	    var tabs = yield chrome.connectNodeClient();
	    if (!tabs) {
	      return {};
	    }

	    var tab = tabs.find(function (t) {
	      return t.id.indexOf(tabId) !== -1;
	    });

	    if (!tab) {
	      return {};
	    }

	    yield chrome.connectNode(tab.tab);
	    chrome.initPage({ clientType });

	    return { tabs, tab, clientType, client: chrome };
	  });

	  return function startDebuggingNode(_x) {
	    return _ref.apply(this, arguments);
	  };
	})();

	var startDebuggingTab = (() => {
	  var _ref2 = _asyncToGenerator(function* (connTarget) {
	    var clientType = connTarget.type;
	    var client = clientType === "chrome" ? chrome : firefox;

	    var tabs = yield client.connectClient();

	    if (!tabs) {
	      return;
	    }

	    var tab = tabs.find(function (t) {
	      return t.id.indexOf(connTarget.param) !== -1;
	    });
	    if (!tab) {
	      return;
	    }

	    var tabConnection = yield client.connectTab(tab.tab);

	    client.initPage({ tab, clientType, tabConnection });

	    return { tab, tabConnection };
	  });

	  return function startDebuggingTab(_x2) {
	    return _ref2.apply(this, arguments);
	  };
	})();

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var firefox = __webpack_require__(886);
	var chrome = __webpack_require__(887);

	function startDebugging(connTarget) {
	  if (connTarget.type === "node") {
	    return startDebuggingNode(connTarget.param);
	  }

	  return startDebuggingTab(connTarget);
	}

	module.exports = {
	  startDebugging,
	  firefox,
	  chrome
	};

/***/ },
/* 886 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var connectClient = (() => {
	  var _ref = _asyncToGenerator(function* () {
	    var useProxy = !getValue("firefox.webSocketConnection");
	    var firefoxHost = getValue(useProxy ? "firefox.proxyHost" : "firefox.webSocketHost");

	    var socket = new WebSocket(`ws://${firefoxHost}`);
	    var transport = useProxy ? new DebuggerTransport(socket) : new WebsocketTransport(socket);

	    debuggerClient = new DebuggerClient(transport);
	    if (!debuggerClient) {
	      return [];
	    }

	    try {
	      yield debuggerClient.connect();
	      var tabs = yield getTabs();
	      return tabs;
	    } catch (err) {
	      console.log(err);
	      return [];
	    }
	  });

	  return function connectClient() {
	    return _ref.apply(this, arguments);
	  };
	})();

	var connectTab = (() => {
	  var _ref2 = _asyncToGenerator(function* (tab) {
	    window.addEventListener("beforeunload", function () {
	      if (tabTarget !== null) {
	        tabTarget.destroy();
	      }
	    });

	    var tabTarget = yield lookupTabTarget(tab);

	    var _ref3 = yield tabTarget.activeTab.attachThread({}),
	        _ref4 = _slicedToArray(_ref3, 2),
	        threadClient = _ref4[1];

	    threadClient.resume();
	    return { debuggerClient, threadClient, tabTarget };
	  });

	  return function connectTab(_x) {
	    return _ref2.apply(this, arguments);
	  };
	})();

	var getTabs = (() => {
	  var _ref5 = _asyncToGenerator(function* () {
	    if (!debuggerClient || !debuggerClient.mainRoot) {
	      return;
	    }

	    var response = yield debuggerClient.listTabs();
	    return createTabs(response.tabs);
	  });

	  return function getTabs() {
	    return _ref5.apply(this, arguments);
	  };
	})();

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var _require = __webpack_require__(830),
	    DebuggerClient = _require.DebuggerClient,
	    DebuggerTransport = _require.DebuggerTransport,
	    TargetFactory = _require.TargetFactory,
	    WebsocketTransport = _require.WebsocketTransport;

	var _require2 = __webpack_require__(828),
	    getValue = _require2.getValue;

	var debuggerClient = null;

	function lookupTabTarget(tab) {
	  var options = { client: debuggerClient, form: tab, chrome: false };
	  return TargetFactory.forRemoteTab(options);
	}

	function createTabs(tabs) {
	  return tabs.map(tab => {
	    return {
	      title: tab.title,
	      url: tab.url,
	      id: tab.actor,
	      tab,
	      clientType: "firefox"
	    };
	  });
	}

	function initPage() {}

	module.exports = {
	  connectClient,
	  connectTab,
	  initPage,
	  getTabs
	};

/***/ },
/* 887 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var connectClient = (() => {
	  var _ref2 = _asyncToGenerator(function* () {
	    if (!getValue("chrome.debug")) {
	      return createTabs([]);
	    }

	    try {
	      var tabs = yield CDP.List({
	        port: getValue("chrome.port"),
	        host: getValue("chrome.host")
	      });

	      return createTabs(tabs, {
	        clientType: "chrome",
	        type: "page"
	      });
	    } catch (e) {
	      return [];
	    }
	  });

	  return function connectClient() {
	    return _ref2.apply(this, arguments);
	  };
	})();

	var connectNodeClient = (() => {
	  var _ref3 = _asyncToGenerator(function* () {
	    if (!getValue("node.debug")) {
	      return createTabs([]);
	    }

	    var tabs = void 0;
	    try {
	      tabs = yield CDP.List({
	        port: getValue("node.port"),
	        host: getValue("node.host")
	      });
	    } catch (e) {
	      return;
	    }

	    return createTabs(tabs, {
	      clientType: "node",
	      type: "node"
	    });
	  });

	  return function connectNodeClient() {
	    return _ref3.apply(this, arguments);
	  };
	})();

	var connectTab = (() => {
	  var _ref4 = _asyncToGenerator(function* (tab) {
	    var tabConnection = yield CDP({ tab: tab.webSocketDebuggerUrl });
	    return tabConnection;
	  });

	  return function connectTab(_x2) {
	    return _ref4.apply(this, arguments);
	  };
	})();

	var connectNode = (() => {
	  var _ref5 = _asyncToGenerator(function* (tab) {
	    var tabConnection = yield CDP({ tab: tab.webSocketDebuggerUrl });

	    window.addEventListener("beforeunload", function () {
	      tabConnection.onclose = function disable() {};
	      tabConnection.close();
	    });

	    return tabConnection;
	  });

	  return function connectNode(_x3) {
	    return _ref5.apply(this, arguments);
	  };
	})();

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var CDP = __webpack_require__(126);

	var _require = __webpack_require__(828),
	    getValue = _require.getValue;

	var _require2 = __webpack_require__(830),
	    networkRequest = _require2.networkRequest;

	var connection = void 0;

	function createTabs(tabs) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      type = _ref.type,
	      clientType = _ref.clientType;

	  return tabs.filter(tab => {
	    return tab.type == type;
	  }).map(tab => {
	    return {
	      title: tab.title,
	      url: tab.url,
	      id: tab.id,
	      tab,
	      clientType
	    };
	  });
	}

	window.criRequest = function (options, callback) {
	  var host = options.host,
	      port = options.port,
	      path = options.path;

	  var url = `http://${host}:${port}${path}`;

	  networkRequest(url).then(res => callback(null, res.content)).catch(err => callback(err));
	};

	function initPage(_ref6) {
	  var tab = _ref6.tab,
	      clientType = _ref6.clientType,
	      tabConnection = _ref6.tabConnection;
	  var Runtime = tabConnection.Runtime,
	      Page = tabConnection.Page;


	  Runtime.enable();

	  if (clientType == "node") {
	    Runtime.runIfWaitingForDebugger();
	  }

	  if (clientType == "chrome") {
	    Page.enable();
	  }

	  return connection;
	}

	module.exports = {
	  connectClient,
	  connectNodeClient,
	  connectNode,
	  connectTab,
	  initPage
	};

/***/ },
/* 888 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var onConnect = (() => {
	  var _ref = _asyncToGenerator(function* (connection, services) {
	    // NOTE: the landing page does not connect to a JS process
	    if (!connection) {
	      return;
	    }

	    var client = getClient(connection);
	    var commands = client.clientCommands;

	    var _bootstrapStore = bootstrapStore(commands, services),
	        store = _bootstrapStore.store,
	        actions = _bootstrapStore.actions,
	        selectors = _bootstrapStore.selectors;

	    bootstrapWorkers();
	    yield client.onConnect(connection, actions);
	    yield loadFromPrefs(actions);

	    window.getGlobalsForTesting = function () {
	      return {
	        store,
	        actions,
	        selectors,
	        client: client.clientCommands,
	        connection
	      };
	    };

	    bootstrapApp(connection, { store, actions });

	    return { store, actions, selectors, client: commands };
	  });

	  return function onConnect(_x, _x2) {
	    return _ref.apply(this, arguments);
	  };
	})();

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var firefox = __webpack_require__(889);
	var chrome = __webpack_require__(893);

	var _require = __webpack_require__(226),
	    prefs = _require.prefs;

	var _require2 = __webpack_require__(897),
	    bootstrapApp = _require2.bootstrapApp,
	    bootstrapStore = _require2.bootstrapStore,
	    bootstrapWorkers = _require2.bootstrapWorkers;

	function loadFromPrefs(actions) {
	  var pauseOnExceptions = prefs.pauseOnExceptions,
	      ignoreCaughtExceptions = prefs.ignoreCaughtExceptions;

	  if (pauseOnExceptions || ignoreCaughtExceptions) {
	    return actions.pauseOnExceptions(pauseOnExceptions, ignoreCaughtExceptions);
	  }
	}

	function getClient(connection) {
	  var clientType = connection.tab.clientType;

	  return clientType == "firefox" ? firefox : chrome;
	}

	module.exports = { onConnect };

/***/ },
/* 889 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var onConnect = exports.onConnect = (() => {
	  var _ref = _asyncToGenerator(function* (connection, actions) {
	    var _connection$tabConnec = connection.tabConnection,
	        tabTarget = _connection$tabConnec.tabTarget,
	        threadClient = _connection$tabConnec.threadClient,
	        debuggerClient = _connection$tabConnec.debuggerClient;


	    if (!tabTarget || !threadClient || !debuggerClient) {
	      return;
	    }

	    setupCommands({ threadClient, tabTarget, debuggerClient });

	    if (actions) {
	      setupEvents({ threadClient, actions });
	    }

	    tabTarget.on("will-navigate", actions.willNavigate);
	    tabTarget.on("navigate", actions.navigated);

	    yield threadClient.reconfigure({ observeAsmJS: true });

	    // In Firefox, we need to initially request all of the sources. This
	    // usually fires off individual `newSource` notifications as the
	    // debugger finds them, but there may be existing sources already in
	    // the debugger (if it's paused already, or if loading the page from
	    // bfcache) so explicity fire `newSource` events for all returned
	    // sources.
	    var sources = yield clientCommands.fetchSources();
	    actions.newSources(sources);

	    // If the threadClient is already paused, make sure to show a
	    // paused state.
	    var pausedPacket = threadClient.getLastPausePacket();
	    if (pausedPacket) {
	      clientEvents.paused("paused", pausedPacket);
	    }
	  });

	  return function onConnect(_x, _x2) {
	    return _ref.apply(this, arguments);
	  };
	})();

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var _require = __webpack_require__(890),
	    setupCommands = _require.setupCommands,
	    clientCommands = _require.clientCommands;

	var _require2 = __webpack_require__(892),
	    setupEvents = _require2.setupEvents,
	    clientEvents = _require2.clientEvents;

	exports.clientCommands = clientCommands;
	exports.clientEvents = clientEvents;

/***/ },
/* 890 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var blackBox = (() => {
	  var _ref2 = _asyncToGenerator(function* (sourceId, isBlackBoxed) {
	    var sourceClient = threadClient.source({ actor: sourceId });
	    if (isBlackBoxed) {
	      yield sourceClient.unblackBox();
	    } else {
	      yield sourceClient.blackBox();
	    }

	    return { isBlackBoxed: !isBlackBoxed };
	  });

	  return function blackBox(_x, _x2) {
	    return _ref2.apply(this, arguments);
	  };
	})();

	var fetchSources = (() => {
	  var _ref3 = _asyncToGenerator(function* () {
	    var _ref4 = yield threadClient.getSources(),
	        sources = _ref4.sources;

	    return sources.map(createSource);
	  });

	  return function fetchSources() {
	    return _ref3.apply(this, arguments);
	  };
	})();

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var _require = __webpack_require__(891),
	    createSource = _require.createSource;

	var bpClients = void 0;
	var threadClient = void 0;
	var tabTarget = void 0;
	var debuggerClient = void 0;

	function setupCommands(dependencies) {
	  threadClient = dependencies.threadClient;
	  tabTarget = dependencies.tabTarget;
	  debuggerClient = dependencies.debuggerClient;
	  bpClients = {};
	}

	function resume() {
	  return new Promise(resolve => {
	    threadClient.resume(resolve);
	  });
	}

	function stepIn() {
	  return new Promise(resolve => {
	    threadClient.stepIn(resolve);
	  });
	}

	function stepOver() {
	  return new Promise(resolve => {
	    threadClient.stepOver(resolve);
	  });
	}

	function stepOut() {
	  return new Promise(resolve => {
	    threadClient.stepOut(resolve);
	  });
	}

	function breakOnNext() {
	  return threadClient.breakOnNext();
	}

	function sourceContents(sourceId) {
	  var sourceClient = threadClient.source({ actor: sourceId });
	  return sourceClient.source();
	}

	function setBreakpoint(location, condition, noSliding) {
	  var sourceClient = threadClient.source({ actor: location.sourceId });

	  return sourceClient.setBreakpoint({
	    line: location.line,
	    column: location.column,
	    condition,
	    noSliding
	  }).then(res => onNewBreakpoint(location, res));
	}

	function onNewBreakpoint(location, res) {
	  var bpClient = res[1];
	  var actualLocation = res[0].actualLocation;
	  bpClients[bpClient.actor] = bpClient;

	  // Firefox only returns `actualLocation` if it actually changed,
	  // but we want it always to exist. Format `actualLocation` if it
	  // exists, otherwise use `location`.
	  actualLocation = actualLocation ? {
	    sourceId: actualLocation.source.actor,
	    line: actualLocation.line,
	    column: actualLocation.column
	  } : location;

	  return {
	    id: bpClient.actor,
	    actualLocation
	  };
	}

	function removeBreakpoint(breakpointId) {
	  var bpClient = bpClients[breakpointId];
	  delete bpClients[breakpointId];
	  return bpClient.remove();
	}

	function setBreakpointCondition(breakpointId, location, condition, noSliding) {
	  var bpClient = bpClients[breakpointId];
	  delete bpClients[breakpointId];

	  return bpClient.setCondition(threadClient, condition, noSliding).then(_bpClient => onNewBreakpoint(location, [{}, _bpClient]));
	}

	function evaluate(script, _ref) {
	  var frameId = _ref.frameId;

	  var params = frameId ? { frameActor: frameId } : {};
	  return new Promise(resolve => {
	    tabTarget.activeConsole.evaluateJS(script, result => resolve(result), params);
	  });
	}

	function debuggeeCommand(script) {
	  tabTarget.activeConsole.evaluateJS(script, () => {}, {});

	  if (!debuggerClient) {
	    return;
	  }

	  var consoleActor = tabTarget.form.consoleActor;
	  var request = debuggerClient._activeRequests.get(consoleActor);
	  request.emit("json-reply", {});
	  debuggerClient._activeRequests.delete(consoleActor);

	  return Promise.resolve();
	}

	function navigate(url) {
	  return tabTarget.activeTab.navigateTo(url);
	}

	function reload() {
	  return tabTarget.activeTab.reload();
	}

	function getProperties(grip) {
	  var objClient = threadClient.pauseGrip(grip);

	  return objClient.getPrototypeAndProperties().then(resp => {
	    return resp;
	  });
	}

	function pauseOnExceptions(shouldPauseOnExceptions, shouldIgnoreCaughtExceptions) {
	  return threadClient.pauseOnExceptions(shouldPauseOnExceptions, shouldIgnoreCaughtExceptions);
	}

	function prettyPrint(sourceId, indentSize) {
	  var sourceClient = threadClient.source({ actor: sourceId });
	  return sourceClient.prettyPrint(indentSize);
	}

	function disablePrettyPrint(sourceId) {
	  var sourceClient = threadClient.source({ actor: sourceId });
	  return sourceClient.disablePrettyPrint();
	}

	function interrupt() {
	  return threadClient.interrupt();
	}

	function eventListeners() {
	  return threadClient.eventListeners();
	}

	function pauseGrip(func) {
	  return threadClient.pauseGrip(func);
	}

	var clientCommands = {
	  blackBox,
	  interrupt,
	  eventListeners,
	  pauseGrip,
	  resume,
	  stepIn,
	  stepOut,
	  stepOver,
	  breakOnNext,
	  sourceContents,
	  setBreakpoint,
	  removeBreakpoint,
	  setBreakpointCondition,
	  evaluate,
	  debuggeeCommand,
	  navigate,
	  reload,
	  getProperties,
	  pauseOnExceptions,
	  prettyPrint,
	  disablePrettyPrint,
	  fetchSources
	};

	module.exports = {
	  setupCommands,
	  clientCommands
	};

/***/ },
/* 891 */
/***/ function(module, exports) {

	"use strict";

	// This module converts Firefox specific types to the generic types

	function createFrame(frame) {
	  var title = void 0;
	  if (frame.type == "call") {
	    var c = frame.callee;
	    title = c.name || c.userDisplayName || c.displayName || "(anonymous)";
	  } else {
	    title = `(${frame.type})`;
	  }

	  return {
	    id: frame.actor,
	    displayName: title,
	    location: {
	      sourceId: frame.where.source.actor,
	      line: frame.where.line,
	      column: frame.where.column
	    },
	    this: frame.this,
	    scope: frame.environment
	  };
	}

	function createSource(source) {
	  return {
	    id: source.actor,
	    url: source.url,
	    isPrettyPrinted: false,
	    sourceMapURL: source.sourceMapURL,
	    isBlackBoxed: false
	  };
	}

	function createPause(packet, response) {
	  // NOTE: useful when the debugger is already paused
	  var frame = packet.frame || response.frames[0];

	  return Object.assign({}, packet, {
	    frame: createFrame(frame),
	    frames: response.frames.map(createFrame)
	  });
	}

	module.exports = {
	  createFrame,
	  createSource,
	  createPause
	};

/***/ },
/* 892 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var paused = (() => {
	  var _ref = _asyncToGenerator(function* (_, packet) {
	    // If paused by an explicit interrupt, which are generated by the
	    // slow script dialog and internal events such as setting
	    // breakpoints, ignore the event.
	    var why = packet.why;

	    if (why.type === "interrupted" && !packet.why.onNext) {
	      return;
	    }

	    // Eagerly fetch the frames
	    var response = yield threadClient.getFrames(0, CALL_STACK_PAGE_SIZE);

	    if (why.type != "alreadyPaused") {
	      var pause = createPause(packet, response);
	      actions.paused(pause);
	    }
	  });

	  return function paused(_x, _x2) {
	    return _ref.apply(this, arguments);
	  };
	})();

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var _require = __webpack_require__(891),
	    createPause = _require.createPause,
	    createSource = _require.createSource;

	var _require2 = __webpack_require__(828),
	    isEnabled = _require2.isEnabled;

	var CALL_STACK_PAGE_SIZE = 1000;

	var threadClient = void 0;
	var actions = void 0;

	function setupEvents(dependencies) {
	  threadClient = dependencies.threadClient;
	  actions = dependencies.actions;

	  if (threadClient) {
	    Object.keys(clientEvents).forEach(eventName => {
	      threadClient.addListener(eventName, clientEvents[eventName]);
	    });
	  }
	}

	function resumed(_, packet) {
	  actions.resumed(packet);
	}

	function newSource(_, _ref2) {
	  var source = _ref2.source;

	  actions.newSource(createSource(source));

	  if (isEnabled("eventListeners")) {
	    actions.fetchEventListeners();
	  }
	}

	var clientEvents = {
	  paused,
	  resumed,
	  newSource
	};

	module.exports = {
	  setupEvents,
	  clientEvents
	};

/***/ },
/* 893 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var onConnect = exports.onConnect = (() => {
	  var _ref = _asyncToGenerator(function* (connection, actions) {
	    var tabConnection = connection.tabConnection,
	        type = connection.connTarget.type;
	    var Debugger = tabConnection.Debugger,
	        Runtime = tabConnection.Runtime,
	        Page = tabConnection.Page;


	    Debugger.enable();
	    Debugger.setPauseOnExceptions({ state: "none" });
	    Debugger.setAsyncCallStackDepth({ maxDepth: 0 });

	    if (type == "chrome") {
	      Page.frameNavigated(pageEvents.frameNavigated);
	      Page.frameStartedLoading(pageEvents.frameStartedLoading);
	      Page.frameStoppedLoading(pageEvents.frameStoppedLoading);
	    }

	    Debugger.scriptParsed(clientEvents.scriptParsed);
	    Debugger.scriptFailedToParse(clientEvents.scriptFailedToParse);
	    Debugger.paused(clientEvents.paused);
	    Debugger.resumed(clientEvents.resumed);

	    setupCommands({ Debugger, Runtime, Page });
	    setupEvents({ actions, Page, type, Runtime });
	  });

	  return function onConnect(_x, _x2) {
	    return _ref.apply(this, arguments);
	  };
	})();

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var _require = __webpack_require__(894),
	    setupCommands = _require.setupCommands,
	    clientCommands = _require.clientCommands;

	var _require2 = __webpack_require__(896),
	    setupEvents = _require2.setupEvents,
	    clientEvents = _require2.clientEvents,
	    pageEvents = _require2.pageEvents;

	exports.clientCommands = clientCommands;
	exports.clientEvents = clientEvents;

/***/ },
/* 894 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var setBreakpoint = (() => {
	  var _ref3 = _asyncToGenerator(function* (location, condition) {
	    var _ref4 = yield debuggerAgent.setBreakpoint({
	      location: toServerLocation(location),
	      columnNumber: location.column
	    }),
	        breakpointId = _ref4.breakpointId,
	        serverLocation = _ref4.serverLocation;

	    var actualLocation = fromServerLocation(serverLocation) || location;

	    return {
	      id: breakpointId,
	      actualLocation: actualLocation
	    };
	  });

	  return function setBreakpoint(_x, _x2) {
	    return _ref3.apply(this, arguments);
	  };
	})();

	var getProperties = (() => {
	  var _ref5 = _asyncToGenerator(function* (object) {
	    var _ref6 = yield runtimeAgent.getProperties({
	      objectId: object.objectId
	    }),
	        result = _ref6.result;

	    var loadedObjects = result.map(createLoadedObject);

	    return { loadedObjects };
	  });

	  return function getProperties(_x3) {
	    return _ref5.apply(this, arguments);
	  };
	})();

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var _require = __webpack_require__(895),
	    toServerLocation = _require.toServerLocation,
	    fromServerLocation = _require.fromServerLocation,
	    createLoadedObject = _require.createLoadedObject;

	var debuggerAgent = void 0;
	var runtimeAgent = void 0;
	var pageAgent = void 0;

	function setupCommands(_ref) {
	  var Debugger = _ref.Debugger,
	      Runtime = _ref.Runtime,
	      Page = _ref.Page;

	  debuggerAgent = Debugger;
	  runtimeAgent = Runtime;
	  pageAgent = Page;
	}

	function resume() {
	  return debuggerAgent.resume();
	}

	function stepIn() {
	  return debuggerAgent.stepInto();
	}

	function stepOver() {
	  return debuggerAgent.stepOver();
	}

	function stepOut() {
	  return debuggerAgent.stepOut();
	}

	function pauseOnExceptions(shouldPauseOnExceptions, shouldIgnoreCaughtExceptions) {
	  if (!shouldPauseOnExceptions) {
	    return debuggerAgent.setPauseOnExceptions({ state: "none" });
	  }
	  var state = shouldIgnoreCaughtExceptions ? "uncaught" : "all";
	  return debuggerAgent.setPauseOnExceptions({ state });
	}

	function breakOnNext() {
	  return debuggerAgent.pause();
	}

	function sourceContents(sourceId) {
	  return debuggerAgent.getScriptSource({ scriptId: sourceId }).then((_ref2) => {
	    var scriptSource = _ref2.scriptSource;
	    return {
	      source: scriptSource,
	      contentType: null
	    };
	  });
	}

	function removeBreakpoint(breakpointId) {
	  return debuggerAgent.removeBreakpoint({ breakpointId });
	}

	function evaluate(script) {
	  return runtimeAgent.evaluate({ expression: script });
	}

	function debuggeeCommand(script) {
	  evaluate(script);
	  return Promise.resolve();
	}

	function navigate(url) {
	  return pageAgent.navigate({ url });
	}

	var clientCommands = {
	  resume,
	  stepIn,
	  stepOut,
	  stepOver,
	  pauseOnExceptions,
	  breakOnNext,
	  sourceContents,
	  setBreakpoint,
	  removeBreakpoint,
	  evaluate,
	  debuggeeCommand,
	  navigate,
	  getProperties
	};

	module.exports = {
	  setupCommands,
	  clientCommands
	};

/***/ },
/* 895 */
/***/ function(module, exports) {

	"use strict";

	function fromServerLocation(serverLocation) {
	  if (serverLocation) {
	    return {
	      sourceId: serverLocation.scriptId,
	      line: serverLocation.lineNumber + 1,
	      column: serverLocation.columnNumber
	    };
	  }
	}

	function toServerLocation(location) {
	  return {
	    scriptId: location.sourceId,
	    lineNumber: location.line - 1
	  };
	}

	function createFrame(frame) {
	  return {
	    id: frame.callFrameId,
	    displayName: frame.functionName,
	    scopeChain: frame.scopeChain,
	    location: fromServerLocation(frame.location)
	  };
	}

	function createLoadedObject(serverObject, parentId) {
	  var value = serverObject.value,
	      name = serverObject.name;


	  return {
	    objectId: value.objectId,
	    parentId,
	    name,
	    value
	  };
	}

	module.exports = {
	  fromServerLocation,
	  toServerLocation,
	  createFrame,
	  createLoadedObject
	};

/***/ },
/* 896 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var paused = (() => {
	  var _ref2 = _asyncToGenerator(function* (_ref3) {
	    var callFrames = _ref3.callFrames,
	        reason = _ref3.reason,
	        data = _ref3.data,
	        hitBreakpoints = _ref3.hitBreakpoints,
	        asyncStackTrace = _ref3.asyncStackTrace;

	    var frames = callFrames.map(createFrame);
	    var frame = frames[0];
	    var why = Object.assign({}, {
	      type: reason
	    }, data);

	    var objectId = frame.scopeChain[0].object.objectId;

	    var _ref4 = yield runtimeAgent.getProperties({
	      objectId
	    }),
	        result = _ref4.result;

	    var loadedObjects = result.map(createLoadedObject);

	    if (clientType == "chrome") {
	      pageAgent.configureOverlay({ message: "Paused in debugger.html" });
	    }

	    yield actions.paused({ frame, why, frames, loadedObjects });
	  });

	  return function paused(_x) {
	    return _ref2.apply(this, arguments);
	  };
	})();

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var _require = __webpack_require__(895),
	    createFrame = _require.createFrame,
	    createLoadedObject = _require.createLoadedObject;

	var actions = void 0;
	var pageAgent = void 0;
	var clientType = void 0;
	var runtimeAgent = void 0;

	function setupEvents(dependencies) {
	  actions = dependencies.actions;
	  pageAgent = dependencies.Page;
	  clientType = dependencies.clientType;
	  runtimeAgent = dependencies.Runtime;
	}

	// Debugger Events
	function scriptParsed(_ref) {
	  var scriptId = _ref.scriptId,
	      url = _ref.url,
	      startLine = _ref.startLine,
	      startColumn = _ref.startColumn,
	      endLine = _ref.endLine,
	      endColumn = _ref.endColumn,
	      executionContextId = _ref.executionContextId,
	      hash = _ref.hash,
	      isContentScript = _ref.isContentScript,
	      isInternalScript = _ref.isInternalScript,
	      isLiveEdit = _ref.isLiveEdit,
	      sourceMapURL = _ref.sourceMapURL,
	      hasSourceURL = _ref.hasSourceURL,
	      deprecatedCommentWasUsed = _ref.deprecatedCommentWasUsed;

	  if (isContentScript) {
	    return;
	  }

	  if (clientType == "node") {
	    sourceMapURL = undefined;
	  }

	  actions.newSource({
	    id: scriptId,
	    url,
	    sourceMapURL,
	    isPrettyPrinted: false
	  });
	}

	function scriptFailedToParse() {}

	function resumed() {
	  if (clientType == "chrome") {
	    pageAgent.configureOverlay({ suspended: false });
	  }

	  actions.resumed();
	}

	function globalObjectCleared() {}

	// Page Events
	function frameNavigated(frame) {
	  actions.navigated();
	}

	function frameStartedLoading() {
	  actions.willNavigate();
	}

	function domContentEventFired() {}

	function loadEventFired() {}

	function frameStoppedLoading() {}

	var clientEvents = {
	  scriptParsed,
	  scriptFailedToParse,
	  paused,
	  resumed,
	  globalObjectCleared
	};

	var pageEvents = {
	  frameNavigated,
	  frameStartedLoading,
	  domContentEventFired,
	  loadEventFired,
	  frameStoppedLoading
	};

	module.exports = {
	  setupEvents,
	  pageEvents,
	  clientEvents
	};

/***/ },
/* 897 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.bootstrapStore = bootstrapStore;
	exports.bootstrapApp = bootstrapApp;
	exports.bootstrapWorkers = bootstrapWorkers;
	exports.teardownWorkers = teardownWorkers;
	var React = __webpack_require__(2);

	var _require = __webpack_require__(3),
	    bindActionCreators = _require.bindActionCreators,
	    combineReducers = _require.combineReducers;

	var ReactDOM = __webpack_require__(22);

	var _require2 = __webpack_require__(828),
	    getValue = _require2.getValue,
	    isFirefoxPanel = _require2.isFirefoxPanel;

	var _require3 = __webpack_require__(131),
	    renderRoot = _require3.renderRoot;

	var _require4 = __webpack_require__(898),
	    startSourceMapWorker = _require4.startSourceMapWorker,
	    stopSourceMapWorker = _require4.stopSourceMapWorker;

	var _require5 = __webpack_require__(903),
	    startPrettyPrintWorker = _require5.startPrettyPrintWorker,
	    stopPrettyPrintWorker = _require5.stopPrettyPrintWorker;

	var _require6 = __webpack_require__(827),
	    startParserWorker = _require6.startParserWorker,
	    stopParserWorker = _require6.stopParserWorker;

	var configureStore = __webpack_require__(189);
	var reducers = __webpack_require__(227);
	var selectors = __webpack_require__(242);

	var App = __webpack_require__(243).default;

	function bootstrapStore(client, services) {
	  var createStore = configureStore({
	    log: getValue("logging.actions"),
	    makeThunkArgs: (args, state) => {
	      return Object.assign({}, args, { client }, services);
	    }
	  });

	  var store = createStore(combineReducers(reducers));
	  var actions = bindActionCreators(__webpack_require__(244).default, store.dispatch);

	  return { store, actions, selectors };
	}

	function bootstrapApp(connection, _ref) {
	  var store = _ref.store,
	      actions = _ref.actions;

	  window.appStore = store;

	  // Expose the bound actions so external things can do things like
	  // selecting a source.
	  window.actions = {
	    selectSource: actions.selectSource,
	    selectSourceURL: actions.selectSourceURL
	  };

	  renderRoot(React, ReactDOM, App, store);
	}

	function bootstrapWorkers() {
	  if (!isFirefoxPanel()) {
	    // When used in Firefox, the toolbox manages the source map worker.
	    startSourceMapWorker(getValue("workers.sourceMapURL"));
	  }
	  startPrettyPrintWorker(getValue("workers.prettyPrintURL"));
	  startParserWorker(getValue("workers.parserURL"));
	}

	function teardownWorkers() {
	  if (!isFirefoxPanel()) {
	    // When used in Firefox, the toolbox manages the source map worker.
	    stopSourceMapWorker();
	  }
	  stopPrettyPrintWorker();
	  stopParserWorker();
	}

/***/ },
/* 898 */
/***/ function(module, exports, __webpack_require__) {

	const {
	  originalToGeneratedId,
	  generatedToOriginalId,
	  isGeneratedId,
	  isOriginalId
	} = __webpack_require__(899);

	const { workerUtils: { WorkerDispatcher } } = __webpack_require__(900);

	const dispatcher = new WorkerDispatcher();

	const getOriginalURLs = dispatcher.task("getOriginalURLs");
	const getGeneratedLocation = dispatcher.task("getGeneratedLocation");
	const getOriginalLocation = dispatcher.task("getOriginalLocation");
	const getOriginalSourceText = dispatcher.task("getOriginalSourceText");
	const applySourceMap = dispatcher.task("applySourceMap");
	const clearSourceMaps = dispatcher.task("clearSourceMaps");
	const hasMappedSource = dispatcher.task("hasMappedSource");

	module.exports = {
	  originalToGeneratedId,
	  generatedToOriginalId,
	  isGeneratedId,
	  isOriginalId,
	  hasMappedSource,
	  getOriginalURLs,
	  getGeneratedLocation,
	  getOriginalLocation,
	  getOriginalSourceText,
	  applySourceMap,
	  clearSourceMaps,
	  startSourceMapWorker: dispatcher.start.bind(dispatcher),
	  stopSourceMapWorker: dispatcher.stop.bind(dispatcher)
	};

/***/ },
/* 899 */
/***/ function(module, exports, __webpack_require__) {

	const md5 = __webpack_require__(248);

	function originalToGeneratedId(originalId) {
	  const match = originalId.match(/(.*)\/originalSource/);
	  return match ? match[1] : "";
	}

	function generatedToOriginalId(generatedId, url) {
	  return `${generatedId}/originalSource-${md5(url)}`;
	}

	function isOriginalId(id) {
	  return !!id.match(/\/originalSource/);
	}

	function isGeneratedId(id) {
	  return !isOriginalId(id);
	}

	/**
	 * Trims the query part or reference identifier of a URL string, if necessary.
	 */
	function trimUrlQuery(url) {
	  let length = url.length;
	  let q1 = url.indexOf("?");
	  let q2 = url.indexOf("&");
	  let q3 = url.indexOf("#");
	  let q = Math.min(q1 != -1 ? q1 : length, q2 != -1 ? q2 : length, q3 != -1 ? q3 : length);

	  return url.slice(0, q);
	}

	/**
	 * Returns true if the specified URL and/or content type are specific to
	 * JavaScript files.
	 *
	 * @return boolean
	 *         True if the source is likely JavaScript.
	 */
	function isJavaScript(url, contentType = "") {
	  return url && /\.(jsm|js)?$/.test(trimUrlQuery(url)) || contentType.includes("javascript");
	}

	function getContentType(url) {
	  if (isJavaScript(url)) {
	    return "text/javascript";
	  }

	  if (url.match(/ts$/)) {
	    return "text/typescript";
	  }

	  if (url.match(/tsx$/)) {
	    return "text/typescript-jsx";
	  }

	  if (url.match(/jsx$/)) {
	    return "text/jsx";
	  }

	  if (url.match(/coffee$/)) {
	    return "text/coffeescript";
	  }

	  if (url.match(/elm$/)) {
	    return "text/elm";
	  }

	  if (url.match(/cljs$/)) {
	    return "text/x-clojure";
	  }

	  return "text/plain";
	}

	module.exports = {
	  originalToGeneratedId,
	  generatedToOriginalId,
	  isOriginalId,
	  isGeneratedId,
	  getContentType
	};

/***/ },
/* 900 */
/***/ function(module, exports, __webpack_require__) {

	const networkRequest = __webpack_require__(901);
	const workerUtils = __webpack_require__(902);

	module.exports = {
	  networkRequest,
	  workerUtils
	};

/***/ },
/* 901 */
/***/ function(module, exports) {

	function networkRequest(url, opts) {
	  return new Promise((resolve, reject) => {
	    const req = new XMLHttpRequest();

	    req.addEventListener("readystatechange", () => {
	      if (req.readyState === XMLHttpRequest.DONE) {
	        if (req.status === 200) {
	          resolve({ content: req.responseText });
	        } else {
	          resolve(req.statusText);
	        }
	      }
	    });

	    // Not working yet.
	    // if (!opts.loadFromCache) {
	    //   req.channel.loadFlags = (
	    //     Components.interfaces.nsIRequest.LOAD_BYPASS_CACHE |
	    //       Components.interfaces.nsIRequest.INHIBIT_CACHING |
	    //       Components.interfaces.nsIRequest.LOAD_ANONYMOUS
	    //   );
	    // }

	    req.open("GET", url);
	    req.send();
	  });
	}

	module.exports = networkRequest;

/***/ },
/* 902 */
/***/ function(module, exports) {



	function WorkerDispatcher() {
	  this.msgId = 1;
	  this.worker = null;
	}

	WorkerDispatcher.prototype = {
	  start(url) {
	    this.worker = new Worker(url);
	    this.worker.onerror = () => {
	      console.error(`Error in worker ${url}`);
	    };
	  },

	  stop() {
	    if (!this.worker) {
	      return;
	    }

	    this.worker.terminate();
	    this.worker = null;
	  },

	  task(method) {
	    return (...args) => {
	      return new Promise((resolve, reject) => {
	        const id = this.msgId++;
	        this.worker.postMessage({ id, method, args });

	        const listener = ({ data: result }) => {
	          if (result.id !== id) {
	            return;
	          }

	          this.worker.removeEventListener("message", listener);
	          if (result.error) {
	            reject(result.error);
	          } else {
	            resolve(result.response);
	          }
	        };

	        this.worker.addEventListener("message", listener);
	      });
	    };
	  }
	};

	function workerHandler(publicInterface) {
	  return function workerHandler(msg) {
	    const { id, method, args } = msg.data;
	    const response = publicInterface[method].apply(undefined, args);
	    if (response instanceof Promise) {
	      response.then(val => self.postMessage({ id, response: val }), err => self.postMessage({ id, error: err }));
	    } else {
	      self.postMessage({ id, response });
	    }
	  };
	}

	module.exports = {
	  WorkerDispatcher,
	  workerHandler
	};

/***/ },
/* 903 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var prettyPrint = (() => {
	  var _ref = _asyncToGenerator(function* (_ref2) {
	    var source = _ref2.source,
	        sourceText = _ref2.sourceText,
	        url = _ref2.url;

	    var contentType = sourceText ? sourceText.contentType : "";
	    var indent = 2;

	    assert(isJavaScript(source.url, contentType), "Can't prettify non-javascript files.");

	    return yield _prettyPrint({
	      url,
	      indent,
	      source: sourceText ? sourceText.text : undefined
	    });
	  });

	  return function prettyPrint(_x) {
	    return _ref.apply(this, arguments);
	  };
	})();

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var _require = __webpack_require__(900),
	    WorkerDispatcher = _require.workerUtils.WorkerDispatcher;

	var _require2 = __webpack_require__(233),
	    isJavaScript = _require2.isJavaScript;

	var assert = __webpack_require__(223);

	var dispatcher = new WorkerDispatcher();
	var _prettyPrint = dispatcher.task("prettyPrint");

	module.exports = {
	  prettyPrint,
	  startPrettyPrintWorker: dispatcher.start.bind(dispatcher),
	  stopPrettyPrintWorker: dispatcher.stop.bind(dispatcher)
	};

/***/ },
/* 904 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.resolveToken = undefined;

	var resolveToken = exports.resolveToken = (() => {
	  var _ref = _asyncToGenerator(function* (cm, token, sourceText, frame) {
	    var loc = getTokenLocation(cm, token);
	    return yield (0, _parser.resolveToken)(sourceText.toJS(), token.textContent || "", loc, frame);
	  });

	  return function resolveToken(_x, _x2, _x3, _x4) {
	    return _ref.apply(this, arguments);
	  };
	})();

	exports.getTokenLocation = getTokenLocation;
	exports.getThisFromFrame = getThisFromFrame;
	exports.previewExpression = previewExpression;
	exports.getExpressionValue = getExpressionValue;

	var _parser = __webpack_require__(827);

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	var get = __webpack_require__(67);

	function getTokenLocation(codeMirror, tokenEl) {
	  var lineOffset = 1;

	  var _tokenEl$getBoundingC = tokenEl.getBoundingClientRect(),
	      left = _tokenEl$getBoundingC.left,
	      top = _tokenEl$getBoundingC.top;

	  var _codeMirror$coordsCha = codeMirror.coordsChar({ left, top }),
	      line = _codeMirror$coordsCha.line,
	      ch = _codeMirror$coordsCha.ch;

	  return {
	    line: line + lineOffset,
	    column: ch
	  };
	}

	function getThisFromFrame(selectedFrame) {
	  if ("this" in selectedFrame) {
	    return { value: selectedFrame.this };
	  }

	  return null;
	}

	// TODO Better define the value for `variables` map once we do it in
	// debugger-html
	function previewExpression(_ref2) {
	  var expression = _ref2.expression,
	      selectedFrame = _ref2.selectedFrame,
	      variables = _ref2.variables,
	      tokenText = _ref2.tokenText;

	  if (!tokenText) {
	    return null;
	  }

	  if (tokenText === "this") {
	    return getThisFromFrame(selectedFrame);
	  }

	  if (variables.has(tokenText)) {
	    return variables.get(tokenText);
	  }

	  return expression || null;
	}

	// `getExpressionValue` and `previewExpression` are utility functions
	// for resolving which expression to show in the preview.
	// Get ExpressionValue, knows how to get the appropriate value for each type:
	// variable, expression, raw value.
	function getExpressionValue(selectedExpression, _ref3) {
	  var getExpression = _ref3.getExpression;

	  var variableValue = get(selectedExpression, "contents.value");
	  if (variableValue) {
	    return variableValue;
	  }

	  var expressionValue = getExpression(selectedExpression.value);
	  if (expressionValue) {
	    return get(expressionValue, "value.result");
	  }

	  var rawValue = selectedExpression.value;
	  return rawValue;
	}

/***/ },
/* 905 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	/**
	 * Author: Hans Engel
	 * Branched from CodeMirror's Scheme mode (by Koh Zi Han, based on implementation by Koh Zi Chun)
	 */

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(306));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";

	CodeMirror.defineMode("clojure", function (options) {
	    var BUILTIN = "builtin", COMMENT = "comment", STRING = "string", CHARACTER = "string-2",
	        ATOM = "atom", NUMBER = "number", BRACKET = "bracket", KEYWORD = "keyword", VAR = "variable";
	    var INDENT_WORD_SKIP = options.indentUnit || 2;
	    var NORMAL_INDENT_UNIT = options.indentUnit || 2;

	    function makeKeywords(str) {
	        var obj = {}, words = str.split(" ");
	        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
	        return obj;
	    }

	    var atoms = makeKeywords("true false nil");

	    var keywords = makeKeywords(
	      "defn defn- def def- defonce defmulti defmethod defmacro defstruct deftype defprotocol defrecord defproject deftest " +
	      "slice defalias defhinted defmacro- defn-memo defnk defnk defonce- defunbound defunbound- defvar defvar- let letfn " +
	      "do case cond condp for loop recur when when-not when-let when-first if if-let if-not . .. -> ->> doto and or dosync " +
	      "doseq dotimes dorun doall load import unimport ns in-ns refer try catch finally throw with-open with-local-vars " +
	      "binding gen-class gen-and-load-class gen-and-save-class handler-case handle");

	    var builtins = makeKeywords(
	        "* *' *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* *command-line-args* *compile-files* " +
	        "*compile-path* *compiler-options* *data-readers* *e *err* *file* *flush-on-newline* *fn-loader* *in* " +
	        "*math-context* *ns* *out* *print-dup* *print-length* *print-level* *print-meta* *print-readably* *read-eval* " +
	        "*source-path* *unchecked-math* *use-context-classloader* *verbose-defrecords* *warn-on-reflection* + +' - -' -> " +
	        "->> ->ArrayChunk ->Vec ->VecNode ->VecSeq -cache-protocol-fn -reset-methods .. / < <= = == > >= EMPTY-NODE accessor " +
	        "aclone add-classpath add-watch agent agent-error agent-errors aget alength alias all-ns alter alter-meta! " +
	        "alter-var-root amap ancestors and apply areduce array-map aset aset-boolean aset-byte aset-char aset-double " +
	        "aset-float aset-int aset-long aset-short assert assoc assoc! assoc-in associative? atom await await-for await1 " +
	        "bases bean bigdec bigint biginteger binding bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set " +
	        "bit-shift-left bit-shift-right bit-test bit-xor boolean boolean-array booleans bound-fn bound-fn* bound? butlast " +
	        "byte byte-array bytes case cat cast char char-array char-escape-string char-name-string char? chars chunk chunk-append " +
	        "chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? class class? clear-agent-errors " +
	        "clojure-version coll? comment commute comp comparator compare compare-and-set! compile complement completing concat cond condp " +
	        "conj conj! cons constantly construct-proxy contains? count counted? create-ns create-struct cycle dec dec' decimal? " +
	        "declare dedupe default-data-readers definline definterface defmacro defmethod defmulti defn defn- defonce defprotocol " +
	        "defrecord defstruct deftype delay delay? deliver denominator deref derive descendants destructure disj disj! dissoc " +
	        "dissoc! distinct distinct? doall dorun doseq dosync dotimes doto double double-array doubles drop drop-last " +
	        "drop-while eduction empty empty? ensure enumeration-seq error-handler error-mode eval even? every-pred every? ex-data ex-info " +
	        "extend extend-protocol extend-type extenders extends? false? ffirst file-seq filter filterv find find-keyword " +
	        "find-ns find-protocol-impl find-protocol-method find-var first flatten float float-array float? floats flush fn fn? " +
	        "fnext fnil for force format frequencies future future-call future-cancel future-cancelled? future-done? future? " +
	        "gen-class gen-interface gensym get get-in get-method get-proxy-class get-thread-bindings get-validator group-by hash " +
	        "hash-combine hash-map hash-set identical? identity if-let if-not ifn? import in-ns inc inc' init-proxy instance? " +
	        "int int-array integer? interleave intern interpose into into-array ints io! isa? iterate iterator-seq juxt keep " +
	        "keep-indexed key keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list list* list? load load-file " +
	        "load-reader load-string loaded-libs locking long long-array longs loop macroexpand macroexpand-1 make-array " +
	        "make-hierarchy map map-indexed map? mapcat mapv max max-key memfn memoize merge merge-with meta method-sig methods " +
	        "min min-key mod munge name namespace namespace-munge neg? newline next nfirst nil? nnext not not-any? not-empty " +
	        "not-every? not= ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ns-refers ns-resolve ns-unalias " +
	        "ns-unmap nth nthnext nthrest num number? numerator object-array odd? or parents partial partition partition-all " +
	        "partition-by pcalls peek persistent! pmap pop pop! pop-thread-bindings pos? pr pr-str prefer-method prefers " +
	        "primitives-classnames print print-ctor print-dup print-method print-simple print-str printf println println-str " +
	        "prn prn-str promise proxy proxy-call-with-super proxy-mappings proxy-name proxy-super push-thread-bindings pvalues " +
	        "quot rand rand-int rand-nth random-sample range ratio? rational? rationalize re-find re-groups re-matcher re-matches re-pattern " +
	        "re-seq read read-line read-string realized? reduce reduce-kv reductions ref ref-history-count ref-max-history " +
	        "ref-min-history ref-set refer refer-clojure reify release-pending-sends rem remove remove-all-methods " +
	        "remove-method remove-ns remove-watch repeat repeatedly replace replicate require reset! reset-meta! resolve rest " +
	        "restart-agent resultset-seq reverse reversible? rseq rsubseq satisfies? second select-keys send send-off seq seq? " +
	        "seque sequence sequential? set set-error-handler! set-error-mode! set-validator! set? short short-array shorts " +
	        "shuffle shutdown-agents slurp some some-fn sort sort-by sorted-map sorted-map-by sorted-set sorted-set-by sorted? " +
	        "special-symbol? spit split-at split-with str string? struct struct-map subs subseq subvec supers swap! symbol " +
	        "symbol? sync take take-last take-nth take-while test the-ns thread-bound? time to-array to-array-2d trampoline transduce " +
	        "transient tree-seq true? type unchecked-add unchecked-add-int unchecked-byte unchecked-char unchecked-dec " +
	        "unchecked-dec-int unchecked-divide-int unchecked-double unchecked-float unchecked-inc unchecked-inc-int " +
	        "unchecked-int unchecked-long unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int "+
	        "unchecked-remainder-int unchecked-short unchecked-subtract unchecked-subtract-int underive unquote " +
	        "unquote-splicing update update-in update-proxy use val vals var-get var-set var? vary-meta vec vector vector-of " +
	        "vector? volatile! volatile? vreset! vswap! when when-first when-let when-not while with-bindings with-bindings* with-in-str with-loading-context " +
	        "with-local-vars with-meta with-open with-out-str with-precision with-redefs with-redefs-fn xml-seq zero? zipmap " +
	        "*default-data-reader-fn* as-> cond-> cond->> reduced reduced? send-via set-agent-send-executor! " +
	        "set-agent-send-off-executor! some-> some->>");

	    var indentKeys = makeKeywords(
	        // Built-ins
	        "ns fn def defn defmethod bound-fn if if-not case condp when while when-not when-first do future comment doto " +
	        "locking proxy with-open with-precision reify deftype defrecord defprotocol extend extend-protocol extend-type " +
	        "try catch " +

	        // Binding forms
	        "let letfn binding loop for doseq dotimes when-let if-let " +

	        // Data structures
	        "defstruct struct-map assoc " +

	        // clojure.test
	        "testing deftest " +

	        // contrib
	        "handler-case handle dotrace deftrace");

	    var tests = {
	        digit: /\d/,
	        digit_or_colon: /[\d:]/,
	        hex: /[0-9a-f]/i,
	        sign: /[+-]/,
	        exponent: /e/i,
	        keyword_char: /[^\s\(\[\;\)\]]/,
	        symbol: /[\w*+!\-\._?:<>\/\xa1-\uffff]/,
	        block_indent: /^(?:def|with)[^\/]+$|\/(?:def|with)/
	    };

	    function stateStack(indent, type, prev) { // represents a state stack object
	        this.indent = indent;
	        this.type = type;
	        this.prev = prev;
	    }

	    function pushStack(state, indent, type) {
	        state.indentStack = new stateStack(indent, type, state.indentStack);
	    }

	    function popStack(state) {
	        state.indentStack = state.indentStack.prev;
	    }

	    function isNumber(ch, stream){
	        // hex
	        if ( ch === '0' && stream.eat(/x/i) ) {
	            stream.eatWhile(tests.hex);
	            return true;
	        }

	        // leading sign
	        if ( ( ch == '+' || ch == '-' ) && ( tests.digit.test(stream.peek()) ) ) {
	          stream.eat(tests.sign);
	          ch = stream.next();
	        }

	        if ( tests.digit.test(ch) ) {
	            stream.eat(ch);
	            stream.eatWhile(tests.digit);

	            if ( '.' == stream.peek() ) {
	                stream.eat('.');
	                stream.eatWhile(tests.digit);
	            } else if ('/' == stream.peek() ) {
	                stream.eat('/');
	                stream.eatWhile(tests.digit);
	            }

	            if ( stream.eat(tests.exponent) ) {
	                stream.eat(tests.sign);
	                stream.eatWhile(tests.digit);
	            }

	            return true;
	        }

	        return false;
	    }

	    // Eat character that starts after backslash \
	    function eatCharacter(stream) {
	        var first = stream.next();
	        // Read special literals: backspace, newline, space, return.
	        // Just read all lowercase letters.
	        if (first && first.match(/[a-z]/) && stream.match(/[a-z]+/, true)) {
	            return;
	        }
	        // Read unicode character: \u1000 \uA0a1
	        if (first === "u") {
	            stream.match(/[0-9a-z]{4}/i, true);
	        }
	    }

	    return {
	        startState: function () {
	            return {
	                indentStack: null,
	                indentation: 0,
	                mode: false
	            };
	        },

	        token: function (stream, state) {
	            if (state.indentStack == null && stream.sol()) {
	                // update indentation, but only if indentStack is empty
	                state.indentation = stream.indentation();
	            }

	            // skip spaces
	            if (state.mode != "string" && stream.eatSpace()) {
	                return null;
	            }
	            var returnType = null;

	            switch(state.mode){
	                case "string": // multi-line string parsing mode
	                    var next, escaped = false;
	                    while ((next = stream.next()) != null) {
	                        if (next == "\"" && !escaped) {

	                            state.mode = false;
	                            break;
	                        }
	                        escaped = !escaped && next == "\\";
	                    }
	                    returnType = STRING; // continue on in string mode
	                    break;
	                default: // default parsing mode
	                    var ch = stream.next();

	                    if (ch == "\"") {
	                        state.mode = "string";
	                        returnType = STRING;
	                    } else if (ch == "\\") {
	                        eatCharacter(stream);
	                        returnType = CHARACTER;
	                    } else if (ch == "'" && !( tests.digit_or_colon.test(stream.peek()) )) {
	                        returnType = ATOM;
	                    } else if (ch == ";") { // comment
	                        stream.skipToEnd(); // rest of the line is a comment
	                        returnType = COMMENT;
	                    } else if (isNumber(ch,stream)){
	                        returnType = NUMBER;
	                    } else if (ch == "(" || ch == "[" || ch == "{" ) {
	                        var keyWord = '', indentTemp = stream.column(), letter;
	                        /**
	                        Either
	                        (indent-word ..
	                        (non-indent-word ..
	                        (;something else, bracket, etc.
	                        */

	                        if (ch == "(") while ((letter = stream.eat(tests.keyword_char)) != null) {
	                            keyWord += letter;
	                        }

	                        if (keyWord.length > 0 && (indentKeys.propertyIsEnumerable(keyWord) ||
	                                                   tests.block_indent.test(keyWord))) { // indent-word
	                            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);
	                        } else { // non-indent word
	                            // we continue eating the spaces
	                            stream.eatSpace();
	                            if (stream.eol() || stream.peek() == ";") {
	                                // nothing significant after
	                                // we restart indentation the user defined spaces after
	                                pushStack(state, indentTemp + NORMAL_INDENT_UNIT, ch);
	                            } else {
	                                pushStack(state, indentTemp + stream.current().length, ch); // else we match
	                            }
	                        }
	                        stream.backUp(stream.current().length - 1); // undo all the eating

	                        returnType = BRACKET;
	                    } else if (ch == ")" || ch == "]" || ch == "}") {
	                        returnType = BRACKET;
	                        if (state.indentStack != null && state.indentStack.type == (ch == ")" ? "(" : (ch == "]" ? "[" :"{"))) {
	                            popStack(state);
	                        }
	                    } else if ( ch == ":" ) {
	                        stream.eatWhile(tests.symbol);
	                        return ATOM;
	                    } else {
	                        stream.eatWhile(tests.symbol);

	                        if (keywords && keywords.propertyIsEnumerable(stream.current())) {
	                            returnType = KEYWORD;
	                        } else if (builtins && builtins.propertyIsEnumerable(stream.current())) {
	                            returnType = BUILTIN;
	                        } else if (atoms && atoms.propertyIsEnumerable(stream.current())) {
	                            returnType = ATOM;
	                        } else {
	                          returnType = VAR;
	                        }
	                    }
	            }

	            return returnType;
	        },

	        indent: function (state) {
	            if (state.indentStack == null) return state.indentation;
	            return state.indentStack.indent;
	        },

	        closeBrackets: {pairs: "()[]{}\"\""},
	        lineComment: ";;"
	    };
	});

	CodeMirror.defineMIME("text/x-clojure", "clojure");
	CodeMirror.defineMIME("text/x-clojurescript", "clojure");
	CodeMirror.defineMIME("application/edn", "clojure");

	});


/***/ },
/* 906 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(306));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";

	  function doFold(cm, pos, options, force) {
	    if (options && options.call) {
	      var finder = options;
	      options = null;
	    } else {
	      var finder = getOption(cm, options, "rangeFinder");
	    }
	    if (typeof pos == "number") pos = CodeMirror.Pos(pos, 0);
	    var minSize = getOption(cm, options, "minFoldSize");

	    function getRange(allowFolded) {
	      var range = finder(cm, pos);
	      if (!range || range.to.line - range.from.line < minSize) return null;
	      var marks = cm.findMarksAt(range.from);
	      for (var i = 0; i < marks.length; ++i) {
	        if (marks[i].__isFold && force !== "fold") {
	          if (!allowFolded) return null;
	          range.cleared = true;
	          marks[i].clear();
	        }
	      }
	      return range;
	    }

	    var range = getRange(true);
	    if (getOption(cm, options, "scanUp")) while (!range && pos.line > cm.firstLine()) {
	      pos = CodeMirror.Pos(pos.line - 1, 0);
	      range = getRange(false);
	    }
	    if (!range || range.cleared || force === "unfold") return;

	    var myWidget = makeWidget(cm, options);
	    CodeMirror.on(myWidget, "mousedown", function(e) {
	      myRange.clear();
	      CodeMirror.e_preventDefault(e);
	    });
	    var myRange = cm.markText(range.from, range.to, {
	      replacedWith: myWidget,
	      clearOnEnter: getOption(cm, options, "clearOnEnter"),
	      __isFold: true
	    });
	    myRange.on("clear", function(from, to) {
	      CodeMirror.signal(cm, "unfold", cm, from, to);
	    });
	    CodeMirror.signal(cm, "fold", cm, range.from, range.to);
	  }

	  function makeWidget(cm, options) {
	    var widget = getOption(cm, options, "widget");
	    if (typeof widget == "string") {
	      var text = document.createTextNode(widget);
	      widget = document.createElement("span");
	      widget.appendChild(text);
	      widget.className = "CodeMirror-foldmarker";
	    }
	    return widget;
	  }

	  // Clumsy backwards-compatible interface
	  CodeMirror.newFoldFunction = function(rangeFinder, widget) {
	    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };
	  };

	  // New-style interface
	  CodeMirror.defineExtension("foldCode", function(pos, options, force) {
	    doFold(this, pos, options, force);
	  });

	  CodeMirror.defineExtension("isFolded", function(pos) {
	    var marks = this.findMarksAt(pos);
	    for (var i = 0; i < marks.length; ++i)
	      if (marks[i].__isFold) return true;
	  });

	  CodeMirror.commands.toggleFold = function(cm) {
	    cm.foldCode(cm.getCursor());
	  };
	  CodeMirror.commands.fold = function(cm) {
	    cm.foldCode(cm.getCursor(), null, "fold");
	  };
	  CodeMirror.commands.unfold = function(cm) {
	    cm.foldCode(cm.getCursor(), null, "unfold");
	  };
	  CodeMirror.commands.foldAll = function(cm) {
	    cm.operation(function() {
	      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
	        cm.foldCode(CodeMirror.Pos(i, 0), null, "fold");
	    });
	  };
	  CodeMirror.commands.unfoldAll = function(cm) {
	    cm.operation(function() {
	      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
	        cm.foldCode(CodeMirror.Pos(i, 0), null, "unfold");
	    });
	  };

	  CodeMirror.registerHelper("fold", "combine", function() {
	    var funcs = Array.prototype.slice.call(arguments, 0);
	    return function(cm, start) {
	      for (var i = 0; i < funcs.length; ++i) {
	        var found = funcs[i](cm, start);
	        if (found) return found;
	      }
	    };
	  });

	  CodeMirror.registerHelper("fold", "auto", function(cm, start) {
	    var helpers = cm.getHelpers(start, "fold");
	    for (var i = 0; i < helpers.length; i++) {
	      var cur = helpers[i](cm, start);
	      if (cur) return cur;
	    }
	  });

	  var defaultOptions = {
	    rangeFinder: CodeMirror.fold.auto,
	    widget: "\u2194",
	    minFoldSize: 0,
	    scanUp: false,
	    clearOnEnter: true
	  };

	  CodeMirror.defineOption("foldOptions", null);

	  function getOption(cm, options, name) {
	    if (options && options[name] !== undefined)
	      return options[name];
	    var editorOptions = cm.options.foldOptions;
	    if (editorOptions && editorOptions[name] !== undefined)
	      return editorOptions[name];
	    return defaultOptions[name];
	  }

	  CodeMirror.defineExtension("foldOption", function(options, name) {
	    return getOption(this, options, name);
	  });
	});


/***/ },
/* 907 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(306));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";

	CodeMirror.registerHelper("fold", "brace", function(cm, start) {
	  var line = start.line, lineText = cm.getLine(line);
	  var tokenType;

	  function findOpening(openCh) {
	    for (var at = start.ch, pass = 0;;) {
	      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);
	      if (found == -1) {
	        if (pass == 1) break;
	        pass = 1;
	        at = lineText.length;
	        continue;
	      }
	      if (pass == 1 && found < start.ch) break;
	      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));
	      if (!/^(comment|string)/.test(tokenType)) return found + 1;
	      at = found - 1;
	    }
	  }

	  var startToken = "{", endToken = "}", startCh = findOpening("{");
	  if (startCh == null) {
	    startToken = "[", endToken = "]";
	    startCh = findOpening("[");
	  }

	  if (startCh == null) return;
	  var count = 1, lastLine = cm.lastLine(), end, endCh;
	  outer: for (var i = line; i <= lastLine; ++i) {
	    var text = cm.getLine(i), pos = i == line ? startCh : 0;
	    for (;;) {
	      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);
	      if (nextOpen < 0) nextOpen = text.length;
	      if (nextClose < 0) nextClose = text.length;
	      pos = Math.min(nextOpen, nextClose);
	      if (pos == text.length) break;
	      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {
	        if (pos == nextOpen) ++count;
	        else if (!--count) { end = i; endCh = pos; break outer; }
	      }
	      ++pos;
	    }
	  }
	  if (end == null || line == end && endCh == startCh) return;
	  return {from: CodeMirror.Pos(line, startCh),
	          to: CodeMirror.Pos(end, endCh)};
	});

	CodeMirror.registerHelper("fold", "import", function(cm, start) {
	  function hasImport(line) {
	    if (line < cm.firstLine() || line > cm.lastLine()) return null;
	    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
	    if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
	    if (start.type != "keyword" || start.string != "import") return null;
	    // Now find closing semicolon, return its position
	    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {
	      var text = cm.getLine(i), semi = text.indexOf(";");
	      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};
	    }
	  }

	  var startLine = start.line, has = hasImport(startLine), prev;
	  if (!has || hasImport(startLine - 1) || ((prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1))
	    return null;
	  for (var end = has.end;;) {
	    var next = hasImport(end.line + 1);
	    if (next == null) break;
	    end = next.end;
	  }
	  return {from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end};
	});

	CodeMirror.registerHelper("fold", "include", function(cm, start) {
	  function hasInclude(line) {
	    if (line < cm.firstLine() || line > cm.lastLine()) return null;
	    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
	    if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
	    if (start.type == "meta" && start.string.slice(0, 8) == "#include") return start.start + 8;
	  }

	  var startLine = start.line, has = hasInclude(startLine);
	  if (has == null || hasInclude(startLine - 1) != null) return null;
	  for (var end = startLine;;) {
	    var next = hasInclude(end + 1);
	    if (next == null) break;
	    ++end;
	  }
	  return {from: CodeMirror.Pos(startLine, has + 1),
	          to: cm.clipPos(CodeMirror.Pos(end))};
	});

	});


/***/ },
/* 908 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(306));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";

	function lineIndent(cm, lineNo) {
	  var text = cm.getLine(lineNo)
	  var spaceTo = text.search(/\S/)
	  if (spaceTo == -1 || /\bcomment\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1))))
	    return -1
	  return CodeMirror.countColumn(text, null, cm.getOption("tabSize"))
	}
	               !
	CodeMirror.registerHelper("fold", "indent", function(cm, start) {
	  var myIndent = lineIndent(cm, start.line)
	  if (myIndent < 0) return
	  var lastLineInFold = null

	  // Go through lines until we find a line that definitely doesn't belong in
	  // the block we're folding, or to the end.
	  for (var i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {
	    var indent = lineIndent(cm, i)
	    if (indent == -1) {
	    } else if (indent > myIndent) {
	      // Lines with a greater indent are considered part of the block.
	      lastLineInFold = i;
	    } else {
	      // If this line has non-space, non-comment content, and is
	      // indented less or equal to the start line, it is the start of
	      // another block.
	      break;
	    }
	  }
	  if (lastLineInFold) return {
	    from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),
	    to: CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)
	  };
	});

	});


/***/ },
/* 909 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(306), __webpack_require__(906));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror", "./foldcode"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";

	  CodeMirror.defineOption("foldGutter", false, function(cm, val, old) {
	    if (old && old != CodeMirror.Init) {
	      cm.clearGutter(cm.state.foldGutter.options.gutter);
	      cm.state.foldGutter = null;
	      cm.off("gutterClick", onGutterClick);
	      cm.off("change", onChange);
	      cm.off("viewportChange", onViewportChange);
	      cm.off("fold", onFold);
	      cm.off("unfold", onFold);
	      cm.off("swapDoc", onChange);
	    }
	    if (val) {
	      cm.state.foldGutter = new State(parseOptions(val));
	      updateInViewport(cm);
	      cm.on("gutterClick", onGutterClick);
	      cm.on("change", onChange);
	      cm.on("viewportChange", onViewportChange);
	      cm.on("fold", onFold);
	      cm.on("unfold", onFold);
	      cm.on("swapDoc", onChange);
	    }
	  });

	  var Pos = CodeMirror.Pos;

	  function State(options) {
	    this.options = options;
	    this.from = this.to = 0;
	  }

	  function parseOptions(opts) {
	    if (opts === true) opts = {};
	    if (opts.gutter == null) opts.gutter = "CodeMirror-foldgutter";
	    if (opts.indicatorOpen == null) opts.indicatorOpen = "CodeMirror-foldgutter-open";
	    if (opts.indicatorFolded == null) opts.indicatorFolded = "CodeMirror-foldgutter-folded";
	    return opts;
	  }

	  function isFolded(cm, line) {
	    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));
	    for (var i = 0; i < marks.length; ++i)
	      if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i];
	  }

	  function marker(spec) {
	    if (typeof spec == "string") {
	      var elt = document.createElement("div");
	      elt.className = spec + " CodeMirror-guttermarker-subtle";
	      return elt;
	    } else {
	      return spec.cloneNode(true);
	    }
	  }

	  function updateFoldInfo(cm, from, to) {
	    var opts = cm.state.foldGutter.options, cur = from;
	    var minSize = cm.foldOption(opts, "minFoldSize");
	    var func = cm.foldOption(opts, "rangeFinder");
	    cm.eachLine(from, to, function(line) {
	      var mark = null;
	      if (isFolded(cm, cur)) {
	        mark = marker(opts.indicatorFolded);
	      } else {
	        var pos = Pos(cur, 0);
	        var range = func && func(cm, pos);
	        if (range && range.to.line - range.from.line >= minSize)
	          mark = marker(opts.indicatorOpen);
	      }
	      cm.setGutterMarker(line, opts.gutter, mark);
	      ++cur;
	    });
	  }

	  function updateInViewport(cm) {
	    var vp = cm.getViewport(), state = cm.state.foldGutter;
	    if (!state) return;
	    cm.operation(function() {
	      updateFoldInfo(cm, vp.from, vp.to);
	    });
	    state.from = vp.from; state.to = vp.to;
	  }

	  function onGutterClick(cm, line, gutter) {
	    var state = cm.state.foldGutter;
	    if (!state) return;
	    var opts = state.options;
	    if (gutter != opts.gutter) return;
	    var folded = isFolded(cm, line);
	    if (folded) folded.clear();
	    else cm.foldCode(Pos(line, 0), opts.rangeFinder);
	  }

	  function onChange(cm) {
	    var state = cm.state.foldGutter;
	    if (!state) return;
	    var opts = state.options;
	    state.from = state.to = 0;
	    clearTimeout(state.changeUpdate);
	    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);
	  }

	  function onViewportChange(cm) {
	    var state = cm.state.foldGutter;
	    if (!state) return;
	    var opts = state.options;
	    clearTimeout(state.changeUpdate);
	    state.changeUpdate = setTimeout(function() {
	      var vp = cm.getViewport();
	      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
	        updateInViewport(cm);
	      } else {
	        cm.operation(function() {
	          if (vp.from < state.from) {
	            updateFoldInfo(cm, vp.from, state.from);
	            state.from = vp.from;
	          }
	          if (vp.to > state.to) {
	            updateFoldInfo(cm, state.to, vp.to);
	            state.to = vp.to;
	          }
	        });
	      }
	    }, opts.updateViewportTimeSpan || 400);
	  }

	  function onFold(cm, from) {
	    var state = cm.state.foldGutter;
	    if (!state) return;
	    var line = from.line;
	    if (line >= state.from && line < state.to)
	      updateFoldInfo(cm, line, line + 1);
	  }
	});


/***/ },
/* 910 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var SplitBox = __webpack_require__(911);

	module.exports = SplitBox;

/***/ },
/* 911 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(22);
	var Draggable = React.createFactory(__webpack_require__(912));
	var dom = React.DOM,
	    PropTypes = React.PropTypes;


	__webpack_require__(913);

	/**
	 * This component represents a Splitter. The splitter supports vertical
	 * as well as horizontal mode.
	 */
	var SplitBox = React.createClass({
	  propTypes: {
	    // Custom class name. You can use more names separated by a space.
	    className: PropTypes.string,
	    // Initial size of controlled panel.
	    initialSize: PropTypes.any,
	    // Optional initial width of controlled panel.
	    initialWidth: PropTypes.number,
	    // Optional initial height of controlled panel.
	    initialHeight: PropTypes.number,
	    // Left/top panel
	    startPanel: PropTypes.any,
	    // Left/top panel collapse state.
	    startPanelCollapsed: PropTypes.bool,
	    // Min panel size.
	    minSize: PropTypes.any,
	    // Max panel size.
	    maxSize: PropTypes.any,
	    // Right/bottom panel
	    endPanel: PropTypes.any,
	    // Right/bottom panel collapse state.
	    endPanelCollapsed: PropTypes.bool,
	    // True if the right/bottom panel should be controlled.
	    endPanelControl: PropTypes.bool,
	    // Size of the splitter handle bar.
	    splitterSize: PropTypes.number,
	    // True if the splitter bar is vertical (default is vertical).
	    vert: PropTypes.bool,
	    // Optional style properties passed into the splitbox
	    style: PropTypes.object,
	    // Optional callback when splitbox resize stops
	    onResizeEnd: PropTypes.func
	  },

	  displayName: "SplitBox",

	  getDefaultProps() {
	    return {
	      splitterSize: 5,
	      vert: true,
	      endPanelControl: false,
	      endPanelCollapsed: false,
	      startPanelCollapsed: false
	    };
	  },

	  /**
	   * The state stores the current orientation (vertical or horizontal)
	   * and the current size (width/height). All these values can change
	   * during the component's life time.
	   */
	  getInitialState() {
	    return {
	      vert: this.props.vert,
	      // We use integers for these properties
	      width: parseInt(this.props.initialWidth || this.props.initialSize),
	      height: parseInt(this.props.initialHeight || this.props.initialSize)
	    };
	  },

	  componentWillReceiveProps(nextProps) {
	    if (this.props.vert !== nextProps.vert) {
	      this.setState({ vert: nextProps.vert });
	    }
	  },

	  // Dragging Events

	  /**
	   * Set 'resizing' cursor on entire document during splitter dragging.
	   * This avoids cursor-flickering that happens when the mouse leaves
	   * the splitter bar area (happens frequently).
	   */
	  onStartMove() {
	    var splitBox = ReactDOM.findDOMNode(this);
	    var doc = splitBox.ownerDocument;
	    var defaultCursor = doc.documentElement.style.cursor;
	    doc.documentElement.style.cursor = this.state.vert ? "ew-resize" : "ns-resize";

	    splitBox.classList.add("dragging");

	    this.setState({
	      defaultCursor: defaultCursor
	    });
	  },

	  onStopMove() {
	    var splitBox = ReactDOM.findDOMNode(this);
	    var doc = splitBox.ownerDocument;
	    doc.documentElement.style.cursor = this.state.defaultCursor;

	    splitBox.classList.remove("dragging");

	    if (this.props.onResizeEnd) {
	      this.props.onResizeEnd(this.state.vert ? this.state.width : this.state.height);
	    }
	  },

	  /**
	   * Adjust size of the controlled panel. Depending on the current
	   * orientation we either remember the width or height of
	   * the splitter box.
	   */
	  onMove(_ref) {
	    var movementX = _ref.movementX,
	        movementY = _ref.movementY;

	    var node = ReactDOM.findDOMNode(this);
	    var doc = node.ownerDocument;

	    if (this.props.endPanelControl) {
	      // For the end panel we need to increase the width/height when the
	      // movement is towards the left/top.
	      movementX = -movementX;
	      movementY = -movementY;
	    }

	    if (this.state.vert) {
	      var isRtl = doc.dir === "rtl";
	      if (isRtl) {
	        // In RTL we need to reverse the movement again -- but only for vertical
	        // splitters
	        movementX = -movementX;
	      }

	      this.setState((state, props) => ({
	        width: state.width + movementX
	      }));
	    } else {
	      this.setState((state, props) => ({
	        height: state.height + movementY
	      }));
	    }
	  },

	  // Rendering
	  preparePanelStyles() {
	    var vert = this.state.vert;
	    var _props = this.props,
	        minSize = _props.minSize,
	        maxSize = _props.maxSize,
	        startPanelCollapsed = _props.startPanelCollapsed,
	        endPanelControl = _props.endPanelControl,
	        endPanelCollapsed = _props.endPanelCollapsed;

	    var leftPanelStyle = void 0,
	        rightPanelStyle = void 0;

	    // Set proper size for panels depending on the current state.
	    if (vert) {
	      var startWidth = endPanelControl ? null : this.state.width,
	          endWidth = endPanelControl ? this.state.width : null;

	      leftPanelStyle = {
	        maxWidth: endPanelControl ? null : maxSize,
	        minWidth: endPanelControl ? null : minSize,
	        width: startPanelCollapsed ? 0 : startWidth
	      };
	      rightPanelStyle = {
	        maxWidth: endPanelControl ? maxSize : null,
	        minWidth: endPanelControl ? minSize : null,
	        width: endPanelCollapsed ? 0 : endWidth
	      };
	    } else {
	      var startHeight = endPanelControl ? null : this.state.height,
	          endHeight = endPanelControl ? this.state.height : null;

	      leftPanelStyle = {
	        maxHeight: endPanelControl ? null : maxSize,
	        minHeight: endPanelControl ? null : minSize,
	        height: endPanelCollapsed ? maxSize : startHeight
	      };
	      rightPanelStyle = {
	        maxHeight: endPanelControl ? maxSize : null,
	        minHeight: endPanelControl ? minSize : null,
	        height: startPanelCollapsed ? maxSize : endHeight
	      };
	    }

	    return { leftPanelStyle, rightPanelStyle };
	  },

	  render() {
	    var vert = this.state.vert;
	    var _props2 = this.props,
	        startPanelCollapsed = _props2.startPanelCollapsed,
	        startPanel = _props2.startPanel,
	        endPanel = _props2.endPanel,
	        endPanelControl = _props2.endPanelControl,
	        splitterSize = _props2.splitterSize,
	        endPanelCollapsed = _props2.endPanelCollapsed;


	    var style = Object.assign({}, this.props.style);

	    // Calculate class names list.
	    var classNames = ["split-box"];
	    classNames.push(vert ? "vert" : "horz");
	    if (this.props.className) {
	      classNames = classNames.concat(this.props.className.split(" "));
	    }

	    var _preparePanelStyles = this.preparePanelStyles(),
	        leftPanelStyle = _preparePanelStyles.leftPanelStyle,
	        rightPanelStyle = _preparePanelStyles.rightPanelStyle;

	    // Calculate splitter size


	    var splitterStyle = {
	      flex: `0 0 ${splitterSize}px`
	    };

	    return dom.div({
	      className: classNames.join(" "),
	      style: style
	    }, !startPanelCollapsed ? dom.div({
	      className: endPanelControl ? "uncontrolled" : "controlled",
	      style: leftPanelStyle
	    }, startPanel) : null, Draggable({
	      className: "splitter",
	      style: splitterStyle,
	      onStart: this.onStartMove,
	      onStop: this.onStopMove,
	      onMove: this.onMove
	    }), !endPanelCollapsed ? dom.div({
	      className: endPanelControl ? "controlled" : "uncontrolled",
	      style: rightPanelStyle
	    }, endPanel) : null);
	  }
	});

	module.exports = SplitBox;

/***/ },
/* 912 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(22);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;


	var Draggable = React.createClass({
	  displayName: "Draggable",

	  propTypes: {
	    onMove: PropTypes.func.isRequired,
	    onStart: PropTypes.func,
	    onStop: PropTypes.func,
	    style: PropTypes.object,
	    className: PropTypes.string
	  },

	  startDragging(ev) {
	    ev.preventDefault();
	    var doc = ReactDOM.findDOMNode(this).ownerDocument;
	    doc.addEventListener("mousemove", this.onMove);
	    doc.addEventListener("mouseup", this.onUp);
	    this.props.onStart && this.props.onStart();
	  },

	  onMove(ev) {
	    ev.preventDefault();
	    // We pass the whole event because we don't know which properties
	    // the callee needs.
	    this.props.onMove(ev);
	  },

	  onUp(ev) {
	    ev.preventDefault();
	    var doc = ReactDOM.findDOMNode(this).ownerDocument;
	    doc.removeEventListener("mousemove", this.onMove);
	    doc.removeEventListener("mouseup", this.onUp);
	    this.props.onStop && this.props.onStop();
	  },

	  render() {
	    return dom.div({
	      style: this.props.style,
	      className: this.props.className,
	      onMouseDown: this.startDragging
	    });
	  }
	});

	module.exports = Draggable;

/***/ },
/* 913 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 914 */,
/* 915 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _reactRedux = __webpack_require__(151);

	var _redux = __webpack_require__(3);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	var _utils = __webpack_require__(234);

	var _url = __webpack_require__(334);

	var _source = __webpack_require__(233);

	__webpack_require__(917);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Autocomplete = (0, _react.createFactory)(__webpack_require__(342).default);

	function searchResults(sources) {
	  function getSourcePath(source) {
	    var _parseURL = (0, _url.parse)(source.get("url")),
	        path = _parseURL.path,
	        href = _parseURL.href;
	    // for URLs like "about:home" the path is null so we pass the full href


	    return path || href;
	  }

	  return sources.valueSeq().filter(source => !(0, _source.isPretty)(source.toJS()) && source.get("url")).map(source => ({
	    value: getSourcePath(source),
	    title: getSourcePath(source).split("/").pop(),
	    subtitle: (0, _utils.endTruncateStr)(getSourcePath(source), 100),
	    id: source.get("id")
	  })).toJS();
	}

	class ProjectSearch extends _react.Component {

	  constructor(props) {
	    super(props);

	    this.state = {
	      inputValue: ""
	    };

	    this.toggle = this.toggle.bind(this);
	    this.onEscape = this.onEscape.bind(this);
	    this.close = this.close.bind(this);
	  }

	  componentWillUnmount() {
	    var shortcuts = this.context.shortcuts;
	    var searchKeys = [L10N.getStr("sources.search.key"), L10N.getStr("sources.searchAlt.key")];
	    searchKeys.forEach(key => shortcuts.off(`CmdOrCtrl+${key}`, this.toggle));
	    shortcuts.off("Escape", this.onEscape);
	  }

	  componentDidMount() {
	    var shortcuts = this.context.shortcuts;
	    var searchKeys = [L10N.getStr("sources.search.key"), L10N.getStr("sources.searchAlt.key")];
	    searchKeys.forEach(key => shortcuts.on(`CmdOrCtrl+${key}`, this.toggle));
	    shortcuts.on("Escape", this.onEscape);
	  }

	  toggle(key, e) {
	    e.preventDefault();
	    this.props.toggleProjectSearch();
	  }

	  onEscape(shortcut, e) {
	    if (this.props.searchOn) {
	      e.preventDefault();
	      this.close();
	    }
	  }

	  close() {
	    this.setState({ inputValue: "" });
	    this.props.toggleProjectSearch(false);
	  }

	  render() {
	    if (!this.props.searchOn) {
	      return null;
	    }

	    return _react.DOM.div({ className: "search-container" }, Autocomplete({
	      selectItem: result => {
	        this.props.selectSource(result.id);
	        this.close();
	      },
	      close: this.close,
	      items: searchResults(this.props.sources),
	      inputValue: this.state.inputValue,
	      placeholder: L10N.getStr("sourceSearch.search"),
	      size: "big"
	    }));
	  }
	}

	ProjectSearch.propTypes = {
	  sources: _react.PropTypes.object.isRequired,
	  selectSource: _react.PropTypes.func.isRequired,
	  toggleProjectSearch: _react.PropTypes.func.isRequired,
	  searchOn: _react.PropTypes.bool
	};

	ProjectSearch.contextTypes = {
	  shortcuts: _react.PropTypes.object
	};

	ProjectSearch.displayName = "ProjectSearch";

	exports.default = (0, _reactRedux.connect)(state => ({
	  sources: (0, _selectors.getSources)(state),
	  searchOn: (0, _selectors.getProjectSearchState)(state)
	}), dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(ProjectSearch);

/***/ },
/* 916 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module), (function() { return this; }())))

/***/ },
/* 917 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 918 */,
/* 919 */
/***/ function(module, exports) {

	module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1792 1792\"><path d=\"M1395 1184q0 13-10 23l-50 50q-10 10-23 10t-23-10l-393-393-393 393q-10 10-23 10t-23-10l-50-50q-10-10-10-23t10-23l466-466q10-10 23-10t23 10l466 466q10 10 10 23z\" fill=\"#696969\"></path></svg>"

/***/ },
/* 920 */
/***/ function(module, exports) {

	module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1792 1792\"><path d=\"M1395 736q0 13-10 23l-466 466q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l50-50q10-10 23-10t23 10l393 393 393-393q10-10 23-10t23 10l50 50q10 10 10 23z\" fill=\"#696969\"></path></svg>"

/***/ },
/* 921 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _redux = __webpack_require__(3);

	var _reactRedux = __webpack_require__(151);

	var _actions = __webpack_require__(244);

	var _actions2 = _interopRequireDefault(_actions);

	var _selectors = __webpack_require__(242);

	var _devtoolsConfig = __webpack_require__(828);

	var _parser = __webpack_require__(827);

	__webpack_require__(922);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	class Outline extends _react.Component {

	  constructor(props) {
	    super(props);
	    this.state = {};
	  }

	  componentWillUpdate(_ref) {
	    var sourceText = _ref.sourceText;

	    if (sourceText) {
	      this.setSymbolDeclarations(sourceText);
	    }
	  }

	  setSymbolDeclarations(sourceText) {
	    var _this = this;

	    return _asyncToGenerator(function* () {
	      var symbolDeclarations = yield (0, _parser.getSymbols)(sourceText.toJS());

	      _this.setState({
	        symbolDeclarations
	      });
	    })();
	  }

	  renderFunction(func) {
	    return _react.DOM.li({}, func.value);
	  }

	  renderFunctions() {
	    var symbolDeclarations = this.state.symbolDeclarations;

	    if (!symbolDeclarations) {
	      return;
	    }

	    var functions = symbolDeclarations.functions;


	    return functions.filter(func => func.value != "anonymous").map(this.renderFunction);
	  }

	  render() {
	    if (!(0, _devtoolsConfig.isEnabled)("outline")) {
	      return null;
	    }

	    return _react.DOM.div({ className: "outline" }, _react.DOM.ul({}, this.renderFunctions()));
	  }
	}

	Outline.propTypes = {
	  selectedSource: _react.PropTypes.object
	};

	Outline.displayName = "Outline";

	exports.default = (0, _reactRedux.connect)(state => {
	  var selectedSource = (0, _selectors.getSelectedSource)(state);
	  var sourceId = selectedSource ? selectedSource.get("id") : null;

	  return {
	    sourceText: (0, _selectors.getSourceText)(state, sourceId)
	  };
	}, dispatch => (0, _redux.bindActionCreators)(_actions2.default, dispatch))(Outline);

/***/ },
/* 922 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 923 */,
/* 924 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _require = __webpack_require__(925),
	    MODE = _require.MODE;

	var _require2 = __webpack_require__(926),
	    REPS = _require2.REPS;

	var _require3 = __webpack_require__(927),
	    createFactories = _require3.createFactories,
	    parseURLEncodedText = _require3.parseURLEncodedText,
	    parseURLParams = _require3.parseURLParams,
	    getSelectableInInspectorGrips = _require3.getSelectableInInspectorGrips,
	    maybeEscapePropertyName = _require3.maybeEscapePropertyName;

	module.exports = {
	  REPS,
	  MODE,
	  createFactories,
	  maybeEscapePropertyName,
	  parseURLEncodedText,
	  parseURLParams,
	  getSelectableInInspectorGrips
	};

/***/ },
/* 925 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  MODE: {
	    TINY: Symbol("TINY"),
	    SHORT: Symbol("SHORT"),
	    LONG: Symbol("LONG")
	  }
	};

/***/ },
/* 926 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip;

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;

	// Load all existing rep templates


	var Undefined = __webpack_require__(929);
	var Null = __webpack_require__(930);
	var StringRep = __webpack_require__(931);
	var LongStringRep = __webpack_require__(932);
	var Number = __webpack_require__(933);
	var ArrayRep = __webpack_require__(934);
	var Obj = __webpack_require__(936);
	var SymbolRep = __webpack_require__(939);
	var InfinityRep = __webpack_require__(940);
	var NaNRep = __webpack_require__(941);

	// DOM types (grips)
	var Attribute = __webpack_require__(942);
	var DateTime = __webpack_require__(943);
	var Document = __webpack_require__(944);
	var Event = __webpack_require__(945);
	var Func = __webpack_require__(946);
	var PromiseRep = __webpack_require__(947);
	var RegExp = __webpack_require__(948);
	var StyleSheet = __webpack_require__(949);
	var CommentNode = __webpack_require__(950);
	var ElementNode = __webpack_require__(951);
	var TextNode = __webpack_require__(953);
	var ErrorRep = __webpack_require__(954);
	var Window = __webpack_require__(955);
	var ObjectWithText = __webpack_require__(956);
	var ObjectWithURL = __webpack_require__(957);
	var GripArray = __webpack_require__(958);
	var GripMap = __webpack_require__(959);
	var Grip = __webpack_require__(938);

	// List of all registered template.
	// XXX there should be a way for extensions to register a new
	// or modify an existing rep.
	var reps = [RegExp, StyleSheet, Event, DateTime, CommentNode, ElementNode, TextNode, Attribute, LongStringRep, Func, PromiseRep, ArrayRep, Document, Window, ObjectWithText, ObjectWithURL, ErrorRep, GripArray, GripMap, Grip, Undefined, Null, StringRep, Number, SymbolRep, InfinityRep, NaNRep];

	/**
	 * Generic rep that is using for rendering native JS types or an object.
	 * The right template used for rendering is picked automatically according
	 * to the current value type. The value must be passed is as 'object'
	 * property.
	 */
	var Rep = React.createClass({
	  displayName: "Rep",

	  propTypes: {
	    object: React.PropTypes.any,
	    defaultRep: React.PropTypes.object,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key]))
	  },

	  render: function () {
	    var rep = getRep(this.props.object, this.props.defaultRep);
	    return rep(this.props);
	  }
	});

	// Helpers

	/**
	 * Return a rep object that is responsible for rendering given
	 * object.
	 *
	 * @param object {Object} Object to be rendered in the UI. This
	 * can be generic JS object as well as a grip (handle to a remote
	 * debuggee object).
	 *
	 * @param defaultObject {React.Component} The default template
	 * that should be used to render given object if none is found.
	 */
	function getRep(object) {
	  var defaultRep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Obj;

	  var type = typeof object;
	  if (type == "object" && object instanceof String) {
	    type = "string";
	  } else if (object && type == "object" && object.type) {
	    type = object.type;
	  }

	  if (isGrip(object)) {
	    type = object.class;
	  }

	  for (var i = 0; i < reps.length; i++) {
	    var rep = reps[i];
	    try {
	      // supportsObject could return weight (not only true/false
	      // but a number), which would allow to priorities templates and
	      // support better extensibility.
	      if (rep.supportsObject(object, type)) {
	        return React.createFactory(rep.rep);
	      }
	    } catch (err) {
	      console.error(err);
	    }
	  }

	  return React.createFactory(defaultRep.rep);
	}

	module.exports = {
	  Rep,
	  REPS: {
	    ArrayRep,
	    Attribute,
	    CommentNode,
	    DateTime,
	    Document,
	    ElementNode,
	    ErrorRep,
	    Event,
	    Func,
	    Grip,
	    GripArray,
	    GripMap,
	    InfinityRep,
	    LongStringRep,
	    NaNRep,
	    Null,
	    Number,
	    Obj,
	    ObjectWithText,
	    ObjectWithURL,
	    PromiseRep,
	    RegExp,
	    Rep,
	    StringRep,
	    StyleSheet,
	    SymbolRep,
	    TextNode,
	    Undefined,
	    Window
	  }
	};

/***/ },
/* 927 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	// Dependencies
	var React = __webpack_require__(2);

	// Utils
	var nodeConstants = __webpack_require__(928);

	/**
	 * Create React factories for given arguments.
	 * Example:
	 *   const { Rep } = createFactories(require("./rep"));
	 */
	function createFactories(args) {
	  var result = {};
	  for (var p in args) {
	    result[p] = React.createFactory(args[p]);
	  }
	  return result;
	}

	/**
	 * Returns true if the given object is a grip (see RDP protocol)
	 */
	function isGrip(object) {
	  return object && object.actor;
	}

	function escapeNewLines(value) {
	  return value.replace(/\r/gm, "\\r").replace(/\n/gm, "\\n");
	}

	// Map from character code to the corresponding escape sequence.  \0
	// isn't here because it would require special treatment in some
	// situations.  \b, \f, and \v aren't here because they aren't very
	// common.  \' isn't here because there's no need, we only
	// double-quote strings.
	var escapeMap = {
	  // Tab.
	  9: "\\t",
	  // Newline.
	  0xa: "\\n",
	  // Carriage return.
	  0xd: "\\r",
	  // Quote.
	  0x22: "\\\"",
	  // Backslash.
	  0x5c: "\\\\"
	};

	// Regexp that matches any character we might possibly want to escape.
	// Note that we over-match here, because it's difficult to, say, match
	// an unpaired surrogate with a regexp.  The details are worked out by
	// the replacement function; see |escapeString|.
	var escapeRegexp = new RegExp("[" +
	// Quote and backslash.
	"\"\\\\" +
	// Controls.
	"\x00-\x1f" +
	// More controls.
	"\x7f-\x9f" +
	// BOM
	"\ufeff" +
	// Replacement characters and non-characters.
	"\ufffc-\uffff" +
	// Surrogates.
	"\ud800-\udfff" +
	// Mathematical invisibles.
	"\u2061-\u2064" +
	// Line and paragraph separators.
	"\u2028-\u2029" +
	// Private use area.
	"\ue000-\uf8ff" + "]", "g");

	/**
	 * Escape a string so that the result is viewable and valid JS.
	 * Control characters, other invisibles, invalid characters,
	 * backslash, and double quotes are escaped.  The resulting string is
	 * surrounded by double quotes.
	 *
	 * @param {String} str
	 *        the input
	 * @return {String} the escaped string
	 */
	function escapeString(str) {
	  return "\"" + str.replace(escapeRegexp, (match, offset) => {
	    var c = match.charCodeAt(0);
	    if (c in escapeMap) {
	      return escapeMap[c];
	    }
	    if (c >= 0xd800 && c <= 0xdfff) {
	      // Find the full code point containing the surrogate, with a
	      // special case for a trailing surrogate at the start of the
	      // string.
	      if (c >= 0xdc00 && offset > 0) {
	        --offset;
	      }
	      var codePoint = str.codePointAt(offset);
	      if (codePoint >= 0xd800 && codePoint <= 0xdfff) {
	        // Unpaired surrogate.
	        return "\\u" + codePoint.toString(16);
	      } else if (codePoint >= 0xf0000 && codePoint <= 0x10fffd) {
	        // Private use area.  Because we visit each pair of a such a
	        // character, return the empty string for one half and the
	        // real result for the other, to avoid duplication.
	        if (c <= 0xdbff) {
	          return "\\u{" + codePoint.toString(16) + "}";
	        }
	        return "";
	      }
	      // Other surrogate characters are passed through.
	      return match;
	    }
	    return "\\u" + ("0000" + c.toString(16)).substr(-4);
	  }) + "\"";
	}

	/**
	 * Escape a property name, if needed.  "Escaping" in this context
	 * means surrounding the property name with quotes.
	 *
	 * @param {String}
	 *        name the property name
	 * @return {String} either the input, or the input surrounded by
	 *                  quotes, properly quoted in JS syntax.
	 */
	function maybeEscapePropertyName(name) {
	  // Quote the property name if it needs quoting.  This particular
	  // test is an approximation; see
	  // https://mathiasbynens.be/notes/javascript-properties.  However,
	  // the full solution requires a fair amount of Unicode data, and so
	  // let's defer that until either it's important, or the \p regexp
	  // syntax lands, see
	  // https://github.com/tc39/proposal-regexp-unicode-property-escapes.
	  if (!/^\w+$/.test(name)) {
	    name = escapeString(name);
	  }
	  return name;
	}

	function cropMultipleLines(text, limit) {
	  return escapeNewLines(cropString(text, limit));
	}

	function rawCropString(text, limit, alternativeText) {
	  if (!alternativeText) {
	    alternativeText = "\u2026";
	  }

	  // Crop the string only if a limit is actually specified.
	  if (!limit || limit <= 0) {
	    return text;
	  }

	  // Set the limit at least to the length of the alternative text
	  // plus one character of the original text.
	  if (limit <= alternativeText.length) {
	    limit = alternativeText.length + 1;
	  }

	  var halfLimit = (limit - alternativeText.length) / 2;

	  if (text.length > limit) {
	    return text.substr(0, Math.ceil(halfLimit)) + alternativeText + text.substr(text.length - Math.floor(halfLimit));
	  }

	  return text;
	}

	function cropString(text, limit, alternativeText) {
	  return rawCropString(sanitizeString(text + ""), limit, alternativeText);
	}

	function sanitizeString(text) {
	  // Replace all non-printable characters, except of
	  // (horizontal) tab (HT: \x09) and newline (LF: \x0A, CR: \x0D),
	  // with unicode replacement character (u+fffd).
	  // eslint-disable-next-line no-control-regex
	  var re = new RegExp("[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]", "g");
	  return text.replace(re, "\ufffd");
	}

	function parseURLParams(url) {
	  url = new URL(url);
	  return parseURLEncodedText(url.searchParams);
	}

	function parseURLEncodedText(text) {
	  var params = [];

	  // In case the text is empty just return the empty parameters
	  if (text == "") {
	    return params;
	  }

	  var searchParams = new URLSearchParams(text);
	  var entries = [].concat(_toConsumableArray(searchParams.entries()));
	  return entries.map(entry => {
	    return {
	      name: entry[0],
	      value: entry[1]
	    };
	  });
	}

	function getFileName(url) {
	  var split = splitURLBase(url);
	  return split.name;
	}

	function splitURLBase(url) {
	  if (!isDataURL(url)) {
	    return splitURLTrue(url);
	  }
	  return {};
	}

	function getURLDisplayString(url) {
	  return cropString(url);
	}

	function isDataURL(url) {
	  return url && url.substr(0, 5) == "data:";
	}

	function splitURLTrue(url) {
	  var reSplitFile = /(.*?):\/{2,3}([^\/]*)(.*?)([^\/]*?)($|\?.*)/;
	  var m = reSplitFile.exec(url);

	  if (!m) {
	    return {
	      name: url,
	      path: url
	    };
	  } else if (m[4] == "" && m[5] == "") {
	    return {
	      protocol: m[1],
	      domain: m[2],
	      path: m[3],
	      name: m[3] != "/" ? m[3] : m[2]
	    };
	  }

	  return {
	    protocol: m[1],
	    domain: m[2],
	    path: m[2] + m[3],
	    name: m[4] + m[5]
	  };
	}

	/**
	 * Wrap the provided render() method of a rep in a try/catch block that will render a
	 * fallback rep if the render fails.
	 */
	function wrapRender(renderMethod) {
	  return function () {
	    try {
	      return renderMethod.call(this);
	    } catch (e) {
	      return React.DOM.span({
	        className: "objectBox objectBox-failure",
	        title: "This object could not be rendered, " + "please file a bug on bugzilla.mozilla.org"
	      },
	      /* Labels have to be hardcoded for reps, see Bug 1317038. */
	      "Invalid object");
	    }
	  };
	}

	/**
	 * Get an array of all the items from the grip in parameter (including the grip itself)
	 * which can be selected in the inspector.
	 *
	 * @param {Object} Grip
	 * @return {Array} Flat array of the grips which can be selected in the inspector
	 */
	function getSelectableInInspectorGrips(grip) {
	  var grips = new Set(getFlattenedGrips([grip]));
	  return [].concat(_toConsumableArray(grips)).filter(isGripSelectableInInspector);
	}

	/**
	 * Indicate if a Grip can be selected in the inspector,
	 * i.e. if it represents a node element.
	 *
	 * @param {Object} Grip
	 * @return {Boolean}
	 */
	function isGripSelectableInInspector(grip) {
	  return grip && typeof grip === "object" && grip.preview && [nodeConstants.TEXT_NODE, nodeConstants.ELEMENT_NODE].includes(grip.preview.nodeType);
	}

	/**
	 * Get a flat array of all the grips and their preview items.
	 *
	 * @param {Array} Grips
	 * @return {Array} Flat array of the grips and their preview items
	 */
	function getFlattenedGrips(grips) {
	  return grips.reduce((res, grip) => {
	    var previewItems = getGripPreviewItems(grip);
	    var flatPreviewItems = previewItems.length > 0 ? getFlattenedGrips(previewItems) : [];

	    return [].concat(_toConsumableArray(res), [grip], _toConsumableArray(flatPreviewItems));
	  }, []);
	}

	/**
	 * Get preview items from a Grip.
	 *
	 * @param {Object} Grip from which we want the preview items
	 * @return {Array} Array of the preview items of the grip, or an empty array
	 *                 if the grip does not have preview items
	 */
	function getGripPreviewItems(grip) {
	  if (!grip) {
	    return [];
	  }

	  // Promise resolved value Grip
	  if (grip.promiseState && grip.promiseState.value) {
	    return [grip.promiseState.value];
	  }

	  // Array Grip
	  if (grip.preview && grip.preview.items) {
	    return grip.preview.items;
	  }

	  // Node Grip
	  if (grip.preview && grip.preview.childNodes) {
	    return grip.preview.childNodes;
	  }

	  // Set or Map Grip
	  if (grip.preview && grip.preview.entries) {
	    return grip.preview.entries.reduce((res, entry) => res.concat(entry), []);
	  }

	  // Event Grip
	  if (grip.preview && grip.preview.target) {
	    return [grip.preview.target];
	  }

	  // Generic Grip
	  if (grip.preview && grip.preview.ownProperties) {
	    var propertiesValues = Object.values(grip.preview.ownProperties).map(property => property.value || property);

	    // ArrayBuffer Grip
	    if (grip.preview.safeGetterValues) {
	      propertiesValues = propertiesValues.concat(Object.values(grip.preview.safeGetterValues).map(property => property.getterValue || property));
	    }

	    return propertiesValues;
	  }

	  return [];
	}

	module.exports = {
	  createFactories,
	  isGrip,
	  cropString,
	  rawCropString,
	  sanitizeString,
	  escapeString,
	  wrapRender,
	  cropMultipleLines,
	  parseURLParams,
	  parseURLEncodedText,
	  getFileName,
	  getURLDisplayString,
	  getSelectableInInspectorGrips,
	  maybeEscapePropertyName
	};

/***/ },
/* 928 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  ELEMENT_NODE: 1,
	  ATTRIBUTE_NODE: 2,
	  TEXT_NODE: 3,
	  CDATA_SECTION_NODE: 4,
	  ENTITY_REFERENCE_NODE: 5,
	  ENTITY_NODE: 6,
	  PROCESSING_INSTRUCTION_NODE: 7,
	  COMMENT_NODE: 8,
	  DOCUMENT_NODE: 9,
	  DOCUMENT_TYPE_NODE: 10,
	  DOCUMENT_FRAGMENT_NODE: 11,
	  NOTATION_NODE: 12,

	  // DocumentPosition
	  DOCUMENT_POSITION_DISCONNECTED: 0x01,
	  DOCUMENT_POSITION_PRECEDING: 0x02,
	  DOCUMENT_POSITION_FOLLOWING: 0x04,
	  DOCUMENT_POSITION_CONTAINS: 0x08,
	  DOCUMENT_POSITION_CONTAINED_BY: 0x10,
	  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 0x20
	};

/***/ },
/* 929 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders undefined value
	 */

	var Undefined = React.createClass({
	  displayName: "UndefinedRep",

	  render: wrapRender(function () {
	    return span({ className: "objectBox objectBox-undefined" }, "undefined");
	  })
	});

	function supportsObject(object, type) {
	  if (object && object.type && object.type == "undefined") {
	    return true;
	  }

	  return type == "undefined";
	}

	// Exports from this module

	module.exports = {
	  rep: Undefined,
	  supportsObject: supportsObject
	};

/***/ },
/* 930 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders null value
	 */

	var Null = React.createClass({
	  displayName: "NullRep",

	  render: wrapRender(function () {
	    return span({ className: "objectBox objectBox-null" }, "null");
	  })
	});

	function supportsObject(object, type) {
	  if (object && object.type && object.type == "null") {
	    return true;
	  }

	  return object == null;
	}

	// Exports from this module

	module.exports = {
	  rep: Null,
	  supportsObject: supportsObject
	};

/***/ },
/* 931 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    escapeString = _require.escapeString,
	    rawCropString = _require.rawCropString,
	    sanitizeString = _require.sanitizeString,
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders a string. String value is enclosed within quotes.
	 */

	var StringRep = React.createClass({
	  displayName: "StringRep",

	  propTypes: {
	    useQuotes: React.PropTypes.bool,
	    style: React.PropTypes.object,
	    object: React.PropTypes.string.isRequired,
	    member: React.PropTypes.any,
	    cropLimit: React.PropTypes.number
	  },

	  getDefaultProps: function () {
	    return {
	      useQuotes: true
	    };
	  },

	  render: wrapRender(function () {
	    var text = this.props.object;
	    var member = this.props.member;
	    var style = this.props.style;

	    var config = { className: "objectBox objectBox-string" };
	    if (style) {
	      config.style = style;
	    }

	    if (this.props.useQuotes) {
	      text = escapeString(text);
	    } else {
	      text = sanitizeString(text);
	    }

	    if ((!member || !member.open) && this.props.cropLimit) {
	      text = rawCropString(text, this.props.cropLimit);
	    }

	    return span(config, text);
	  })
	});

	function supportsObject(object, type) {
	  return type == "string";
	}

	// Exports from this module

	module.exports = {
	  rep: StringRep,
	  supportsObject: supportsObject
	};

/***/ },
/* 932 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    escapeString = _require.escapeString,
	    sanitizeString = _require.sanitizeString,
	    isGrip = _require.isGrip,
	    wrapRender = _require.wrapRender;
	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders a long string grip.
	 */

	var LongStringRep = React.createClass({
	  displayName: "LongStringRep",

	  propTypes: {
	    useQuotes: React.PropTypes.bool,
	    style: React.PropTypes.object,
	    cropLimit: React.PropTypes.number.isRequired,
	    member: React.PropTypes.string,
	    object: React.PropTypes.object.isRequired
	  },

	  getDefaultProps: function () {
	    return {
	      useQuotes: true
	    };
	  },

	  render: wrapRender(function () {
	    var _props = this.props,
	        cropLimit = _props.cropLimit,
	        member = _props.member,
	        object = _props.object,
	        style = _props.style,
	        useQuotes = _props.useQuotes;
	    var fullText = object.fullText,
	        initial = object.initial,
	        length = object.length;


	    var config = { className: "objectBox objectBox-string" };
	    if (style) {
	      config.style = style;
	    }

	    var string = member && member.open ? fullText || initial : initial.substring(0, cropLimit);

	    if (string.length < length) {
	      string += "\u2026";
	    }
	    var formattedString = useQuotes ? escapeString(string) : sanitizeString(string);
	    return span(config, formattedString);
	  })
	});

	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	  return object.type === "longString";
	}

	// Exports from this module
	module.exports = {
	  rep: LongStringRep,
	  supportsObject: supportsObject
	};

/***/ },
/* 933 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders a number
	 */

	var Number = React.createClass({
	  displayName: "Number",

	  propTypes: {
	    object: React.PropTypes.oneOfType([React.PropTypes.object, React.PropTypes.number, React.PropTypes.bool]).isRequired
	  },

	  stringify: function (object) {
	    var isNegativeZero = Object.is(object, -0) || object.type && object.type == "-0";

	    return isNegativeZero ? "-0" : String(object);
	  },

	  render: wrapRender(function () {
	    var value = this.props.object;

	    return span({ className: "objectBox objectBox-number" }, this.stringify(value));
	  })
	});

	function supportsObject(object, type) {
	  return ["boolean", "number", "-0"].includes(type);
	}

	// Exports from this module

	module.exports = {
	  rep: Number,
	  supportsObject: supportsObject
	};

/***/ },
/* 934 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    createFactories = _require.createFactories,
	    wrapRender = _require.wrapRender;

	var Caption = React.createFactory(__webpack_require__(935));

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;

	var ModePropType = React.PropTypes.oneOf(
	// @TODO Change this to Object.values once it's supported in Node's version of V8
	Object.keys(MODE).map(key => MODE[key]));

	// Shortcuts
	var DOM = React.DOM;

	/**
	 * Renders an array. The array is enclosed by left and right bracket
	 * and the max number of rendered items depends on the current mode.
	 */
	var ArrayRep = React.createClass({
	  displayName: "ArrayRep",

	  propTypes: {
	    mode: ModePropType,
	    objectLink: React.PropTypes.func,
	    object: React.PropTypes.array.isRequired
	  },

	  getTitle: function (object, context) {
	    return "[" + object.length + "]";
	  },

	  arrayIterator: function (array, max) {
	    var items = [];
	    var delim = void 0;

	    for (var i = 0; i < array.length && i < max; i++) {
	      try {
	        var value = array[i];

	        delim = i == array.length - 1 ? "" : ", ";

	        items.push(ItemRep({
	          object: value,
	          // Hardcode tiny mode to avoid recursive handling.
	          mode: MODE.TINY,
	          delim: delim
	        }));
	      } catch (exc) {
	        items.push(ItemRep({
	          object: exc,
	          mode: MODE.TINY,
	          delim: delim
	        }));
	      }
	    }

	    if (array.length > max) {
	      items.push(Caption({
	        object: this.safeObjectLink({
	          object: this.props.object
	        }, array.length - max + " more…")
	      }));
	    }

	    return items;
	  },

	  /**
	   * Returns true if the passed object is an array with additional (custom)
	   * properties, otherwise returns false. Custom properties should be
	   * displayed in extra expandable section.
	   *
	   * Example array with a custom property.
	   * let arr = [0, 1];
	   * arr.myProp = "Hello";
	   *
	   * @param {Array} array The array object.
	   */
	  hasSpecialProperties: function (array) {
	    function isInteger(x) {
	      var y = parseInt(x, 10);
	      if (isNaN(y)) {
	        return false;
	      }
	      return x === y.toString();
	    }

	    var propsArray = Object.getOwnPropertyNames(array);
	    for (var i = 0; i < propsArray.length; i++) {
	      var p = propsArray[i];

	      // Valid indexes are skipped
	      if (isInteger(p)) {
	        continue;
	      }

	      // Ignore standard 'length' property, anything else is custom.
	      if (p != "length") {
	        return true;
	      }
	    }

	    return false;
	  },

	  // Event Handlers

	  onToggleProperties: function (event) {},

	  onClickBracket: function (event) {},

	  safeObjectLink: function (config) {
	    for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      children[_key - 1] = arguments[_key];
	    }

	    if (this.props.objectLink) {
	      var _props;

	      return (_props = this.props).objectLink.apply(_props, [Object.assign({
	        object: this.props.object
	      }, config)].concat(children));
	    }

	    if (Object.keys(config).length === 0 && children.length === 1) {
	      return children[0];
	    }

	    return DOM.span.apply(DOM, [config].concat(children));
	  },

	  render: wrapRender(function () {
	    var _props2 = this.props,
	        object = _props2.object,
	        _props2$mode = _props2.mode,
	        mode = _props2$mode === undefined ? MODE.SHORT : _props2$mode;


	    var items = void 0;
	    var brackets = void 0;
	    var needSpace = function (space) {
	      return space ? { left: "[ ", right: " ]" } : { left: "[", right: "]" };
	    };

	    if (mode === MODE.TINY) {
	      var isEmpty = object.length === 0;
	      items = [DOM.span({ className: "length" }, isEmpty ? "" : object.length)];
	      brackets = needSpace(false);
	    } else {
	      var max = mode === MODE.SHORT ? 3 : 10;
	      items = this.arrayIterator(object, max);
	      brackets = needSpace(items.length > 0);
	    }

	    return DOM.span.apply(DOM, [{
	      className: "objectBox objectBox-array" }, this.safeObjectLink({
	      className: "arrayLeftBracket",
	      object: object
	    }, brackets.left)].concat(_toConsumableArray(items), [this.safeObjectLink({
	      className: "arrayRightBracket",
	      object: object
	    }, brackets.right), DOM.span({
	      className: "arrayProperties",
	      role: "group" })]));
	  })
	});

	/**
	 * Renders array item. Individual values are separated by a comma.
	 */
	var ItemRep = React.createFactory(React.createClass({
	  displayName: "ItemRep",

	  propTypes: {
	    object: React.PropTypes.any.isRequired,
	    delim: React.PropTypes.string.isRequired,
	    mode: ModePropType
	  },

	  render: wrapRender(function () {
	    var _createFactories = createFactories(__webpack_require__(926)),
	        Rep = _createFactories.Rep;

	    var object = this.props.object;
	    var delim = this.props.delim;
	    var mode = this.props.mode;
	    return DOM.span({}, Rep({ object: object, mode: mode }), delim);
	  })
	}));

	function supportsObject(object, type) {
	  return Array.isArray(object) || Object.prototype.toString.call(object) === "[object Arguments]";
	}

	// Exports from this module
	module.exports = {
	  rep: ArrayRep,
	  supportsObject: supportsObject
	};

/***/ },
/* 935 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Dependencies
	var React = __webpack_require__(2);
	var DOM = React.DOM;

	var _require = __webpack_require__(927),
	    wrapRender = _require.wrapRender;

	/**
	 * Renders a caption. This template is used by other components
	 * that needs to distinguish between a simple text/value and a label.
	 */


	var Caption = React.createClass({
	  displayName: "Caption",

	  propTypes: {
	    object: React.PropTypes.oneOfType([React.PropTypes.number, React.PropTypes.string]).isRequired
	  },

	  render: wrapRender(function () {
	    return DOM.span({ "className": "caption" }, this.props.object);
	  })
	});

	// Exports from this module
	module.exports = Caption;

/***/ },
/* 936 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    wrapRender = _require.wrapRender;

	var Caption = React.createFactory(__webpack_require__(935));
	var PropRep = React.createFactory(__webpack_require__(937));

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;
	// Shortcuts


	var span = React.DOM.span;
	/**
	 * Renders an object. An object is represented by a list of its
	 * properties enclosed in curly brackets.
	 */

	var Obj = React.createClass({
	  displayName: "Obj",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    objectLink: React.PropTypes.func,
	    title: React.PropTypes.string
	  },

	  getTitle: function (object) {
	    var title = this.props.title || object.class || "Object";
	    return this.safeObjectLink({ className: "objectTitle" }, title);
	  },

	  safePropIterator: function (object, max) {
	    max = typeof max === "undefined" ? 3 : max;
	    try {
	      return this.propIterator(object, max);
	    } catch (err) {
	      console.error(err);
	    }
	    return [];
	  },

	  propIterator: function (object, max) {
	    var isInterestingProp = (t, value) => {
	      // Do not pick objects, it could cause recursion.
	      return t == "boolean" || t == "number" || t == "string" && value;
	    };

	    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=945377
	    if (Object.prototype.toString.call(object) === "[object Generator]") {
	      object = Object.getPrototypeOf(object);
	    }

	    // Object members with non-empty values are preferred since it gives the
	    // user a better overview of the object.
	    var propsArray = this.getPropsArray(object, max, isInterestingProp);

	    if (propsArray.length <= max) {
	      // There are not enough props yet (or at least, not enough props to
	      // be able to know whether we should print "more…" or not).
	      // Let's display also empty members and functions.
	      propsArray = propsArray.concat(this.getPropsArray(object, max, (t, value) => {
	        return !isInterestingProp(t, value);
	      }));
	    }

	    if (propsArray.length > max) {
	      propsArray.pop();
	      var objectLink = this.props.objectLink || span;

	      propsArray.push(Caption({
	        object: objectLink({
	          object: object
	        }, Object.keys(object).length - max + " more…")
	      }));
	    } else if (propsArray.length > 0) {
	      // Remove the last comma.
	      propsArray[propsArray.length - 1] = React.cloneElement(propsArray[propsArray.length - 1], { delim: "" });
	    }

	    return propsArray;
	  },

	  getPropsArray: function (object, max, filter) {
	    var propsArray = [];

	    max = max || 3;
	    if (!object) {
	      return propsArray;
	    }

	    // Hardcode tiny mode to avoid recursive handling.
	    var mode = MODE.TINY;

	    try {
	      for (var name in object) {
	        if (propsArray.length > max) {
	          return propsArray;
	        }

	        var value = void 0;
	        try {
	          value = object[name];
	        } catch (exc) {
	          continue;
	        }

	        var t = typeof value;
	        if (filter(t, value)) {
	          propsArray.push(PropRep({
	            mode: mode,
	            name: name,
	            object: value,
	            equal: ": ",
	            delim: ", "
	          }));
	        }
	      }
	    } catch (err) {
	      console.error(err);
	    }

	    return propsArray;
	  },

	  safeObjectLink: function (config) {
	    for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      children[_key - 1] = arguments[_key];
	    }

	    if (this.props.objectLink) {
	      var _props;

	      return (_props = this.props).objectLink.apply(_props, [Object.assign({
	        object: this.props.object
	      }, config)].concat(children));
	    }

	    if (Object.keys(config).length === 0 && children.length === 1) {
	      return children[0];
	    }

	    return span.apply(undefined, [config].concat(children));
	  },

	  render: wrapRender(function () {
	    var object = this.props.object;
	    var propsArray = this.safePropIterator(object);

	    if (this.props.mode === MODE.TINY || !propsArray.length) {
	      return span({ className: "objectBox objectBox-object" }, this.getTitle(object));
	    }

	    return span.apply(undefined, [{ className: "objectBox objectBox-object" }, this.getTitle(object), this.safeObjectLink({
	      className: "objectLeftBrace"
	    }, " { ")].concat(_toConsumableArray(propsArray), [this.safeObjectLink({
	      className: "objectRightBrace"
	    }, " }")]));
	  })
	});
	function supportsObject(object, type) {
	  return true;
	}

	// Exports from this module
	module.exports = {
	  rep: Obj,
	  supportsObject: supportsObject
	};

/***/ },
/* 937 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    createFactories = _require.createFactories,
	    maybeEscapePropertyName = _require.maybeEscapePropertyName,
	    wrapRender = _require.wrapRender;

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;
	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Property for Obj (local JS objects), Grip (remote JS objects)
	 * and GripMap (remote JS maps and weakmaps) reps.
	 * It's used to render object properties.
	 */

	var PropRep = React.createClass({
	  displayName: "PropRep",

	  propTypes: {
	    // Property name.
	    name: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.object]).isRequired,
	    // Equal character rendered between property name and value.
	    equal: React.PropTypes.string,
	    // Delimiter character used to separate individual properties.
	    delim: React.PropTypes.string,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    objectLink: React.PropTypes.func,
	    attachedActorIds: React.PropTypes.array,
	    onDOMNodeMouseOver: React.PropTypes.func,
	    onDOMNodeMouseOut: React.PropTypes.func,
	    onInspectIconClick: React.PropTypes.func,
	    // Normally a PropRep will quote a property name that isn't valid
	    // when unquoted; but this flag can be used to suppress the
	    // quoting.
	    suppressQuotes: React.PropTypes.bool
	  },

	  render: wrapRender(function () {
	    var Grip = __webpack_require__(938);

	    var _createFactories = createFactories(__webpack_require__(926)),
	        Rep = _createFactories.Rep;

	    var _props = this.props,
	        name = _props.name,
	        mode = _props.mode,
	        equal = _props.equal,
	        delim = _props.delim,
	        suppressQuotes = _props.suppressQuotes;


	    var key = void 0;
	    // The key can be a simple string, for plain objects,
	    // or another object for maps and weakmaps.
	    if (typeof name === "string") {
	      if (!suppressQuotes) {
	        name = maybeEscapePropertyName(name);
	      }
	      key = span({ "className": "nodeName" }, name);
	    } else {
	      key = Rep(Object.assign({}, this.props, {
	        object: name,
	        mode: mode || MODE.TINY,
	        defaultRep: Grip
	      }));
	    }

	    return span({}, key, span({
	      "className": "objectEqual"
	    }, equal), Rep(Object.assign({}, this.props)), span({
	      "className": "objectComma"
	    }, delim));
	  })
	});

	// Exports from this module
	module.exports = PropRep;

/***/ },
/* 938 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	// ReactJS
	var React = __webpack_require__(2);
	// Dependencies

	var _require = __webpack_require__(927),
	    createFactories = _require.createFactories,
	    isGrip = _require.isGrip,
	    wrapRender = _require.wrapRender;

	var Caption = React.createFactory(__webpack_require__(935));
	var PropRep = React.createFactory(__webpack_require__(937));

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;
	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders generic grip. Grip is client representation
	 * of remote JS object and is used as an input object
	 * for this rep component.
	 */

	var GripRep = React.createClass({
	  displayName: "Grip",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    isInterestingProp: React.PropTypes.func,
	    title: React.PropTypes.string,
	    objectLink: React.PropTypes.func,
	    attachedActorIds: React.PropTypes.array,
	    onDOMNodeMouseOver: React.PropTypes.func,
	    onDOMNodeMouseOut: React.PropTypes.func,
	    onInspectIconClick: React.PropTypes.func
	  },

	  getTitle: function (object) {
	    var title = this.props.title || object.class || "Object";
	    return this.safeObjectLink({}, title);
	  },

	  safePropIterator: function (object, max) {
	    max = typeof max === "undefined" ? 3 : max;
	    try {
	      return this.propIterator(object, max);
	    } catch (err) {
	      console.error(err);
	    }
	    return [];
	  },

	  propIterator: function (object, max) {
	    if (object.preview && Object.keys(object.preview).includes("wrappedValue")) {
	      var _createFactories = createFactories(__webpack_require__(926)),
	          Rep = _createFactories.Rep;

	      return [Rep({
	        object: object.preview.wrappedValue,
	        mode: this.props.mode || MODE.TINY,
	        defaultRep: Grip
	      })];
	    }

	    // Property filter. Show only interesting properties to the user.
	    var isInterestingProp = this.props.isInterestingProp || ((type, value) => {
	      return type == "boolean" || type == "number" || type == "string" && value.length != 0;
	    });

	    var properties = object.preview ? object.preview.ownProperties : {};
	    var propertiesLength = object.preview && object.preview.ownPropertiesLength ? object.preview.ownPropertiesLength : object.ownPropertyLength;

	    if (object.preview && object.preview.safeGetterValues) {
	      properties = Object.assign({}, properties, object.preview.safeGetterValues);
	      propertiesLength += Object.keys(object.preview.safeGetterValues).length;
	    }

	    var indexes = this.getPropIndexes(properties, max, isInterestingProp);
	    if (indexes.length < max && indexes.length < propertiesLength) {
	      // There are not enough props yet. Then add uninteresting props to display them.
	      indexes = indexes.concat(this.getPropIndexes(properties, max - indexes.length, (t, value, name) => {
	        return !isInterestingProp(t, value, name);
	      }));
	    }

	    var truncate = Object.keys(properties).length > max;
	    // The server synthesizes some property names for a Proxy, like
	    // <target> and <handler>; we don't want to quote these because,
	    // as synthetic properties, they appear more natural when
	    // unquoted.
	    var suppressQuotes = object.class === "Proxy";
	    var propsArray = this.getProps(properties, indexes, truncate, suppressQuotes);
	    if (truncate) {
	      // There are some undisplayed props. Then display "more...".
	      propsArray.push(Caption({
	        object: this.safeObjectLink({}, `${propertiesLength - max} more…`)
	      }));
	    }

	    return propsArray;
	  },

	  /**
	   * Get props ordered by index.
	   *
	   * @param {Object} properties Props object.
	   * @param {Array} indexes Indexes of props.
	   * @param {Boolean} truncate true if the grip will be truncated.
	   * @param {Boolean} suppressQuotes true if we should suppress quotes
	   *                  on property names.
	   * @return {Array} Props.
	   */
	  getProps: function (properties, indexes, truncate, suppressQuotes) {
	    var propsArray = [];

	    // Make indexes ordered by ascending.
	    indexes.sort(function (a, b) {
	      return a - b;
	    });

	    indexes.forEach(i => {
	      var name = Object.keys(properties)[i];
	      var value = this.getPropValue(properties[name]);

	      var propRepProps = Object.assign({}, this.props, {
	        mode: MODE.TINY,
	        name: name,
	        object: value,
	        equal: ": ",
	        delim: i !== indexes.length - 1 || truncate ? ", " : "",
	        defaultRep: Grip,
	        // Do not propagate title to properties reps
	        title: undefined,
	        suppressQuotes
	      });
	      delete propRepProps.objectLink;
	      propsArray.push(PropRep(propRepProps));
	    });

	    return propsArray;
	  },

	  /**
	   * Get the indexes of props in the object.
	   *
	   * @param {Object} properties Props object.
	   * @param {Number} max The maximum length of indexes array.
	   * @param {Function} filter Filter the props you want.
	   * @return {Array} Indexes of interesting props in the object.
	   */
	  getPropIndexes: function (properties, max, filter) {
	    var indexes = [];

	    try {
	      var i = 0;
	      for (var name in properties) {
	        if (indexes.length >= max) {
	          return indexes;
	        }

	        // Type is specified in grip's "class" field and for primitive
	        // values use typeof.
	        var value = this.getPropValue(properties[name]);
	        var type = value.class || typeof value;
	        type = type.toLowerCase();

	        if (filter(type, value, name)) {
	          indexes.push(i);
	        }
	        i++;
	      }
	    } catch (err) {
	      console.error(err);
	    }
	    return indexes;
	  },

	  /**
	   * Get the actual value of a property.
	   *
	   * @param {Object} property
	   * @return {Object} Value of the property.
	   */
	  getPropValue: function (property) {
	    var value = property;
	    if (typeof property === "object") {
	      var keys = Object.keys(property);
	      if (keys.includes("value")) {
	        value = property.value;
	      } else if (keys.includes("getterValue")) {
	        value = property.getterValue;
	      }
	    }
	    return value;
	  },

	  safeObjectLink: function (config) {
	    for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      children[_key - 1] = arguments[_key];
	    }

	    if (this.props.objectLink) {
	      var _props;

	      return (_props = this.props).objectLink.apply(_props, [Object.assign({
	        object: this.props.object
	      }, config)].concat(children));
	    }

	    if (Object.keys(config).length === 0 && children.length === 1) {
	      return children[0];
	    }

	    return span.apply(undefined, [config].concat(children));
	  },

	  render: wrapRender(function () {
	    var object = this.props.object;
	    var propsArray = this.safePropIterator(object, this.props.mode === MODE.LONG ? 10 : 3);

	    if (this.props.mode === MODE.TINY) {
	      return span({ className: "objectBox objectBox-object" }, this.getTitle(object));
	    }

	    return span.apply(undefined, [{ className: "objectBox objectBox-object" }, this.getTitle(object), this.safeObjectLink({
	      className: "objectLeftBrace"
	    }, " { ")].concat(_toConsumableArray(propsArray), [this.safeObjectLink({
	      className: "objectRightBrace"
	    }, " }")]));
	  })
	});

	// Registration
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	  return object.preview && object.preview.ownProperties;
	}

	// Grip is used in propIterator and has to be defined here.
	var Grip = {
	  rep: GripRep,
	  supportsObject: supportsObject
	};

	// Exports from this module
	module.exports = Grip;

/***/ },
/* 939 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders a symbol.
	 */

	var SymbolRep = React.createClass({
	  displayName: "SymbolRep",

	  propTypes: {
	    object: React.PropTypes.object.isRequired
	  },

	  render: wrapRender(function () {
	    var object = this.props.object;
	    var name = object.name;


	    return span({ className: "objectBox objectBox-symbol" }, `Symbol(${name || ""})`);
	  })
	});

	function supportsObject(object, type) {
	  return type == "symbol";
	}

	// Exports from this module
	module.exports = {
	  rep: SymbolRep,
	  supportsObject: supportsObject
	};

/***/ },
/* 940 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders a Infinity object
	 */

	var InfinityRep = React.createClass({
	  displayName: "Infinity",

	  propTypes: {
	    object: React.PropTypes.object.isRequired
	  },

	  render: wrapRender(function () {
	    return span({ className: "objectBox objectBox-number" }, this.props.object.type);
	  })
	});

	function supportsObject(object, type) {
	  return type == "Infinity" || type == "-Infinity";
	}

	// Exports from this module
	module.exports = {
	  rep: InfinityRep,
	  supportsObject: supportsObject
	};

/***/ },
/* 941 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders a NaN object
	 */

	var NaNRep = React.createClass({
	  displayName: "NaN",

	  render: wrapRender(function () {
	    return span({ className: "objectBox objectBox-nan" }, "NaN");
	  })
	});

	function supportsObject(object, type) {
	  return type == "NaN";
	}

	// Exports from this module
	module.exports = {
	  rep: NaNRep,
	  supportsObject: supportsObject
	};

/***/ },
/* 942 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// ReactJS
	var React = __webpack_require__(2);

	// Reps

	var _require = __webpack_require__(927),
	    createFactories = _require.createFactories,
	    isGrip = _require.isGrip,
	    wrapRender = _require.wrapRender;

	var StringRep = __webpack_require__(931);

	// Shortcuts
	var span = React.DOM.span;

	var _createFactories = createFactories(StringRep),
	    StringRepFactory = _createFactories.rep;

	/**
	 * Renders DOM attribute
	 */


	var Attribute = React.createClass({
	  displayName: "Attr",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    objectLink: React.PropTypes.func
	  },

	  getTitle: function (grip) {
	    return grip.preview.nodeName;
	  },

	  render: wrapRender(function () {
	    var _this = this;

	    var object = this.props.object;
	    var value = object.preview.value;
	    var objectLink = function (config) {
	      for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        children[_key - 1] = arguments[_key];
	      }

	      if (_this.props.objectLink) {
	        var _props;

	        return (_props = _this.props).objectLink.apply(_props, [Object.assign({ object }, config)].concat(children));
	      }
	      return span.apply(undefined, [config].concat(children));
	    };

	    return objectLink({ className: "objectLink-Attr" }, span({ className: "attrTitle" }, this.getTitle(object)), span({ className: "attrEqual" }, "="), StringRepFactory({ object: value }));
	  })
	});

	// Registration

	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }

	  return type == "Attr" && grip.preview;
	}

	module.exports = {
	  rep: Attribute,
	  supportsObject: supportsObject
	};

/***/ },
/* 943 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// ReactJS
	var React = __webpack_require__(2);

	// Reps

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip,
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Used to render JS built-in Date() object.
	 */

	var DateTime = React.createClass({
	  displayName: "Date",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    objectLink: React.PropTypes.func
	  },

	  getTitle: function (grip) {
	    if (this.props.objectLink) {
	      return this.props.objectLink({
	        object: grip
	      }, grip.class + " ");
	    }
	    return "";
	  },

	  render: wrapRender(function () {
	    var grip = this.props.object;
	    var date = void 0;
	    try {
	      date = span({ className: "objectBox" }, this.getTitle(grip), span({ className: "Date" }, new Date(grip.preview.timestamp).toISOString()));
	    } catch (e) {
	      date = span({ className: "objectBox" }, "Invalid Date");
	    }

	    return date;
	  })
	});

	// Registration

	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }

	  return type == "Date" && grip.preview;
	}

	// Exports from this module
	module.exports = {
	  rep: DateTime,
	  supportsObject: supportsObject
	};

/***/ },
/* 944 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// ReactJS
	var React = __webpack_require__(2);

	// Reps

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip,
	    getURLDisplayString = _require.getURLDisplayString,
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders DOM document object.
	 */

	var Document = React.createClass({
	  displayName: "Document",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    objectLink: React.PropTypes.func
	  },

	  getLocation: function (grip) {
	    var location = grip.preview.location;
	    return location ? getURLDisplayString(location) : "";
	  },

	  getTitle: function (grip) {
	    if (this.props.objectLink) {
	      return span({ className: "objectBox" }, this.props.objectLink({
	        object: grip
	      }, grip.class + " "));
	    }
	    return "";
	  },

	  getTooltip: function (doc) {
	    return doc.location.href;
	  },

	  render: wrapRender(function () {
	    var grip = this.props.object;

	    return span({ className: "objectBox objectBox-object" }, this.getTitle(grip), span({ className: "objectPropValue" }, this.getLocation(grip)));
	  })
	});

	// Registration

	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }

	  return object.preview && type == "HTMLDocument";
	}

	// Exports from this module
	module.exports = {
	  rep: Document,
	  supportsObject: supportsObject
	};

/***/ },
/* 945 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// ReactJS
	var React = __webpack_require__(2);

	// Reps

	var _require = __webpack_require__(927),
	    createFactories = _require.createFactories,
	    isGrip = _require.isGrip,
	    wrapRender = _require.wrapRender;

	var _createFactories = createFactories(__webpack_require__(938)),
	    rep = _createFactories.rep;

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;

	/**
	 * Renders DOM event objects.
	 */


	var Event = React.createClass({
	  displayName: "event",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    objectLink: React.PropTypes.func,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    attachedActorIds: React.PropTypes.array,
	    onDOMNodeMouseOver: React.PropTypes.func,
	    onDOMNodeMouseOut: React.PropTypes.func,
	    onInspectIconClick: React.PropTypes.func
	  },

	  getTitle: function (props) {
	    var preview = props.object.preview;
	    var title = preview.type;

	    if (preview.eventKind == "key" && preview.modifiers && preview.modifiers.length) {
	      title = `${title} ${preview.modifiers.join("-")}`;
	    }
	    return title;
	  },

	  render: wrapRender(function () {
	    // Use `Object.assign` to keep `this.props` without changes because:
	    // 1. JSON.stringify/JSON.parse is slow.
	    // 2. Immutable.js is planned for the future.
	    var gripProps = Object.assign({}, this.props, {
	      title: this.getTitle(this.props)
	    });
	    gripProps.object = Object.assign({}, this.props.object);
	    gripProps.object.preview = Object.assign({}, this.props.object.preview);

	    gripProps.object.preview.ownProperties = {};
	    if (gripProps.object.preview.target) {
	      Object.assign(gripProps.object.preview.ownProperties, {
	        target: gripProps.object.preview.target
	      });
	    }
	    Object.assign(gripProps.object.preview.ownProperties, gripProps.object.preview.properties);

	    delete gripProps.object.preview.properties;
	    gripProps.object.ownPropertyLength = Object.keys(gripProps.object.preview.ownProperties).length;

	    switch (gripProps.object.class) {
	      case "MouseEvent":
	        gripProps.isInterestingProp = (type, value, name) => {
	          return ["target", "clientX", "clientY", "layerX", "layerY"].includes(name);
	        };
	        break;
	      case "KeyboardEvent":
	        gripProps.isInterestingProp = (type, value, name) => {
	          return ["target", "key", "charCode", "keyCode"].includes(name);
	        };
	        break;
	      case "MessageEvent":
	        gripProps.isInterestingProp = (type, value, name) => {
	          return ["target", "isTrusted", "data"].includes(name);
	        };
	        break;
	      default:
	        gripProps.isInterestingProp = (type, value, name) => {
	          // We want to show the properties in the order they are declared.
	          return Object.keys(gripProps.object.preview.ownProperties).includes(name);
	        };
	    }

	    return rep(gripProps);
	  })
	});

	// Registration

	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }

	  return grip.preview && grip.preview.kind == "DOMEvent";
	}

	// Exports from this module
	module.exports = {
	  rep: Event,
	  supportsObject: supportsObject
	};

/***/ },
/* 946 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// ReactJS
	var React = __webpack_require__(2);

	// Reps

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip,
	    cropString = _require.cropString,
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * This component represents a template for Function objects.
	 */

	var Func = React.createClass({
	  displayName: "Func",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    objectLink: React.PropTypes.func
	  },

	  getTitle: function (grip) {
	    var title = "function ";
	    if (grip.isGenerator) {
	      title = "function* ";
	    }
	    if (grip.isAsync) {
	      title = "async " + title;
	    }

	    if (this.props.objectLink) {
	      return this.props.objectLink({
	        object: grip
	      }, title);
	    }

	    return title;
	  },

	  summarizeFunction: function (grip) {
	    var name = grip.userDisplayName || grip.displayName || grip.name || "";
	    return cropString(name + "()", 100);
	  },

	  render: wrapRender(function () {
	    var grip = this.props.object;

	    return (
	      // Set dir="ltr" to prevent function parentheses from
	      // appearing in the wrong direction
	      span({ dir: "ltr", className: "objectBox objectBox-function" }, this.getTitle(grip), this.summarizeFunction(grip))
	    );
	  })
	});

	// Registration

	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return type == "function";
	  }

	  return type == "Function";
	}

	// Exports from this module

	module.exports = {
	  rep: Func,
	  supportsObject: supportsObject
	};

/***/ },
/* 947 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	// ReactJS
	var React = __webpack_require__(2);
	// Dependencies

	var _require = __webpack_require__(927),
	    createFactories = _require.createFactories,
	    isGrip = _require.isGrip,
	    wrapRender = _require.wrapRender;

	var PropRep = React.createFactory(__webpack_require__(937));

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;
	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders a DOM Promise object.
	 */

	var PromiseRep = React.createClass({
	  displayName: "Promise",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    objectLink: React.PropTypes.func,
	    attachedActorIds: React.PropTypes.array,
	    onDOMNodeMouseOver: React.PropTypes.func,
	    onDOMNodeMouseOut: React.PropTypes.func,
	    onInspectIconClick: React.PropTypes.func
	  },

	  getTitle: function (object) {
	    var title = object.class;
	    return this.safeObjectLink({}, title);
	  },

	  getProps: function (promiseState) {
	    var keys = ["state"];
	    if (Object.keys(promiseState).includes("value")) {
	      keys.push("value");
	    }

	    return keys.map((key, i) => {
	      var object = promiseState[key];
	      return PropRep(Object.assign({}, this.props, {
	        mode: MODE.TINY,
	        name: `<${key}>`,
	        object,
	        equal: ": ",
	        delim: i < keys.length - 1 ? ", " : "",
	        suppressQuotes: true
	      }));
	    });
	  },

	  safeObjectLink: function (config) {
	    for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      children[_key - 1] = arguments[_key];
	    }

	    if (this.props.objectLink) {
	      var _props;

	      return (_props = this.props).objectLink.apply(_props, [Object.assign({
	        object: this.props.object
	      }, config)].concat(children));
	    }

	    if (Object.keys(config).length === 0 && children.length === 1) {
	      return children[0];
	    }

	    return span.apply(undefined, [config].concat(children));
	  },

	  render: wrapRender(function () {
	    var object = this.props.object;
	    var promiseState = object.promiseState;


	    if (this.props.mode === MODE.TINY) {
	      var _createFactories = createFactories(__webpack_require__(926)),
	          Rep = _createFactories.Rep;

	      return span({ className: "objectBox objectBox-object" }, this.getTitle(object), this.safeObjectLink({
	        className: "objectLeftBrace"
	      }, " { "), Rep({ object: promiseState.state }), this.safeObjectLink({
	        className: "objectRightBrace"
	      }, " }"));
	    }

	    var propsArray = this.getProps(promiseState);
	    return span.apply(undefined, [{ className: "objectBox objectBox-object" }, this.getTitle(object), this.safeObjectLink({
	      className: "objectLeftBrace"
	    }, " { ")].concat(_toConsumableArray(propsArray), [this.safeObjectLink({
	      className: "objectRightBrace"
	    }, " }")]));
	  })
	});

	// Registration
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	  return type === "Promise";
	}

	// Exports from this module
	module.exports = {
	  rep: PromiseRep,
	  supportsObject: supportsObject
	};

/***/ },
/* 948 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// ReactJS
	var React = __webpack_require__(2);

	// Reps

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip,
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders a grip object with regular expression.
	 */

	var RegExp = React.createClass({
	  displayName: "regexp",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    objectLink: React.PropTypes.func
	  },

	  getSource: function (grip) {
	    return grip.displayString;
	  },

	  render: wrapRender(function () {
	    var _this = this;

	    var object = this.props.object;

	    var objectLink = function (config) {
	      for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        children[_key - 1] = arguments[_key];
	      }

	      if (_this.props.objectLink) {
	        var _props;

	        return (_props = _this.props).objectLink.apply(_props, [Object.assign({ object }, config)].concat(children));
	      }
	      return span.apply(undefined, [config].concat(children));
	    };

	    return objectLink({
	      className: "objectBox objectBox-regexp regexpSource"
	    }, this.getSource(object));
	  })
	});

	// Registration

	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }

	  return type == "RegExp";
	}

	// Exports from this module
	module.exports = {
	  rep: RegExp,
	  supportsObject: supportsObject
	};

/***/ },
/* 949 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// ReactJS
	var React = __webpack_require__(2);

	// Reps

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip,
	    getURLDisplayString = _require.getURLDisplayString,
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var DOM = React.DOM;

	/**
	 * Renders a grip representing CSSStyleSheet
	 */
	var StyleSheet = React.createClass({
	  displayName: "object",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    objectLink: React.PropTypes.func
	  },

	  getTitle: function (grip) {
	    var title = "StyleSheet ";
	    if (this.props.objectLink) {
	      return DOM.span({ className: "objectBox" }, this.props.objectLink({
	        object: grip
	      }, title));
	    }
	    return title;
	  },

	  getLocation: function (grip) {
	    // Embedded stylesheets don't have URL and so, no preview.
	    var url = grip.preview ? grip.preview.url : "";
	    return url ? getURLDisplayString(url) : "";
	  },

	  render: wrapRender(function () {
	    var grip = this.props.object;

	    return DOM.span({ className: "objectBox objectBox-object" }, this.getTitle(grip), DOM.span({ className: "objectPropValue" }, this.getLocation(grip)));
	  })
	});

	// Registration

	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }

	  return type == "CSSStyleSheet";
	}

	// Exports from this module

	module.exports = {
	  rep: StyleSheet,
	  supportsObject: supportsObject
	};

/***/ },
/* 950 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip,
	    cropString = _require.cropString,
	    cropMultipleLines = _require.cropMultipleLines,
	    wrapRender = _require.wrapRender;

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;

	var nodeConstants = __webpack_require__(928);

	// Shortcuts
	var span = React.DOM.span;

	/**
	 * Renders DOM comment node.
	 */

	var CommentNode = React.createClass({
	  displayName: "CommentNode",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key]))
	  },

	  render: wrapRender(function () {
	    var _props = this.props,
	        object = _props.object,
	        _props$mode = _props.mode,
	        mode = _props$mode === undefined ? MODE.SHORT : _props$mode;
	    var textContent = object.preview.textContent;

	    if (mode === MODE.TINY) {
	      textContent = cropMultipleLines(textContent, 30);
	    } else if (mode === MODE.SHORT) {
	      textContent = cropString(textContent, 50);
	    }

	    return span({ className: "objectBox theme-comment" }, `<!-- ${textContent} -->`);
	  })
	});

	// Registration
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	  return object.preview && object.preview.nodeType === nodeConstants.COMMENT_NODE;
	}

	// Exports from this module
	module.exports = {
	  rep: CommentNode,
	  supportsObject: supportsObject
	};

/***/ },
/* 951 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	// ReactJS
	var React = __webpack_require__(2);

	// Utils

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip,
	    wrapRender = _require.wrapRender;

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;

	var nodeConstants = __webpack_require__(928);
	var Svg = __webpack_require__(952);

	// Shortcuts
	var span = React.DOM.span;

	/**
	 * Renders DOM element node.
	 */

	var ElementNode = React.createClass({
	  displayName: "ElementNode",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    attachedActorIds: React.PropTypes.array,
	    onDOMNodeMouseOver: React.PropTypes.func,
	    onDOMNodeMouseOut: React.PropTypes.func,
	    onInspectIconClick: React.PropTypes.func,
	    objectLink: React.PropTypes.func
	  },

	  getElements: function (grip, mode) {
	    var _grip$preview = grip.preview,
	        attributes = _grip$preview.attributes,
	        nodeName = _grip$preview.nodeName;

	    var nodeNameElement = span({
	      className: "tag-name theme-fg-color3"
	    }, nodeName);

	    if (mode === MODE.TINY) {
	      var elements = [nodeNameElement];
	      if (attributes.id) {
	        elements.push(span({ className: "attr-name theme-fg-color2" }, `#${attributes.id}`));
	      }
	      if (attributes.class) {
	        elements.push(span({ className: "attr-name theme-fg-color2" }, attributes.class.replace(/(^\s+)|(\s+$)/g, "").split(" ").map(cls => `.${cls}`).join("")));
	      }
	      return elements;
	    }
	    var attributeElements = Object.keys(attributes).sort(function getIdAndClassFirst(a1, a2) {
	      if ([a1, a2].includes("id")) {
	        return 3 * (a1 === "id" ? -1 : 1);
	      }
	      if ([a1, a2].includes("class")) {
	        return 2 * (a1 === "class" ? -1 : 1);
	      }

	      // `id` and `class` excepted,
	      // we want to keep the same order that in `attributes`.
	      return 0;
	    }).reduce((arr, name, i, keys) => {
	      var value = attributes[name];
	      var attribute = span({}, span({ className: "attr-name theme-fg-color2" }, `${name}`), `="`, span({ className: "attr-value theme-fg-color6" }, `${value}`), `"`);

	      return arr.concat([" ", attribute]);
	    }, []);

	    return ["<", nodeNameElement].concat(_toConsumableArray(attributeElements), [">"]);
	  },

	  render: wrapRender(function () {
	    var _this = this;

	    var _props = this.props,
	        object = _props.object,
	        mode = _props.mode,
	        attachedActorIds = _props.attachedActorIds,
	        onDOMNodeMouseOver = _props.onDOMNodeMouseOver,
	        onDOMNodeMouseOut = _props.onDOMNodeMouseOut,
	        onInspectIconClick = _props.onInspectIconClick;

	    var elements = this.getElements(object, mode);
	    var objectLink = function (config) {
	      for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        children[_key - 1] = arguments[_key];
	      }

	      if (_this.props.objectLink) {
	        var _props2;

	        return (_props2 = _this.props).objectLink.apply(_props2, [Object.assign({ object }, config)].concat(children));
	      }
	      return span.apply(undefined, [config].concat(children));
	    };

	    var isInTree = attachedActorIds ? attachedActorIds.includes(object.actor) : true;

	    var baseConfig = { className: "objectBox objectBox-node" };
	    var inspectIcon = void 0;
	    if (isInTree) {
	      if (onDOMNodeMouseOver) {
	        Object.assign(baseConfig, {
	          onMouseOver: _ => onDOMNodeMouseOver(object)
	        });
	      }

	      if (onDOMNodeMouseOut) {
	        Object.assign(baseConfig, {
	          onMouseOut: onDOMNodeMouseOut
	        });
	      }

	      if (onInspectIconClick) {
	        inspectIcon = Svg("open-inspector", {
	          element: "a",
	          draggable: false,
	          // TODO: Localize this with "openNodeInInspector" when Bug 1317038 lands
	          title: "Click to select the node in the inspector",
	          onClick: e => onInspectIconClick(object, e)
	        });
	      }
	    }

	    return span(baseConfig, objectLink.apply(undefined, [{}].concat(_toConsumableArray(elements))), inspectIcon);
	  })
	});

	// Registration
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	  return object.preview && object.preview.nodeType === nodeConstants.ELEMENT_NODE;
	}

	// Exports from this module
	module.exports = {
	  rep: ElementNode,
	  supportsObject: supportsObject
	};

/***/ },
/* 952 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(2);
	var InlineSVG = __webpack_require__(346);

	var svg = {
	  "open-inspector": __webpack_require__(688)
	};

	module.exports = function (name, props) {
	  // eslint-disable-line
	  if (!svg[name]) {
	    throw new Error("Unknown SVG: " + name);
	  }
	  var className = name;
	  if (props && props.className) {
	    className = `${name} ${props.className}`;
	  }
	  if (name === "subSettings") {
	    className = "";
	  }
	  props = Object.assign({}, props, { className, src: svg[name] });
	  return React.createElement(InlineSVG, props);
	};

/***/ },
/* 953 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// ReactJS
	var React = __webpack_require__(2);

	// Reps

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip,
	    cropString = _require.cropString,
	    wrapRender = _require.wrapRender;

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;

	var Svg = __webpack_require__(952);

	// Shortcuts
	var DOM = React.DOM;

	/**
	 * Renders DOM #text node.
	 */
	var TextNode = React.createClass({
	  displayName: "TextNode",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    objectLink: React.PropTypes.func,
	    attachedActorIds: React.PropTypes.array,
	    onDOMNodeMouseOver: React.PropTypes.func,
	    onDOMNodeMouseOut: React.PropTypes.func,
	    onInspectIconClick: React.PropTypes.func
	  },

	  getTextContent: function (grip) {
	    return cropString(grip.preview.textContent);
	  },

	  getTitle: function (grip) {
	    var title = "#text";
	    if (this.props.objectLink) {
	      return this.props.objectLink({
	        object: grip
	      }, title);
	    }
	    return title;
	  },

	  render: wrapRender(function () {
	    var _props = this.props,
	        grip = _props.object,
	        _props$mode = _props.mode,
	        mode = _props$mode === undefined ? MODE.SHORT : _props$mode,
	        attachedActorIds = _props.attachedActorIds,
	        onDOMNodeMouseOver = _props.onDOMNodeMouseOver,
	        onDOMNodeMouseOut = _props.onDOMNodeMouseOut,
	        onInspectIconClick = _props.onInspectIconClick;


	    var baseConfig = { className: "objectBox objectBox-textNode" };
	    var inspectIcon = void 0;
	    var isInTree = attachedActorIds ? attachedActorIds.includes(grip.actor) : true;

	    if (isInTree) {
	      if (onDOMNodeMouseOver) {
	        Object.assign(baseConfig, {
	          onMouseOver: _ => onDOMNodeMouseOver(grip)
	        });
	      }

	      if (onDOMNodeMouseOut) {
	        Object.assign(baseConfig, {
	          onMouseOut: onDOMNodeMouseOut
	        });
	      }

	      if (onInspectIconClick) {
	        inspectIcon = Svg("open-inspector", {
	          element: "a",
	          draggable: false,
	          // TODO: Localize this with "openNodeInInspector" when Bug 1317038 lands
	          title: "Click to select the node in the inspector",
	          onClick: e => onInspectIconClick(grip, e)
	        });
	      }
	    }

	    if (mode === MODE.TINY) {
	      return DOM.span(baseConfig, this.getTitle(grip), inspectIcon);
	    }

	    return DOM.span(baseConfig, this.getTitle(grip), DOM.span({ className: "nodeValue" }, " ", `"${this.getTextContent(grip)}"`), inspectIcon);
	  })
	});

	// Registration

	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }

	  return grip.preview && grip.class == "Text";
	}

	// Exports from this module
	module.exports = {
	  rep: TextNode,
	  supportsObject: supportsObject
	};

/***/ },
/* 954 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// ReactJS
	var React = __webpack_require__(2);
	// Utils

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip,
	    wrapRender = _require.wrapRender;

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;
	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders Error objects.
	 */

	var ErrorRep = React.createClass({
	  displayName: "Error",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    objectLink: React.PropTypes.func
	  },

	  render: wrapRender(function () {
	    var _this = this;

	    var object = this.props.object;
	    var preview = object.preview;
	    var name = preview && preview.name ? preview.name : "Error";

	    var content = this.props.mode === MODE.TINY ? name : `${name}: ${preview.message}`;

	    if (preview.stack && this.props.mode !== MODE.TINY) {
	      /*
	       * Since Reps are used in the JSON Viewer, we can't localize
	       * the "Stack trace" label (defined in debugger.properties as
	       * "variablesViewErrorStacktrace" property), until Bug 1317038 lands.
	       */
	      content = `${content}\nStack trace:\n${preview.stack}`;
	    }

	    var objectLink = function (config) {
	      for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        children[_key - 1] = arguments[_key];
	      }

	      if (_this.props.objectLink) {
	        var _props;

	        return (_props = _this.props).objectLink.apply(_props, [Object.assign({ object }, config)].concat(children));
	      }
	      return span.apply(undefined, [config].concat(children));
	    };

	    return objectLink({ className: "objectBox-stackTrace" }, content);
	  })
	});

	// Registration
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	  return object.preview && type === "Error";
	}

	// Exports from this module
	module.exports = {
	  rep: ErrorRep,
	  supportsObject: supportsObject
	};

/***/ },
/* 955 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// ReactJS
	var React = __webpack_require__(2);

	// Reps

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip,
	    getURLDisplayString = _require.getURLDisplayString,
	    wrapRender = _require.wrapRender;

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;

	// Shortcuts


	var DOM = React.DOM;

	/**
	 * Renders a grip representing a window.
	 */
	var Window = React.createClass({
	  displayName: "Window",

	  propTypes: {
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    object: React.PropTypes.object.isRequired,
	    objectLink: React.PropTypes.func
	  },

	  getTitle: function (object) {
	    var title = object.displayClass || object.class || "Window";
	    if (this.props.objectLink) {
	      return DOM.span({ className: "objectBox" }, this.props.objectLink({
	        object
	      }, title));
	    }
	    return title;
	  },

	  getLocation: function (object) {
	    return getURLDisplayString(object.preview.url);
	  },

	  render: wrapRender(function () {
	    var _props = this.props,
	        mode = _props.mode,
	        object = _props.object;


	    if (mode === MODE.TINY) {
	      return DOM.span({ className: "objectBox objectBox-Window" }, this.getTitle(object));
	    }

	    return DOM.span({ className: "objectBox objectBox-Window" }, this.getTitle(object), " ", DOM.span({ className: "objectPropValue" }, this.getLocation(object)));
	  })
	});

	// Registration

	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }

	  return object.preview && type == "Window";
	}

	// Exports from this module
	module.exports = {
	  rep: Window,
	  supportsObject: supportsObject
	};

/***/ },
/* 956 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// ReactJS
	var React = __webpack_require__(2);

	// Reps

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip,
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders a grip object with textual data.
	 */

	var ObjectWithText = React.createClass({
	  displayName: "ObjectWithText",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    objectLink: React.PropTypes.func
	  },

	  getTitle: function (grip) {
	    if (this.props.objectLink) {
	      return span({ className: "objectBox" }, this.props.objectLink({
	        object: grip
	      }, this.getType(grip) + " "));
	    }
	    return "";
	  },

	  getType: function (grip) {
	    return grip.class;
	  },

	  getDescription: function (grip) {
	    return "\"" + grip.preview.text + "\"";
	  },

	  render: wrapRender(function () {
	    var grip = this.props.object;
	    return span({ className: "objectBox objectBox-" + this.getType(grip) }, this.getTitle(grip), span({ className: "objectPropValue" }, this.getDescription(grip)));
	  })
	});

	// Registration

	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }

	  return grip.preview && grip.preview.kind == "ObjectWithText";
	}

	// Exports from this module
	module.exports = {
	  rep: ObjectWithText,
	  supportsObject: supportsObject
	};

/***/ },
/* 957 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// ReactJS
	var React = __webpack_require__(2);

	// Reps

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip,
	    getURLDisplayString = _require.getURLDisplayString,
	    wrapRender = _require.wrapRender;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders a grip object with URL data.
	 */

	var ObjectWithURL = React.createClass({
	  displayName: "ObjectWithURL",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    objectLink: React.PropTypes.func
	  },

	  getTitle: function (grip) {
	    if (this.props.objectLink) {
	      return span({ className: "objectBox" }, this.props.objectLink({
	        object: grip
	      }, this.getType(grip) + " "));
	    }
	    return "";
	  },

	  getType: function (grip) {
	    return grip.class;
	  },

	  getDescription: function (grip) {
	    return getURLDisplayString(grip.preview.url);
	  },

	  render: wrapRender(function () {
	    var grip = this.props.object;
	    return span({ className: "objectBox objectBox-" + this.getType(grip) }, this.getTitle(grip), span({ className: "objectPropValue" }, this.getDescription(grip)));
	  })
	});

	// Registration

	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }

	  return grip.preview && grip.preview.kind == "ObjectWithURL";
	}

	// Exports from this module
	module.exports = {
	  rep: ObjectWithURL,
	  supportsObject: supportsObject
	};

/***/ },
/* 958 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    createFactories = _require.createFactories,
	    isGrip = _require.isGrip,
	    wrapRender = _require.wrapRender;

	var Caption = React.createFactory(__webpack_require__(935));

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;

	// Shortcuts


	var span = React.DOM.span;

	/**
	 * Renders an array. The array is enclosed by left and right bracket
	 * and the max number of rendered items depends on the current mode.
	 */

	var GripArray = React.createClass({
	  displayName: "GripArray",

	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    provider: React.PropTypes.object,
	    objectLink: React.PropTypes.func,
	    attachedActorIds: React.PropTypes.array,
	    onDOMNodeMouseOver: React.PropTypes.func,
	    onDOMNodeMouseOut: React.PropTypes.func,
	    onInspectIconClick: React.PropTypes.func
	  },

	  getLength: function (grip) {
	    if (!grip.preview) {
	      return 0;
	    }

	    return grip.preview.length || grip.preview.childNodesLength || 0;
	  },

	  getTitle: function (object, context) {
	    if (this.props.mode === MODE.TINY) {
	      return "";
	    }

	    var title = this.props.title || object.class || "Array";
	    return this.safeObjectLink({}, title + " ");
	  },

	  getPreviewItems: function (grip) {
	    if (!grip.preview) {
	      return null;
	    }

	    return grip.preview.items || grip.preview.childNodes || null;
	  },

	  arrayIterator: function (grip, max) {
	    var items = [];
	    var gripLength = this.getLength(grip);

	    if (!gripLength) {
	      return items;
	    }

	    var previewItems = this.getPreviewItems(grip);
	    if (!previewItems) {
	      return items;
	    }

	    var delim = void 0;
	    // number of grip preview items is limited to 10, but we may have more
	    // items in grip-array.
	    var delimMax = gripLength > previewItems.length ? previewItems.length : previewItems.length - 1;
	    var provider = this.props.provider;

	    for (var i = 0; i < previewItems.length && i < max; i++) {
	      try {
	        var itemGrip = previewItems[i];
	        var value = provider ? provider.getValue(itemGrip) : itemGrip;

	        delim = i == delimMax ? "" : ", ";

	        items.push(GripArrayItem(Object.assign({}, this.props, {
	          object: value,
	          delim: delim,
	          // Do not propagate title to array items reps
	          title: undefined
	        })));
	      } catch (exc) {
	        items.push(GripArrayItem(Object.assign({}, this.props, {
	          object: exc,
	          delim: delim,
	          // Do not propagate title to array items reps
	          title: undefined
	        })));
	      }
	    }
	    if (previewItems.length > max || gripLength > previewItems.length) {
	      var leftItemNum = gripLength - max > 0 ? gripLength - max : gripLength - previewItems.length;
	      items.push(Caption({
	        object: this.safeObjectLink({}, leftItemNum + " more…")
	      }));
	    }

	    return items;
	  },

	  safeObjectLink: function (config) {
	    for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      children[_key - 1] = arguments[_key];
	    }

	    if (this.props.objectLink) {
	      var _props;

	      return (_props = this.props).objectLink.apply(_props, [Object.assign({
	        object: this.props.object
	      }, config)].concat(children));
	    }

	    if (Object.keys(config).length === 0 && children.length === 1) {
	      return children[0];
	    }

	    return span.apply(undefined, [config].concat(children));
	  },

	  render: wrapRender(function () {
	    var _props2 = this.props,
	        object = _props2.object,
	        _props2$mode = _props2.mode,
	        mode = _props2$mode === undefined ? MODE.SHORT : _props2$mode;


	    var items = void 0;
	    var brackets = void 0;
	    var needSpace = function (space) {
	      return space ? { left: "[ ", right: " ]" } : { left: "[", right: "]" };
	    };

	    if (mode === MODE.TINY) {
	      var objectLength = this.getLength(object);
	      var isEmpty = objectLength === 0;
	      items = [span({ className: "length" }, isEmpty ? "" : objectLength)];
	      brackets = needSpace(false);
	    } else {
	      var max = mode === MODE.SHORT ? 3 : 10;
	      items = this.arrayIterator(object, max);
	      brackets = needSpace(items.length > 0);
	    }

	    var title = this.getTitle(object);

	    return span.apply(undefined, [{
	      className: "objectBox objectBox-array" }, title, this.safeObjectLink({
	      className: "arrayLeftBracket"
	    }, brackets.left)].concat(_toConsumableArray(items), [this.safeObjectLink({
	      className: "arrayRightBracket"
	    }, brackets.right), span({
	      className: "arrayProperties",
	      role: "group" })]));
	  })
	});

	/**
	 * Renders array item. Individual values are separated by
	 * a delimiter (a comma by default).
	 */
	var GripArrayItem = React.createFactory(React.createClass({
	  displayName: "GripArrayItem",

	  propTypes: {
	    delim: React.PropTypes.string,
	    object: React.PropTypes.oneOfType([React.PropTypes.object, React.PropTypes.number, React.PropTypes.string]).isRequired,
	    objectLink: React.PropTypes.func,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    provider: React.PropTypes.object,
	    attachedActorIds: React.PropTypes.array,
	    onDOMNodeMouseOver: React.PropTypes.func,
	    onDOMNodeMouseOut: React.PropTypes.func,
	    onInspectIconClick: React.PropTypes.func
	  },

	  render: function () {
	    var _createFactories = createFactories(__webpack_require__(926)),
	        Rep = _createFactories.Rep;

	    return span({}, Rep(Object.assign({}, this.props, {
	      mode: MODE.TINY
	    })), this.props.delim);
	  }
	}));

	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }

	  return grip.preview && (grip.preview.kind == "ArrayLike" || type === "DocumentFragment");
	}

	// Exports from this module
	module.exports = {
	  rep: GripArray,
	  supportsObject: supportsObject
	};

/***/ },
/* 959 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	// Dependencies
	var React = __webpack_require__(2);

	var _require = __webpack_require__(927),
	    isGrip = _require.isGrip,
	    wrapRender = _require.wrapRender;

	var Caption = React.createFactory(__webpack_require__(935));
	var PropRep = React.createFactory(__webpack_require__(937));

	var _require2 = __webpack_require__(925),
	    MODE = _require2.MODE;
	// Shortcuts


	var span = React.DOM.span;
	/**
	 * Renders an map. A map is represented by a list of its
	 * entries enclosed in curly brackets.
	 */

	var GripMap = React.createClass({
	  displayName: "GripMap",

	  propTypes: {
	    object: React.PropTypes.object,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    objectLink: React.PropTypes.func,
	    isInterestingEntry: React.PropTypes.func,
	    attachedActorIds: React.PropTypes.array,
	    onDOMNodeMouseOver: React.PropTypes.func,
	    onDOMNodeMouseOut: React.PropTypes.func,
	    onInspectIconClick: React.PropTypes.func,
	    title: React.PropTypes.string
	  },

	  getTitle: function (object) {
	    var title = this.props.title || (object && object.class ? object.class : "Map");
	    return this.safeObjectLink({}, title);
	  },

	  safeEntriesIterator: function (object, max) {
	    max = typeof max === "undefined" ? 3 : max;
	    try {
	      return this.entriesIterator(object, max);
	    } catch (err) {
	      console.error(err);
	    }
	    return [];
	  },

	  entriesIterator: function (object, max) {
	    // Entry filter. Show only interesting entries to the user.
	    var isInterestingEntry = this.props.isInterestingEntry || ((type, value) => {
	      return type == "boolean" || type == "number" || type == "string" && value.length != 0;
	    });

	    var mapEntries = object.preview && object.preview.entries ? object.preview.entries : [];

	    var indexes = this.getEntriesIndexes(mapEntries, max, isInterestingEntry);
	    if (indexes.length < max && indexes.length < mapEntries.length) {
	      // There are not enough entries yet, so we add uninteresting entries.
	      indexes = indexes.concat(this.getEntriesIndexes(mapEntries, max - indexes.length, (t, value, name) => {
	        return !isInterestingEntry(t, value, name);
	      }));
	    }

	    var entries = this.getEntries(mapEntries, indexes);
	    if (entries.length < mapEntries.length) {
	      // There are some undisplayed entries. Then display "more…".
	      entries.push(Caption({
	        key: "more",
	        object: this.safeObjectLink({}, `${mapEntries.length - max} more…`)
	      }));
	    }

	    return entries;
	  },

	  /**
	   * Get entries ordered by index.
	   *
	   * @param {Array} entries Entries array.
	   * @param {Array} indexes Indexes of entries.
	   * @return {Array} Array of PropRep.
	   */
	  getEntries: function (entries, indexes) {
	    var _props = this.props,
	        objectLink = _props.objectLink,
	        attachedActorIds = _props.attachedActorIds,
	        onDOMNodeMouseOver = _props.onDOMNodeMouseOver,
	        onDOMNodeMouseOut = _props.onDOMNodeMouseOut,
	        onInspectIconClick = _props.onInspectIconClick;

	    // Make indexes ordered by ascending.

	    indexes.sort(function (a, b) {
	      return a - b;
	    });

	    return indexes.map((index, i) => {
	      var _entries$index = _slicedToArray(entries[index], 2),
	          key = _entries$index[0],
	          entryValue = _entries$index[1];

	      var value = entryValue.value !== undefined ? entryValue.value : entryValue;

	      return PropRep({
	        // key,
	        name: key,
	        equal: ": ",
	        object: value,
	        // Do not add a trailing comma on the last entry
	        // if there won't be a "more..." item.
	        delim: i < indexes.length - 1 || indexes.length < entries.length ? ", " : "",
	        mode: MODE.TINY,
	        objectLink,
	        attachedActorIds,
	        onDOMNodeMouseOver,
	        onDOMNodeMouseOut,
	        onInspectIconClick
	      });
	    });
	  },

	  /**
	   * Get the indexes of entries in the map.
	   *
	   * @param {Array} entries Entries array.
	   * @param {Number} max The maximum length of indexes array.
	   * @param {Function} filter Filter the entry you want.
	   * @return {Array} Indexes of filtered entries in the map.
	   */
	  getEntriesIndexes: function (entries, max, filter) {
	    return entries.reduce((indexes, _ref, i) => {
	      var _ref2 = _slicedToArray(_ref, 2),
	          key = _ref2[0],
	          entry = _ref2[1];

	      if (indexes.length < max) {
	        var value = entry && entry.value !== undefined ? entry.value : entry;
	        // Type is specified in grip's "class" field and for primitive
	        // values use typeof.
	        var type = (value && value.class ? value.class : typeof value).toLowerCase();

	        if (filter(type, value, key)) {
	          indexes.push(i);
	        }
	      }

	      return indexes;
	    }, []);
	  },

	  safeObjectLink: function (config) {
	    for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      children[_key - 1] = arguments[_key];
	    }

	    if (this.props.objectLink) {
	      var _props2;

	      return (_props2 = this.props).objectLink.apply(_props2, [Object.assign({
	        object: this.props.object
	      }, config)].concat(children));
	    }

	    if (Object.keys(config).length === 0 && children.length === 1) {
	      return children[0];
	    }

	    return span.apply(undefined, [config].concat(children));
	  },

	  render: wrapRender(function () {
	    var object = this.props.object;
	    var propsArray = this.safeEntriesIterator(object, this.props.mode === MODE.LONG ? 10 : 3);

	    if (this.props.mode === MODE.TINY) {
	      return span({ className: "objectBox objectBox-object" }, this.getTitle(object));
	    }

	    return span({ className: "objectBox objectBox-object" }, this.getTitle(object), this.safeObjectLink({
	      className: "objectLeftBrace"
	    }, " { "), propsArray, this.safeObjectLink({
	      className: "objectRightBrace"
	    }, " }"));
	  })
	});

	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }
	  return grip.preview && grip.preview.kind == "MapLike";
	}

	// Exports from this module
	module.exports = {
	  rep: GripMap,
	  supportsObject: supportsObject
	};

/***/ },
/* 960 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Debugger\n# which is available from the Web Developer sub-menu -> 'Debugger'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (collapsePanes): This is the tooltip for the button\n# that collapses the left and right panes in the debugger UI.\ncollapsePanes=Collapse panes\n\n# LOCALIZATION NOTE (copySourceUrl): This is the text that appears in the\n# context menu to copy the source URL of file open.\ncopySourceUrl=Copy Source Url\n\n# LOCALIZATION NOTE (copySourceUrl.accesskey): Access key to copy the source URL of a file from\n# the context menu.\ncopySourceUrl.accesskey=u\n\n# LOCALIZATION NOTE (expandPanes): This is the tooltip for the button\n# that expands the left and right panes in the debugger UI.\nexpandPanes=Expand panes\n\n# LOCALIZATION NOTE (pauseButtonTooltip): The tooltip that is displayed for the pause\n# button when the debugger is in a running state.\npauseButtonTooltip=Pause %S\n\n# LOCALIZATION NOTE (pausePendingButtonTooltip): The tooltip that is displayed for\n# the pause button after it's been clicked but before the next JavaScript to run.\npausePendingButtonTooltip=Waiting for next execution\n\n# LOCALIZATION NOTE (resumeButtonTooltip): The label that is displayed on the pause\n# button when the debugger is in a paused state.\nresumeButtonTooltip=Resume %S\n\n# LOCALIZATION NOTE (stepOverTooltip): The label that is displayed on the\n# button that steps over a function call.\nstepOverTooltip=Step Over %S\n\n# LOCALIZATION NOTE (stepInTooltip): The label that is displayed on the\n# button that steps into a function call.\nstepInTooltip=Step In %S\n\n# LOCALIZATION NOTE (stepOutTooltip): The label that is displayed on the\n# button that steps out of a function call.\nstepOutTooltip=Step Out %S\n\n# LOCALIZATION NOTE (noWorkersText): The text to display in the workers list\n# when there are no workers.\nnoWorkersText=This page has no workers.\n\n# LOCALIZATION NOTE (noSourcesText): The text to display in the sources list\n# when there are no sources.\nnoSourcesText=This page has no sources.\n\n# LOCALIZATION NOTE (noEventListenersText): The text to display in the events tab\n# when there are no events.\nnoEventListenersText=No event listeners to display\n\n# LOCALIZATION NOTE (eventListenersHeader): The text to display in the events\n# header.\neventListenersHeader=Event Listeners\n\n# LOCALIZATION NOTE (noStackFramesText): The text to display in the call stack tab\n# when there are no stack frames.\nnoStackFramesText=No stack frames to display\n\n# LOCALIZATION NOTE (eventCheckboxTooltip): The tooltip text to display when\n# the user hovers over the checkbox used to toggle an event breakpoint.\neventCheckboxTooltip=Toggle breaking on this event\n\n# LOCALIZATION NOTE (eventOnSelector): The text to display in the events tab\n# for every event item, between the event type and event selector.\neventOnSelector=on\n\n# LOCALIZATION NOTE (eventInSource): The text to display in the events tab\n# for every event item, between the event selector and listener's owner source.\neventInSource=in\n\n# LOCALIZATION NOTE (eventNodes): The text to display in the events tab when\n# an event is listened on more than one target node.\neventNodes=%S nodes\n\n# LOCALIZATION NOTE (eventNative): The text to display in the events tab when\n# a listener is added from plugins, thus getting translated to native code.\neventNative=[native code]\n\n# LOCALIZATION NOTE (*Events): The text to display in the events tab for\n# each group of sub-level event entries.\nanimationEvents=Animation\naudioEvents=Audio\nbatteryEvents=Battery\nclipboardEvents=Clipboard\ncompositionEvents=Composition\ndeviceEvents=Device\ndisplayEvents=Display\ndragAndDropEvents=Drag and Drop\ngamepadEvents=Gamepad\nindexedDBEvents=IndexedDB\ninteractionEvents=Interaction\nkeyboardEvents=Keyboard\nmediaEvents=HTML5 Media\nmouseEvents=Mouse\nmutationEvents=Mutation\nnavigationEvents=Navigation\npointerLockEvents=Pointer Lock\nsensorEvents=Sensor\nstorageEvents=Storage\ntimeEvents=Time\ntouchEvents=Touch\notherEvents=Other\n\n# LOCALIZATION NOTE (sources.search.key): Key shortcut to open the search for\n# searching all the source files the debugger has seen.\nsources.search.key=P\n\n# LOCALIZATION NOTE (sources.noSourcesAvailable): Text shown when the debugger\n# does not have any sources.\nsources.noSourcesAvailable=This page has no sources\n\n# LOCALIZATION NOTE (sources.searchAlt.key): Alternate key shortcut to open\n# the search for searching all the source files the debugger has seen.\nsources.searchAlt.key=O\n\n# LOCALIZATION NOTE (sourceSearch.search.key): Key shortcut to open the search\n# for searching within a the currently opened files in the editor\nsourceSearch.search.key=F\n\n# LOCALIZATION NOTE (sourceSearch.search.placeholder): placeholder text in\n# the source search input bar\nsourceSearch.search.placeholder=Search in file…\n\n# LOCALIZATION NOTE (sourceSearch.search.again.key): Key shortcut to re-open\n# the search for re-searching the same search triggered from a sourceSearch\nsourceSearch.search.again.key=G\n\n# LOCALIZATION NOTE (sourceSearch.resultsSummary1): Shows a summary of\n# the number of matches for autocomplete\nsourceSearch.resultsSummary1=%d results\n\n# LOCALIZATION NOTE (noMatchingStringsText): The text to display in the\n# global search results when there are no matching strings after filtering.\nnoMatchingStringsText=No matches found\n\n# LOCALIZATION NOTE (emptySearchText): This is the text that appears in the\n# filter text box when it is empty and the scripts container is selected.\nemptySearchText=Search scripts (%S)\n\n# LOCALIZATION NOTE (emptyVariablesFilterText): This is the text that\n# appears in the filter text box for the variables view container.\nemptyVariablesFilterText=Filter variables\n\n# LOCALIZATION NOTE (emptyPropertiesFilterText): This is the text that\n# appears in the filter text box for the editor's variables view bubble.\nemptyPropertiesFilterText=Filter properties\n\n# LOCALIZATION NOTE (searchPanelFilter): This is the text that appears in the\n# filter panel popup for the filter scripts operation.\nsearchPanelFilter=Filter scripts (%S)\n\n# LOCALIZATION NOTE (searchPanelGlobal): This is the text that appears in the\n# filter panel popup for the global search operation.\nsearchPanelGlobal=Search in all files (%S)\n\n# LOCALIZATION NOTE (searchPanelFunction): This is the text that appears in the\n# filter panel popup for the function search operation.\nsearchPanelFunction=Search for function definition (%S)\n\n# LOCALIZATION NOTE (searchPanelToken): This is the text that appears in the\n# filter panel popup for the token search operation.\nsearchPanelToken=Find in this file (%S)\n\n# LOCALIZATION NOTE (searchPanelGoToLine): This is the text that appears in the\n# filter panel popup for the line search operation.\nsearchPanelGoToLine=Go to line (%S)\n\n# LOCALIZATION NOTE (searchPanelVariable): This is the text that appears in the\n# filter panel popup for the variables search operation.\nsearchPanelVariable=Filter variables (%S)\n\n# LOCALIZATION NOTE (breakpointMenuItem): The text for all the elements that\n# are displayed in the breakpoints menu item popup.\nbreakpointMenuItem.setConditional=Configure conditional breakpoint\nbreakpointMenuItem.enableSelf=Enable breakpoint\nbreakpointMenuItem.disableSelf=Disable breakpoint\nbreakpointMenuItem.deleteSelf=Remove breakpoint\nbreakpointMenuItem.enableOthers=Enable others\nbreakpointMenuItem.disableOthers=Disable others\nbreakpointMenuItem.deleteOthers=Remove others\nbreakpointMenuItem.enableAll=Enable all breakpoints\nbreakpointMenuItem.disableAll=Disable all breakpoints\nbreakpointMenuItem.deleteAll=Remove all breakpoints\n\n# LOCALIZATION NOTE (breakpoints.header): Breakpoints right sidebar pane header.\nbreakpoints.header=Breakpoints\n\n# LOCALIZATION NOTE (breakpoints.none): The text that appears when there are\n# no breakpoints present\nbreakpoints.none=No Breakpoints\n\n# LOCALIZATION NOTE (breakpoints.enable): The text that may appear as a tooltip\n# when hovering over the 'disable breakpoints' switch button in right sidebar\nbreakpoints.enable=Enable Breakpoints\n\n# LOCALIZATION NOTE (breakpoints.disable): The text that may appear as a tooltip\n# when hovering over the 'disable breakpoints' switch button in right sidebar\nbreakpoints.disable=Disable Breakpoints\n\n# LOCALIZATION NOTE (breakpoints.removeBreakpointTooltip): The tooltip that is displayed\n# for remove breakpoint button in right sidebar\nbreakpoints.removeBreakpointTooltip=Remove Breakpoint\n\n# LOCALIZATION NOTE (callStack.header): Call Stack right sidebar pane header.\ncallStack.header=Call Stack\n\n# LOCALIZATION NOTE (callStack.notPaused): Call Stack right sidebar pane\n# message when not paused.\ncallStack.notPaused=Not Paused\n\n# LOCALIZATION NOTE (callStack.collapse): Call Stack right sidebar pane\n# message to hide some of the frames that are shown.\ncallStack.collapse=Collapse Rows\n\n# LOCALIZATION NOTE (callStack.expand): Call Stack right sidebar pane\n# message to show more of the frames.\ncallStack.expand=Expand Rows\n\n# LOCALIZATION NOTE (editor.searchResults): Editor Search bar message\n# for the summarizing the selected search result. e.g. 5 of 10 results.\neditor.searchResults=%d of %d results\n\n# LOCALIZATION NOTE (sourceSearch.singleResult): Copy shown when there is one result.\neditor.singleResult=1 result\n\n# LOCALIZATION NOTE (editor.noResults): Editor Search bar message\n# for when no results found.\neditor.noResults=no results\n\n# LOCALIZATION NOTE (editor.searchTypeToggleTitle): Search bar title for\n# toggling search type buttons(function search, variable search)\neditor.searchTypeToggleTitle=Search for:\n\n# LOCALIZATION NOTE (editor.addBreakpoint): Editor gutter context menu item\n# for adding a breakpoint on a line.\neditor.addBreakpoint=Add Breakpoint\n\n# LOCALIZATION NOTE (editor.disableBreakpoint): Editor gutter context menu item\n# for disabling a breakpoint on a line.\neditor.disableBreakpoint=Disable Breakpoint\n\n# LOCALIZATION NOTE (editor.enableBreakpoint): Editor gutter context menu item\n# for enabling a breakpoint on a line.\neditor.enableBreakpoint=Enable Breakpoint\n\n# LOCALIZATION NOTE (editor.removeBreakpoint): Editor gutter context menu item\n# for removing a breakpoint on a line.\neditor.removeBreakpoint=Remove Breakpoint\n\n# LOCALIZATION NOTE (editor.editBreakpoint): Editor gutter context menu item\n# for setting a breakpoint condition on a line.\neditor.editBreakpoint=Edit Breakpoint\n\n# LOCALIZATION NOTE (editor.addConditionalBreakpoint): Editor gutter context\n# menu item for adding a breakpoint condition on a line.\neditor.addConditionalBreakpoint=Add Conditional Breakpoint\n\n# LOCALIZATION NOTE (editor.conditionalPanel.placeholder): Placeholder text for\n# input element inside ConditionalPanel component\neditor.conditionalPanel.placeholder=This breakpoint will pause when the expression is true\n\n# LOCALIZATION NOTE (editor.conditionalPanel.placeholder): Tooltip text for\n# close button inside ConditionalPanel component\neditor.conditionalPanel.close=Cancel edit breakpoint and close\n\n# LOCALIZATION NOTE (editor.jumpToMappedLocation1): Context menu item\n# for navigating to a source mapped location\neditor.jumpToMappedLocation1=Jump to %S location\n\n# LOCALIZATION NOTE (generated): Source Map term for a server source location\ngenerated=generated\n\n# LOCALIZATION NOTE (original): Source Map term for a debugger UI source location\noriginal=original\n\n# LOCALIZATION NOTE (expressions.placeholder): Placeholder text for expression\n# input element\nexpressions.placeholder=Add Watch Expression\n\n# LOCALIZATION NOTE (sourceTabs.closeTab): Editor source tab context menu item\n# for closing the selected tab below the mouse.\nsourceTabs.closeTab=Close tab\n\n# LOCALIZATION NOTE (sourceTabs.closeTab.accesskey): Access key to close the currently select\n# source tab from the editor context menu item.\nsourceTabs.closeTab.accesskey=c\n\n# LOCALIZATION NOTE (sourceTabs.closeOtherTabs): Editor source tab context menu item\n# for closing the other tabs.\nsourceTabs.closeOtherTabs=Close others\n\n# LOCALIZATION NOTE (sourceTabs.closeOtherTabs.accesskey): Access key to close other source tabs\n# from the editor context menu.\nsourceTabs.closeOtherTabs.accesskey=o\n\n# LOCALIZATION NOTE (sourceTabs.closeTabsToEnd): Editor source tab context menu item\n# for closing the tabs to the end (the right for LTR languages) of the selected tab.\nsourceTabs.closeTabsToEnd=Close tabs to the right\n\n# LOCALIZATION NOTE (sourceTabs.closeTabsToEnd.accesskey): Access key to close source tabs\n# after the selected tab from the editor context menu.\nsourceTabs.closeTabsToEnd.accesskey=e\n\n# LOCALIZATION NOTE (sourceTabs.closeAllTabs): Editor source tab context menu item\n# for closing all tabs.\nsourceTabs.closeAllTabs=Close all tabs\n\n# LOCALIZATION NOTE (sourceTabs.closeAllTabs.accesskey): Access key to close all tabs from the\n# editor context menu.\nsourceTabs.closeAllTabs.accesskey=a\n\n# LOCALIZATION NOTE (sourceTabs.revealInTree): Editor source tab context menu item\n# for revealing source in tree.\nsourceTabs.revealInTree=Reveal in Tree\n\n# LOCALIZATION NOTE (sourceTabs.revealInTree.accesskey): Access key to reveal a source in the\n# tree from the context menu.\nsourceTabs.revealInTree.accesskey=r\n\n# LOCALIZATION NOTE (sourceTabs.copyLink): Editor source tab context menu item\n# for copying a link address.\nsourceTabs.copyLink=Copy Link Address\n\n# LOCALIZATION NOTE (sourceTabs.copyLink.accesskey): Access key to copy a link addresss from the\n# editor context menu.\nsourceTabs.copyLink.accesskey=l\n\n# LOCALIZATION NOTE (sourceTabs.prettyPrint): Editor source tab context menu item\n# for pretty printing the source.\nsourceTabs.prettyPrint=Pretty Print Source\n\n# LOCALIZATION NOTE (sourceTabs.prettyPrint.accesskey): Access key to pretty print a source from\n# the editor context menu.\nsourceTabs.prettyPrint.accesskey=p\n\n# LOCALIZATION NOTE (sourceFooter.blackbox): Tooltip text associated\n# with the blackbox button\nsourceFooter.blackbox=Blackbox Source\n\n# LOCALIZATION NOTE (sourceFooter.unblackbox): Tooltip text associated\n# with the blackbox button\nsourceFooter.unblackbox=Unblackbox Source\n\n# LOCALIZATION NOTE (sourceFooter.blackbox.accesskey): Access key to blackbox\n# an associated source\nsourceFooter.blackbox.accesskey=b\n\n# LOCALIZATION NOTE (sourceFooter.blackboxed): Text associated\n# with a blackboxed source\nsourceFooter.blackboxed=Blackboxed Source\n\n# LOCALIZATION NOTE (sourceTabs.closeTabButtonTooltip): The tooltip that is displayed\n# for close tab button in source tabs.\nsourceTabs.closeTabButtonTooltip=Close tab\n\n# LOCALIZATION NOTE (sourceTabs.newTabButtonTooltip): The tooltip that is displayed for\n# new tab button in source tabs.\nsourceTabs.newTabButtonTooltip=Search for sources (%S)\n\n# LOCALIZATION NOTE (scopes.header): Scopes right sidebar pane header.\nscopes.header=Scopes\n\n# LOCALIZATION NOTE (scopes.notAvailable): Scopes right sidebar pane message\n# for when the debugger is paused, but there isn't pause data.\nscopes.notAvailable=Scopes Unavailable\n\n# LOCALIZATION NOTE (scopes.notPaused): Scopes right sidebar pane message\n# for when the debugger is not paused.\nscopes.notPaused=Not Paused\n\n# LOCALIZATION NOTE (scopes.block): Refers to a block of code in\n# the scopes pane when the debugger is paused.\nscopes.block=Block\n\n# LOCALIZATION NOTE (sources.header): Sources left sidebar header\nsources.header=Sources\n\n# LOCALIZATION NOTE (sources.search): Sources left sidebar prompt\n# e.g. Cmd+P to search. On a mac, we use the command unicode character.\n# On windows, it's ctrl.\nsources.search=%S to search\n\n# LOCALIZATION NOTE (watchExpressions.header): Watch Expressions right sidebar\n# pane header.\nwatchExpressions.header=Watch Expressions\n\n# LOCALIZATION NOTE (watchExpressions.refreshButton): Watch Expressions header\n# button for refreshing the expressions.\nwatchExpressions.refreshButton=Refresh\n\n# LOCALIZATION NOTE (welcome.search): The center pane welcome panel's\n# search prompt. e.g. cmd+p to search for files. On windows, it's ctrl, on\n# a mac we use the unicode character.\nwelcome.search=%S to search for sources\n\n# LOCALIZATION NOTE (sourceSearch.search): The center pane Source Search\n# prompt for searching for files.\nsourceSearch.search=Search Sources…\n\n# LOCALIZATION NOTE (sourceSearch.noResults): The center pane Source Search\n# message when the query did not match any of the sources.\nsourceSearch.noResults=No files matching %S found\n\n# LOCALIZATION NOTE (ignoreExceptions): The pause on exceptions button tooltip\n# when the debugger will not pause on exceptions.\nignoreExceptions=Ignore exceptions. Click to pause on uncaught exceptions\n\n# LOCALIZATION NOTE (pauseOnUncaughtExceptions): The pause on exceptions button\n# tooltip when the debugger will pause on uncaught exceptions.\npauseOnUncaughtExceptions=Pause on uncaught exceptions. Click to pause on all exceptions\n\n# LOCALIZATION NOTE (pauseOnExceptions): The pause on exceptions button tooltip\n# when the debugger will pause on all exceptions.\npauseOnExceptions=Pause on all exceptions. Click to ignore exceptions\n\n# LOCALIZATION NOTE (loadingText): The text that is displayed in the script\n# editor when the loading process has started but there is no file to display\n# yet.\nloadingText=Loading\\u2026\n\n# LOCALIZATION NOTE (errorLoadingText2): The text that is displayed in the debugger\n# viewer when there is an error loading a file\nerrorLoadingText2=Error loading this URL: %S\n\n# LOCALIZATION NOTE (addWatchExpressionText): The text that is displayed in the\n# watch expressions list to add a new item.\naddWatchExpressionText=Add watch expression\n\n# LOCALIZATION NOTE (addWatchExpressionButton): The button that is displayed in the\n# variables view popup.\naddWatchExpressionButton=Watch\n\n# LOCALIZATION NOTE (emptyVariablesText): The text that is displayed in the\n# variables pane when there are no variables to display.\nemptyVariablesText=No variables to display\n\n# LOCALIZATION NOTE (scopeLabel): The text that is displayed in the variables\n# pane as a header for each variable scope (e.g. \"Global scope, \"With scope\",\n# etc.).\nscopeLabel=%S scope\n\n# LOCALIZATION NOTE (watchExpressionsScopeLabel): The name of the watch\n# expressions scope. This text is displayed in the variables pane as a header for\n# the watch expressions scope.\nwatchExpressionsScopeLabel=Watch expressions\n\n# LOCALIZATION NOTE (globalScopeLabel): The name of the global scope. This text\n# is added to scopeLabel and displayed in the variables pane as a header for\n# the global scope.\nglobalScopeLabel=Global\n\n# LOCALIZATION NOTE (variablesViewErrorStacktrace): This is the text that is\n# shown before the stack trace in an error.\nvariablesViewErrorStacktrace=Stack trace:\n\n# LOCALIZATION NOTE (variablesViewMoreObjects): the text that is displayed\n# when you have an object preview that does not show all of the elements. At the end of the list\n# you see \"N more...\" in the web console output.\n# This is a semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of remaining items in the object\n# example: 3 more…\nvariablesViewMoreObjects=#1 more…;#1 more…\n\n# LOCALIZATION NOTE (variablesEditableNameTooltip): The text that is displayed\n# in the variables list on an item with an editable name.\nvariablesEditableNameTooltip=Double click to edit\n\n# LOCALIZATION NOTE (variablesEditableValueTooltip): The text that is displayed\n# in the variables list on an item with an editable value.\nvariablesEditableValueTooltip=Click to change value\n\n# LOCALIZATION NOTE (variablesCloseButtonTooltip): The text that is displayed\n# in the variables list on an item which can be removed.\nvariablesCloseButtonTooltip=Click to remove\n\n# LOCALIZATION NOTE (variablesEditButtonTooltip): The text that is displayed\n# in the variables list on a getter or setter which can be edited.\nvariablesEditButtonTooltip=Click to set value\n\n# LOCALIZATION NOTE (variablesEditableValueTooltip): The text that is displayed\n# in a tooltip on the \"open in inspector\" button in the the variables list for a\n# DOMNode item.\nvariablesDomNodeValueTooltip=Click to select the node in the inspector\n\n# LOCALIZATION NOTE (configurable|...|Tooltip): The text that is displayed\n# in the variables list on certain variables or properties as tooltips.\n# Expanations of what these represent can be found at the following links:\n# https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n# https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n# https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n# https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n# It's probably best to keep these in English.\nconfigurableTooltip=configurable\nenumerableTooltip=enumerable\nwritableTooltip=writable\nfrozenTooltip=frozen\nsealedTooltip=sealed\nextensibleTooltip=extensible\noverriddenTooltip=overridden\nWebIDLTooltip=WebIDL\n\n# LOCALIZATION NOTE (variablesSeparatorLabel): The text that is displayed\n# in the variables list as a separator between the name and value.\nvariablesSeparatorLabel=:\n\n# LOCALIZATION NOTE (watchExpressionsSeparatorLabel2): The text that is displayed\n# in the watch expressions list as a separator between the code and evaluation.\nwatchExpressionsSeparatorLabel2=\\u0020→\n\n# LOCALIZATION NOTE (functionSearchSeparatorLabel): The text that is displayed\n# in the functions search panel as a separator between function's inferred name\n# and its real name (if available).\nfunctionSearchSeparatorLabel=←\n\n# LOCALIZATION NOTE(symbolSearch.search.functionsPlaceholder): The placeholder\n# text displayed when the user searches for functions in a file\nsymbolSearch.search.functionsPlaceholder=Search functions…\n\n# LOCALIZATION NOTE(symbolSearch.search.variablesPlaceholder): The placeholder\n# text displayed when the user searches for variables in a file\nsymbolSearch.search.variablesPlaceholder=Search variables…\n\n# LOCALIZATION NOTE(symbolSearch.search.key): The shortcut (cmd+shift+o) for\n# searching for a function or variable\nsymbolSearch.search.key=O\n\n# LOCALIZATION NOTE(symbolSearch.searchModifier.regex): A search option\n# when searching text in a file\nsymbolSearch.searchModifier.regex=Regex\n\n# LOCALIZATION NOTE(symbolSearch.searchModifier.caseSensitive): A search option\n# when searching text in a file\nsymbolSearch.searchModifier.caseSensitive=Case sensitive\n\n# LOCALIZATION NOTE(symbolSearch.searchModifier.wholeWord): A search option\n# when searching text in a file\nsymbolSearch.searchModifier.wholeWord=Whole word\n\n# LOCALIZATION NOTE (resumptionOrderPanelTitle): This is the text that appears\n# as a description in the notification panel popup, when multiple debuggers are\n# open in separate tabs and the user tries to resume them in the wrong order.\n# The substitution parameter is the URL of the last paused window that must be\n# resumed first.\nresumptionOrderPanelTitle=There are one or more paused debuggers. Please resume the most-recently paused debugger first at: %S\n\nvariablesViewOptimizedOut=(optimized away)\nvariablesViewUninitialized=(uninitialized)\nvariablesViewMissingArgs=(unavailable)\n\nanonymousSourcesLabel=Anonymous Sources\n\nexperimental=This is an experimental feature\n\n# LOCALIZATION NOTE (whyPaused.debuggerStatement): The text that is displayed\n# in a info block explaining how the debugger is currently paused due to a `debugger`\n# statement in the code\nwhyPaused.debuggerStatement=Paused on debugger statement\n\n# LOCALIZATION NOTE (whyPaused.breakpoint): The text that is displayed\n# in a info block explaining how the debugger is currently paused on a breakpoint\nwhyPaused.breakpoint=Paused on breakpoint\n\n# LOCALIZATION NOTE (whyPaused.exception): The text that is displayed\n# in a info block explaining how the debugger is currently paused on an exception\nwhyPaused.exception=Paused on exception\n\n# LOCALIZATION NOTE (whyPaused.resumeLimit): The text that is displayed\n# in a info block explaining how the debugger is currently paused while stepping\n# in or out of the stack\nwhyPaused.resumeLimit=Paused while stepping\n\n# LOCALIZATION NOTE (whyPaused.pauseOnDOMEvents): The text that is displayed\n# in a info block explaining how the debugger is currently paused on a\n# dom event\nwhyPaused.pauseOnDOMEvents=Paused on event listener\n\n# LOCALIZATION NOTE (whyPaused.breakpointConditionThrown): The text that is displayed\n# in an info block when evaluating a conditional breakpoint throws an error\nwhyPaused.breakpointConditionThrown=Error with conditional breakpoint\n\n# LOCALIZATION NOTE (whyPaused.xhr): The text that is displayed\n# in a info block explaining how the debugger is currently paused on an\n# xml http request\nwhyPaused.xhr=Paused on XMLHttpRequest\n\n# LOCALIZATION NOTE (whyPaused.promiseRejection): The text that is displayed\n# in a info block explaining how the debugger is currently paused on a\n# promise rejection\nwhyPaused.promiseRejection=Paused on promise rejection\n\n# LOCALIZATION NOTE (whyPaused.assert): The text that is displayed\n# in a info block explaining how the debugger is currently paused on an\n# assert\nwhyPaused.assert=Paused on assertion\n\n# LOCALIZATION NOTE (whyPaused.debugCommand): The text that is displayed\n# in a info block explaining how the debugger is currently paused on a\n# debugger statement\nwhyPaused.debugCommand=Paused on debugged function\n\n# LOCALIZATION NOTE (whyPaused.other): The text that is displayed\n# in a info block explaining how the debugger is currently paused on an event\n# listener breakpoint set\nwhyPaused.other=Debugger paused\n\n# LOCALIZATION NOTE (ctrl): The text that is used for documenting\n# keyboard shortcuts that use the control key\nctrl=Ctrl\n"

/***/ },
/* 961 */,
/* 962 */,
/* 963 */,
/* 964 */,
/* 965 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SourceEditorUtils = exports.SourceEditor = undefined;

	var _sourceEditor = __webpack_require__(966);

	var _sourceEditor2 = _interopRequireDefault(_sourceEditor);

	var _utils = __webpack_require__(969);

	var SourceEditorUtils = _interopRequireWildcard(_utils);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.SourceEditor = _sourceEditor2.default;
	exports.SourceEditorUtils = SourceEditorUtils;

/***/ },
/* 966 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * CodeMirror source editor utils
	 * @module utils/source-editor
	 */

	var CodeMirror = __webpack_require__(306);

	__webpack_require__(307);
	__webpack_require__(309);
	__webpack_require__(310);
	__webpack_require__(313);
	__webpack_require__(314);
	__webpack_require__(315);
	__webpack_require__(905);
	__webpack_require__(318);
	__webpack_require__(906);
	__webpack_require__(907);
	__webpack_require__(908);
	__webpack_require__(909);

	__webpack_require__(967);

	// NOTE: we should eventually use debugger-html context type mode


	// Maximum allowed margin (in number of lines) from top or bottom of the editor
	// while shifting to a line which was initially out of view.
	var MAX_VERTICAL_OFFSET = 3;

	class SourceEditor {

	  constructor(opts) {
	    this.opts = opts;
	  }

	  appendToLocalElement(node) {
	    this.editor = CodeMirror(node, this.opts);
	  }

	  destroy() {
	    // Unlink the current document.
	    if (this.editor.doc) {
	      this.editor.doc.cm = null;
	    }
	  }

	  get codeMirror() {
	    return this.editor;
	  }

	  setText(str) {
	    this.editor.setValue(str);
	  }

	  getText() {
	    return this.editor.getValue();
	  }

	  setMode(value) {
	    this.editor.setOption("mode", value);
	  }

	  /**
	   * Replaces the current document with a new source document
	   * @memberof utils/source-editor
	   */
	  replaceDocument(doc) {
	    this.editor.swapDoc(doc);
	  }

	  /**
	   * Creates a CodeMirror Document
	   * @returns CodeMirror.Doc
	   * @memberof utils/source-editor
	   */
	  createDocument() {
	    return new CodeMirror.Doc("");
	  }

	  /**
	   * Aligns the provided line to either "top", "center" or "bottom" of the
	   * editor view with a maximum margin of MAX_VERTICAL_OFFSET lines from top or
	   * bottom.
	   * @memberof utils/source-editor
	   */
	  alignLine(line) {
	    var align = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "top";

	    var cm = this.editor;
	    var from = cm.lineAtHeight(0, "page");
	    var to = cm.lineAtHeight(cm.getWrapperElement().clientHeight, "page");
	    var linesVisible = to - from;
	    var halfVisible = Math.round(linesVisible / 2);

	    // If the target line is in view, skip the vertical alignment part.
	    if (line <= to && line >= from) {
	      return;
	    }

	    // Setting the offset so that the line always falls in the upper half
	    // of visible lines (lower half for bottom aligned).
	    // MAX_VERTICAL_OFFSET is the maximum allowed value.
	    var offset = Math.min(halfVisible, MAX_VERTICAL_OFFSET);

	    var topLine = {
	      center: Math.max(line - halfVisible, 0),
	      bottom: Math.max(line - linesVisible + offset, 0),
	      top: Math.max(line - offset, 0)
	    }[align || "top"] || offset;

	    // Bringing down the topLine to total lines in the editor if exceeding.
	    topLine = Math.min(topLine, cm.lineCount());
	    this.setFirstVisibleLine(topLine);
	  }

	  /**
	   * Scrolls the view such that the given line number is the first visible line.
	   * @memberof utils/source-editor
	   */
	  setFirstVisibleLine(line) {
	    var _editor$charCoords = this.editor.charCoords({ line: line, ch: 0 }, "local"),
	        top = _editor$charCoords.top;

	    this.editor.scrollTo(0, top);
	  }
	}

	module.exports = SourceEditor;

/***/ },
/* 967 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 968 */,
/* 969 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.removeLineClass = removeLineClass;
	exports.clearLineClass = clearLineClass;
	exports.getTextForLine = getTextForLine;
	exports.getCursorLine = getCursorLine;
	exports.resizeBreakpointGutter = resizeBreakpointGutter;
	function forEachLine(codeMirror, iter) {
	  codeMirror.doc.iter(0, codeMirror.lineCount(), iter);
	}

	function removeLineClass(codeMirror, line, className) {
	  codeMirror.removeLineClass(line, "line", className);
	}

	function clearLineClass(codeMirror, className) {
	  forEachLine(codeMirror, line => {
	    removeLineClass(codeMirror, line, className);
	  });
	}

	function getTextForLine(codeMirror, line) {
	  return codeMirror.getLine(line - 1).trim();
	}

	function getCursorLine(codeMirror) {
	  return codeMirror.getCursor().line;
	}

	/**
	 * Forces the breakpoint gutter to be the same size as the line
	 * numbers gutter. Editor CSS will absolutely position the gutter
	 * beneath the line numbers. This makes it easy to be flexible with
	 * how we overlay breakpoints.
	 */
	function resizeBreakpointGutter(editor) {
	  var gutters = editor.display.gutters;
	  var lineNumbers = gutters.querySelector(".CodeMirror-linenumbers");
	  var breakpoints = gutters.querySelector(".breakpoints");
	  breakpoints.style.width = `${lineNumbers.clientWidth}px`;
	}

/***/ },
/* 970 */
/***/ function(module, exports) {

	module.exports = "<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 34 32\"><path fill=\"#444444\" d=\"M19.314 15.987c0 1.321-1.071 2.392-2.392 2.392s-2.392-1.071-2.392-2.392c0-1.321 1.071-2.392 2.392-2.392s2.392 1.071 2.392 2.392z\"></path><path fill=\"#444444\" d=\"M16.922 24.783c1.878 1.826 3.729 2.906 5.221 2.906 0.489 0 0.952-0.103 1.337-0.334 1.337-0.772 1.826-2.701 1.363-5.453-0.077-0.489-0.18-0.977-0.309-1.492 0.514-0.154 0.977-0.309 1.44-0.463 2.598-1.003 4.038-2.392 4.038-3.909 0-1.543-1.44-2.932-4.038-3.909-0.463-0.18-0.926-0.334-1.44-0.463 0.129-0.514 0.232-1.003 0.309-1.492 0.437-2.803-0.051-4.758-1.389-5.53-0.386-0.231-0.849-0.334-1.337-0.334-1.466 0-3.344 1.080-5.221 2.906-1.852-1.826-3.704-2.906-5.195-2.906-0.489 0-0.952 0.103-1.337 0.334-1.337 0.772-1.826 2.701-1.363 5.453 0.077 0.489 0.18 0.977 0.309 1.492-0.514 0.154-0.977 0.309-1.44 0.463-2.598 1.003-4.038 2.392-4.038 3.909 0 1.543 1.44 2.932 4.038 3.909 0.463 0.18 0.926 0.334 1.44 0.463-0.129 0.514-0.232 1.003-0.309 1.492-0.437 2.752 0.051 4.707 1.363 5.453 0.386 0.232 0.849 0.334 1.337 0.334 1.492 0.051 3.344-1.029 5.221-2.829v0zM15.481 21.311c0.463 0.026 0.952 0.026 1.44 0.026s0.977 0 1.44-0.026c-0.463 0.617-0.952 1.183-1.44 1.723-0.489-0.54-0.977-1.106-1.44-1.723zM12.292 18.662c0.257 0.437 0.489 0.849 0.772 1.26-0.797-0.103-1.543-0.232-2.263-0.386 0.232-0.694 0.489-1.415 0.797-2.135 0.206 0.411 0.437 0.849 0.694 1.26zM10.8 12.463c0.72-0.154 1.466-0.283 2.263-0.386-0.257 0.412-0.514 0.823-0.772 1.26s-0.489 0.849-0.694 1.286c-0.334-0.746-0.592-1.466-0.797-2.161zM12.215 15.987c0.334-0.694 0.694-1.389 1.106-2.083 0.386-0.669 0.823-1.337 1.26-2.006 0.772-0.051 1.543-0.077 2.341-0.077 0.823 0 1.595 0.026 2.341 0.077 0.463 0.669 0.874 1.337 1.26 2.006 0.412 0.694 0.772 1.389 1.106 2.083-0.334 0.694-0.694 1.389-1.106 2.083-0.386 0.669-0.823 1.337-1.26 2.006-0.772 0.051-1.543 0.077-2.341 0.077-0.823 0-1.595-0.026-2.341-0.077-0.463-0.669-0.874-1.337-1.26-2.006-0.412-0.695-0.772-1.389-1.106-2.083v0zM22.272 14.598l-0.694-1.286c-0.257-0.437-0.489-0.849-0.772-1.26 0.797 0.103 1.543 0.232 2.263 0.386-0.231 0.72-0.489 1.44-0.797 2.161v0zM22.272 17.376c0.309 0.72 0.566 1.44 0.797 2.135-0.72 0.154-1.466 0.283-2.263 0.386 0.257-0.412 0.514-0.823 0.772-1.26 0.232-0.386 0.463-0.823 0.694-1.26v0zM22.863 26.301c-0.206 0.129-0.463 0.18-0.746 0.18-1.26 0-2.829-1.029-4.372-2.572 0.746-0.797 1.466-1.698 2.186-2.701 1.209-0.103 2.366-0.283 3.447-0.54 0.129 0.463 0.206 0.926 0.283 1.389 0.36 2.186 0.077 3.755-0.797 4.244zM24.201 12.746c2.881 0.823 4.604 2.083 4.604 3.241 0 1.003-1.183 2.006-3.266 2.804-0.412 0.154-0.874 0.309-1.337 0.437-0.334-1.055-0.746-2.135-1.26-3.241 0.514-1.106 0.952-2.186 1.26-3.241v0zM22.143 5.493c0.283 0 0.514 0.051 0.746 0.18 0.849 0.489 1.157 2.032 0.797 4.244-0.077 0.437-0.18 0.9-0.283 1.389-1.080-0.232-2.238-0.412-3.447-0.54-0.694-1.003-1.44-1.903-2.186-2.701 1.543-1.518 3.112-2.572 4.372-2.572zM18.362 10.663c-0.463-0.026-0.952-0.026-1.44-0.026s-0.977 0-1.44 0.026c0.463-0.617 0.952-1.183 1.44-1.723 0.489 0.54 0.977 1.132 1.44 1.723v0zM10.98 5.673c0.206-0.129 0.463-0.18 0.746-0.18 1.26 0 2.829 1.029 4.372 2.572-0.746 0.797-1.466 1.697-2.186 2.701-1.209 0.103-2.366 0.283-3.447 0.54-0.129-0.463-0.206-0.926-0.283-1.389-0.36-2.186-0.077-3.729 0.797-4.244v0zM9.643 19.228c-2.881-0.823-4.604-2.083-4.604-3.241 0-1.003 1.183-2.006 3.266-2.803 0.412-0.154 0.874-0.309 1.337-0.437 0.334 1.055 0.746 2.135 1.26 3.241-0.514 1.106-0.952 2.212-1.26 3.241zM10.183 22.057c0.077-0.437 0.18-0.9 0.283-1.389 1.080 0.232 2.238 0.412 3.447 0.54 0.694 1.003 1.44 1.903 2.186 2.701-1.543 1.517-3.112 2.572-4.372 2.572-0.283 0-0.514-0.051-0.746-0.18-0.875-0.489-1.157-2.058-0.797-4.244z\"></path></svg>"

/***/ },
/* 971 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 972 */,
/* 973 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = simplifyDisplayName;
	// Decodes an anonymous naming scheme that
	// spider monkey implements based on "Naming Anonymous JavaScript Functions"
	// http://johnjbarton.github.io/nonymous/index.html
	var objectProperty = /([\w\d]+)$/;
	var arrayProperty = /\[(.*?)\]$/;
	var functionProperty = /([\w\d]+)[\/\.<]*?$/;
	var annonymousProperty = /([\w\d]+)\(\^\)$/;

	function simplifyDisplayName(displayName) {
	  var scenarios = [objectProperty, arrayProperty, functionProperty, annonymousProperty];

	  for (var reg of scenarios) {
	    var match = reg.exec(displayName);
	    if (match) {
	      return match[1];
	    }
	  }

	  return displayName;
	}

/***/ }
/******/ ])
});
;