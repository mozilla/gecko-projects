/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

var { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
var { AppConstants } = ChromeUtils.import(
  "resource://gre/modules/AppConstants.jsm"
);
var { setTimeout } = ChromeUtils.import("resource://gre/modules/Timer.jsm");

/**
 * Get the payloads of a type recursively, including from all subprocesses.
 *
 * @param {Object} profile The gecko profile.
 * @param {string} type The marker payload type, e.g. "DiskIO".
 * @param {Array} payloadTarget The recursive list of payloads.
 * @return {Array} The final payloads.
 */
function getAllPayloadsOfType(profile, type, payloadTarget = []) {
  for (const { markers } of profile.threads) {
    for (const markerTuple of markers.data) {
      const payload = markerTuple[markers.schema.data];
      if (payload && payload.type === type) {
        payloadTarget.push(payload);
      }
    }
  }

  for (const subProcess of profile.processes) {
    getAllPayloadsOfType(subProcess, type, payloadTarget);
  }

  return payloadTarget;
}

/**
 * This is a helper function be able to run `await wait(500)`. Unfortunately
 * this is needed as the act of collecting functions relies on the periodic
 * sampling of the threads. See:
 * https://bugzilla.mozilla.org/show_bug.cgi?id=1529053
 *
 * @param {number} time
 * @returns {Promise}
 */
function wait(time) {
  return new Promise(resolve => {
    // eslint-disable-next-line mozilla/no-arbitrary-setTimeout
    setTimeout(resolve, time);
  });
}

/**
 * This function takes a thread, and a sample tuple from the "data" array, and
 * inflates the frame to be an array of strings.
 *
 * @param {Object} thread - The thread from the profile.
 * @param {Array} sample - The tuple from the thread.samples.data array.
 * @returns {Array<string>} An array of function names.
 */
function getInflatedStackLocations(thread, sample) {
  let stackTable = thread.stackTable;
  let frameTable = thread.frameTable;
  let stringTable = thread.stringTable;
  let SAMPLE_STACK_SLOT = thread.samples.schema.stack;
  let STACK_PREFIX_SLOT = stackTable.schema.prefix;
  let STACK_FRAME_SLOT = stackTable.schema.frame;
  let FRAME_LOCATION_SLOT = frameTable.schema.location;

  // Build the stack from the raw data and accumulate the locations in
  // an array.
  let stackIndex = sample[SAMPLE_STACK_SLOT];
  let locations = [];
  while (stackIndex !== null) {
    let stackEntry = stackTable.data[stackIndex];
    let frame = frameTable.data[stackEntry[STACK_FRAME_SLOT]];
    locations.push(stringTable[frame[FRAME_LOCATION_SLOT]]);
    stackIndex = stackEntry[STACK_PREFIX_SLOT];
  }

  // The profiler tree is inverted, so reverse the array.
  return locations.reverse();
}

/**
 * It can be helpful to deterministically do at least one more profile sample.
 * Sampling is done based on a timer. This function spins on a while loop until
 * at least one more sample is collected.
 *
 * @return {number} The index of the collected sample.
 */
function doAtLeastOnePeriodicSample() {
  function getProfileSampleCount() {
    const profile = Services.profiler.getProfileData();
    return profile.threads[0].samples.data.length;
  }

  const sampleCount = getProfileSampleCount();
  // Create an infinite loop until a sample has been collected.
  while (true) {
    if (sampleCount < getProfileSampleCount()) {
      return sampleCount;
    }
  }
}

/**
 * This utility matches up stacks to see if they contain a certain sequence of
 * stack frames. A correctly functioning profiler will have a certain sequence
 * of stacks, but we can't always determine exactly which stacks will show up
 * due to implementation changes, as well as memory addresses being arbitrary to
 * that particular build.
 *
 * This function triggers a test failure with a nice debug message when it
 * fails.
 *
 * @param {Array<string>} actualStackFrames - As generated by
 *     inflatedStackFrames.
 * @param {Array<string | RegExp>} expectedStackFrames - Matches a subset of
 *     actualStackFrames
 */
function expectStackToContain(
  actualStackFrames,
  expectedStackFrames,
  message = "The actual stack and expected stack do not match."
) {
  // Log the stacks that are being passed to this assertion, as it could be
  // useful for when these tests fail.
  console.log("Actual stack: ", actualStackFrames);
  console.log(
    "Expected to contain: ",
    expectedStackFrames.map(s => s.toString())
  );

  let actualIndex = 0;

  // Start walking the expected stack and look for matches.
  for (
    let expectedIndex = 0;
    expectedIndex < expectedStackFrames.length;
    expectedIndex++
  ) {
    const expectedStackFrame = expectedStackFrames[expectedIndex];

    while (true) {
      // Make sure that we haven't run out of actual stack frames.
      if (actualIndex >= actualStackFrames.length) {
        info(`Could not find a match for: "${expectedStackFrame.toString()}"`);
        Assert.ok(false, message);
      }

      const actualStackFrame = actualStackFrames[actualIndex];
      actualIndex++;

      const itMatches =
        typeof expectedStackFrame === "string"
          ? expectedStackFrame === actualStackFrame
          : actualStackFrame.match(expectedStackFrame);

      if (itMatches) {
        // We found a match, break out of this loop.
        break;
      }
      // Keep on looping looking for a match.
    }
  }

  Assert.ok(true, message);
}
