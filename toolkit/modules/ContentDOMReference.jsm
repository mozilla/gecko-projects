/* vim: set ts=2 sw=2 sts=2 et tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */

/**
 * This module holds weak references to DOM elements that exist within the
 * current content process, and converts them to a unique identifier that can be
 * passed between processes. The identifer, if received by the same content process
 * that issued it, can then be converted back into the DOM element (presuming the
 * element hasn't had all of its other references dropped).
 *
 * The hope is that this module can eliminate the need for passing CPOW references
 * between processes during runtime.
 */

var EXPORTED_SYMBOLS = ["ContentDOMReference"];

const {XPCOMUtils} = ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");

XPCOMUtils.defineLazyServiceGetter(this, "gUUIDGenerator",
                                   "@mozilla.org/uuid-generator;1",
                                   "nsIUUIDGenerator");

/**
 * An identifier generated by ContentDOMReference is a unique pair of BrowsingContext
 * ID and a UUID. gRegistry maps BrowsingContext's to an object with the following
 * properties:
 *
 *   UUIDToElement:
 *     A Map of UUID strings to WeakReference's to the elements they refer to.
 *
 *   elementToUUID:
 *     A WeakMap from a DOM element to a UUID that refers to it.
 */
var gRegistry = new WeakMap();

var ContentDOMReference = {
  /**
   * Generate and return an identifier for a given DOM element.
   *
   * @param {Element} element The DOM element to generate the identifier for.
   * @return {Object} The identifier for the DOM element that can be passed between
   * processes as a message.
   */
  get(element) {
    if (!element) {
      throw new Error("Can't create a ContentDOMReference identifier for " +
                      "non-existant nodes.");
    }

    let browsingContext = element.ownerGlobal.getWindowGlobalChild().browsingContext;
    let mappings = gRegistry.get(browsingContext);
    if (!mappings) {
      mappings = {
        UUIDToElement: new Map(),
        elementToUUID: new WeakMap(),
      };
      gRegistry.set(browsingContext, mappings);
    }

    let uuid = mappings.elementToUUID.get(element);
    if (uuid) {
      // We already had this element registered, so return the pre-existing UUID.
      return { browsingContextId: browsingContext.id, uuid };
    }

    // We must be registering a new element at this point.
    uuid = gUUIDGenerator.generateUUID().toString();
    mappings.elementToUUID.set(element, uuid);
    mappings.UUIDToElement.set(uuid, Cu.getWeakReference(element));

    return { browsingContextId: browsingContext.id, uuid };
  },

  /**
   * Resolves an identifier back into the DOM Element that it was generated from.
   *
   * @param {Object} The identifier generated via ContentDOMReference.get for a
   * DOM element.
   * @return {Element} The DOM element that the identifier was generated for, or
   * null if the element does not still exist.
   */
  resolve(identifier) {
    let browsingContext = BrowsingContext.get(identifier.browsingContextId);
    let uuid = identifier.uuid;
    return this._resolveUUIDToElement(browsingContext, uuid);
  },

  /**
   * Removes an identifier from the registry so that subsequent attempts
   * to resolve it will result in null. This is generally a good idea to avoid
   * identifiers lying around taking up space (identifiers don't keep the
   * DOM element alive, but the weak pointers themselves consume memory, and
   * that's what we reclaim when revoking).
   *
   * @param {Object} The identifier to revoke, issued by ContentDOMReference.get for
   * a DOM element.
   */
  revoke(identifier) {
    let browsingContext = BrowsingContext.get(identifier.browsingContextId);
    let uuid = identifier.uuid;

    let mappings = gRegistry.get(browsingContext);
    if (!mappings) {
      return;
    }

    let element = this._resolveUUIDToElement(browsingContext, uuid);
    if (element) {
      mappings.elementToUUID.delete(element);
    }

    mappings.UUIDToElement.delete(uuid);
  },

  /**
   * Private helper function that resolves a BrowsingContext and UUID (the
   * pair that makes up an identifier) to a DOM element.
   *
   * @param {BrowsingContext} browsingContext The BrowsingContext that was hosting
   * the DOM element at the time that the identifier was generated.
   * @param {String} uuid The UUID generated for the DOM element.
   *
   * @return {Element} The DOM element that the identifier was generated for, or
   * null if the element does not still exist.
   */
  _resolveUUIDToElement(browsingContext, uuid) {
    let mappings = gRegistry.get(browsingContext);
    if (!mappings) {
      return null;
    }

    let weakReference = mappings.UUIDToElement.get(uuid);
    if (!weakReference) {
      return null;
    }

    return weakReference.get();
  },
};
