/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "frontend/BCEScriptStencil.h"

#include "frontend/AbstractScopePtr.h"  // AbstractScope
#include "frontend/BytecodeEmitter.h"   // BytecodeEmitter
#include "frontend/BytecodeSection.h"   // BytecodeSection, PerScriptData
#include "vm/SharedStencil.h"

using namespace js;
using namespace js::frontend;

BCEScriptStencil::BCEScriptStencil(BytecodeEmitter& bce,
                                   UniquePtr<ImmutableScriptData> immutableData)
    : ScriptStencil(bce.cx), bce_(bce) {
  init(bce, std::move(immutableData));
}

void BCEScriptStencil::init(BytecodeEmitter& bce,
                            UniquePtr<ImmutableScriptData> immutableData) {
  natoms = bce.perScriptData().atomIndices()->count();

  immutableFlags = bce.sc->immutableFlags();

  MOZ_ASSERT(bce.outermostScope().hasOnChain(ScopeKind::NonSyntactic) ==
             immutableFlags.hasFlag(ImmutableFlags::HasNonSyntacticScope));

  gcThings = bce.perScriptData().gcThingList().stealGCThings();

  // Hand over the ImmutableScriptData instance generated by BCE.
  immutableScriptData = std::move(immutableData);

  // Update flags specific to functions.
  if (isFunction()) {
    FunctionBox* funbox = bce.sc->asFunctionBox();
    functionIndex.emplace(funbox->index());
    fieldInitializers = funbox->fieldInitializers;

    // Set flags that don't have direct flag representation within the
    // FunctionBox.
    immutableFlags.setFlag(ImmutableFlags::HasMappedArgsObj,
                           funbox->hasMappedArgsObj());

    // While IsLikelyConstructorWrapper is required to be the same between
    // syntax and normal parsing, BinAST cannot ensure this. Work around this by
    // using the existing value if this is delazification.
    if (bce.emitterMode != BytecodeEmitter::LazyFunction) {
      immutableFlags.setFlag(ImmutableFlags::IsLikelyConstructorWrapper,
                             funbox->isLikelyConstructorWrapper());
    }
  } /* isFunctionBox */
}

void BCEScriptStencil::initAtomMap(GCPtrAtom* atoms) const {
  const AtomIndexMap& indices = *bce_.perScriptData().atomIndices();

  for (AtomIndexMap::Range r = indices.all(); !r.empty(); r.popFront()) {
    JSAtom* atom = r.front().key();
    uint32_t index = r.front().value();
    MOZ_ASSERT(index < indices.count());
    atoms[index].init(atom);
  }
}
