[general.html]
  type: testharness
  expected: TIMEOUT
  [Window: Aborting rejects with AbortError]
    expected: FAIL

  [Window: Aborting rejects with AbortError - no-cors]
    expected: FAIL

  [Window: Request objects have a signal property]
    expected: FAIL

  [Window: Signal on request object]
    expected: FAIL

  [Window: Signal on request object created from request object]
    expected: FAIL

  [Window: Signal on request object created from request object, with signal on second request]
    expected: FAIL

  [Window: Signal on request object created from request object, with signal on second request overriding another]
    expected: FAIL

  [Window: Signal retained after unrelated properties are overridden by fetch]
    expected: FAIL

  [Window: Signal removed by setting to null]
    expected: FAIL

  [Window: Already aborted signal rejects immediately]
    expected: FAIL

  [Window: Request is still 'used' if signal is aborted before fetching]
    expected: FAIL

  [Window: response.arrayBuffer() rejects if already aborted]
    expected: FAIL

  [Window: response.blob() rejects if already aborted]
    expected: FAIL

  [Window: response.formData() rejects if already aborted]
    expected: FAIL

  [Window: response.json() rejects if already aborted]
    expected: FAIL

  [Window: response.text() rejects if already aborted]
    expected: FAIL

  [Window: Already aborted signal does not make request]
    expected: FAIL

  [Window: Already aborted signal can be used for many fetches]
    expected: FAIL

  [Window: Signal can be used to abort other fetches, even if another fetch succeeded before aborting]
    expected: FAIL

  [Window: Underlying connection is closed when aborting after receiving response]
    expected: FAIL

  [Window: Underlying connection is closed when aborting after receiving response - no-cors]
    expected: FAIL

  [Window: Fetch aborted & connection closed when aborted after calling response.arrayBuffer()]
    expected: FAIL

  [Window: Fetch aborted & connection closed when aborted after calling response.blob()]
    expected: FAIL

  [Window: Fetch aborted & connection closed when aborted after calling response.formData()]
    expected: FAIL

  [Window: Fetch aborted & connection closed when aborted after calling response.json()]
    expected: FAIL

  [Window: Fetch aborted & connection closed when aborted after calling response.text()]
    expected: FAIL

  [Window: Stream errors once aborted. Underlying connection closed.]
    expected: FAIL

  [Window: Stream errors once aborted, after reading. Underlying connection closed.]
    expected: FAIL

  [Window: Stream will not error if body is empty. It's closed with an empty queue before it errors.]
    expected: FAIL

  [Window: Readable stream synchronously cancels with AbortError if aborted before reading]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Aborting rejects with AbortError]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Aborting rejects with AbortError - no-cors]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Request objects have a signal property]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Signal on request object]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Signal on request object created from request object]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Signal on request object created from request object, with signal on second request]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Signal on request object created from request object, with signal on second request overriding another]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Signal retained after unrelated properties are overridden by fetch]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Signal removed by setting to null]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Already aborted signal rejects immediately]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Request is still 'used' if signal is aborted before fetching]
    expected: FAIL

  [DedicatedWorkerGlobalScope: response.arrayBuffer() rejects if already aborted]
    expected: FAIL

  [DedicatedWorkerGlobalScope: response.blob() rejects if already aborted]
    expected: FAIL

  [DedicatedWorkerGlobalScope: response.formData() rejects if already aborted]
    expected: FAIL

  [DedicatedWorkerGlobalScope: response.json() rejects if already aborted]
    expected: FAIL

  [DedicatedWorkerGlobalScope: response.text() rejects if already aborted]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Already aborted signal does not make request]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Already aborted signal can be used for many fetches]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Signal can be used to abort other fetches, even if another fetch succeeded before aborting]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Underlying connection is closed when aborting after receiving response]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Underlying connection is closed when aborting after receiving response - no-cors]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.arrayBuffer()]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.blob()]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.formData()]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.json()]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.text()]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Stream errors once aborted. Underlying connection closed.]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Stream errors once aborted, after reading. Underlying connection closed.]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Stream will not error if body is empty. It's closed with an empty queue before it errors.]
    expected: FAIL

  [DedicatedWorkerGlobalScope: Readable stream synchronously cancels with AbortError if aborted before reading]
    expected: FAIL

  [SharedWorkerGlobalScope: Aborting rejects with AbortError]
    expected: FAIL

  [SharedWorkerGlobalScope: Aborting rejects with AbortError - no-cors]
    expected: FAIL

  [SharedWorkerGlobalScope: Request objects have a signal property]
    expected: FAIL

  [SharedWorkerGlobalScope: Signal on request object]
    expected: FAIL

  [SharedWorkerGlobalScope: Signal on request object created from request object]
    expected: FAIL

  [SharedWorkerGlobalScope: Signal on request object created from request object, with signal on second request]
    expected: FAIL

  [SharedWorkerGlobalScope: Signal on request object created from request object, with signal on second request overriding another]
    expected: FAIL

  [SharedWorkerGlobalScope: Signal retained after unrelated properties are overridden by fetch]
    expected: FAIL

  [SharedWorkerGlobalScope: Signal removed by setting to null]
    expected: FAIL

  [SharedWorkerGlobalScope: Already aborted signal rejects immediately]
    expected: FAIL

  [SharedWorkerGlobalScope: Request is still 'used' if signal is aborted before fetching]
    expected: FAIL

  [SharedWorkerGlobalScope: response.arrayBuffer() rejects if already aborted]
    expected: FAIL

  [SharedWorkerGlobalScope: response.blob() rejects if already aborted]
    expected: FAIL

  [SharedWorkerGlobalScope: response.formData() rejects if already aborted]
    expected: FAIL

  [SharedWorkerGlobalScope: response.json() rejects if already aborted]
    expected: FAIL

  [SharedWorkerGlobalScope: response.text() rejects if already aborted]
    expected: FAIL

  [SharedWorkerGlobalScope: Already aborted signal does not make request]
    expected: FAIL

  [SharedWorkerGlobalScope: Already aborted signal can be used for many fetches]
    expected: FAIL

  [SharedWorkerGlobalScope: Signal can be used to abort other fetches, even if another fetch succeeded before aborting]
    expected: FAIL

  [SharedWorkerGlobalScope: Underlying connection is closed when aborting after receiving response]
    expected: FAIL

  [SharedWorkerGlobalScope: Underlying connection is closed when aborting after receiving response - no-cors]
    expected: FAIL

  [SharedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.arrayBuffer()]
    expected: FAIL

  [SharedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.blob()]
    expected: FAIL

  [SharedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.formData()]
    expected: FAIL

  [SharedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.json()]
    expected: FAIL

  [SharedWorkerGlobalScope: Fetch aborted & connection closed when aborted after calling response.text()]
    expected: FAIL

  [SharedWorkerGlobalScope: Stream errors once aborted. Underlying connection closed.]
    expected: FAIL

  [SharedWorkerGlobalScope: Stream errors once aborted, after reading. Underlying connection closed.]
    expected: FAIL

  [SharedWorkerGlobalScope: Stream will not error if body is empty. It's closed with an empty queue before it errors.]
    expected: FAIL

  [SharedWorkerGlobalScope: Readable stream synchronously cancels with AbortError if aborted before reading]
    expected: FAIL

