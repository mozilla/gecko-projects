# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this file,
# You can obtain one at http://mozilla.org/MPL/2.0/.

from __future__ import print_function
import buildconfig
import sys
import yaml
from mozbuild.preprocessor import Preprocessor
from io import BytesIO

valid_keys = {
    'name',
    'type',
    'value',
    'mirror',
    'do_not_use_directly',
}

valid_mirrors = {
    'never',
    'once',
    'always'
}

valid_bool_types = {
    'bool',
    # These ones are defined in StaticPrefsBase.h.
    'RelaxedAtomicBool',
    'ReleaseAcquireAtomicBool',
    'SequentiallyConsistentAtomicBool',
}

valid_types = valid_bool_types.union({
    'int32_t',
    'uint32_t',
    'float',
    # These ones are defined in StaticPrefsBase.h.
    'String',
    'RelaxedAtomicInt32',
    'RelaxedAtomicUint32',
    'ReleaseAcquireAtomicInt32',
    'ReleaseAcquireAtomicUint32',
    'SequentiallyConsistentAtomicInt32',
    'SequentiallyConsistentAtomicUint32',
    'AtomicFloat',
})

header_template = '''\
// This file was autogenerated by generate_static_pref_list.py. DO NOT EDIT.
'''

mirror_templates = {
    'never': '''\
PREF("{name}", {typ}, {value})
''',

    'once': '''\
VARCACHE_PREF(
  Once,
  "{name}",
   {id},
  {typ}, {value}
)
''',

    'always': '''\
VARCACHE_PREF(
  Live,
  "{name}",
   {id},
  {typ}, {value}
)
''',
}


def error(msg):
    raise ValueError(msg)


def pref_id(pref):
    if pref['mirror'] == 'never':
        if pref.get('do_not_use_directly'):
            error('`do_not_use_directly` uselessly set with `mirror` value '
                  '`never` for pref `{}`'.format(pref['name']))
        return None

    id = pref['name'].replace('.', '_').replace('-', '_')
    if pref.get('do_not_use_directly'):
        id += '_do_not_use_directly'
    return id


def generate_header(pref_list):
    lines = [header_template]

    prev_pref = None
    for pref in pref_list:
        # Check all given keys are known ones.
        for key in pref:
            if key not in valid_keys:
                error('invalid key `{}`'.format(key))

        # 'name' must be present, valid, and in the right section.
        if 'name' not in pref:
            error('missing `name` key')
        name = pref['name']
        if type(name) != str:
            error('non-string `name` value `{}`'.format(name))
        if '.' not in name:
            error('`name` value `{}` lacks a \'.\''.format(name))
        if prev_pref:
            prev_pref_prefix = prev_pref['name'].partition('.')[0]
            if prev_pref_prefix > name:
                error('`{}` pref must come before `{}` pref'
                      .format(name, prev_pref['name']))

        # 'type' must be present and valid.
        if 'type' not in pref:
            error('missing `type` key for pref `{}`'.format(name))
        typ = pref['type']
        if typ not in valid_types:
            error('invalid `type` value `{}` for pref `{}`'.format(typ, name))

        # 'value' must be present and valid.
        if 'value' not in pref:
            error('missing `value` key for pref `{}`'.format(name))
        value = pref['value']
        if typ == 'String':
            if type(value) != str:
                error('non-string value `{}` for `String` pref `{}`; '
                      'add double quotes'
                      .format(value, name))
            # Quote string literals, and escape double-quote chars.
            value = '"{}"'.format(value.replace('"', '\\"'))
        elif typ in valid_bool_types:
            if value is True:               # Convert Python bools to C++ bools.
                value = 'true'
            elif value is False:
                value = 'false'
            else:
                error('invalid boolean value `{}` for pref `{}`'
                      .format(value, name))

        # 'mirror' must be present and valid.
        if 'mirror' not in pref:
            error('missing `mirror` key for pref `{}`'.format(name))
        mirror = pref['mirror']
        if mirror not in mirror_templates:
            error('invalid `mirror` value `{}` for pref `{}`'
                  .format(mirror, name))

        # Generate the C++ code.
        lines.append(mirror_templates[mirror].format(
            name=name,
            id=pref_id(pref),
            typ=typ,
            value=value,
        ))

        prev_pref = pref

    return '\n'.join(lines)


def emit_header(output, pref_list_filename):
    pp = Preprocessor()
    pp.context.update(buildconfig.defines['ALLDEFINES'])

    # A necessary hack until MOZ_DEBUG_FLAGS are part of buildconfig.defines.
    if buildconfig.substs.get('MOZ_DEBUG'):
        pp.context['DEBUG'] = '1'

    pp.out = BytesIO()
    pp.do_filter('substitution')
    pp.do_include(pref_list_filename)

    try:
        pref_list = yaml.safe_load(pp.out.getvalue())
        output.write('{}'.format(generate_header(pref_list)))
    except (IOError, ValueError) as e:
        print('{}: error:\n  {}\n'
              .format(pref_list_filename, e))
        sys.exit(1)
