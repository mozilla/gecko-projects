# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this file,
# You can obtain one at http://mozilla.org/MPL/2.0/.

from __future__ import print_function
import buildconfig
import os
import sys
import yaml
from collections import defaultdict
from io import BytesIO
from mozbuild.preprocessor import Preprocessor
from mozbuild.util import ensureParentDir, FileAvoidWrite

VALID_KEYS = {
    'name',
    'type',
    'value',
    'mirror',
    'do_not_use_directly',
    'include',
}

VALID_BOOL_TYPES = {
    'bool',
    # These ones are defined in StaticPrefsBase.h.
    'RelaxedAtomicBool',
    'ReleaseAcquireAtomicBool',
    'SequentiallyConsistentAtomicBool',
}

VALID_TYPES = VALID_BOOL_TYPES.union({
    'int32_t',
    'uint32_t',
    'float',
    # These ones are defined in StaticPrefsBase.h.
    'String',
    'RelaxedAtomicInt32',
    'RelaxedAtomicUint32',
    'ReleaseAcquireAtomicInt32',
    'ReleaseAcquireAtomicUint32',
    'SequentiallyConsistentAtomicInt32',
    'SequentiallyConsistentAtomicUint32',
    'AtomicFloat',
})

FIRST_LINE = '''\
// This file was generated by generate_static_pref_list.py. DO NOT EDIT.
'''

MIRROR_TEMPLATES = {
    'never': '''\
PREF("{name}", {typ}, {value})
''',

    'once': '''\
VARCACHE_PREF(
  Once,
  "{name}",
   {base_id},
   {full_id},
  {typ}, {value}
)
''',

    'always': '''\
VARCACHE_PREF(
  Live,
  "{name}",
   {base_id},
   {full_id},
  {typ}, {value}
)
''',
}

PREFS_FILE_TEMPLATE1 = '''\
// Include it to gain access to StaticPrefs::{group}_*.

#ifndef mozilla_StaticPrefs_{group}_h
#define mozilla_StaticPrefs_{group}_h

'''

PREFS_FILE_TEMPLATE2 = '''\
#include "mozilla/StaticPrefListBegin.h"
#include "mozilla/StaticPrefList_{group}.h"
#include "mozilla/StaticPrefListEnd.h"

#endif  // mozilla_StaticPrefs_{group}_h
'''


def error(msg):
    raise ValueError(msg)


def mk_id(name):
    "Replace '.' and '-' with '_', e.g. 'foo.bar-baz' becomes 'foo_bar_baz'."
    return name.replace('.', '_').replace('-', '_')


def pref_ids(pref):
    if pref['mirror'] == 'never':
        if pref.get('do_not_use_directly'):
            error('`do_not_use_directly` uselessly set with `mirror` value '
                  '`never` for pref `{}`'.format(pref['name']))
        return (None, None)

    base_id = mk_id(pref['name'])
    full_id = base_id
    if pref['mirror'] == 'once':
        full_id += '_AtStartup'
    if pref.get('do_not_use_directly'):
        full_id += '_DoNotUseDirectly'

    return (base_id, full_id)


def generate_headers(pref_list):
    # The generated code, one list of lines per pref group.
    code = defaultdict(list)

    # The required includes, one set of header file names per pref group.
    includes = defaultdict(set)

    prev_pref = None
    for pref in pref_list:
        # Check all given keys are known ones.
        for key in pref:
            if key not in VALID_KEYS:
                error('invalid key `{}`'.format(key))

        # 'name' must be present, valid, and in the right section.
        if 'name' not in pref:
            error('missing `name` key')
        name = pref['name']
        if type(name) != str:
            error('non-string `name` value `{}`'.format(name))

        segs = name.split('.', 1)
        if len(segs) != 2:
            error('`name` value `{}` lacks a \'.\''.format(name))
        group = mk_id(segs[0])
        if prev_pref:
            prev_pref_prefix = prev_pref['name'].partition('.')[0]
            if prev_pref_prefix > name:
                error('`{}` pref must come before `{}` pref'
                      .format(name, prev_pref['name']))

        # 'type' must be present and valid.
        if 'type' not in pref:
            error('missing `type` key for pref `{}`'.format(name))
        typ = pref['type']
        if typ not in VALID_TYPES:
            error('invalid `type` value `{}` for pref `{}`'.format(typ, name))

        # 'value' must be present and valid.
        if 'value' not in pref:
            error('missing `value` key for pref `{}`'.format(name))
        value = pref['value']
        if typ == 'String':
            if type(value) != str:
                error('non-string `value` value `{}` for `String` pref `{}`; '
                      'add double quotes'
                      .format(value, name))
            # Quote string literals, and escape double-quote chars.
            value = '"{}"'.format(value.replace('"', '\\"'))
        elif typ in VALID_BOOL_TYPES:
            if value is True:               # Convert Python bools to C++ bools.
                value = 'true'
            elif value is False:
                value = 'false'
            else:
                error('invalid boolean value `{}` for pref `{}`'
                      .format(value, name))

        # 'mirror' must be present and valid.
        if 'mirror' not in pref:
            error('missing `mirror` key for pref `{}`'.format(name))
        mirror = pref['mirror']
        if mirror not in MIRROR_TEMPLATES:
            error('invalid `mirror` value `{}` for pref `{}`'
                  .format(mirror, name))

        # Check 'do_not_use_directly' if present.
        if 'do_not_use_directly' in pref:
            do_not_use_directly = pref['do_not_use_directly']
            if type(do_not_use_directly) != bool:
                error('non-boolean `do_not_use_directly` value `{}` for pref '
                      '`{}`'.format(do_not_use_directly, name))

        # Check and process 'include' if present.
        if 'include' in pref:
            include = pref['include']
            if type(include) != str:
                error('non-string `include` value `{}` for pref `{}`'
                      .format(include, name))
            if include.startswith('<'):
                if not include.endswith('>'):
                    error('`include` value `{}` starts with `<` but does not '
                          'end with `>` for pref `{}`'.format(include, name))
            else:
                # It's not a system header. Add double quotes.
                include = '"{}"'.format(include)
            includes[group].add(include)

        # Append the C++ definition to the relevant output file's code.
        ids = pref_ids(pref)
        code[group].append(MIRROR_TEMPLATES[mirror].format(
            name=name,
            base_id=ids[0],
            full_id=ids[1],
            typ=typ,
            value=value,
        ))

        prev_pref = pref

    return (code, includes)


def emit_header(fd, pref_list_filename):
    pp = Preprocessor()
    pp.context.update(buildconfig.defines['ALLDEFINES'])

    # A necessary hack until MOZ_DEBUG_FLAGS are part of buildconfig.defines.
    if buildconfig.substs.get('MOZ_DEBUG'):
        pp.context['DEBUG'] = '1'

    pp.out = BytesIO()
    pp.do_filter('substitution')
    pp.do_include(pref_list_filename)

    try:
        pref_list = yaml.safe_load(pp.out.getvalue())
        (code, includes) = generate_headers(pref_list)
    except (IOError, ValueError) as e:
        print('{}: error:\n  {}\n'
              .format(pref_list_filename, e))
        sys.exit(1)

    # When generating multiple files from a script, the build system treats the
    # first named output file (StaticPrefList.h in this case) specially -- it
    # is created elsewhere, and written to via `fd`.
    #
    # This file has one `#include "mozilla/StaticPrefList_X.h` per pref group.
    fd.write(FIRST_LINE)
    fd.write('\n')
    for group in sorted(code):
        fd.write('#include "mozilla/StaticPrefList_{}.h"\n'.format(group))

    # We must create the remaining output files ourselves. This requires
    # creating the output directory directly if it doesn't already exist.
    ensureParentDir(fd.name)
    init_dirname = os.path.dirname(fd.name)
    base_dirname = os.path.dirname(init_dirname)

    # This file has one `#include "mozilla/StaticPrefs_X.h` per pref group.
    with FileAvoidWrite(os.path.join(base_dirname, 'StaticPrefsAll.h')) as fd:
        fd.write(FIRST_LINE)
        fd.write('\n')
        for group in sorted(code):
            fd.write('#include "mozilla/StaticPrefs_{}.h"\n'.format(group))

    for group, lines in sorted(code.items()):
        # This header contains all the definitions for the pref group.
        filename = 'StaticPrefList_{}.h'.format(group)
        with FileAvoidWrite(os.path.join(init_dirname, filename)) as fd:
            fd.write(FIRST_LINE)
            fd.write('\n')
            fd.write('\n'.join(lines))

        # This header wraps the previous header file. It is the header used
        # directly by application code.
        filename = 'StaticPrefs_{}.h'.format(group)
        with FileAvoidWrite(filename) as fd:
            fd.write(FIRST_LINE)
            fd.write(PREFS_FILE_TEMPLATE1.format(group=group))
            if group in includes:
                # Add any necessary includes, from 'include' values.
                for include in sorted(includes[group]):
                    fd.write('#include {}\n'.format(include))
                fd.write('\n')
            fd.write(PREFS_FILE_TEMPLATE2.format(group=group))
